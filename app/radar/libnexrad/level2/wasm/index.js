var _R = Object.defineProperty;
var yR = (r,e)=>{
    for (var t in e)
        _R(r, t, {
            get: e[t],
            enumerable: !0
        })
}
;
function Hn() {}
function mv(r, e) {
    for (let t in e)
        r[t] = e[t];
    return r
}
function cS(r) {
    return r()
}
function uS() {
    return Object.create(null)
}
function Wi(r) {
    r.forEach(cS)
}
function Wl(r) {
    return typeof r == "function"
}
function di(r, e) {
    return r != r ? e == e : r !== e || r && typeof r == "object" || typeof r == "function"
}
function xR(r) {
    return Object.keys(r).length === 0
}
function H_(r, ...e) {
    if (r == null)
        return Hn;
    let t = r.subscribe(...e);
    return t.unsubscribe ? ()=>t.unsubscribe() : t
}
function tn(r) {
    let e;
    return H_(r, t=>e = t)(),
    e
}
function Ht(r, e, t) {
    r.$$.on_destroy.push(H_(e, t))
}
function W_(r) {
    return r ?? ""
}
function bn(r, e, t) {
    return r.set(t),
    e
}
function Se(r, e) {
    r.appendChild(e)
}
function yn(r, e, t) {
    r.insertBefore(e, t || null)
}
function mn(r) {
    r.parentNode.removeChild(r)
}
function As(r, e) {
    for (let t = 0; t < r.length; t += 1)
        r[t] && r[t].d(e)
}
function qe(r) {
    return document.createElement(r)
}
function Un(r) {
    return document.createTextNode(r)
}
function It() {
    return Un(" ")
}
function xu() {
    return Un("")
}
function wn(r, e, t, o) {
    return r.addEventListener(e, t, o),
    ()=>r.removeEventListener(e, t, o)
}
function Ga(r) {
    return function(e) {
        return e.preventDefault(),
        r.call(this, e)
    }
}
function je(r, e, t) {
    t == null ? r.removeAttribute(e) : r.getAttribute(e) !== t && r.setAttribute(e, t)
}
function gv(r) {
    return r === "" ? null : +r
}
function vR(r) {
    return Array.from(r.childNodes)
}
function gi(r, e) {
    e = "" + e,
    r.wholeText !== e && (r.data = e)
}
function j_(r, e) {
    r.value = e ?? ""
}
function vu(r, e, t, o) {
    r.style.setProperty(e, t, o ? "important" : "")
}
function bu(r, e) {
    for (let t = 0; t < r.options.length; t += 1) {
        let o = r.options[t];
        if (o.__value === e) {
            o.selected = !0;
            return
        }
    }
    r.selectedIndex = -1
}
function Op(r) {
    let e = r.querySelector(":checked") || r.options[0];
    return e && e.__value
}
function Gn(r, e, t) {
    r.classList[t ? "add" : "remove"](e)
}
function bR(r, e, t=!1) {
    let o = document.createEvent("CustomEvent");
    return o.initCustomEvent(r, t, !1, e),
    o
}
var Np;
function Fp(r) {
    Np = r
}
function _v() {
    if (!Np)
        throw new Error("Function called outside component initialization");
    return Np
}
function Ha(r) {
    _v().$$.on_mount.push(r)
}
function yv(r) {
    _v().$$.after_update.push(r)
}
function Qs() {
    let r = _v();
    return (e,t)=>{
        let o = r.$$.callbacks[e];
        if (o) {
            let c = bR(e, t);
            o.slice().forEach(d=>{
                d.call(r, c)
            }
            )
        }
    }
}
function Wa(r, e) {
    let t = r.$$.callbacks[e.type];
    t && t.slice().forEach(o=>o.call(this, e))
}
var Bp = []
  , Bi = []
  , X_ = []
  , xv = []
  , wR = Promise.resolve()
  , vv = !1;
function TR() {
    vv || (vv = !0,
    wR.then(hS))
}
function jl(r) {
    X_.push(r)
}
function ua(r) {
    xv.push(r)
}
var bv = new Set
  , Z_ = 0;
function hS() {
    let r = Np;
    do {
        for (; Z_ < Bp.length; ) {
            let e = Bp[Z_];
            Z_++,
            Fp(e),
            ER(e.$$)
        }
        for (Fp(null),
        Bp.length = 0,
        Z_ = 0; Bi.length; )
            Bi.pop()();
        for (let e = 0; e < X_.length; e += 1) {
            let t = X_[e];
            bv.has(t) || (bv.add(t),
            t())
        }
        X_.length = 0
    } while (Bp.length);
    for (; xv.length; )
        xv.pop()();
    vv = !1,
    bv.clear(),
    Fp(r)
}
function ER(r) {
    if (r.fragment !== null) {
        r.update(),
        Wi(r.before_update);
        let e = r.dirty;
        r.dirty = [-1],
        r.fragment && r.fragment.p(r.ctx, e),
        r.after_update.forEach(jl)
    }
}
var q_ = new Set, wu;
function eo() {
    wu = {
        r: 0,
        c: [],
        p: wu
    }
}
function to() {
    wu.r || Wi(wu.c),
    wu = wu.p
}
function Wn(r, e) {
    r && r.i && (q_.delete(r),
    r.i(e))
}
function ri(r, e, t, o) {
    if (r && r.o) {
        if (q_.has(r))
            return;
        q_.add(r),
        wu.c.push(()=>{
            q_.delete(r),
            o && (t && r.d(1),
            o())
        }
        ),
        r.o(e)
    }
}
function wv(r, e) {
    let t = {}
      , o = {}
      , c = {
        $$scope: 1
    }
      , d = r.length;
    for (; d--; ) {
        let p = r[d]
          , i = e[d];
        if (i) {
            for (let v in p)
                v in i || (o[v] = 1);
            for (let v in i)
                c[v] || (t[v] = i[v],
                c[v] = 1);
            r[d] = i
        } else
            for (let v in p)
                c[v] = 1
    }
    for (let p in o)
        p in t || (t[p] = void 0);
    return t
}
function Tv(r) {
    return typeof r == "object" && r !== null ? r : {}
}
function ha(r, e, t) {
    let o = r.$$.props[e];
    o !== void 0 && (r.$$.bound[o] = t,
    t(r.$$.ctx[o]))
}
function Qi(r) {
    r && r.c()
}
function qi(r, e, t, o) {
    let {fragment: c, on_mount: d, on_destroy: p, after_update: i} = r.$$;
    c && c.m(e, t),
    o || jl(()=>{
        let v = d.map(cS).filter(Wl);
        p ? p.push(...v) : Wi(v),
        r.$$.on_mount = []
    }
    ),
    i.forEach(jl)
}
function Ki(r, e) {
    let t = r.$$;
    t.fragment !== null && (Wi(t.on_destroy),
    t.fragment && t.fragment.d(e),
    t.on_destroy = t.fragment = null,
    t.ctx = [])
}
function SR(r, e) {
    r.$$.dirty[0] === -1 && (Bp.push(r),
    TR(),
    r.$$.dirty.fill(0)),
    r.$$.dirty[e / 31 | 0] |= 1 << e % 31
}
function _i(r, e, t, o, c, d, p, i=[-1]) {
    let v = Np;
    Fp(r);
    let x = r.$$ = {
        fragment: null,
        ctx: null,
        props: d,
        update: Hn,
        not_equal: c,
        bound: uS(),
        on_mount: [],
        on_destroy: [],
        on_disconnect: [],
        before_update: [],
        after_update: [],
        context: new Map(e.context || (v ? v.$$.context : [])),
        callbacks: uS(),
        dirty: i,
        skip_bound: !1,
        root: e.target || v.$$.root
    };
    p && p(x.root);
    let E = !1;
    if (x.ctx = t ? t(r, e.props || {}, (A,C,...I)=>{
        let D = I.length ? I[0] : C;
        return x.ctx && c(x.ctx[A], x.ctx[A] = D) && (!x.skip_bound && x.bound[A] && x.bound[A](D),
        E && SR(r, A)),
        C
    }
    ) : [],
    x.update(),
    E = !0,
    Wi(x.before_update),
    x.fragment = o ? o(x.ctx) : !1,
    e.target) {
        if (e.hydrate) {
            let A = vR(e.target);
            x.fragment && x.fragment.l(A),
            A.forEach(mn)
        } else
            x.fragment && x.fragment.c();
        e.intro && Wn(r.$$.fragment),
        qi(r, e.target, e.anchor, e.customElement),
        hS()
    }
    Fp(v)
}
var mi = class {
    $destroy() {
        Ki(this, 1),
        this.$destroy = Hn
    }
    $on(e, t) {
        let o = this.$$.callbacks[e] || (this.$$.callbacks[e] = []);
        return o.push(t),
        ()=>{
            let c = o.indexOf(t);
            c !== -1 && o.splice(c, 1)
        }
    }
    $set(e) {
        this.$$set && !xR(e) && (this.$$.skip_bound = !0,
        this.$$set(e),
        this.$$.skip_bound = !1)
    }
}
;
var fd = [];
function K_(r, e) {
    return {
        subscribe: yi(r, e).subscribe
    }
}
function yi(r, e=Hn) {
    let t, o = new Set;
    function c(i) {
        if (di(r, i) && (r = i,
        t)) {
            let v = !fd.length;
            for (let x of o)
                x[1](),
                fd.push(x, r);
            if (v) {
                for (let x = 0; x < fd.length; x += 2)
                    fd[x][0](fd[x + 1]);
                fd.length = 0
            }
        }
    }
    function d(i) {
        c(i(r))
    }
    function p(i, v=Hn) {
        let x = [i, v];
        return o.add(x),
        o.size === 1 && (t = e(c) || Hn),
        i(r),
        ()=>{
            o.delete(x),
            o.size === 0 && (t(),
            t = null)
        }
    }
    return {
        set: c,
        update: d,
        subscribe: p
    }
}
function dS(r, e, t) {
    let o = !Array.isArray(r)
      , c = o ? [r] : r
      , d = e.length < 2;
    return K_(t, p=>{
        let i = !1
          , v = []
          , x = 0
          , E = Hn
          , A = ()=>{
            if (x)
                return;
            E();
            let I = e(o ? v[0] : v, p);
            d ? p(I) : E = Wl(I) ? I : Hn
        }
          , C = c.map((I,D)=>H_(I, P=>{
            v[D] = P,
            x &= ~(1 << D),
            i && A()
        }
        , ()=>{
            x |= 1 << D
        }
        ));
        return i = !0,
        A(),
        function() {
            Wi(C),
            E()
        }
    }
    )
}
var Up = {};
yR(Up, {
    MODE: ()=>AR,
    NODE_ENV: ()=>MR,
    SNOWPACK_PUBLIC_CREDS: ()=>Ev,
    SSR: ()=>IR
});
var Ev = "null"
  , AR = "production"
  , MR = "production"
  , IR = !1;
import.meta.env = Up;
function CR() {
    let r = new Worker(new URL("./worker.js",import.meta.url));
    return {
        worker: r,
        setOnMessage: function(t, o, c, d, p, i, v, x, E, A) {
            r.onmessage = function(C) {
                let I = C.data.action
                  , D = C.data.data;
                if (I === "error" && v.update(P=>(P.error = !0,
                P.message = D.message,
                P.header = D.header,
                P)),
                I === "noop" && E.handleQueue({
                    message: "noop",
                    fileName: D.fileName
                }),
                I === "initialize" && (t.update(P=>(P.loading = D.file,
                P.finished = 0,
                P[D.file] = {
                    fileName: D.fileName,
                    fileNumber: D.file
                },
                P)),
                d.update(P=>{
                    for (let k = 0; k < P.length; k++)
                        P[k].file === null && (P[k].file = D.file);
                    return P
                }
                )),
                I === "update" && t.update(P=>(P.loading = D.file,
                P.finished = 0,
                P[D.file] && Object.assign(P[D.file], {
                    station: D.station,
                    scans: [],
                    idxs: {},
                    percent: 0,
                    vcp: D.vcp,
                    radarMetadata: {}
                }),
                P)),
                I === "archive2" && t.update(P=>(P[D.file] && (P[D.file].vcp = D.vcp),
                P)),
                I === "contentFinished" && (t.update(P=>(P.loading = -1,
                P.finished = 1,
                P[D.file] && (P[D.file].percent = -1),
                P)),
                E.handleQueue({
                    message: "initialize",
                    fileNumber: D.file,
                    fileName: D.fileName
                })),
                I === "metadata" && (t.update(P=>{
                    if (P.loading = D.file,
                    P.finished = 0,
                    !P[D.file])
                        return P;
                    let k = D.elevation.toFixed(1);
                    if (!(k in P[D.file].idxs))
                        P[D.file].idxs[k] = P[D.file].scans.length,
                        P[D.file].scans.push([[{
                            elevation: D.elevation,
                            idx: D.idx,
                            date: D.date,
                            percent: D.percent,
                            fields: D.fields,
                            fileNumber: D.file,
                            rounded: k,
                            fileName: D.fileName
                        }]]);
                    else {
                        let U = P[D.file].scans[P[D.file].idxs[k]];
                        for (let Z = 0; Z < U.length; Z++) {
                            let K = U[Z];
                            for (let X = 0; X < K.length; X++)
                                if (D.idx - K[X].idx == 1)
                                    return K.push({
                                        elevation: D.elevation,
                                        idx: D.idx,
                                        date: D.date,
                                        percent: D.percent,
                                        fields: D.fields,
                                        fileNumber: D.file,
                                        rounded: k,
                                        fileName: D.fileName
                                    }),
                                    P[D.file].percent = Math.max(P[D.file].percent, D.percent),
                                    P
                        }
                        P[D.file].scans[P[D.file].idxs[k]].push([{
                            elevation: D.elevation,
                            idx: D.idx,
                            date: D.date,
                            percent: D.percent,
                            fields: D.fields,
                            fileNumber: D.file,
                            rounded: k,
                            fileName: D.fileName
                        }])
                    }
                    return P[D.file].percent = Math.max(P[D.file].percent, D.percent),
                    P
                }
                ),
                D.idx === 0)) {
                    if (!tn(t)[D.file])
                        return;
                    tn(c).station != tn(t)[D.file].station && c.update(P=>({
                        lat: D.lat,
                        lon: D.lon,
                        station: tn(t)[D.file].station
                    })),
                    t.update(P=>(P[D.file] && (P[D.file].radarMetadata = {
                        lat: D.lat,
                        lon: D.lon,
                        station: tn(t)[D.file].station
                    }),
                    P))
                }
                if (I === "loadData") {
                    if (tn(t).filter(Z=>Z != null).map(Z=>Z.fileName).indexOf(D.fileName) < 0) {
                        let Z = `${D.fileName}_ ${D.type}_ ${D.elevation}`;
                        A.deleteItem(Z) === 0 && A.dequeue();
                        return
                    }
                    o.update(Z=>(Z[D.file] || (Z[D.file] = {
                        0: Array.apply(null, Array(30)).map(function() {}),
                        1: Array.apply(null, Array(30)).map(function() {}),
                        255: Array.apply(null, Array(30)).map(function() {}),
                        9: Array.apply(null, Array(30)).map(function() {}),
                        10: Array.apply(null, Array(30)).map(function() {}),
                        5: Array.apply(null, Array(30)).map(function() {}),
                        2: Array.apply(null, Array(30)).map(function() {})
                    }),
                    Z[D.file][D.type][D.elevation] = D.float,
                    Z));
                    let U = `${D.fileName}_ ${D.type}_ ${D.elevation}`;
                    A.deleteItem(U) === 0 && A.dequeue()
                }
                if (I === "didNotExist") {
                    let P = `${D.fileName}_ ${D.type}_ ${D.elevation}`;
                    A.deleteItem(P) === 0 && A.dequeue()
                }
                if (I === "loadTexture") {
                    if (tn(t).filter(Z=>Z != null).map(Z=>Z.fileName).indexOf(D.fileName) < 0) {
                        let Z = `${D.fileName}_ ${D.type}_ ${D.elevation}`;
                        A.deleteItem(Z) === 0 && A.dequeue();
                        return
                    }
                    p.update(Z=>{
                        let K = {};
                        return K.float = D.float,
                        K.size = D.size,
                        K.scale = D.scale,
                        K.offset = D.offset,
                        K.bin1 = D.bin1,
                        K.binMax = D.binMax,
                        K.ngates = D.ngates / (1e3 / D.gate_size),
                        Z[D.fileNum] = K,
                        Z
                    }
                    );
                    let U = `${D.fileName}_ ${D.type}_ ${D.elevation}`;
                    A.deleteItem(U) === 0 && A.dequeue()
                }
                I === "clearMap" && (E.handleQueue({
                    message: "deleted",
                    fileNumber: D.fileNum,
                    fileName: D.fileName
                }),
                tn(t)[tn(d)[0].file] === void 0 && x.update(P=>!0)),
                I === "try_again" && E.handleQueue({
                    message: "try_again",
                    fileName: D.fileName,
                    buffer: C.data.buffer
                })
            }
        }
    }
}
var fS = CR;
var Y_ = Symbol("single")
  , Sr = Symbol("double")
  , ja = Symbol("single_hidden")
  , Vs = {
    REFLECTIVITY: Symbol("reflectivity"),
    VELOCITY: Symbol("velocity"),
    VELOCITY_DEALIASED: Symbol("velocity_dealiased"),
    CC: Symbol("cc"),
    PHI: Symbol("phi"),
    SW: Symbol("sw"),
    ZDR: Symbol("zdr")
}
  , da = {
    DEALIASED: Symbol("dealiased"),
    RAW: Symbol("raw")
}
  , Yr = {
    READING: Symbol("reading"),
    MODE3D: Symbol("mode3d"),
    CROSS: Symbol("cross"),
    LIVE: Symbol("live")
}
  , pd = {
    FILE: Symbol("file"),
    ELEVATION: Symbol("elevation")
}
  , Gs = {
    HISTORICAL: Symbol("historical"),
    LIVE: Symbol("live")
};
function go(r=null) {
    let e = r ? r.f : function() {}
      , {REFLECTIVITY: t, VELOCITY: o, VELOCITY_DEALIASED: c, CC: d, PHI: p, ZDR: i, SW: v} = Vs
      , x = {
        [t]: 0,
        [o]: 1,
        [c]: 255,
        [d]: 9,
        [p]: 10,
        [i]: 5,
        [v]: 2
    }
      , {READING: E, MODE3D: A, CROSS: C} = Yr
      , {DEALIASED: I} = da;
    function D(K, X, W, fe) {
        return {
            elevation: K,
            file: X,
            type: W,
            dealiased: 0,
            scan: fe
        }
    }
    function P(K, X) {
        if (tn(Ms)[K] === void 0) {
            let W = Tu.enqueue({
                fileNum: K,
                field: 254,
                fileName: X,
                idx: 255,
                selections: tn(ui),
                scans: tn(ai)
            });
            Xa.update(fe=>!0)
        }
    }
    function k(K, X, W, fe, ce) {
        if (tn(bs)[W] && tn(bs)[W][K][X])
            return;
        let _e, oe = tn(ui)[fe].scan.scan, ee;
        K === 255 ? ee = 1 : ee = K;
        for (let j = 0; j < oe.length; j++)
            if (oe[j].fields.indexOf(ee) > -1) {
                _e = !0;
                break
            }
        if (_e) {
            let j = Tu.enqueue({
                fileNum: W,
                idx: X,
                field: K,
                fileName: ce
            })
        } else
            tn(bs)[W] && (tn(bs)[W][K][X] = new Float32Array([]));
        tn(ws)[fe].setLoading()
    }
    function U(K, X) {
        let W;
        X === 255 && (X = 1);
        for (let fe = 0; fe < K.length; fe++)
            if (K[fe].fields.indexOf(X) > -1) {
                W = K[fe].idx;
                break
            }
        return W
    }
    function Z(K) {
        if (K === null)
            return;
        let X;
        tn(Jr) === Sr ? X = [0, 1] : X = [0];
        let W = [null, null]
          , fe = [];
        for (let se = 0; se < K.scan.length; se++)
            fe = fe.concat(K.scan[se].fields);
        let ce = new Set(fe)
          , _e = tn(ws).map((se,ke)=>{
            if (se && X.indexOf(ke) > -1)
                return x[se.field]
        }
        ).filter(se=>se != null)
          , oe = tn(ws);
        _e = _e.map((se,ke)=>{
            let Be;
            if (se === 255 ? Be = 1 : Be = se,
            ce.has(Be))
                return se;
            if (ke == 0)
                return oe[ke].updateField(t),
                0;
            if (ke == 1)
                return tn(Za) === I ? (oe[ke].updateField(c),
                255) : (oe[ke].updateField(o),
                1)
        }
        );
        let ee = K.scan
          , j = JSON.stringify(tn(ui))
          , ne = tn(ui)[0].file
          , be = _e.map(se=>D(U(ee, se), K.fileNumber, se, K))
          , te = JSON.stringify(be)
          , ae = be[0].file;
        if (j !== te) {
            ui.update(se=>_e.map(ke=>D(U(ee, ke), K.fileNumber, ke, K))),
            tn(ui)[0].scan.station != tn(Hs).station && Hs.update(se=>tn(ai)[tn(ui)[0].file].radarMetadata);
            for (let se = 0; se < _e.length; se++)
                k(_e[se], U(ee, _e[se]), K.fileNumber, se, K.fileName);
            ae != tn(Ws) && ((tn(zr) === A || tn(zr) === C) && P(K.fileNumber, K.fileName),
            Ws.update(se=>ae))
        }
    }
    return {
        logStore: Z
    }
}
var DR = go()
  , {HISTORICAL: WV, LIVE: pS} = Gs;
function mS() {
    let r, e, t, o = [], c = "READY", d, p, i = 0, v = !1, x, E, A = new Map;
    function C(oe) {
        d = oe
    }
    function I(oe) {
        p = oe
    }
    function D(oe) {
        if (tn(js) != pS)
            return;
        let ee, j;
        if (oe.message === "initialize" && (i -= 1,
        d && d(i),
        c === "READY" && (o.shift(),
        [ee] = A.keys(),
        j = A.get(ee),
        j && P(j.fileName))),
        oe.message === "try_again") {
            let ne = {
                message: "initialize",
                fileName: oe.fileName,
                buffer: oe.buffer
            };
            A.set(oe.fileName, ne),
            c === "READY" && (o.shift(),
            [ee] = A.keys(),
            j = A.get(ee),
            j && P(j.fileName))
        }
        oe.message === "deleted" && (c = "READY"),
        oe.message === "noop" && (i -= 1,
        console.log("received noop", i),
        d && d(i),
        A.has(oe.fileName) && A.delete(oe.fileName),
        c === "READY" && (o.shift(),
        [ee] = A.keys(),
        j = A.get(ee),
        j && P(j.fileName)))
    }
    function P(oe) {
        if (A.size !== 0 && o.length === 0) {
            let ee = A.get(oe);
            if (ee === void 0)
                return;
            A.delete(oe),
            o.push(ee),
            U(),
            tn(Is).postMessage(ee, [ee.buffer])
        }
    }
    function k() {
        let oe = tn(ai)
          , ee = tn($r);
        Object.assign(ee, {
            fileNames: [],
            elevations: [],
            stations: [],
            scans: []
        }),
        ee.fileNames = [],
        ee.stations = [],
        ee.scans = {},
        ee.elevations = {};
        let j = {}
          , ne = {};
        for (let be = 0; be < oe.length; be++)
            oe[be] != null && (ee.fileNames.push(oe[be].fileName),
            ee.stations.indexOf(oe[be].station) < 0 && ee.stations.push(oe[be].station),
            oe[be].station in j ? j[oe[be].station] = j[oe[be].station].concat(Object.keys(oe[be].idxs)) : j[oe[be].station] = Object.keys(oe[be].idxs),
            oe[be].station in ne ? ne[oe[be].station] = ne[oe[be].station].concat(oe[be].scans) : ne[oe[be].station] = oe[be].scans);
        for (let be = 0; be < ee.stations.length; be++) {
            let te = ee.stations[be];
            ee.elevations[te] = [],
            ee.scans[te] = {},
            ee.elevations[te] = Array.from(new Set(j[te])).sort(function(se, ke) {
                return +se - +ke
            });
            let ae = ne[te];
            for (let se = 0; se < ee.elevations[te].length; se++)
                ee.scans[te][ee.elevations[te][se]] = [];
            for (let se = 0; se < ae.length; se++)
                ee.scans[te][ae[se][0][0].rounded].push(...ae[se]);
            for (let se in ee.scans[te])
                ee.scans[te][se] = ee.scans[te][se].sort(function(ke, Be) {
                    return ke[0].date - Be[0].date
                })
        }
    }
    function U() {
        let ee = tn(ai).filter(te=>te != null), j = Date.now(), ne, be;
        if (ee.length === 5) {
            for (let Ke = 0; Ke < ee.length; Ke++)
                if (!ee[Ke].scans || !ee[Ke].scans[0]) {
                    ne = Ke,
                    be = ee[Ke].fileName;
                    break
                } else {
                    let bt = ee[Ke].scans[0][0][0].date;
                    bt < j && (ne = Ke,
                    be = ee[Ke].fileName,
                    j = bt)
                }
            ai.update(Ke=>(Ke[ne] = void 0,
            Ke));
            let te = tn(ui), ae = tn($r), se, ke, Be;
            if (se = te[0].scan ? te[0].scan.station : void 0,
            Object.keys(ae.scans).indexOf(se) < 0)
                ui.set([{
                    elevation: null,
                    file: null,
                    type: null,
                    dealiased: null,
                    scan: null
                }, {
                    elevation: null,
                    file: null,
                    type: null,
                    dealiased: null,
                    scan: null
                }]),
                Ws.set(null),
                Hs.set({});
            else {
                ke = te[0].scan ? te[0].scan.scan[0].rounded : void 0,
                se = te[0].scan ? te[0].scan.station : void 0,
                Be = ae.scans && te[0].scan ? ae.scans[se][ke] : void 0;
                let Ke = te[0].scan.scan[0].date.getTime(), bt;
                for (let Et = 0; Et < Be.length; Et++)
                    if (Be[Et][0].date.getTime() === Ke) {
                        bt = Et;
                        break
                    }
                if (!bt && Be.length > 0) {
                    let Et = {
                        fileNumber: Be[0][0].fileNumber,
                        scan: Be[0],
                        fileName: Be[0][0].fileName,
                        station: se
                    };
                    DR.logStore(Et),
                    Ws.set(Be[0][0].fileNumber)
                }
            }
            bs.update(Ke=>(Ke[ne] = void 0,
            Ke)),
            Ms.update(Ke=>(Ke[ne] = void 0,
            Ke)),
            c = "DELETING",
            tn(Is).postMessage({
                message: "deleteFile",
                data: {
                    fileNum: ne,
                    fileName: be
                }
            })
        }
    }
    function Z() {
        let oe = tn(ai);
        for (let ee = 0; ee < oe.length; ee++) {
            if (oe[ee] === void 0 || oe[ee].station === e)
                continue;
            let j = oe[ee].fileName
              , ne = oe[ee].fileNumber;
            oe[ee].fileNumber === tn(ui)[0].file && (ui.set([{
                elevation: null,
                file: null,
                type: null,
                dealiased: null,
                scan: null
            }, {
                elevation: null,
                file: null,
                type: null,
                dealiased: null,
                scan: null
            }]),
            Ws.set(null),
            Hs.set({})),
            ai.update(be=>(be[ee] = void 0,
            be)),
            bs.update(be=>(be[ee] = void 0,
            be)),
            Ms.update(be=>(be[ee] = void 0,
            be)),
            tn(Is).postMessage({
                message: "deleteFile",
                data: {
                    fileNum: ne,
                    fileName: j
                }
            })
        }
    }
    function K() {
        clearTimeout(E)
    }
    function X() {
        let oe = {
            id: t,
            action: "ping"
        };
        r.send(JSON.stringify(oe)),
        E = setTimeout(()=>{
            console.log("closing in pong"),
            r.close()
        }
        , 3e3)
    }
    function W() {
        if (!r)
            return new Promise(function(oe, ee) {
                r = new WebSocket("wss://radar.quadweather.com"),
                r.onerror = function(j) {
                    r.close()
                }
                ,
                r.onopen = async function() {
                    x && (clearInterval(x),
                    x = null),
                    r.isAlive = !0,
                    K(),
                    x = setInterval(X, 5e3);
                    let j = await es.getToken();
                    fetch("https://radar.quadweather.com/socket/alerts", {
                        headers: {
                            Authorization: `Bearer ${j}`
                        }
                    }).then(ne=>ne.json()).then(ne=>{
                        Vp.update(be=>(be = ne,
                        be))
                    }
                    ).catch(ne=>console.log("fetch error", ne)),
                    fetch("https://radar.quadweather.com/socket/lightning", {
                        headers: {
                            Authorization: `Bearer ${j}`
                        }
                    }).then(ne=>ne.json()).then(ne=>{
                        Gp.update(be=>(be = ne,
                        be))
                    }
                    ).catch(ne=>console.log("fetch error", ne)),
                    oe(r)
                }
                ,
                r.onclose = function() {
                    K(),
                    clearInterval(x),
                    x = null,
                    r = null,
                    tn(js) === pS && setTimeout(function() {
                        W()
                    }, Math.random() * 1e3)
                }
                ,
                r.onmessage = async function(j) {
                    let ne = j.data;
                    if (ne instanceof Blob)
                        j.data.arrayBuffer().then(be=>console.log(be));
                    else {
                        let be = JSON.parse(ne);
                        if (be.data && (t = be.data,
                        e)) {
                            Qr.update(ae=>!0);
                            let te;
                            tn(_o) && (v = !0),
                            te = {
                                id: t,
                                site: e,
                                action: "new_site"
                            },
                            r.send(JSON.stringify(te))
                        }
                        if (be.action === "pong" && K(),
                        be.action === "no_file" && (Qr.update(te=>!1),
                        Yi.update(te=>(te.error = !0,
                        te.message = `Site ${e} does not have any recent radar data available.`,
                        te.header = "No data available",
                        te.color = "normal",
                        te))),
                        be.action === "new_file") {
                            let te = await es.getToken();
                            fetch(`https://radar.quadweather.com/socket/data?site=${be.site}&file_name=${be.fileName}`, {
                                headers: {
                                    Authorization: `Bearer ${te}`
                                }
                            }).then(ae=>ae.arrayBuffer()).then(ae=>{
                                v && (v = !1,
                                fe());
                                let se = []
                                  , Be = tn(ai).filter(tt=>tt != null);
                                for (let tt = 0; tt < Be.length; tt++)
                                    se.push(Be[tt].fileName);
                                se.indexOf(be.fileName) < 0 && be.site === e ? (A.has(be.fileName) || (i++,
                                A.set(be.fileName, {
                                    message: "initialize",
                                    fileName: be.fileName,
                                    buffer: ae
                                })),
                                d && d(i),
                                P(be.fileName)) : Qr.update(tt=>!1)
                            }
                            ).catch(ae=>console.log(ae))
                        }
                        if (be.action === "new_site") {
                            let te = []
                              , se = tn(ai).filter(ke=>ke != null);
                            for (let ke = 0; ke < se.length; ke++)
                                te.push(se[ke].fileName);
                            if (!be.fileName) {
                                Qr.update(ke=>!1);
                                return
                            }
                            if (te.indexOf(be.fileName) >= 0 && be.site === e)
                                Qr.update(ke=>!1),
                                d && d(0);
                            else {
                                let ke = await es.getToken();
                                fetch(`https://radar.quadweather.com/socket/data?site=${be.site}&file_name=${be.fileName}`, {
                                    headers: {
                                        Authorization: `Bearer ${ke}`
                                    }
                                }).then(Be=>Be.arrayBuffer()).then(Be=>{
                                    te.indexOf(be.fileName) < 0 && be.site === e && (A.has(be.fileName) || (i++,
                                    A.set(be.fileName, {
                                        message: "initialize",
                                        fileName: be.fileName,
                                        buffer: Be
                                    })),
                                    d && d(i),
                                    P(be.fileName))
                                }
                                ).catch(Be=>console.log(Be))
                            }
                        }
                        if (be.action === "loop_response")
                            if (be.files.length === 0) {
                                Qr.update(te=>!1);
                                return
                            } else
                                for (let te = 0; te < be.files.length; te++) {
                                    let ae = await es.getToken();
                                    fetch(`https://radar.quadweather.com/socket/data?site=${be.site}&file_name=${be.files[te]}`, {
                                        headers: {
                                            Authorization: `Bearer ${ae}`
                                        }
                                    }).then(se=>se.arrayBuffer()).then(se=>{
                                        let ke = []
                                          , tt = tn(ai).filter(Ke=>Ke != null);
                                        for (let Ke = 0; Ke < tt.length; Ke++)
                                            ke.push(tt[Ke].fileName);
                                        ke.indexOf(be.files[te]) < 0 && be.site === e && (A.has(be.files[te]) || (i++,
                                        A.set(be.files[te], {
                                            message: "initialize",
                                            fileName: be.files[te],
                                            buffer: se
                                        })),
                                        d && d(i),
                                        P(be.files[te]))
                                    }
                                    ).catch(se=>console.log(se))
                                }
                        if (be.action === "new_alerts") {
                            let te = await es.getToken();
                            fetch("https://radar.quadweather.com/socket/alerts", {
                                headers: {
                                    Authorization: `Bearer ${te}`
                                }
                            }).then(ae=>ae.json()).then(ae=>{
                                Vp.update(se=>(se = ae,
                                se))
                            }
                            ).catch(ae=>console.log("fetch error", ae))
                        }
                        if (be.action === "new_lightning") {
                            let te = await es.getToken();
                            fetch("https://radar.quadweather.com/socket/lightning", {
                                headers: {
                                    Authorization: `Bearer ${te}`
                                }
                            }).then(ae=>ae.json()).then(ae=>{
                                Gp.update(se=>(se = ae,
                                se))
                            }
                            ).catch(ae=>console.log("fetch error", ae))
                        }
                    }
                }
            }
            )
    }
    function fe() {
        if (e) {
            Z();
            let oe, ee = [], ne = tn(ai).filter(te=>te != null);
            for (let te = 0; te < ne.length; te++)
                ee.push(ne[te].fileName);
            let be = {
                id: t,
                site: e,
                action: "load_loop",
                fileNames: ee
            };
            r.send(JSON.stringify(be))
        }
    }
    function ce(oe) {
        if (oe != e)
            e = oe,
            p(),
            v = !1,
            Qr.update(j=>!0);
        else
            return;
        let ee = {
            id: t,
            site: e,
            action: "new_site"
        };
        r.send(JSON.stringify(ee))
    }
    function _e() {
        r && (r.close(),
        r = null)
    }
    return {
        get site() {
            return e
        },
        set site(oe) {
            e = oe
        },
        get ws() {
            return r
        },
        connect: W,
        close: _e,
        setSite: ce,
        loadLoop: fe,
        handleQueue: D,
        setTrigger: C,
        setCancel: I
    }
}
function gS() {
    let r = new Map
      , e = !1;
    function t(p) {
        return r.has(p)
    }
    function o(p) {
        return r.delete(p) ? (e = !1,
        0) : 1
    }
    function c() {
        let i = tn(ai).filter(A=>A != null).map(A=>A.fileName);
        if (r.size === 0) {
            e = !1;
            return
        }
        let v, x;
        for (let[A,C] of r)
            if (C.item.field != 255) {
                v = A,
                x = C;
                break
            }
        if (v || ([v] = r.keys(),
        x = r.get(v)),
        i.indexOf(x.item.fileName) < 0) {
            o(v) === 0 && c();
            return
        }
        let E = x.item.field;
        if (e = !0,
        E === 255)
            tn(Is).postMessage({
                message: "dealiasVelocity",
                data: x.item
            });
        else if (E === 1)
            tn(Is).postMessage({
                message: "loadVelocity",
                data: x.item
            });
        else if (E === 254) {
            let A = x.item.selections[0].file;
            if (x.item.scans[A] === void 0) {
                o(v) === 0 && c();
                return
            }
            tn(Is).postMessage({
                message: "set3d",
                data: x.item
            })
        } else
            tn(Is).postMessage({
                message: "loadData",
                data: x.item
            })
    }
    function d(p) {
        let i = `${p.fileName}_ ${p.field}_ ${p.idx}`;
        return t(i) ? 1 : (r.set(i, {
            status: "QUEUED",
            item: p
        }),
        r.size === 1 && c(),
        0)
    }
    return {
        enqueue: d,
        dequeue: c,
        deleteItem: o
    }
}
function _S(r, e) {
    let t = 0
      , o = e[0]
      , c = Math.abs(r - o);
    for (let d = 0; d < e.length; d++) {
        let p = Math.abs(r - e[d]);
        p < c && (c = p,
        o = e[d],
        t = d)
    }
    return t
}
function yS(r, e, t, o, c) {
    let d = 6378.1
      , p = Math.PI / 180
      , i = Math.acos(Math.sin(p * e) * Math.sin(p * o) + Math.cos(p * e) * Math.cos(p * o) * Math.cos(p * t - p * r))
      , v = i / Math.sin(i)
      , x = v * Math.cos(p * o) * Math.sin(p * t - p * r)
      , E = v * (Math.cos(e * p) * Math.sin(o * p) - Math.sin(e * p) * Math.cos(o * p) * Math.cos(t * p - r * p))
      , A = 6378.1 * Math.sqrt(x * x + E * E)
      , C = Math.tan(p * c) * A
      , I = d - d * Math.sin(Math.PI / 2 - A / d);
    return C + I
}
function xS() {
    let {LIVE: r} = Gs, e = go(), t = 0, o, c, d, p, i, v, x, E, A = tn(ws);
    function C() {
        return {
            max: E,
            fileIdx: v,
            station_state: d,
            elevation_state: p,
            idx: x,
            currentIdx: I(i)
        }
    }
    function I(_e) {
        if (_e === void 0 || !tn(ui)[0].scan)
            return;
        let oe = tn(ui)[0].scan.scan[0].date.getTime();
        for (let ee = 0; ee < _e.length; ee++)
            if (_e[ee][0].date.getTime() === oe)
                return ee
    }
    function D(_e) {
        let oe = tn(ui)
          , ee = tn($r);
        if (t = _e,
        t === 0) {
            if (Qr.set(!1),
            !oe[0].scan && !ji.site ? X({
                elevation: ee.elevations[ee.stations[0]][0],
                station: ee.stations[0]
            }) : !oe[0].scan && ji.site ? ee.elevations[ji.site] && X({
                elevation: ee.elevations[ji.site][0],
                station: ji.site
            }) : oe[0].scan && oe[0].scan.station != ji.site && ee.elevations[ji.site] && X({
                elevation: ee.elevations[ji.site][0],
                station: ji.site
            }),
            tn(md) && i) {
                let j = {
                    fileNumber: i[i.length - 1][0].fileNumber,
                    scan: i[i.length - 1],
                    fileName: i[i.length - 1][0].fileName,
                    station: ji.site
                };
                e.logStore(j),
                x = i.length - 1
            }
        } else
            Qr.set(!0)
    }
    function P() {
        _o.set(!1),
        window.cancelAnimationFrame(o),
        A[0].triggerRepaint(),
        tn(Jr) === Sr && A[1] && A[1].triggerRepaint()
    }
    function k(_e) {
        c === void 0 && (c = _e),
        _e - c >= 125 ? (W(),
        c = _e,
        x === E - 1 ? (window.cancelAnimationFrame(o),
        setTimeout(function() {
            if (tn(_o)) {
                x = 0,
                c = void 0;
                let ee = {
                    fileNumber: i[x][0].fileNumber,
                    scan: i[x],
                    fileName: i[x][0].fileName,
                    station: d
                };
                e.logStore(ee),
                o = window.requestAnimationFrame(k)
            }
        }, 1e3)) : o = window.requestAnimationFrame(k)) : o = window.requestAnimationFrame(k)
    }
    function U() {
        if (tn(_o))
            _o.set(!1),
            window.cancelAnimationFrame(o),
            A[0].triggerRepaint(),
            tn(Jr) === Sr && A[1] && A[1].triggerRepaint();
        else {
            _o.set(!0),
            x = 0,
            c = void 0;
            let _e = {
                fileNumber: i[x][0].fileNumber,
                scan: i[x],
                fileName: i[x][0].fileName,
                station: d
            };
            e.logStore(_e),
            o = window.requestAnimationFrame(k)
        }
    }
    ji.setTrigger(D),
    ji.setCancel(P);
    function Z() {
        let _e = tn(ui)
          , oe = tn($r);
        d = _e[0].scan ? _e[0].scan.station : void 0,
        p = _e[0].scan ? _e[0].scan.scan[0].rounded : void 0,
        i = oe.scans && _e[0].scan ? oe.scans[d][p] : void 0,
        v = _e[0].scan ? _e[0].scan.fileNumber : void 0,
        i && (E = i.length)
    }
    function K() {
        !tn($r).scans || !d || !p || (i = tn($r).scans[d][p],
        E = i.length,
        x = I(i))
    }
    function X(_e) {
        if (tn(Qr))
            return;
        x = I(i);
        let oe = 0, ee;
        i && (oe = i[x][0].date.getTime(),
        ee = i[x][0].fileNumber),
        i = tn($r).scans[_e.station][_e.elevation];
        let j = i.map(be=>be[0].date.getTime());
        E = i.length,
        x = _S(oe, j),
        i[x][0].fileNumber != ee && (x = 0);
        let ne = {
            fileNumber: i[x][0].fileNumber,
            scan: i[x],
            fileName: i[x][0].fileName,
            station: _e.station
        };
        tn(js) === r && (ji.setSite(_e.station),
        A[0].setLayoutProperty("sites", "icon-image", ["case", ["==", ["slice", ["get", "STATION_ID"], 7], ji.site], "selected", "unselected"]),
        (tn(Jr) === Sr || tn(Jr) === ja) && A[1] && A[1].setLayoutProperty("sites", "icon-image", ["case", ["==", ["slice", ["get", "STATION_ID"], 7], ji.site], "selected", "unselected"])),
        e.logStore(ne)
    }
    function W() {
        if (x === void 0 || (x = x + 1 < E ? x + 1 : x,
        x > E - 1 && (x = E - 1),
        x === E - 1 ? md.set(!0) : md.set(!1),
        i[x] === void 0))
            return;
        let _e = {
            fileNumber: i[x][0].fileNumber,
            scan: i[x],
            fileName: i[x][0].fileName,
            station: d
        };
        e.logStore(_e)
    }
    function fe() {
        if (x === void 0 || (x = x - 1 >= 0 ? x - 1 : x,
        x === E - 1 ? md.set(!0) : md.set(!1),
        i[x] === void 0))
            return;
        let _e = {
            fileNumber: i[x][0].fileNumber,
            scan: i[x],
            fileName: i[x][0].fileName,
            station: d
        };
        e.logStore(_e)
    }
    function ce() {
        tn(Qr) || (Qr.set(!0),
        ji.loadLoop())
    }
    return {
        handleClick: X,
        setSites: K,
        setStates: Z,
        handleLoadClick: ce,
        setValues: C,
        previous: fe,
        advance: W,
        handleAnimateClick: U
    }
}
var vS = class {
    constructor(e=[], t=LR) {
        if (this.data = e,
        this.length = this.data.length,
        this.compare = t,
        this.length > 0)
            for (let o = (this.length >> 1) - 1; o >= 0; o--)
                this._down(o)
    }
    push(e) {
        this.data.push(e),
        this.length++,
        this._up(this.length - 1)
    }
    pop() {
        if (this.length === 0)
            return;
        let e = this.data[0]
          , t = this.data.pop();
        return this.length--,
        this.length > 0 && (this.data[0] = t,
        this._down(0)),
        e
    }
    peek() {
        return this.data[0]
    }
    _up(e) {
        let {data: t, compare: o} = this
          , c = t[e];
        for (; e > 0; ) {
            let d = e - 1 >> 1
              , p = t[d];
            if (o(c, p) >= 0)
                break;
            t[e] = p,
            e = d
        }
        t[e] = c
    }
    _down(e) {
        let {data: t, compare: o} = this
          , c = this.length >> 1
          , d = t[e];
        for (; e < c; ) {
            let p = (e << 1) + 1
              , i = t[p]
              , v = p + 1;
            if (v < this.length && o(t[v], i) < 0 && (p = v,
            i = t[v]),
            o(i, d) >= 0)
                break;
            t[e] = i,
            e = p
        }
        t[e] = d
    }
}
;
function LR(r, e) {
    return r < e ? -1 : r > e ? 1 : 0
}
var J_ = vS;
var RR = 4
  , bS = 0
  , wS = 1
  , PR = 2;
function gd(r) {
    let e = r.length;
    for (; --e >= 0; )
        r[e] = 0
}
var kR = 0
  , TS = 1
  , zR = 2
  , OR = 3
  , NR = 258
  , Sv = 29
  , Hp = 256
  , Wp = Hp + 1 + Sv
  , _d = 30
  , Av = 19
  , ES = 2 * Wp + 1
  , Eu = 15
  , Mv = 16
  , FR = 7
  , Iv = 256
  , SS = 16
  , AS = 17
  , MS = 18
  , Cv = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0])
  , $_ = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13])
  , BR = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7])
  , IS = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
  , UR = 512
  , qa = new Array((Wp + 2) * 2);
gd(qa);
var jp = new Array(_d * 2);
gd(jp);
var Xp = new Array(UR);
gd(Xp);
var Zp = new Array(NR - OR + 1);
gd(Zp);
var Dv = new Array(Sv);
gd(Dv);
var Q_ = new Array(_d);
gd(Q_);
function Lv(r, e, t, o, c) {
    this.static_tree = r,
    this.extra_bits = e,
    this.extra_base = t,
    this.elems = o,
    this.max_length = c,
    this.has_stree = r && r.length
}
var CS, DS, LS;
function Rv(r, e) {
    this.dyn_tree = r,
    this.max_code = 0,
    this.stat_desc = e
}
var RS = r=>r < 256 ? Xp[r] : Xp[256 + (r >>> 7)]
  , qp = (r,e)=>{
    r.pending_buf[r.pending++] = e & 255,
    r.pending_buf[r.pending++] = e >>> 8 & 255
}
  , Xs = (r,e,t)=>{
    r.bi_valid > Mv - t ? (r.bi_buf |= e << r.bi_valid & 65535,
    qp(r, r.bi_buf),
    r.bi_buf = e >> Mv - r.bi_valid,
    r.bi_valid += t - Mv) : (r.bi_buf |= e << r.bi_valid & 65535,
    r.bi_valid += t)
}
  , fa = (r,e,t)=>{
    Xs(r, t[e * 2], t[e * 2 + 1])
}
  , PS = (r,e)=>{
    let t = 0;
    do
        t |= r & 1,
        r >>>= 1,
        t <<= 1;
    while (--e > 0);
    return t >>> 1
}
  , VR = r=>{
    r.bi_valid === 16 ? (qp(r, r.bi_buf),
    r.bi_buf = 0,
    r.bi_valid = 0) : r.bi_valid >= 8 && (r.pending_buf[r.pending++] = r.bi_buf & 255,
    r.bi_buf >>= 8,
    r.bi_valid -= 8)
}
  , GR = (r,e)=>{
    let t = e.dyn_tree, o = e.max_code, c = e.stat_desc.static_tree, d = e.stat_desc.has_stree, p = e.stat_desc.extra_bits, i = e.stat_desc.extra_base, v = e.stat_desc.max_length, x, E, A, C, I, D, P = 0;
    for (C = 0; C <= Eu; C++)
        r.bl_count[C] = 0;
    for (t[r.heap[r.heap_max] * 2 + 1] = 0,
    x = r.heap_max + 1; x < ES; x++)
        E = r.heap[x],
        C = t[t[E * 2 + 1] * 2 + 1] + 1,
        C > v && (C = v,
        P++),
        t[E * 2 + 1] = C,
        !(E > o) && (r.bl_count[C]++,
        I = 0,
        E >= i && (I = p[E - i]),
        D = t[E * 2],
        r.opt_len += D * (C + I),
        d && (r.static_len += D * (c[E * 2 + 1] + I)));
    if (P !== 0) {
        do {
            for (C = v - 1; r.bl_count[C] === 0; )
                C--;
            r.bl_count[C]--,
            r.bl_count[C + 1] += 2,
            r.bl_count[v]--,
            P -= 2
        } while (P > 0);
        for (C = v; C !== 0; C--)
            for (E = r.bl_count[C]; E !== 0; )
                A = r.heap[--x],
                !(A > o) && (t[A * 2 + 1] !== C && (r.opt_len += (C - t[A * 2 + 1]) * t[A * 2],
                t[A * 2 + 1] = C),
                E--)
    }
}
  , kS = (r,e,t)=>{
    let o = new Array(Eu + 1), c = 0, d, p;
    for (d = 1; d <= Eu; d++)
        o[d] = c = c + t[d - 1] << 1;
    for (p = 0; p <= e; p++) {
        let i = r[p * 2 + 1];
        i !== 0 && (r[p * 2] = PS(o[i]++, i))
    }
}
  , HR = ()=>{
    let r, e, t, o, c, d = new Array(Eu + 1);
    for (t = 0,
    o = 0; o < Sv - 1; o++)
        for (Dv[o] = t,
        r = 0; r < 1 << Cv[o]; r++)
            Zp[t++] = o;
    for (Zp[t - 1] = o,
    c = 0,
    o = 0; o < 16; o++)
        for (Q_[o] = c,
        r = 0; r < 1 << $_[o]; r++)
            Xp[c++] = o;
    for (c >>= 7; o < _d; o++)
        for (Q_[o] = c << 7,
        r = 0; r < 1 << $_[o] - 7; r++)
            Xp[256 + c++] = o;
    for (e = 0; e <= Eu; e++)
        d[e] = 0;
    for (r = 0; r <= 143; )
        qa[r * 2 + 1] = 8,
        r++,
        d[8]++;
    for (; r <= 255; )
        qa[r * 2 + 1] = 9,
        r++,
        d[9]++;
    for (; r <= 279; )
        qa[r * 2 + 1] = 7,
        r++,
        d[7]++;
    for (; r <= 287; )
        qa[r * 2 + 1] = 8,
        r++,
        d[8]++;
    for (kS(qa, Wp + 1, d),
    r = 0; r < _d; r++)
        jp[r * 2 + 1] = 5,
        jp[r * 2] = PS(r, 5);
    CS = new Lv(qa,Cv,Hp + 1,Wp,Eu),
    DS = new Lv(jp,$_,0,_d,Eu),
    LS = new Lv(new Array(0),BR,0,Av,FR)
}
  , zS = r=>{
    let e;
    for (e = 0; e < Wp; e++)
        r.dyn_ltree[e * 2] = 0;
    for (e = 0; e < _d; e++)
        r.dyn_dtree[e * 2] = 0;
    for (e = 0; e < Av; e++)
        r.bl_tree[e * 2] = 0;
    r.dyn_ltree[Iv * 2] = 1,
    r.opt_len = r.static_len = 0,
    r.last_lit = r.matches = 0
}
  , OS = r=>{
    r.bi_valid > 8 ? qp(r, r.bi_buf) : r.bi_valid > 0 && (r.pending_buf[r.pending++] = r.bi_buf),
    r.bi_buf = 0,
    r.bi_valid = 0
}
  , WR = (r,e,t,o)=>{
    OS(r),
    o && (qp(r, t),
    qp(r, ~t)),
    r.pending_buf.set(r.window.subarray(e, e + t), r.pending),
    r.pending += t
}
  , NS = (r,e,t,o)=>{
    let c = e * 2
      , d = t * 2;
    return r[c] < r[d] || r[c] === r[d] && o[e] <= o[t]
}
  , Pv = (r,e,t)=>{
    let o = r.heap[t]
      , c = t << 1;
    for (; c <= r.heap_len && (c < r.heap_len && NS(e, r.heap[c + 1], r.heap[c], r.depth) && c++,
    !NS(e, o, r.heap[c], r.depth)); )
        r.heap[t] = r.heap[c],
        t = c,
        c <<= 1;
    r.heap[t] = o
}
  , FS = (r,e,t)=>{
    let o, c, d = 0, p, i;
    if (r.last_lit !== 0)
        do
            o = r.pending_buf[r.d_buf + d * 2] << 8 | r.pending_buf[r.d_buf + d * 2 + 1],
            c = r.pending_buf[r.l_buf + d],
            d++,
            o === 0 ? fa(r, c, e) : (p = Zp[c],
            fa(r, p + Hp + 1, e),
            i = Cv[p],
            i !== 0 && (c -= Dv[p],
            Xs(r, c, i)),
            o--,
            p = RS(o),
            fa(r, p, t),
            i = $_[p],
            i !== 0 && (o -= Q_[p],
            Xs(r, o, i)));
        while (d < r.last_lit);
    fa(r, Iv, e)
}
  , kv = (r,e)=>{
    let t = e.dyn_tree, o = e.stat_desc.static_tree, c = e.stat_desc.has_stree, d = e.stat_desc.elems, p, i, v = -1, x;
    for (r.heap_len = 0,
    r.heap_max = ES,
    p = 0; p < d; p++)
        t[p * 2] !== 0 ? (r.heap[++r.heap_len] = v = p,
        r.depth[p] = 0) : t[p * 2 + 1] = 0;
    for (; r.heap_len < 2; )
        x = r.heap[++r.heap_len] = v < 2 ? ++v : 0,
        t[x * 2] = 1,
        r.depth[x] = 0,
        r.opt_len--,
        c && (r.static_len -= o[x * 2 + 1]);
    for (e.max_code = v,
    p = r.heap_len >> 1; p >= 1; p--)
        Pv(r, t, p);
    x = d;
    do
        p = r.heap[1],
        r.heap[1] = r.heap[r.heap_len--],
        Pv(r, t, 1),
        i = r.heap[1],
        r.heap[--r.heap_max] = p,
        r.heap[--r.heap_max] = i,
        t[x * 2] = t[p * 2] + t[i * 2],
        r.depth[x] = (r.depth[p] >= r.depth[i] ? r.depth[p] : r.depth[i]) + 1,
        t[p * 2 + 1] = t[i * 2 + 1] = x,
        r.heap[1] = x++,
        Pv(r, t, 1);
    while (r.heap_len >= 2);
    r.heap[--r.heap_max] = r.heap[1],
    GR(r, e),
    kS(t, v, r.bl_count)
}
  , BS = (r,e,t)=>{
    let o, c = -1, d, p = e[0 * 2 + 1], i = 0, v = 7, x = 4;
    for (p === 0 && (v = 138,
    x = 3),
    e[(t + 1) * 2 + 1] = 65535,
    o = 0; o <= t; o++)
        d = p,
        p = e[(o + 1) * 2 + 1],
        !(++i < v && d === p) && (i < x ? r.bl_tree[d * 2] += i : d !== 0 ? (d !== c && r.bl_tree[d * 2]++,
        r.bl_tree[SS * 2]++) : i <= 10 ? r.bl_tree[AS * 2]++ : r.bl_tree[MS * 2]++,
        i = 0,
        c = d,
        p === 0 ? (v = 138,
        x = 3) : d === p ? (v = 6,
        x = 3) : (v = 7,
        x = 4))
}
  , US = (r,e,t)=>{
    let o, c = -1, d, p = e[0 * 2 + 1], i = 0, v = 7, x = 4;
    for (p === 0 && (v = 138,
    x = 3),
    o = 0; o <= t; o++)
        if (d = p,
        p = e[(o + 1) * 2 + 1],
        !(++i < v && d === p)) {
            if (i < x)
                do
                    fa(r, d, r.bl_tree);
                while (--i != 0);
            else
                d !== 0 ? (d !== c && (fa(r, d, r.bl_tree),
                i--),
                fa(r, SS, r.bl_tree),
                Xs(r, i - 3, 2)) : i <= 10 ? (fa(r, AS, r.bl_tree),
                Xs(r, i - 3, 3)) : (fa(r, MS, r.bl_tree),
                Xs(r, i - 11, 7));
            i = 0,
            c = d,
            p === 0 ? (v = 138,
            x = 3) : d === p ? (v = 6,
            x = 3) : (v = 7,
            x = 4)
        }
}
  , jR = r=>{
    let e;
    for (BS(r, r.dyn_ltree, r.l_desc.max_code),
    BS(r, r.dyn_dtree, r.d_desc.max_code),
    kv(r, r.bl_desc),
    e = Av - 1; e >= 3 && r.bl_tree[IS[e] * 2 + 1] === 0; e--)
        ;
    return r.opt_len += 3 * (e + 1) + 5 + 5 + 4,
    e
}
  , XR = (r,e,t,o)=>{
    let c;
    for (Xs(r, e - 257, 5),
    Xs(r, t - 1, 5),
    Xs(r, o - 4, 4),
    c = 0; c < o; c++)
        Xs(r, r.bl_tree[IS[c] * 2 + 1], 3);
    US(r, r.dyn_ltree, e - 1),
    US(r, r.dyn_dtree, t - 1)
}
  , ZR = r=>{
    let e = 4093624447, t;
    for (t = 0; t <= 31; t++,
    e >>>= 1)
        if (e & 1 && r.dyn_ltree[t * 2] !== 0)
            return bS;
    if (r.dyn_ltree[9 * 2] !== 0 || r.dyn_ltree[10 * 2] !== 0 || r.dyn_ltree[13 * 2] !== 0)
        return wS;
    for (t = 32; t < Hp; t++)
        if (r.dyn_ltree[t * 2] !== 0)
            return wS;
    return bS
}
  , VS = !1
  , qR = r=>{
    VS || (HR(),
    VS = !0),
    r.l_desc = new Rv(r.dyn_ltree,CS),
    r.d_desc = new Rv(r.dyn_dtree,DS),
    r.bl_desc = new Rv(r.bl_tree,LS),
    r.bi_buf = 0,
    r.bi_valid = 0,
    zS(r)
}
  , GS = (r,e,t,o)=>{
    Xs(r, (kR << 1) + (o ? 1 : 0), 3),
    WR(r, e, t, !0)
}
  , KR = r=>{
    Xs(r, TS << 1, 3),
    fa(r, Iv, qa),
    VR(r)
}
  , YR = (r,e,t,o)=>{
    let c, d, p = 0;
    r.level > 0 ? (r.strm.data_type === PR && (r.strm.data_type = ZR(r)),
    kv(r, r.l_desc),
    kv(r, r.d_desc),
    p = jR(r),
    c = r.opt_len + 3 + 7 >>> 3,
    d = r.static_len + 3 + 7 >>> 3,
    d <= c && (c = d)) : c = d = t + 5,
    t + 4 <= c && e !== -1 ? GS(r, e, t, o) : r.strategy === RR || d === c ? (Xs(r, (TS << 1) + (o ? 1 : 0), 3),
    FS(r, qa, jp)) : (Xs(r, (zR << 1) + (o ? 1 : 0), 3),
    XR(r, r.l_desc.max_code + 1, r.d_desc.max_code + 1, p + 1),
    FS(r, r.dyn_ltree, r.dyn_dtree)),
    zS(r),
    o && OS(r)
}
  , JR = (r,e,t)=>(r.pending_buf[r.d_buf + r.last_lit * 2] = e >>> 8 & 255,
r.pending_buf[r.d_buf + r.last_lit * 2 + 1] = e & 255,
r.pending_buf[r.l_buf + r.last_lit] = t & 255,
r.last_lit++,
e === 0 ? r.dyn_ltree[t * 2]++ : (r.matches++,
e--,
r.dyn_ltree[(Zp[t] + Hp + 1) * 2]++,
r.dyn_dtree[RS(e) * 2]++),
r.last_lit === r.lit_bufsize - 1)
  , $R = qR
  , QR = GS
  , eP = YR
  , tP = JR
  , nP = KR
  , iP = {
    _tr_init: $R,
    _tr_stored_block: QR,
    _tr_flush_block: eP,
    _tr_tally: tP,
    _tr_align: nP
}
  , rP = (r,e,t,o)=>{
    let c = r & 65535 | 0
      , d = r >>> 16 & 65535 | 0
      , p = 0;
    for (; t !== 0; ) {
        p = t > 2e3 ? 2e3 : t,
        t -= p;
        do
            c = c + e[o++] | 0,
            d = d + c | 0;
        while (--p);
        c %= 65521,
        d %= 65521
    }
    return c | d << 16 | 0
}
  , Kp = rP
  , sP = ()=>{
    let r, e = [];
    for (var t = 0; t < 256; t++) {
        r = t;
        for (var o = 0; o < 8; o++)
            r = r & 1 ? 3988292384 ^ r >>> 1 : r >>> 1;
        e[t] = r
    }
    return e
}
  , oP = new Uint32Array(sP())
  , aP = (r,e,t,o)=>{
    let c = oP
      , d = o + t;
    r ^= -1;
    for (let p = o; p < d; p++)
        r = r >>> 8 ^ c[(r ^ e[p]) & 255];
    return r ^ -1
}
  , ts = aP
  , yd = {
    2: "need dictionary",
    1: "stream end",
    0: "",
    "-1": "file error",
    "-2": "stream error",
    "-3": "data error",
    "-4": "insufficient memory",
    "-5": "buffer error",
    "-6": "incompatible version"
}
  , Yp = {
    Z_NO_FLUSH: 0,
    Z_PARTIAL_FLUSH: 1,
    Z_SYNC_FLUSH: 2,
    Z_FULL_FLUSH: 3,
    Z_FINISH: 4,
    Z_BLOCK: 5,
    Z_TREES: 6,
    Z_OK: 0,
    Z_STREAM_END: 1,
    Z_NEED_DICT: 2,
    Z_ERRNO: -1,
    Z_STREAM_ERROR: -2,
    Z_DATA_ERROR: -3,
    Z_MEM_ERROR: -4,
    Z_BUF_ERROR: -5,
    Z_NO_COMPRESSION: 0,
    Z_BEST_SPEED: 1,
    Z_BEST_COMPRESSION: 9,
    Z_DEFAULT_COMPRESSION: -1,
    Z_FILTERED: 1,
    Z_HUFFMAN_ONLY: 2,
    Z_RLE: 3,
    Z_FIXED: 4,
    Z_DEFAULT_STRATEGY: 0,
    Z_BINARY: 0,
    Z_TEXT: 1,
    Z_UNKNOWN: 2,
    Z_DEFLATED: 8
}
  , {_tr_init: lP, _tr_stored_block: cP, _tr_flush_block: uP, _tr_tally: Xl, _tr_align: hP} = iP
  , {Z_NO_FLUSH: Su, Z_PARTIAL_FLUSH: dP, Z_FULL_FLUSH: fP, Z_FINISH: Zl, Z_BLOCK: HS, Z_OK: pa, Z_STREAM_END: WS, Z_STREAM_ERROR: yo, Z_DATA_ERROR: pP, Z_BUF_ERROR: zv, Z_DEFAULT_COMPRESSION: mP, Z_FILTERED: gP, Z_HUFFMAN_ONLY: ey, Z_RLE: _P, Z_FIXED: yP, Z_DEFAULT_STRATEGY: xP, Z_UNKNOWN: vP, Z_DEFLATED: ty} = Yp
  , bP = 9
  , wP = 15
  , TP = 8
  , EP = 29
  , SP = 256
  , Ov = SP + 1 + EP
  , AP = 30
  , MP = 19
  , IP = 2 * Ov + 1
  , CP = 15
  , xi = 3
  , ql = 258
  , No = ql + xi + 1
  , DP = 32
  , ny = 42
  , Nv = 69
  , iy = 73
  , ry = 91
  , sy = 103
  , Au = 113
  , Jp = 666
  , Or = 1
  , $p = 2
  , Mu = 3
  , xd = 4
  , LP = 3
  , Kl = (r,e)=>(r.msg = yd[e],
e)
  , jS = r=>(r << 1) - (r > 4 ? 9 : 0)
  , Yl = r=>{
    let e = r.length;
    for (; --e >= 0; )
        r[e] = 0
}
  , RP = (r,e,t)=>(e << r.hash_shift ^ t) & r.hash_mask
  , Jl = RP
  , $l = r=>{
    let e = r.state
      , t = e.pending;
    t > r.avail_out && (t = r.avail_out),
    t !== 0 && (r.output.set(e.pending_buf.subarray(e.pending_out, e.pending_out + t), r.next_out),
    r.next_out += t,
    e.pending_out += t,
    r.total_out += t,
    r.avail_out -= t,
    e.pending -= t,
    e.pending === 0 && (e.pending_out = 0))
}
  , us = (r,e)=>{
    uP(r, r.block_start >= 0 ? r.block_start : -1, r.strstart - r.block_start, e),
    r.block_start = r.strstart,
    $l(r.strm)
}
  , Ci = (r,e)=>{
    r.pending_buf[r.pending++] = e
}
  , Qp = (r,e)=>{
    r.pending_buf[r.pending++] = e >>> 8 & 255,
    r.pending_buf[r.pending++] = e & 255
}
  , PP = (r,e,t,o)=>{
    let c = r.avail_in;
    return c > o && (c = o),
    c === 0 ? 0 : (r.avail_in -= c,
    e.set(r.input.subarray(r.next_in, r.next_in + c), t),
    r.state.wrap === 1 ? r.adler = Kp(r.adler, e, c, t) : r.state.wrap === 2 && (r.adler = ts(r.adler, e, c, t)),
    r.next_in += c,
    r.total_in += c,
    c)
}
  , XS = (r,e)=>{
    let t = r.max_chain_length, o = r.strstart, c, d, p = r.prev_length, i = r.nice_match, v = r.strstart > r.w_size - No ? r.strstart - (r.w_size - No) : 0, x = r.window, E = r.w_mask, A = r.prev, C = r.strstart + ql, I = x[o + p - 1], D = x[o + p];
    r.prev_length >= r.good_match && (t >>= 2),
    i > r.lookahead && (i = r.lookahead);
    do
        if (c = e,
        !(x[c + p] !== D || x[c + p - 1] !== I || x[c] !== x[o] || x[++c] !== x[o + 1])) {
            o += 2,
            c++;
            do
                ;
            while (x[++o] === x[++c] && x[++o] === x[++c] && x[++o] === x[++c] && x[++o] === x[++c] && x[++o] === x[++c] && x[++o] === x[++c] && x[++o] === x[++c] && x[++o] === x[++c] && o < C);
            if (d = ql - (C - o),
            o = C - ql,
            d > p) {
                if (r.match_start = e,
                p = d,
                d >= i)
                    break;
                I = x[o + p - 1],
                D = x[o + p]
            }
        }
    while ((e = A[e & E]) > v && --t != 0);
    return p <= r.lookahead ? p : r.lookahead
}
  , Iu = r=>{
    let e = r.w_size, t, o, c, d, p;
    do {
        if (d = r.window_size - r.lookahead - r.strstart,
        r.strstart >= e + (e - No)) {
            r.window.set(r.window.subarray(e, e + e), 0),
            r.match_start -= e,
            r.strstart -= e,
            r.block_start -= e,
            o = r.hash_size,
            t = o;
            do
                c = r.head[--t],
                r.head[t] = c >= e ? c - e : 0;
            while (--o);
            o = e,
            t = o;
            do
                c = r.prev[--t],
                r.prev[t] = c >= e ? c - e : 0;
            while (--o);
            d += e
        }
        if (r.strm.avail_in === 0)
            break;
        if (o = PP(r.strm, r.window, r.strstart + r.lookahead, d),
        r.lookahead += o,
        r.lookahead + r.insert >= xi)
            for (p = r.strstart - r.insert,
            r.ins_h = r.window[p],
            r.ins_h = Jl(r, r.ins_h, r.window[p + 1]); r.insert && (r.ins_h = Jl(r, r.ins_h, r.window[p + xi - 1]),
            r.prev[p & r.w_mask] = r.head[r.ins_h],
            r.head[r.ins_h] = p,
            p++,
            r.insert--,
            !(r.lookahead + r.insert < xi)); )
                ;
    } while (r.lookahead < No && r.strm.avail_in !== 0)
}
  , kP = (r,e)=>{
    let t = 65535;
    for (t > r.pending_buf_size - 5 && (t = r.pending_buf_size - 5); ; ) {
        if (r.lookahead <= 1) {
            if (Iu(r),
            r.lookahead === 0 && e === Su)
                return Or;
            if (r.lookahead === 0)
                break
        }
        r.strstart += r.lookahead,
        r.lookahead = 0;
        let o = r.block_start + t;
        if ((r.strstart === 0 || r.strstart >= o) && (r.lookahead = r.strstart - o,
        r.strstart = o,
        us(r, !1),
        r.strm.avail_out === 0) || r.strstart - r.block_start >= r.w_size - No && (us(r, !1),
        r.strm.avail_out === 0))
            return Or
    }
    return r.insert = 0,
    e === Zl ? (us(r, !0),
    r.strm.avail_out === 0 ? Mu : xd) : (r.strstart > r.block_start && (us(r, !1),
    r.strm.avail_out === 0),
    Or)
}
  , Fv = (r,e)=>{
    let t, o;
    for (; ; ) {
        if (r.lookahead < No) {
            if (Iu(r),
            r.lookahead < No && e === Su)
                return Or;
            if (r.lookahead === 0)
                break
        }
        if (t = 0,
        r.lookahead >= xi && (r.ins_h = Jl(r, r.ins_h, r.window[r.strstart + xi - 1]),
        t = r.prev[r.strstart & r.w_mask] = r.head[r.ins_h],
        r.head[r.ins_h] = r.strstart),
        t !== 0 && r.strstart - t <= r.w_size - No && (r.match_length = XS(r, t)),
        r.match_length >= xi)
            if (o = Xl(r, r.strstart - r.match_start, r.match_length - xi),
            r.lookahead -= r.match_length,
            r.match_length <= r.max_lazy_match && r.lookahead >= xi) {
                r.match_length--;
                do
                    r.strstart++,
                    r.ins_h = Jl(r, r.ins_h, r.window[r.strstart + xi - 1]),
                    t = r.prev[r.strstart & r.w_mask] = r.head[r.ins_h],
                    r.head[r.ins_h] = r.strstart;
                while (--r.match_length != 0);
                r.strstart++
            } else
                r.strstart += r.match_length,
                r.match_length = 0,
                r.ins_h = r.window[r.strstart],
                r.ins_h = Jl(r, r.ins_h, r.window[r.strstart + 1]);
        else
            o = Xl(r, 0, r.window[r.strstart]),
            r.lookahead--,
            r.strstart++;
        if (o && (us(r, !1),
        r.strm.avail_out === 0))
            return Or
    }
    return r.insert = r.strstart < xi - 1 ? r.strstart : xi - 1,
    e === Zl ? (us(r, !0),
    r.strm.avail_out === 0 ? Mu : xd) : r.last_lit && (us(r, !1),
    r.strm.avail_out === 0) ? Or : $p
}
  , vd = (r,e)=>{
    let t, o, c;
    for (; ; ) {
        if (r.lookahead < No) {
            if (Iu(r),
            r.lookahead < No && e === Su)
                return Or;
            if (r.lookahead === 0)
                break
        }
        if (t = 0,
        r.lookahead >= xi && (r.ins_h = Jl(r, r.ins_h, r.window[r.strstart + xi - 1]),
        t = r.prev[r.strstart & r.w_mask] = r.head[r.ins_h],
        r.head[r.ins_h] = r.strstart),
        r.prev_length = r.match_length,
        r.prev_match = r.match_start,
        r.match_length = xi - 1,
        t !== 0 && r.prev_length < r.max_lazy_match && r.strstart - t <= r.w_size - No && (r.match_length = XS(r, t),
        r.match_length <= 5 && (r.strategy === gP || r.match_length === xi && r.strstart - r.match_start > 4096) && (r.match_length = xi - 1)),
        r.prev_length >= xi && r.match_length <= r.prev_length) {
            c = r.strstart + r.lookahead - xi,
            o = Xl(r, r.strstart - 1 - r.prev_match, r.prev_length - xi),
            r.lookahead -= r.prev_length - 1,
            r.prev_length -= 2;
            do
                ++r.strstart <= c && (r.ins_h = Jl(r, r.ins_h, r.window[r.strstart + xi - 1]),
                t = r.prev[r.strstart & r.w_mask] = r.head[r.ins_h],
                r.head[r.ins_h] = r.strstart);
            while (--r.prev_length != 0);
            if (r.match_available = 0,
            r.match_length = xi - 1,
            r.strstart++,
            o && (us(r, !1),
            r.strm.avail_out === 0))
                return Or
        } else if (r.match_available) {
            if (o = Xl(r, 0, r.window[r.strstart - 1]),
            o && us(r, !1),
            r.strstart++,
            r.lookahead--,
            r.strm.avail_out === 0)
                return Or
        } else
            r.match_available = 1,
            r.strstart++,
            r.lookahead--
    }
    return r.match_available && (o = Xl(r, 0, r.window[r.strstart - 1]),
    r.match_available = 0),
    r.insert = r.strstart < xi - 1 ? r.strstart : xi - 1,
    e === Zl ? (us(r, !0),
    r.strm.avail_out === 0 ? Mu : xd) : r.last_lit && (us(r, !1),
    r.strm.avail_out === 0) ? Or : $p
}
  , zP = (r,e)=>{
    let t, o, c, d, p = r.window;
    for (; ; ) {
        if (r.lookahead <= ql) {
            if (Iu(r),
            r.lookahead <= ql && e === Su)
                return Or;
            if (r.lookahead === 0)
                break
        }
        if (r.match_length = 0,
        r.lookahead >= xi && r.strstart > 0 && (c = r.strstart - 1,
        o = p[c],
        o === p[++c] && o === p[++c] && o === p[++c])) {
            d = r.strstart + ql;
            do
                ;
            while (o === p[++c] && o === p[++c] && o === p[++c] && o === p[++c] && o === p[++c] && o === p[++c] && o === p[++c] && o === p[++c] && c < d);
            r.match_length = ql - (d - c),
            r.match_length > r.lookahead && (r.match_length = r.lookahead)
        }
        if (r.match_length >= xi ? (t = Xl(r, 1, r.match_length - xi),
        r.lookahead -= r.match_length,
        r.strstart += r.match_length,
        r.match_length = 0) : (t = Xl(r, 0, r.window[r.strstart]),
        r.lookahead--,
        r.strstart++),
        t && (us(r, !1),
        r.strm.avail_out === 0))
            return Or
    }
    return r.insert = 0,
    e === Zl ? (us(r, !0),
    r.strm.avail_out === 0 ? Mu : xd) : r.last_lit && (us(r, !1),
    r.strm.avail_out === 0) ? Or : $p
}
  , OP = (r,e)=>{
    let t;
    for (; ; ) {
        if (r.lookahead === 0 && (Iu(r),
        r.lookahead === 0)) {
            if (e === Su)
                return Or;
            break
        }
        if (r.match_length = 0,
        t = Xl(r, 0, r.window[r.strstart]),
        r.lookahead--,
        r.strstart++,
        t && (us(r, !1),
        r.strm.avail_out === 0))
            return Or
    }
    return r.insert = 0,
    e === Zl ? (us(r, !0),
    r.strm.avail_out === 0 ? Mu : xd) : r.last_lit && (us(r, !1),
    r.strm.avail_out === 0) ? Or : $p
}
;
function ma(r, e, t, o, c) {
    this.good_length = r,
    this.max_lazy = e,
    this.nice_length = t,
    this.max_chain = o,
    this.func = c
}
var em = [new ma(0,0,0,0,kP), new ma(4,4,8,4,Fv), new ma(4,5,16,8,Fv), new ma(4,6,32,32,Fv), new ma(4,4,16,16,vd), new ma(8,16,32,32,vd), new ma(8,16,128,128,vd), new ma(8,32,128,256,vd), new ma(32,128,258,1024,vd), new ma(32,258,258,4096,vd)]
  , NP = r=>{
    r.window_size = 2 * r.w_size,
    Yl(r.head),
    r.max_lazy_match = em[r.level].max_lazy,
    r.good_match = em[r.level].good_length,
    r.nice_match = em[r.level].nice_length,
    r.max_chain_length = em[r.level].max_chain,
    r.strstart = 0,
    r.block_start = 0,
    r.lookahead = 0,
    r.insert = 0,
    r.match_length = r.prev_length = xi - 1,
    r.match_available = 0,
    r.ins_h = 0
}
;
function FP() {
    this.strm = null,
    this.status = 0,
    this.pending_buf = null,
    this.pending_buf_size = 0,
    this.pending_out = 0,
    this.pending = 0,
    this.wrap = 0,
    this.gzhead = null,
    this.gzindex = 0,
    this.method = ty,
    this.last_flush = -1,
    this.w_size = 0,
    this.w_bits = 0,
    this.w_mask = 0,
    this.window = null,
    this.window_size = 0,
    this.prev = null,
    this.head = null,
    this.ins_h = 0,
    this.hash_size = 0,
    this.hash_bits = 0,
    this.hash_mask = 0,
    this.hash_shift = 0,
    this.block_start = 0,
    this.match_length = 0,
    this.prev_match = 0,
    this.match_available = 0,
    this.strstart = 0,
    this.match_start = 0,
    this.lookahead = 0,
    this.prev_length = 0,
    this.max_chain_length = 0,
    this.max_lazy_match = 0,
    this.level = 0,
    this.strategy = 0,
    this.good_match = 0,
    this.nice_match = 0,
    this.dyn_ltree = new Uint16Array(IP * 2),
    this.dyn_dtree = new Uint16Array((2 * AP + 1) * 2),
    this.bl_tree = new Uint16Array((2 * MP + 1) * 2),
    Yl(this.dyn_ltree),
    Yl(this.dyn_dtree),
    Yl(this.bl_tree),
    this.l_desc = null,
    this.d_desc = null,
    this.bl_desc = null,
    this.bl_count = new Uint16Array(CP + 1),
    this.heap = new Uint16Array(2 * Ov + 1),
    Yl(this.heap),
    this.heap_len = 0,
    this.heap_max = 0,
    this.depth = new Uint16Array(2 * Ov + 1),
    Yl(this.depth),
    this.l_buf = 0,
    this.lit_bufsize = 0,
    this.last_lit = 0,
    this.d_buf = 0,
    this.opt_len = 0,
    this.static_len = 0,
    this.matches = 0,
    this.insert = 0,
    this.bi_buf = 0,
    this.bi_valid = 0
}
var ZS = r=>{
    if (!r || !r.state)
        return Kl(r, yo);
    r.total_in = r.total_out = 0,
    r.data_type = vP;
    let e = r.state;
    return e.pending = 0,
    e.pending_out = 0,
    e.wrap < 0 && (e.wrap = -e.wrap),
    e.status = e.wrap ? ny : Au,
    r.adler = e.wrap === 2 ? 0 : 1,
    e.last_flush = Su,
    lP(e),
    pa
}
  , qS = r=>{
    let e = ZS(r);
    return e === pa && NP(r.state),
    e
}
  , BP = (r,e)=>!r || !r.state || r.state.wrap !== 2 ? yo : (r.state.gzhead = e,
pa)
  , KS = (r,e,t,o,c,d)=>{
    if (!r)
        return yo;
    let p = 1;
    if (e === mP && (e = 6),
    o < 0 ? (p = 0,
    o = -o) : o > 15 && (p = 2,
    o -= 16),
    c < 1 || c > bP || t !== ty || o < 8 || o > 15 || e < 0 || e > 9 || d < 0 || d > yP)
        return Kl(r, yo);
    o === 8 && (o = 9);
    let i = new FP;
    return r.state = i,
    i.strm = r,
    i.wrap = p,
    i.gzhead = null,
    i.w_bits = o,
    i.w_size = 1 << i.w_bits,
    i.w_mask = i.w_size - 1,
    i.hash_bits = c + 7,
    i.hash_size = 1 << i.hash_bits,
    i.hash_mask = i.hash_size - 1,
    i.hash_shift = ~~((i.hash_bits + xi - 1) / xi),
    i.window = new Uint8Array(i.w_size * 2),
    i.head = new Uint16Array(i.hash_size),
    i.prev = new Uint16Array(i.w_size),
    i.lit_bufsize = 1 << c + 6,
    i.pending_buf_size = i.lit_bufsize * 4,
    i.pending_buf = new Uint8Array(i.pending_buf_size),
    i.d_buf = 1 * i.lit_bufsize,
    i.l_buf = (1 + 2) * i.lit_bufsize,
    i.level = e,
    i.strategy = d,
    i.method = t,
    qS(r)
}
  , UP = (r,e)=>KS(r, e, ty, wP, TP, xP)
  , VP = (r,e)=>{
    let t, o;
    if (!r || !r.state || e > HS || e < 0)
        return r ? Kl(r, yo) : yo;
    let c = r.state;
    if (!r.output || !r.input && r.avail_in !== 0 || c.status === Jp && e !== Zl)
        return Kl(r, r.avail_out === 0 ? zv : yo);
    c.strm = r;
    let d = c.last_flush;
    if (c.last_flush = e,
    c.status === ny)
        if (c.wrap === 2)
            r.adler = 0,
            Ci(c, 31),
            Ci(c, 139),
            Ci(c, 8),
            c.gzhead ? (Ci(c, (c.gzhead.text ? 1 : 0) + (c.gzhead.hcrc ? 2 : 0) + (c.gzhead.extra ? 4 : 0) + (c.gzhead.name ? 8 : 0) + (c.gzhead.comment ? 16 : 0)),
            Ci(c, c.gzhead.time & 255),
            Ci(c, c.gzhead.time >> 8 & 255),
            Ci(c, c.gzhead.time >> 16 & 255),
            Ci(c, c.gzhead.time >> 24 & 255),
            Ci(c, c.level === 9 ? 2 : c.strategy >= ey || c.level < 2 ? 4 : 0),
            Ci(c, c.gzhead.os & 255),
            c.gzhead.extra && c.gzhead.extra.length && (Ci(c, c.gzhead.extra.length & 255),
            Ci(c, c.gzhead.extra.length >> 8 & 255)),
            c.gzhead.hcrc && (r.adler = ts(r.adler, c.pending_buf, c.pending, 0)),
            c.gzindex = 0,
            c.status = Nv) : (Ci(c, 0),
            Ci(c, 0),
            Ci(c, 0),
            Ci(c, 0),
            Ci(c, 0),
            Ci(c, c.level === 9 ? 2 : c.strategy >= ey || c.level < 2 ? 4 : 0),
            Ci(c, LP),
            c.status = Au);
        else {
            let p = ty + (c.w_bits - 8 << 4) << 8
              , i = -1;
            c.strategy >= ey || c.level < 2 ? i = 0 : c.level < 6 ? i = 1 : c.level === 6 ? i = 2 : i = 3,
            p |= i << 6,
            c.strstart !== 0 && (p |= DP),
            p += 31 - p % 31,
            c.status = Au,
            Qp(c, p),
            c.strstart !== 0 && (Qp(c, r.adler >>> 16),
            Qp(c, r.adler & 65535)),
            r.adler = 1
        }
    if (c.status === Nv)
        if (c.gzhead.extra) {
            for (t = c.pending; c.gzindex < (c.gzhead.extra.length & 65535) && !(c.pending === c.pending_buf_size && (c.gzhead.hcrc && c.pending > t && (r.adler = ts(r.adler, c.pending_buf, c.pending - t, t)),
            $l(r),
            t = c.pending,
            c.pending === c.pending_buf_size)); )
                Ci(c, c.gzhead.extra[c.gzindex] & 255),
                c.gzindex++;
            c.gzhead.hcrc && c.pending > t && (r.adler = ts(r.adler, c.pending_buf, c.pending - t, t)),
            c.gzindex === c.gzhead.extra.length && (c.gzindex = 0,
            c.status = iy)
        } else
            c.status = iy;
    if (c.status === iy)
        if (c.gzhead.name) {
            t = c.pending;
            do {
                if (c.pending === c.pending_buf_size && (c.gzhead.hcrc && c.pending > t && (r.adler = ts(r.adler, c.pending_buf, c.pending - t, t)),
                $l(r),
                t = c.pending,
                c.pending === c.pending_buf_size)) {
                    o = 1;
                    break
                }
                c.gzindex < c.gzhead.name.length ? o = c.gzhead.name.charCodeAt(c.gzindex++) & 255 : o = 0,
                Ci(c, o)
            } while (o !== 0);
            c.gzhead.hcrc && c.pending > t && (r.adler = ts(r.adler, c.pending_buf, c.pending - t, t)),
            o === 0 && (c.gzindex = 0,
            c.status = ry)
        } else
            c.status = ry;
    if (c.status === ry)
        if (c.gzhead.comment) {
            t = c.pending;
            do {
                if (c.pending === c.pending_buf_size && (c.gzhead.hcrc && c.pending > t && (r.adler = ts(r.adler, c.pending_buf, c.pending - t, t)),
                $l(r),
                t = c.pending,
                c.pending === c.pending_buf_size)) {
                    o = 1;
                    break
                }
                c.gzindex < c.gzhead.comment.length ? o = c.gzhead.comment.charCodeAt(c.gzindex++) & 255 : o = 0,
                Ci(c, o)
            } while (o !== 0);
            c.gzhead.hcrc && c.pending > t && (r.adler = ts(r.adler, c.pending_buf, c.pending - t, t)),
            o === 0 && (c.status = sy)
        } else
            c.status = sy;
    if (c.status === sy && (c.gzhead.hcrc ? (c.pending + 2 > c.pending_buf_size && $l(r),
    c.pending + 2 <= c.pending_buf_size && (Ci(c, r.adler & 255),
    Ci(c, r.adler >> 8 & 255),
    r.adler = 0,
    c.status = Au)) : c.status = Au),
    c.pending !== 0) {
        if ($l(r),
        r.avail_out === 0)
            return c.last_flush = -1,
            pa
    } else if (r.avail_in === 0 && jS(e) <= jS(d) && e !== Zl)
        return Kl(r, zv);
    if (c.status === Jp && r.avail_in !== 0)
        return Kl(r, zv);
    if (r.avail_in !== 0 || c.lookahead !== 0 || e !== Su && c.status !== Jp) {
        let p = c.strategy === ey ? OP(c, e) : c.strategy === _P ? zP(c, e) : em[c.level].func(c, e);
        if ((p === Mu || p === xd) && (c.status = Jp),
        p === Or || p === Mu)
            return r.avail_out === 0 && (c.last_flush = -1),
            pa;
        if (p === $p && (e === dP ? hP(c) : e !== HS && (cP(c, 0, 0, !1),
        e === fP && (Yl(c.head),
        c.lookahead === 0 && (c.strstart = 0,
        c.block_start = 0,
        c.insert = 0))),
        $l(r),
        r.avail_out === 0))
            return c.last_flush = -1,
            pa
    }
    return e !== Zl ? pa : c.wrap <= 0 ? WS : (c.wrap === 2 ? (Ci(c, r.adler & 255),
    Ci(c, r.adler >> 8 & 255),
    Ci(c, r.adler >> 16 & 255),
    Ci(c, r.adler >> 24 & 255),
    Ci(c, r.total_in & 255),
    Ci(c, r.total_in >> 8 & 255),
    Ci(c, r.total_in >> 16 & 255),
    Ci(c, r.total_in >> 24 & 255)) : (Qp(c, r.adler >>> 16),
    Qp(c, r.adler & 65535)),
    $l(r),
    c.wrap > 0 && (c.wrap = -c.wrap),
    c.pending !== 0 ? pa : WS)
}
  , GP = r=>{
    if (!r || !r.state)
        return yo;
    let e = r.state.status;
    return e !== ny && e !== Nv && e !== iy && e !== ry && e !== sy && e !== Au && e !== Jp ? Kl(r, yo) : (r.state = null,
    e === Au ? Kl(r, pP) : pa)
}
  , HP = (r,e)=>{
    let t = e.length;
    if (!r || !r.state)
        return yo;
    let o = r.state
      , c = o.wrap;
    if (c === 2 || c === 1 && o.status !== ny || o.lookahead)
        return yo;
    if (c === 1 && (r.adler = Kp(r.adler, e, t, 0)),
    o.wrap = 0,
    t >= o.w_size) {
        c === 0 && (Yl(o.head),
        o.strstart = 0,
        o.block_start = 0,
        o.insert = 0);
        let v = new Uint8Array(o.w_size);
        v.set(e.subarray(t - o.w_size, t), 0),
        e = v,
        t = o.w_size
    }
    let d = r.avail_in
      , p = r.next_in
      , i = r.input;
    for (r.avail_in = t,
    r.next_in = 0,
    r.input = e,
    Iu(o); o.lookahead >= xi; ) {
        let v = o.strstart
          , x = o.lookahead - (xi - 1);
        do
            o.ins_h = Jl(o, o.ins_h, o.window[v + xi - 1]),
            o.prev[v & o.w_mask] = o.head[o.ins_h],
            o.head[o.ins_h] = v,
            v++;
        while (--x);
        o.strstart = v,
        o.lookahead = xi - 1,
        Iu(o)
    }
    return o.strstart += o.lookahead,
    o.block_start = o.strstart,
    o.insert = o.lookahead,
    o.lookahead = 0,
    o.match_length = o.prev_length = xi - 1,
    o.match_available = 0,
    r.next_in = p,
    r.input = i,
    r.avail_in = d,
    o.wrap = c,
    pa
}
  , WP = UP
  , jP = KS
  , XP = qS
  , ZP = ZS
  , qP = BP
  , KP = VP
  , YP = GP
  , JP = HP
  , $P = "pako deflate (from Nodeca project)"
  , tm = {
    deflateInit: WP,
    deflateInit2: jP,
    deflateReset: XP,
    deflateResetKeep: ZP,
    deflateSetHeader: qP,
    deflate: KP,
    deflateEnd: YP,
    deflateSetDictionary: JP,
    deflateInfo: $P
}
  , QP = (r,e)=>Object.prototype.hasOwnProperty.call(r, e)
  , ek = function(r) {
    let e = Array.prototype.slice.call(arguments, 1);
    for (; e.length; ) {
        let t = e.shift();
        if (!!t) {
            if (typeof t != "object")
                throw new TypeError(t + "must be non-object");
            for (let o in t)
                QP(t, o) && (r[o] = t[o])
        }
    }
    return r
}
  , tk = r=>{
    let e = 0;
    for (let o = 0, c = r.length; o < c; o++)
        e += r[o].length;
    let t = new Uint8Array(e);
    for (let o = 0, c = 0, d = r.length; o < d; o++) {
        let p = r[o];
        t.set(p, c),
        c += p.length
    }
    return t
}
  , oy = {
    assign: ek,
    flattenChunks: tk
}
  , YS = !0;
try {
    String.fromCharCode.apply(null, new Uint8Array(1))
} catch (r) {
    YS = !1
}
var nm = new Uint8Array(256);
for (let r = 0; r < 256; r++)
    nm[r] = r >= 252 ? 6 : r >= 248 ? 5 : r >= 240 ? 4 : r >= 224 ? 3 : r >= 192 ? 2 : 1;
nm[254] = nm[254] = 1;
var nk = r=>{
    if (typeof TextEncoder == "function" && TextEncoder.prototype.encode)
        return new TextEncoder().encode(r);
    let e, t, o, c, d, p = r.length, i = 0;
    for (c = 0; c < p; c++)
        t = r.charCodeAt(c),
        (t & 64512) == 55296 && c + 1 < p && (o = r.charCodeAt(c + 1),
        (o & 64512) == 56320 && (t = 65536 + (t - 55296 << 10) + (o - 56320),
        c++)),
        i += t < 128 ? 1 : t < 2048 ? 2 : t < 65536 ? 3 : 4;
    for (e = new Uint8Array(i),
    d = 0,
    c = 0; d < i; c++)
        t = r.charCodeAt(c),
        (t & 64512) == 55296 && c + 1 < p && (o = r.charCodeAt(c + 1),
        (o & 64512) == 56320 && (t = 65536 + (t - 55296 << 10) + (o - 56320),
        c++)),
        t < 128 ? e[d++] = t : t < 2048 ? (e[d++] = 192 | t >>> 6,
        e[d++] = 128 | t & 63) : t < 65536 ? (e[d++] = 224 | t >>> 12,
        e[d++] = 128 | t >>> 6 & 63,
        e[d++] = 128 | t & 63) : (e[d++] = 240 | t >>> 18,
        e[d++] = 128 | t >>> 12 & 63,
        e[d++] = 128 | t >>> 6 & 63,
        e[d++] = 128 | t & 63);
    return e
}
  , ik = (r,e)=>{
    if (e < 65534 && r.subarray && YS)
        return String.fromCharCode.apply(null, r.length === e ? r : r.subarray(0, e));
    let t = "";
    for (let o = 0; o < e; o++)
        t += String.fromCharCode(r[o]);
    return t
}
  , rk = (r,e)=>{
    let t = e || r.length;
    if (typeof TextDecoder == "function" && TextDecoder.prototype.decode)
        return new TextDecoder().decode(r.subarray(0, e));
    let o, c, d = new Array(t * 2);
    for (c = 0,
    o = 0; o < t; ) {
        let p = r[o++];
        if (p < 128) {
            d[c++] = p;
            continue
        }
        let i = nm[p];
        if (i > 4) {
            d[c++] = 65533,
            o += i - 1;
            continue
        }
        for (p &= i === 2 ? 31 : i === 3 ? 15 : 7; i > 1 && o < t; )
            p = p << 6 | r[o++] & 63,
            i--;
        if (i > 1) {
            d[c++] = 65533;
            continue
        }
        p < 65536 ? d[c++] = p : (p -= 65536,
        d[c++] = 55296 | p >> 10 & 1023,
        d[c++] = 56320 | p & 1023)
    }
    return ik(d, c)
}
  , sk = (r,e)=>{
    e = e || r.length,
    e > r.length && (e = r.length);
    let t = e - 1;
    for (; t >= 0 && (r[t] & 192) == 128; )
        t--;
    return t < 0 || t === 0 ? e : t + nm[r[t]] > e ? t : e
}
  , im = {
    string2buf: nk,
    buf2string: rk,
    utf8border: sk
};
function ok() {
    this.input = null,
    this.next_in = 0,
    this.avail_in = 0,
    this.total_in = 0,
    this.output = null,
    this.next_out = 0,
    this.avail_out = 0,
    this.total_out = 0,
    this.msg = "",
    this.state = null,
    this.data_type = 2,
    this.adler = 0
}
var JS = ok
  , $S = Object.prototype.toString
  , {Z_NO_FLUSH: ak, Z_SYNC_FLUSH: lk, Z_FULL_FLUSH: ck, Z_FINISH: uk, Z_OK: ay, Z_STREAM_END: hk, Z_DEFAULT_COMPRESSION: dk, Z_DEFAULT_STRATEGY: fk, Z_DEFLATED: pk} = Yp;
function Bv(r) {
    this.options = oy.assign({
        level: dk,
        method: pk,
        chunkSize: 16384,
        windowBits: 15,
        memLevel: 8,
        strategy: fk
    }, r || {});
    let e = this.options;
    e.raw && e.windowBits > 0 ? e.windowBits = -e.windowBits : e.gzip && e.windowBits > 0 && e.windowBits < 16 && (e.windowBits += 16),
    this.err = 0,
    this.msg = "",
    this.ended = !1,
    this.chunks = [],
    this.strm = new JS,
    this.strm.avail_out = 0;
    let t = tm.deflateInit2(this.strm, e.level, e.method, e.windowBits, e.memLevel, e.strategy);
    if (t !== ay)
        throw new Error(yd[t]);
    if (e.header && tm.deflateSetHeader(this.strm, e.header),
    e.dictionary) {
        let o;
        if (typeof e.dictionary == "string" ? o = im.string2buf(e.dictionary) : $S.call(e.dictionary) === "[object ArrayBuffer]" ? o = new Uint8Array(e.dictionary) : o = e.dictionary,
        t = tm.deflateSetDictionary(this.strm, o),
        t !== ay)
            throw new Error(yd[t]);
        this._dict_set = !0
    }
}
Bv.prototype.push = function(r, e) {
    let t = this.strm, o = this.options.chunkSize, c, d;
    if (this.ended)
        return !1;
    for (e === ~~e ? d = e : d = e === !0 ? uk : ak,
    typeof r == "string" ? t.input = im.string2buf(r) : $S.call(r) === "[object ArrayBuffer]" ? t.input = new Uint8Array(r) : t.input = r,
    t.next_in = 0,
    t.avail_in = t.input.length; ; ) {
        if (t.avail_out === 0 && (t.output = new Uint8Array(o),
        t.next_out = 0,
        t.avail_out = o),
        (d === lk || d === ck) && t.avail_out <= 6) {
            this.onData(t.output.subarray(0, t.next_out)),
            t.avail_out = 0;
            continue
        }
        if (c = tm.deflate(t, d),
        c === hk)
            return t.next_out > 0 && this.onData(t.output.subarray(0, t.next_out)),
            c = tm.deflateEnd(this.strm),
            this.onEnd(c),
            this.ended = !0,
            c === ay;
        if (t.avail_out === 0) {
            this.onData(t.output);
            continue
        }
        if (d > 0 && t.next_out > 0) {
            this.onData(t.output.subarray(0, t.next_out)),
            t.avail_out = 0;
            continue
        }
        if (t.avail_in === 0)
            break
    }
    return !0
}
;
Bv.prototype.onData = function(r) {
    this.chunks.push(r)
}
;
Bv.prototype.onEnd = function(r) {
    r === ay && (this.result = oy.flattenChunks(this.chunks)),
    this.chunks = [],
    this.err = r,
    this.msg = this.strm.msg
}
;
var ly = 30
  , mk = 12
  , gk = function(e, t) {
    let o, c, d, p, i, v, x, E, A, C, I, D, P, k, U, Z, K, X, W, fe, ce, _e, oe, ee, j = e.state;
    o = e.next_in,
    oe = e.input,
    c = o + (e.avail_in - 5),
    d = e.next_out,
    ee = e.output,
    p = d - (t - e.avail_out),
    i = d + (e.avail_out - 257),
    v = j.dmax,
    x = j.wsize,
    E = j.whave,
    A = j.wnext,
    C = j.window,
    I = j.hold,
    D = j.bits,
    P = j.lencode,
    k = j.distcode,
    U = (1 << j.lenbits) - 1,
    Z = (1 << j.distbits) - 1;
    e: do {
        D < 15 && (I += oe[o++] << D,
        D += 8,
        I += oe[o++] << D,
        D += 8),
        K = P[I & U];
        t: for (; ; ) {
            if (X = K >>> 24,
            I >>>= X,
            D -= X,
            X = K >>> 16 & 255,
            X === 0)
                ee[d++] = K & 65535;
            else if (X & 16) {
                W = K & 65535,
                X &= 15,
                X && (D < X && (I += oe[o++] << D,
                D += 8),
                W += I & (1 << X) - 1,
                I >>>= X,
                D -= X),
                D < 15 && (I += oe[o++] << D,
                D += 8,
                I += oe[o++] << D,
                D += 8),
                K = k[I & Z];
                n: for (; ; ) {
                    if (X = K >>> 24,
                    I >>>= X,
                    D -= X,
                    X = K >>> 16 & 255,
                    X & 16) {
                        if (fe = K & 65535,
                        X &= 15,
                        D < X && (I += oe[o++] << D,
                        D += 8,
                        D < X && (I += oe[o++] << D,
                        D += 8)),
                        fe += I & (1 << X) - 1,
                        fe > v) {
                            e.msg = "invalid distance too far back",
                            j.mode = ly;
                            break e
                        }
                        if (I >>>= X,
                        D -= X,
                        X = d - p,
                        fe > X) {
                            if (X = fe - X,
                            X > E && j.sane) {
                                e.msg = "invalid distance too far back",
                                j.mode = ly;
                                break e
                            }
                            if (ce = 0,
                            _e = C,
                            A === 0) {
                                if (ce += x - X,
                                X < W) {
                                    W -= X;
                                    do
                                        ee[d++] = C[ce++];
                                    while (--X);
                                    ce = d - fe,
                                    _e = ee
                                }
                            } else if (A < X) {
                                if (ce += x + A - X,
                                X -= A,
                                X < W) {
                                    W -= X;
                                    do
                                        ee[d++] = C[ce++];
                                    while (--X);
                                    if (ce = 0,
                                    A < W) {
                                        X = A,
                                        W -= X;
                                        do
                                            ee[d++] = C[ce++];
                                        while (--X);
                                        ce = d - fe,
                                        _e = ee
                                    }
                                }
                            } else if (ce += A - X,
                            X < W) {
                                W -= X;
                                do
                                    ee[d++] = C[ce++];
                                while (--X);
                                ce = d - fe,
                                _e = ee
                            }
                            for (; W > 2; )
                                ee[d++] = _e[ce++],
                                ee[d++] = _e[ce++],
                                ee[d++] = _e[ce++],
                                W -= 3;
                            W && (ee[d++] = _e[ce++],
                            W > 1 && (ee[d++] = _e[ce++]))
                        } else {
                            ce = d - fe;
                            do
                                ee[d++] = ee[ce++],
                                ee[d++] = ee[ce++],
                                ee[d++] = ee[ce++],
                                W -= 3;
                            while (W > 2);
                            W && (ee[d++] = ee[ce++],
                            W > 1 && (ee[d++] = ee[ce++]))
                        }
                    } else if ((X & 64) == 0) {
                        K = k[(K & 65535) + (I & (1 << X) - 1)];
                        continue n
                    } else {
                        e.msg = "invalid distance code",
                        j.mode = ly;
                        break e
                    }
                    break
                }
            } else if ((X & 64) == 0) {
                K = P[(K & 65535) + (I & (1 << X) - 1)];
                continue t
            } else if (X & 32) {
                j.mode = mk;
                break e
            } else {
                e.msg = "invalid literal/length code",
                j.mode = ly;
                break e
            }
            break
        }
    } while (o < c && d < i);
    W = D >> 3,
    o -= W,
    D -= W << 3,
    I &= (1 << D) - 1,
    e.next_in = o,
    e.next_out = d,
    e.avail_in = o < c ? 5 + (c - o) : 5 - (o - c),
    e.avail_out = d < i ? 257 + (i - d) : 257 - (d - i),
    j.hold = I,
    j.bits = D
}
  , bd = 15
  , QS = 852
  , eA = 592
  , tA = 0
  , Uv = 1
  , nA = 2
  , _k = new Uint16Array([3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0])
  , yk = new Uint8Array([16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78])
  , xk = new Uint16Array([1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0])
  , vk = new Uint8Array([16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64])
  , bk = (r,e,t,o,c,d,p,i)=>{
    let v = i.bits, x = 0, E = 0, A = 0, C = 0, I = 0, D = 0, P = 0, k = 0, U = 0, Z = 0, K, X, W, fe, ce, _e = null, oe = 0, ee, j = new Uint16Array(bd + 1), ne = new Uint16Array(bd + 1), be = null, te = 0, ae, se, ke;
    for (x = 0; x <= bd; x++)
        j[x] = 0;
    for (E = 0; E < o; E++)
        j[e[t + E]]++;
    for (I = v,
    C = bd; C >= 1 && j[C] === 0; C--)
        ;
    if (I > C && (I = C),
    C === 0)
        return c[d++] = 1 << 24 | 64 << 16 | 0,
        c[d++] = 1 << 24 | 64 << 16 | 0,
        i.bits = 1,
        0;
    for (A = 1; A < C && j[A] === 0; A++)
        ;
    for (I < A && (I = A),
    k = 1,
    x = 1; x <= bd; x++)
        if (k <<= 1,
        k -= j[x],
        k < 0)
            return -1;
    if (k > 0 && (r === tA || C !== 1))
        return -1;
    for (ne[1] = 0,
    x = 1; x < bd; x++)
        ne[x + 1] = ne[x] + j[x];
    for (E = 0; E < o; E++)
        e[t + E] !== 0 && (p[ne[e[t + E]]++] = E);
    if (r === tA ? (_e = be = p,
    ee = 19) : r === Uv ? (_e = _k,
    oe -= 257,
    be = yk,
    te -= 257,
    ee = 256) : (_e = xk,
    be = vk,
    ee = -1),
    Z = 0,
    E = 0,
    x = A,
    ce = d,
    D = I,
    P = 0,
    W = -1,
    U = 1 << I,
    fe = U - 1,
    r === Uv && U > QS || r === nA && U > eA)
        return 1;
    for (; ; ) {
        ae = x - P,
        p[E] < ee ? (se = 0,
        ke = p[E]) : p[E] > ee ? (se = be[te + p[E]],
        ke = _e[oe + p[E]]) : (se = 32 + 64,
        ke = 0),
        K = 1 << x - P,
        X = 1 << D,
        A = X;
        do
            X -= K,
            c[ce + (Z >> P) + X] = ae << 24 | se << 16 | ke | 0;
        while (X !== 0);
        for (K = 1 << x - 1; Z & K; )
            K >>= 1;
        if (K !== 0 ? (Z &= K - 1,
        Z += K) : Z = 0,
        E++,
        --j[x] == 0) {
            if (x === C)
                break;
            x = e[t + p[E]]
        }
        if (x > I && (Z & fe) !== W) {
            for (P === 0 && (P = I),
            ce += A,
            D = x - P,
            k = 1 << D; D + P < C && (k -= j[D + P],
            !(k <= 0)); )
                D++,
                k <<= 1;
            if (U += 1 << D,
            r === Uv && U > QS || r === nA && U > eA)
                return 1;
            W = Z & fe,
            c[W] = I << 24 | D << 16 | ce - d | 0
        }
    }
    return Z !== 0 && (c[ce + Z] = x - P << 24 | 64 << 16 | 0),
    i.bits = I,
    0
}
  , rm = bk
  , wk = 0
  , iA = 1
  , rA = 2
  , {Z_FINISH: sA, Z_BLOCK: Tk, Z_TREES: cy, Z_OK: Cu, Z_STREAM_END: Ek, Z_NEED_DICT: Sk, Z_STREAM_ERROR: xo, Z_DATA_ERROR: oA, Z_MEM_ERROR: aA, Z_BUF_ERROR: Ak, Z_DEFLATED: lA} = Yp
  , cA = 1
  , uA = 2
  , hA = 3
  , dA = 4
  , fA = 5
  , pA = 6
  , mA = 7
  , gA = 8
  , _A = 9
  , yA = 10
  , uy = 11
  , Ka = 12
  , Vv = 13
  , xA = 14
  , Gv = 15
  , vA = 16
  , bA = 17
  , wA = 18
  , TA = 19
  , hy = 20
  , dy = 21
  , EA = 22
  , SA = 23
  , AA = 24
  , MA = 25
  , IA = 26
  , Hv = 27
  , CA = 28
  , DA = 29
  , sr = 30
  , LA = 31
  , Mk = 32
  , Ik = 852
  , Ck = 592
  , Dk = 15
  , Lk = Dk
  , RA = r=>(r >>> 24 & 255) + (r >>> 8 & 65280) + ((r & 65280) << 8) + ((r & 255) << 24);
function Rk() {
    this.mode = 0,
    this.last = !1,
    this.wrap = 0,
    this.havedict = !1,
    this.flags = 0,
    this.dmax = 0,
    this.check = 0,
    this.total = 0,
    this.head = null,
    this.wbits = 0,
    this.wsize = 0,
    this.whave = 0,
    this.wnext = 0,
    this.window = null,
    this.hold = 0,
    this.bits = 0,
    this.length = 0,
    this.offset = 0,
    this.extra = 0,
    this.lencode = null,
    this.distcode = null,
    this.lenbits = 0,
    this.distbits = 0,
    this.ncode = 0,
    this.nlen = 0,
    this.ndist = 0,
    this.have = 0,
    this.next = null,
    this.lens = new Uint16Array(320),
    this.work = new Uint16Array(288),
    this.lendyn = null,
    this.distdyn = null,
    this.sane = 0,
    this.back = 0,
    this.was = 0
}
var PA = r=>{
    if (!r || !r.state)
        return xo;
    let e = r.state;
    return r.total_in = r.total_out = e.total = 0,
    r.msg = "",
    e.wrap && (r.adler = e.wrap & 1),
    e.mode = cA,
    e.last = 0,
    e.havedict = 0,
    e.dmax = 32768,
    e.head = null,
    e.hold = 0,
    e.bits = 0,
    e.lencode = e.lendyn = new Int32Array(Ik),
    e.distcode = e.distdyn = new Int32Array(Ck),
    e.sane = 1,
    e.back = -1,
    Cu
}
, kA = r=>{
    if (!r || !r.state)
        return xo;
    let e = r.state;
    return e.wsize = 0,
    e.whave = 0,
    e.wnext = 0,
    PA(r)
}
, zA = (r,e)=>{
    let t;
    if (!r || !r.state)
        return xo;
    let o = r.state;
    return e < 0 ? (t = 0,
    e = -e) : (t = (e >> 4) + 1,
    e < 48 && (e &= 15)),
    e && (e < 8 || e > 15) ? xo : (o.window !== null && o.wbits !== e && (o.window = null),
    o.wrap = t,
    o.wbits = e,
    kA(r))
}
, OA = (r,e)=>{
    if (!r)
        return xo;
    let t = new Rk;
    r.state = t,
    t.window = null;
    let o = zA(r, e);
    return o !== Cu && (r.state = null),
    o
}
, Pk = r=>OA(r, Lk), NA = !0, Wv, jv, kk = r=>{
    if (NA) {
        Wv = new Int32Array(512),
        jv = new Int32Array(32);
        let e = 0;
        for (; e < 144; )
            r.lens[e++] = 8;
        for (; e < 256; )
            r.lens[e++] = 9;
        for (; e < 280; )
            r.lens[e++] = 7;
        for (; e < 288; )
            r.lens[e++] = 8;
        for (rm(iA, r.lens, 0, 288, Wv, 0, r.work, {
            bits: 9
        }),
        e = 0; e < 32; )
            r.lens[e++] = 5;
        rm(rA, r.lens, 0, 32, jv, 0, r.work, {
            bits: 5
        }),
        NA = !1
    }
    r.lencode = Wv,
    r.lenbits = 9,
    r.distcode = jv,
    r.distbits = 5
}
, FA = (r,e,t,o)=>{
    let c, d = r.state;
    return d.window === null && (d.wsize = 1 << d.wbits,
    d.wnext = 0,
    d.whave = 0,
    d.window = new Uint8Array(d.wsize)),
    o >= d.wsize ? (d.window.set(e.subarray(t - d.wsize, t), 0),
    d.wnext = 0,
    d.whave = d.wsize) : (c = d.wsize - d.wnext,
    c > o && (c = o),
    d.window.set(e.subarray(t - o, t - o + c), d.wnext),
    o -= c,
    o ? (d.window.set(e.subarray(t - o, t), 0),
    d.wnext = o,
    d.whave = d.wsize) : (d.wnext += c,
    d.wnext === d.wsize && (d.wnext = 0),
    d.whave < d.wsize && (d.whave += c))),
    0
}
, zk = (r,e)=>{
    let t, o, c, d, p, i, v, x, E, A, C, I, D, P, k = 0, U, Z, K, X, W, fe, ce, _e, oe = new Uint8Array(4), ee, j, ne = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
    if (!r || !r.state || !r.output || !r.input && r.avail_in !== 0)
        return xo;
    t = r.state,
    t.mode === Ka && (t.mode = Vv),
    p = r.next_out,
    c = r.output,
    v = r.avail_out,
    d = r.next_in,
    o = r.input,
    i = r.avail_in,
    x = t.hold,
    E = t.bits,
    A = i,
    C = v,
    _e = Cu;
    e: for (; ; )
        switch (t.mode) {
        case cA:
            if (t.wrap === 0) {
                t.mode = Vv;
                break
            }
            for (; E < 16; ) {
                if (i === 0)
                    break e;
                i--,
                x += o[d++] << E,
                E += 8
            }
            if (t.wrap & 2 && x === 35615) {
                t.check = 0,
                oe[0] = x & 255,
                oe[1] = x >>> 8 & 255,
                t.check = ts(t.check, oe, 2, 0),
                x = 0,
                E = 0,
                t.mode = uA;
                break
            }
            if (t.flags = 0,
            t.head && (t.head.done = !1),
            !(t.wrap & 1) || (((x & 255) << 8) + (x >> 8)) % 31) {
                r.msg = "incorrect header check",
                t.mode = sr;
                break
            }
            if ((x & 15) !== lA) {
                r.msg = "unknown compression method",
                t.mode = sr;
                break
            }
            if (x >>>= 4,
            E -= 4,
            ce = (x & 15) + 8,
            t.wbits === 0)
                t.wbits = ce;
            else if (ce > t.wbits) {
                r.msg = "invalid window size",
                t.mode = sr;
                break
            }
            t.dmax = 1 << t.wbits,
            r.adler = t.check = 1,
            t.mode = x & 512 ? yA : Ka,
            x = 0,
            E = 0;
            break;
        case uA:
            for (; E < 16; ) {
                if (i === 0)
                    break e;
                i--,
                x += o[d++] << E,
                E += 8
            }
            if (t.flags = x,
            (t.flags & 255) !== lA) {
                r.msg = "unknown compression method",
                t.mode = sr;
                break
            }
            if (t.flags & 57344) {
                r.msg = "unknown header flags set",
                t.mode = sr;
                break
            }
            t.head && (t.head.text = x >> 8 & 1),
            t.flags & 512 && (oe[0] = x & 255,
            oe[1] = x >>> 8 & 255,
            t.check = ts(t.check, oe, 2, 0)),
            x = 0,
            E = 0,
            t.mode = hA;
        case hA:
            for (; E < 32; ) {
                if (i === 0)
                    break e;
                i--,
                x += o[d++] << E,
                E += 8
            }
            t.head && (t.head.time = x),
            t.flags & 512 && (oe[0] = x & 255,
            oe[1] = x >>> 8 & 255,
            oe[2] = x >>> 16 & 255,
            oe[3] = x >>> 24 & 255,
            t.check = ts(t.check, oe, 4, 0)),
            x = 0,
            E = 0,
            t.mode = dA;
        case dA:
            for (; E < 16; ) {
                if (i === 0)
                    break e;
                i--,
                x += o[d++] << E,
                E += 8
            }
            t.head && (t.head.xflags = x & 255,
            t.head.os = x >> 8),
            t.flags & 512 && (oe[0] = x & 255,
            oe[1] = x >>> 8 & 255,
            t.check = ts(t.check, oe, 2, 0)),
            x = 0,
            E = 0,
            t.mode = fA;
        case fA:
            if (t.flags & 1024) {
                for (; E < 16; ) {
                    if (i === 0)
                        break e;
                    i--,
                    x += o[d++] << E,
                    E += 8
                }
                t.length = x,
                t.head && (t.head.extra_len = x),
                t.flags & 512 && (oe[0] = x & 255,
                oe[1] = x >>> 8 & 255,
                t.check = ts(t.check, oe, 2, 0)),
                x = 0,
                E = 0
            } else
                t.head && (t.head.extra = null);
            t.mode = pA;
        case pA:
            if (t.flags & 1024 && (I = t.length,
            I > i && (I = i),
            I && (t.head && (ce = t.head.extra_len - t.length,
            t.head.extra || (t.head.extra = new Uint8Array(t.head.extra_len)),
            t.head.extra.set(o.subarray(d, d + I), ce)),
            t.flags & 512 && (t.check = ts(t.check, o, I, d)),
            i -= I,
            d += I,
            t.length -= I),
            t.length))
                break e;
            t.length = 0,
            t.mode = mA;
        case mA:
            if (t.flags & 2048) {
                if (i === 0)
                    break e;
                I = 0;
                do
                    ce = o[d + I++],
                    t.head && ce && t.length < 65536 && (t.head.name += String.fromCharCode(ce));
                while (ce && I < i);
                if (t.flags & 512 && (t.check = ts(t.check, o, I, d)),
                i -= I,
                d += I,
                ce)
                    break e
            } else
                t.head && (t.head.name = null);
            t.length = 0,
            t.mode = gA;
        case gA:
            if (t.flags & 4096) {
                if (i === 0)
                    break e;
                I = 0;
                do
                    ce = o[d + I++],
                    t.head && ce && t.length < 65536 && (t.head.comment += String.fromCharCode(ce));
                while (ce && I < i);
                if (t.flags & 512 && (t.check = ts(t.check, o, I, d)),
                i -= I,
                d += I,
                ce)
                    break e
            } else
                t.head && (t.head.comment = null);
            t.mode = _A;
        case _A:
            if (t.flags & 512) {
                for (; E < 16; ) {
                    if (i === 0)
                        break e;
                    i--,
                    x += o[d++] << E,
                    E += 8
                }
                if (x !== (t.check & 65535)) {
                    r.msg = "header crc mismatch",
                    t.mode = sr;
                    break
                }
                x = 0,
                E = 0
            }
            t.head && (t.head.hcrc = t.flags >> 9 & 1,
            t.head.done = !0),
            r.adler = t.check = 0,
            t.mode = Ka;
            break;
        case yA:
            for (; E < 32; ) {
                if (i === 0)
                    break e;
                i--,
                x += o[d++] << E,
                E += 8
            }
            r.adler = t.check = RA(x),
            x = 0,
            E = 0,
            t.mode = uy;
        case uy:
            if (t.havedict === 0)
                return r.next_out = p,
                r.avail_out = v,
                r.next_in = d,
                r.avail_in = i,
                t.hold = x,
                t.bits = E,
                Sk;
            r.adler = t.check = 1,
            t.mode = Ka;
        case Ka:
            if (e === Tk || e === cy)
                break e;
        case Vv:
            if (t.last) {
                x >>>= E & 7,
                E -= E & 7,
                t.mode = Hv;
                break
            }
            for (; E < 3; ) {
                if (i === 0)
                    break e;
                i--,
                x += o[d++] << E,
                E += 8
            }
            switch (t.last = x & 1,
            x >>>= 1,
            E -= 1,
            x & 3) {
            case 0:
                t.mode = xA;
                break;
            case 1:
                if (kk(t),
                t.mode = hy,
                e === cy) {
                    x >>>= 2,
                    E -= 2;
                    break e
                }
                break;
            case 2:
                t.mode = bA;
                break;
            case 3:
                r.msg = "invalid block type",
                t.mode = sr
            }
            x >>>= 2,
            E -= 2;
            break;
        case xA:
            for (x >>>= E & 7,
            E -= E & 7; E < 32; ) {
                if (i === 0)
                    break e;
                i--,
                x += o[d++] << E,
                E += 8
            }
            if ((x & 65535) != (x >>> 16 ^ 65535)) {
                r.msg = "invalid stored block lengths",
                t.mode = sr;
                break
            }
            if (t.length = x & 65535,
            x = 0,
            E = 0,
            t.mode = Gv,
            e === cy)
                break e;
        case Gv:
            t.mode = vA;
        case vA:
            if (I = t.length,
            I) {
                if (I > i && (I = i),
                I > v && (I = v),
                I === 0)
                    break e;
                c.set(o.subarray(d, d + I), p),
                i -= I,
                d += I,
                v -= I,
                p += I,
                t.length -= I;
                break
            }
            t.mode = Ka;
            break;
        case bA:
            for (; E < 14; ) {
                if (i === 0)
                    break e;
                i--,
                x += o[d++] << E,
                E += 8
            }
            if (t.nlen = (x & 31) + 257,
            x >>>= 5,
            E -= 5,
            t.ndist = (x & 31) + 1,
            x >>>= 5,
            E -= 5,
            t.ncode = (x & 15) + 4,
            x >>>= 4,
            E -= 4,
            t.nlen > 286 || t.ndist > 30) {
                r.msg = "too many length or distance symbols",
                t.mode = sr;
                break
            }
            t.have = 0,
            t.mode = wA;
        case wA:
            for (; t.have < t.ncode; ) {
                for (; E < 3; ) {
                    if (i === 0)
                        break e;
                    i--,
                    x += o[d++] << E,
                    E += 8
                }
                t.lens[ne[t.have++]] = x & 7,
                x >>>= 3,
                E -= 3
            }
            for (; t.have < 19; )
                t.lens[ne[t.have++]] = 0;
            if (t.lencode = t.lendyn,
            t.lenbits = 7,
            ee = {
                bits: t.lenbits
            },
            _e = rm(wk, t.lens, 0, 19, t.lencode, 0, t.work, ee),
            t.lenbits = ee.bits,
            _e) {
                r.msg = "invalid code lengths set",
                t.mode = sr;
                break
            }
            t.have = 0,
            t.mode = TA;
        case TA:
            for (; t.have < t.nlen + t.ndist; ) {
                for (; k = t.lencode[x & (1 << t.lenbits) - 1],
                U = k >>> 24,
                Z = k >>> 16 & 255,
                K = k & 65535,
                !(U <= E); ) {
                    if (i === 0)
                        break e;
                    i--,
                    x += o[d++] << E,
                    E += 8
                }
                if (K < 16)
                    x >>>= U,
                    E -= U,
                    t.lens[t.have++] = K;
                else {
                    if (K === 16) {
                        for (j = U + 2; E < j; ) {
                            if (i === 0)
                                break e;
                            i--,
                            x += o[d++] << E,
                            E += 8
                        }
                        if (x >>>= U,
                        E -= U,
                        t.have === 0) {
                            r.msg = "invalid bit length repeat",
                            t.mode = sr;
                            break
                        }
                        ce = t.lens[t.have - 1],
                        I = 3 + (x & 3),
                        x >>>= 2,
                        E -= 2
                    } else if (K === 17) {
                        for (j = U + 3; E < j; ) {
                            if (i === 0)
                                break e;
                            i--,
                            x += o[d++] << E,
                            E += 8
                        }
                        x >>>= U,
                        E -= U,
                        ce = 0,
                        I = 3 + (x & 7),
                        x >>>= 3,
                        E -= 3
                    } else {
                        for (j = U + 7; E < j; ) {
                            if (i === 0)
                                break e;
                            i--,
                            x += o[d++] << E,
                            E += 8
                        }
                        x >>>= U,
                        E -= U,
                        ce = 0,
                        I = 11 + (x & 127),
                        x >>>= 7,
                        E -= 7
                    }
                    if (t.have + I > t.nlen + t.ndist) {
                        r.msg = "invalid bit length repeat",
                        t.mode = sr;
                        break
                    }
                    for (; I--; )
                        t.lens[t.have++] = ce
                }
            }
            if (t.mode === sr)
                break;
            if (t.lens[256] === 0) {
                r.msg = "invalid code -- missing end-of-block",
                t.mode = sr;
                break
            }
            if (t.lenbits = 9,
            ee = {
                bits: t.lenbits
            },
            _e = rm(iA, t.lens, 0, t.nlen, t.lencode, 0, t.work, ee),
            t.lenbits = ee.bits,
            _e) {
                r.msg = "invalid literal/lengths set",
                t.mode = sr;
                break
            }
            if (t.distbits = 6,
            t.distcode = t.distdyn,
            ee = {
                bits: t.distbits
            },
            _e = rm(rA, t.lens, t.nlen, t.ndist, t.distcode, 0, t.work, ee),
            t.distbits = ee.bits,
            _e) {
                r.msg = "invalid distances set",
                t.mode = sr;
                break
            }
            if (t.mode = hy,
            e === cy)
                break e;
        case hy:
            t.mode = dy;
        case dy:
            if (i >= 6 && v >= 258) {
                r.next_out = p,
                r.avail_out = v,
                r.next_in = d,
                r.avail_in = i,
                t.hold = x,
                t.bits = E,
                gk(r, C),
                p = r.next_out,
                c = r.output,
                v = r.avail_out,
                d = r.next_in,
                o = r.input,
                i = r.avail_in,
                x = t.hold,
                E = t.bits,
                t.mode === Ka && (t.back = -1);
                break
            }
            for (t.back = 0; k = t.lencode[x & (1 << t.lenbits) - 1],
            U = k >>> 24,
            Z = k >>> 16 & 255,
            K = k & 65535,
            !(U <= E); ) {
                if (i === 0)
                    break e;
                i--,
                x += o[d++] << E,
                E += 8
            }
            if (Z && (Z & 240) == 0) {
                for (X = U,
                W = Z,
                fe = K; k = t.lencode[fe + ((x & (1 << X + W) - 1) >> X)],
                U = k >>> 24,
                Z = k >>> 16 & 255,
                K = k & 65535,
                !(X + U <= E); ) {
                    if (i === 0)
                        break e;
                    i--,
                    x += o[d++] << E,
                    E += 8
                }
                x >>>= X,
                E -= X,
                t.back += X
            }
            if (x >>>= U,
            E -= U,
            t.back += U,
            t.length = K,
            Z === 0) {
                t.mode = IA;
                break
            }
            if (Z & 32) {
                t.back = -1,
                t.mode = Ka;
                break
            }
            if (Z & 64) {
                r.msg = "invalid literal/length code",
                t.mode = sr;
                break
            }
            t.extra = Z & 15,
            t.mode = EA;
        case EA:
            if (t.extra) {
                for (j = t.extra; E < j; ) {
                    if (i === 0)
                        break e;
                    i--,
                    x += o[d++] << E,
                    E += 8
                }
                t.length += x & (1 << t.extra) - 1,
                x >>>= t.extra,
                E -= t.extra,
                t.back += t.extra
            }
            t.was = t.length,
            t.mode = SA;
        case SA:
            for (; k = t.distcode[x & (1 << t.distbits) - 1],
            U = k >>> 24,
            Z = k >>> 16 & 255,
            K = k & 65535,
            !(U <= E); ) {
                if (i === 0)
                    break e;
                i--,
                x += o[d++] << E,
                E += 8
            }
            if ((Z & 240) == 0) {
                for (X = U,
                W = Z,
                fe = K; k = t.distcode[fe + ((x & (1 << X + W) - 1) >> X)],
                U = k >>> 24,
                Z = k >>> 16 & 255,
                K = k & 65535,
                !(X + U <= E); ) {
                    if (i === 0)
                        break e;
                    i--,
                    x += o[d++] << E,
                    E += 8
                }
                x >>>= X,
                E -= X,
                t.back += X
            }
            if (x >>>= U,
            E -= U,
            t.back += U,
            Z & 64) {
                r.msg = "invalid distance code",
                t.mode = sr;
                break
            }
            t.offset = K,
            t.extra = Z & 15,
            t.mode = AA;
        case AA:
            if (t.extra) {
                for (j = t.extra; E < j; ) {
                    if (i === 0)
                        break e;
                    i--,
                    x += o[d++] << E,
                    E += 8
                }
                t.offset += x & (1 << t.extra) - 1,
                x >>>= t.extra,
                E -= t.extra,
                t.back += t.extra
            }
            if (t.offset > t.dmax) {
                r.msg = "invalid distance too far back",
                t.mode = sr;
                break
            }
            t.mode = MA;
        case MA:
            if (v === 0)
                break e;
            if (I = C - v,
            t.offset > I) {
                if (I = t.offset - I,
                I > t.whave && t.sane) {
                    r.msg = "invalid distance too far back",
                    t.mode = sr;
                    break
                }
                I > t.wnext ? (I -= t.wnext,
                D = t.wsize - I) : D = t.wnext - I,
                I > t.length && (I = t.length),
                P = t.window
            } else
                P = c,
                D = p - t.offset,
                I = t.length;
            I > v && (I = v),
            v -= I,
            t.length -= I;
            do
                c[p++] = P[D++];
            while (--I);
            t.length === 0 && (t.mode = dy);
            break;
        case IA:
            if (v === 0)
                break e;
            c[p++] = t.length,
            v--,
            t.mode = dy;
            break;
        case Hv:
            if (t.wrap) {
                for (; E < 32; ) {
                    if (i === 0)
                        break e;
                    i--,
                    x |= o[d++] << E,
                    E += 8
                }
                if (C -= v,
                r.total_out += C,
                t.total += C,
                C && (r.adler = t.check = t.flags ? ts(t.check, c, C, p - C) : Kp(t.check, c, C, p - C)),
                C = v,
                (t.flags ? x : RA(x)) !== t.check) {
                    r.msg = "incorrect data check",
                    t.mode = sr;
                    break
                }
                x = 0,
                E = 0
            }
            t.mode = CA;
        case CA:
            if (t.wrap && t.flags) {
                for (; E < 32; ) {
                    if (i === 0)
                        break e;
                    i--,
                    x += o[d++] << E,
                    E += 8
                }
                if (x !== (t.total & 4294967295)) {
                    r.msg = "incorrect length check",
                    t.mode = sr;
                    break
                }
                x = 0,
                E = 0
            }
            t.mode = DA;
        case DA:
            _e = Ek;
            break e;
        case sr:
            _e = oA;
            break e;
        case LA:
            return aA;
        case Mk:
        default:
            return xo
        }
    return r.next_out = p,
    r.avail_out = v,
    r.next_in = d,
    r.avail_in = i,
    t.hold = x,
    t.bits = E,
    (t.wsize || C !== r.avail_out && t.mode < sr && (t.mode < Hv || e !== sA)) && FA(r, r.output, r.next_out, C - r.avail_out),
    A -= r.avail_in,
    C -= r.avail_out,
    r.total_in += A,
    r.total_out += C,
    t.total += C,
    t.wrap && C && (r.adler = t.check = t.flags ? ts(t.check, c, C, r.next_out - C) : Kp(t.check, c, C, r.next_out - C)),
    r.data_type = t.bits + (t.last ? 64 : 0) + (t.mode === Ka ? 128 : 0) + (t.mode === hy || t.mode === Gv ? 256 : 0),
    (A === 0 && C === 0 || e === sA) && _e === Cu && (_e = Ak),
    _e
}
, Ok = r=>{
    if (!r || !r.state)
        return xo;
    let e = r.state;
    return e.window && (e.window = null),
    r.state = null,
    Cu
}
, Nk = (r,e)=>{
    if (!r || !r.state)
        return xo;
    let t = r.state;
    return (t.wrap & 2) == 0 ? xo : (t.head = e,
    e.done = !1,
    Cu)
}
, Fk = (r,e)=>{
    let t = e.length, o, c, d;
    return !r || !r.state || (o = r.state,
    o.wrap !== 0 && o.mode !== uy) ? xo : o.mode === uy && (c = 1,
    c = Kp(c, e, t, 0),
    c !== o.check) ? oA : (d = FA(r, e, t, t),
    d ? (o.mode = LA,
    aA) : (o.havedict = 1,
    Cu))
}
, Bk = kA, Uk = zA, Vk = PA, Gk = Pk, Hk = OA, Wk = zk, jk = Ok, Xk = Nk, Zk = Fk, qk = "pako inflate (from Nodeca project)", Ya = {
    inflateReset: Bk,
    inflateReset2: Uk,
    inflateResetKeep: Vk,
    inflateInit: Gk,
    inflateInit2: Hk,
    inflate: Wk,
    inflateEnd: jk,
    inflateGetHeader: Xk,
    inflateSetDictionary: Zk,
    inflateInfo: qk
};
function Kk() {
    this.text = 0,
    this.time = 0,
    this.xflags = 0,
    this.os = 0,
    this.extra = null,
    this.extra_len = 0,
    this.name = "",
    this.comment = "",
    this.hcrc = 0,
    this.done = !1
}
var Yk = Kk
  , BA = Object.prototype.toString
  , {Z_NO_FLUSH: Jk, Z_FINISH: $k, Z_OK: sm, Z_STREAM_END: Xv, Z_NEED_DICT: Zv, Z_STREAM_ERROR: Qk, Z_DATA_ERROR: UA, Z_MEM_ERROR: ez} = Yp;
function om(r) {
    this.options = oy.assign({
        chunkSize: 1024 * 64,
        windowBits: 15,
        to: ""
    }, r || {});
    let e = this.options;
    e.raw && e.windowBits >= 0 && e.windowBits < 16 && (e.windowBits = -e.windowBits,
    e.windowBits === 0 && (e.windowBits = -15)),
    e.windowBits >= 0 && e.windowBits < 16 && !(r && r.windowBits) && (e.windowBits += 32),
    e.windowBits > 15 && e.windowBits < 48 && (e.windowBits & 15) == 0 && (e.windowBits |= 15),
    this.err = 0,
    this.msg = "",
    this.ended = !1,
    this.chunks = [],
    this.strm = new JS,
    this.strm.avail_out = 0;
    let t = Ya.inflateInit2(this.strm, e.windowBits);
    if (t !== sm)
        throw new Error(yd[t]);
    if (this.header = new Yk,
    Ya.inflateGetHeader(this.strm, this.header),
    e.dictionary && (typeof e.dictionary == "string" ? e.dictionary = im.string2buf(e.dictionary) : BA.call(e.dictionary) === "[object ArrayBuffer]" && (e.dictionary = new Uint8Array(e.dictionary)),
    e.raw && (t = Ya.inflateSetDictionary(this.strm, e.dictionary),
    t !== sm)))
        throw new Error(yd[t])
}
om.prototype.push = function(r, e) {
    let t = this.strm, o = this.options.chunkSize, c = this.options.dictionary, d, p, i;
    if (this.ended)
        return !1;
    for (e === ~~e ? p = e : p = e === !0 ? $k : Jk,
    BA.call(r) === "[object ArrayBuffer]" ? t.input = new Uint8Array(r) : t.input = r,
    t.next_in = 0,
    t.avail_in = t.input.length; ; ) {
        for (t.avail_out === 0 && (t.output = new Uint8Array(o),
        t.next_out = 0,
        t.avail_out = o),
        d = Ya.inflate(t, p),
        d === Zv && c && (d = Ya.inflateSetDictionary(t, c),
        d === sm ? d = Ya.inflate(t, p) : d === UA && (d = Zv)); t.avail_in > 0 && d === Xv && t.state.wrap > 0 && r[t.next_in] !== 0; )
            Ya.inflateReset(t),
            d = Ya.inflate(t, p);
        switch (d) {
        case Qk:
        case UA:
        case Zv:
        case ez:
            return this.onEnd(d),
            this.ended = !0,
            !1
        }
        if (i = t.avail_out,
        t.next_out && (t.avail_out === 0 || d === Xv))
            if (this.options.to === "string") {
                let v = im.utf8border(t.output, t.next_out)
                  , x = t.next_out - v
                  , E = im.buf2string(t.output, v);
                t.next_out = x,
                t.avail_out = o - x,
                x && t.output.set(t.output.subarray(v, v + x), 0),
                this.onData(E)
            } else
                this.onData(t.output.length === t.next_out ? t.output : t.output.subarray(0, t.next_out));
        if (!(d === sm && i === 0)) {
            if (d === Xv)
                return d = Ya.inflateEnd(this.strm),
                this.onEnd(d),
                this.ended = !0,
                !0;
            if (t.avail_in === 0)
                break
        }
    }
    return !0
}
;
om.prototype.onData = function(r) {
    this.chunks.push(r)
}
;
om.prototype.onEnd = function(r) {
    r === sm && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = oy.flattenChunks(this.chunks)),
    this.chunks = [],
    this.err = r,
    this.msg = this.strm.msg
}
;
function qv(r, e) {
    let t = new om(e);
    if (t.push(r),
    t.err)
        throw t.msg || yd[t.err];
    return t.result
}
function tz(r, e) {
    return e = e || {},
    e.raw = !0,
    qv(r, e)
}
var nz = om
  , iz = qv
  , rz = tz
  , sz = qv
  , oz = Yp
  , az = {
    Inflate: nz,
    inflate: iz,
    inflateRaw: rz,
    ungzip: sz,
    constants: oz
};
var {Inflate: iG, inflate: lz, inflateRaw: rG, ungzip: sG} = az;
var fy = lz;
function VA() {
    let r = new J_([],function(I, D) {
        return D.time - I.time
    }
    ), e = 0, t = 0, o, c;
    function d() {
        for (; r.length; ) {
            let I = new FileReader
              , D = r.pop();
            I.onload = function(P) {
                let k = P.target.result
                  , U = new Uint8Array(k);
                try {
                    U = fy(U)
                } catch (K) {}
                let Z = "";
                for (let K = 0; K < 6; K++)
                    Z = Z + String.fromCharCode(U[K]);
                if (Z != "AR2V00" && Z != "ARCHIV") {
                    e -= 1,
                    Z === "ARCHIV" ? Yi.update(K=>(K.error = !0,
                    K.message = "The application cannot yet read files in an old format like " + D.name + ".",
                    K.header = "Old format",
                    K)) : Yi.update(K=>(K.error = !0,
                    K.message = "The file " + D.name + " could not be read due to an unexpected format.",
                    K.header = "Unexpected format",
                    K));
                    return
                }
                tn(Is).postMessage({
                    message: "initialize",
                    fileName: D.name,
                    buffer: U.buffer
                }, [U.buffer])
            }
            ,
            I.readAsArrayBuffer(D)
        }
    }
    function p(I) {
        I.preventDefault(),
        console.log(c),
        c = !0,
        console.log(c),
        o.style.pointerEvents = "none"
    }
    function i(I) {
        I.preventDefault()
    }
    function v(I) {
        I.preventDefault(),
        c = !1,
        o.style.pointerEvents = ""
    }
    function x(I) {
        if (o.style.pointerEvents = "",
        I.preventDefault(),
        c = !1,
        I.dataTransfer.items) {
            let D = [];
            for (let P = 0; P < I.dataTransfer.items.length; P++)
                if (I.dataTransfer.items[P].kind === "file") {
                    let k = I.dataTransfer.items[P].getAsFile();
                    k.time = Date.now(),
                    D.push(k)
                }
            E(D)
        }
    }
    function E(I) {
        let D = 0;
        for (let U = 0; U < tn(ai).length; U++)
            tn(ai)[U] && D++;
        let P = tn(ai).filter(U=>U != null).map(U=>U.fileName)
          , k = [];
        for (let U = 0; U < I.length; U++) {
            let Z = I[U];
            if (P.indexOf(Z.name) >= 0) {
                Yi.update(K=>(K.error = !0,
                K.message = "A file already exists with the name " + Z.name,
                K.header = "Duplicate file",
                K));
                return
            }
            k.push(Z)
        }
        if (e + I.length > 5 || I.length + D > 5) {
            Yi.update(U=>(U.error = !0,
            U.message = "The application cannot load more than 5 files. Remove a file using the File view before loading another.",
            U.header = "Too many files",
            U));
            return
        }
        for (let U = 0; U < k.length; U++)
            r.push(k[U]);
        e = e + k.length,
        d()
    }
    function A() {
        if (!!e) {
            if (tn(ai).finished === 1 && (percent = 1,
            t += 1),
            t === e)
                percent = -1,
                t = 0,
                e = 0;
            else if (tn(ai)[tn(ai).loading]) {
                let I = tn(ai).loading
                  , D = tn(ai)[I].percent;
                D != null && (percent = D)
            }
        }
    }
    function C() {
        let I = this.files
          , D = [];
        for (let P = 0, k = I.length; P < k; P++) {
            let U = I[P];
            U.time = Date.now(),
            D.push(U)
        }
        E(D)
    }
    return {
        set b(I) {
            o = I
        },
        get b() {
            return o
        },
        set hovering(I) {
            c = I
        },
        get hovering() {
            return c
        },
        set count(I) {
            e = I
        },
        get count() {
            return e
        },
        set numLoaded(I) {
            t = I
        },
        get numLoaded() {
            return t
        },
        handleDragDrop: x,
        handleDragEnter: p,
        handleDragLeave: v,
        handleDragOver: i,
        updatePercent: A,
        handleFiles: C
    }
}
function ga(r, e) {
    var t = {};
    for (var o in r)
        Object.prototype.hasOwnProperty.call(r, o) && e.indexOf(o) < 0 && (t[o] = r[o]);
    if (r != null && typeof Object.getOwnPropertySymbols == "function") {
        var c = 0;
        for (o = Object.getOwnPropertySymbols(r); c < o.length; c++)
            e.indexOf(o[c]) < 0 && Object.prototype.propertyIsEnumerable.call(r, o[c]) && (t[o[c]] = r[o[c]])
    }
    return t
}
var wd = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {};
function Kv(r) {
    return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r
}
function Yv(r, e) {
    return r(e = {
        exports: {}
    }, e.exports),
    e.exports
}
var Du = Yv(function(r, e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var t = function() {
        function o() {
            var c = this;
            this.locked = new Map,
            this.addToLocked = function(d, p) {
                var i = c.locked.get(d);
                i === void 0 ? p === void 0 ? c.locked.set(d, []) : c.locked.set(d, [p]) : p !== void 0 && (i.unshift(p),
                c.locked.set(d, i))
            }
            ,
            this.isLocked = function(d) {
                return c.locked.has(d)
            }
            ,
            this.lock = function(d) {
                return new Promise(function(p, i) {
                    c.isLocked(d) ? c.addToLocked(d, p) : (c.addToLocked(d),
                    p())
                }
                )
            }
            ,
            this.unlock = function(d) {
                var p = c.locked.get(d);
                if (p !== void 0 && p.length !== 0) {
                    var i = p.pop();
                    c.locked.set(d, p),
                    i !== void 0 && setTimeout(i, 0)
                } else
                    c.locked.delete(d)
            }
        }
        return o.getInstance = function() {
            return o.instance === void 0 && (o.instance = new o),
            o.instance
        }
        ,
        o
    }();
    e.default = function() {
        return t.getInstance()
    }
});
Kv(Du);
var cz = Kv(Yv(function(r, e) {
    var t = wd && wd.__awaiter || function(v, x, E, A) {
        return new (E || (E = Promise))(function(C, I) {
            function D(U) {
                try {
                    k(A.next(U))
                } catch (Z) {
                    I(Z)
                }
            }
            function P(U) {
                try {
                    k(A.throw(U))
                } catch (Z) {
                    I(Z)
                }
            }
            function k(U) {
                U.done ? C(U.value) : new E(function(Z) {
                    Z(U.value)
                }
                ).then(D, P)
            }
            k((A = A.apply(v, x || [])).next())
        }
        )
    }
      , o = wd && wd.__generator || function(v, x) {
        var E, A, C, I, D = {
            label: 0,
            sent: function() {
                if (1 & C[0])
                    throw C[1];
                return C[1]
            },
            trys: [],
            ops: []
        };
        return I = {
            next: P(0),
            throw: P(1),
            return: P(2)
        },
        typeof Symbol == "function" && (I[Symbol.iterator] = function() {
            return this
        }
        ),
        I;
        function P(k) {
            return function(U) {
                return function(Z) {
                    if (E)
                        throw new TypeError("Generator is already executing.");
                    for (; D; )
                        try {
                            if (E = 1,
                            A && (C = 2 & Z[0] ? A.return : Z[0] ? A.throw || ((C = A.return) && C.call(A),
                            0) : A.next) && !(C = C.call(A, Z[1])).done)
                                return C;
                            switch (A = 0,
                            C && (Z = [2 & Z[0], C.value]),
                            Z[0]) {
                            case 0:
                            case 1:
                                C = Z;
                                break;
                            case 4:
                                return D.label++,
                                {
                                    value: Z[1],
                                    done: !1
                                };
                            case 5:
                                D.label++,
                                A = Z[1],
                                Z = [0];
                                continue;
                            case 7:
                                Z = D.ops.pop(),
                                D.trys.pop();
                                continue;
                            default:
                                if (C = D.trys,
                                !((C = C.length > 0 && C[C.length - 1]) || Z[0] !== 6 && Z[0] !== 2)) {
                                    D = 0;
                                    continue
                                }
                                if (Z[0] === 3 && (!C || Z[1] > C[0] && Z[1] < C[3])) {
                                    D.label = Z[1];
                                    break
                                }
                                if (Z[0] === 6 && D.label < C[1]) {
                                    D.label = C[1],
                                    C = Z;
                                    break
                                }
                                if (C && D.label < C[2]) {
                                    D.label = C[2],
                                    D.ops.push(Z);
                                    break
                                }
                                C[2] && D.ops.pop(),
                                D.trys.pop();
                                continue
                            }
                            Z = x.call(v, D)
                        } catch (K) {
                            Z = [6, K],
                            A = 0
                        } finally {
                            E = C = 0
                        }
                    if (5 & Z[0])
                        throw Z[1];
                    return {
                        value: Z[0] ? Z[1] : void 0,
                        done: !0
                    }
                }([k, U])
            }
        }
    }
    ;
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var c = "browser-tabs-lock-key";
    function d(v) {
        return new Promise(function(x) {
            return setTimeout(x, v)
        }
        )
    }
    function p(v) {
        for (var x = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz", E = "", A = 0; A < v; A++)
            E += x[Math.floor(Math.random() * x.length)];
        return E
    }
    var i = function() {
        function v() {
            this.acquiredIatSet = new Set,
            this.id = Date.now().toString() + p(15),
            this.acquireLock = this.acquireLock.bind(this),
            this.releaseLock = this.releaseLock.bind(this),
            this.releaseLock__private__ = this.releaseLock__private__.bind(this),
            this.waitForSomethingToChange = this.waitForSomethingToChange.bind(this),
            this.refreshLockWhileAcquired = this.refreshLockWhileAcquired.bind(this),
            v.waiters === void 0 && (v.waiters = [])
        }
        return v.prototype.acquireLock = function(x, E) {
            return E === void 0 && (E = 5e3),
            t(this, void 0, void 0, function() {
                var A, C, I, D, P, k;
                return o(this, function(U) {
                    switch (U.label) {
                    case 0:
                        A = Date.now() + p(4),
                        C = Date.now() + E,
                        I = c + "-" + x,
                        D = window.localStorage,
                        U.label = 1;
                    case 1:
                        return Date.now() < C ? [4, d(30)] : [3, 8];
                    case 2:
                        return U.sent(),
                        D.getItem(I) !== null ? [3, 5] : (P = this.id + "-" + x + "-" + A,
                        [4, d(Math.floor(25 * Math.random()))]);
                    case 3:
                        return U.sent(),
                        D.setItem(I, JSON.stringify({
                            id: this.id,
                            iat: A,
                            timeoutKey: P,
                            timeAcquired: Date.now(),
                            timeRefreshed: Date.now()
                        })),
                        [4, d(30)];
                    case 4:
                        return U.sent(),
                        (k = D.getItem(I)) !== null && (k = JSON.parse(k)).id === this.id && k.iat === A ? (this.acquiredIatSet.add(A),
                        this.refreshLockWhileAcquired(I, A),
                        [2, !0]) : [3, 7];
                    case 5:
                        return v.lockCorrector(),
                        [4, this.waitForSomethingToChange(C)];
                    case 6:
                        U.sent(),
                        U.label = 7;
                    case 7:
                        return A = Date.now() + p(4),
                        [3, 1];
                    case 8:
                        return [2, !1]
                    }
                })
            })
        }
        ,
        v.prototype.refreshLockWhileAcquired = function(x, E) {
            return t(this, void 0, void 0, function() {
                var A = this;
                return o(this, function(C) {
                    return setTimeout(function() {
                        return t(A, void 0, void 0, function() {
                            var I, D;
                            return o(this, function(P) {
                                switch (P.label) {
                                case 0:
                                    return [4, Du.default().lock(E)];
                                case 1:
                                    return P.sent(),
                                    this.acquiredIatSet.has(E) ? (I = window.localStorage,
                                    (D = I.getItem(x)) === null ? (Du.default().unlock(E),
                                    [2]) : ((D = JSON.parse(D)).timeRefreshed = Date.now(),
                                    I.setItem(x, JSON.stringify(D)),
                                    Du.default().unlock(E),
                                    this.refreshLockWhileAcquired(x, E),
                                    [2])) : (Du.default().unlock(E),
                                    [2])
                                }
                            })
                        })
                    }, 1e3),
                    [2]
                })
            })
        }
        ,
        v.prototype.waitForSomethingToChange = function(x) {
            return t(this, void 0, void 0, function() {
                return o(this, function(E) {
                    switch (E.label) {
                    case 0:
                        return [4, new Promise(function(A) {
                            var C = !1
                              , I = Date.now()
                              , D = !1;
                            function P() {
                                if (D || (window.removeEventListener("storage", P),
                                v.removeFromWaiting(P),
                                clearTimeout(k),
                                D = !0),
                                !C) {
                                    C = !0;
                                    var U = 50 - (Date.now() - I);
                                    U > 0 ? setTimeout(A, U) : A()
                                }
                            }
                            window.addEventListener("storage", P),
                            v.addToWaiting(P);
                            var k = setTimeout(P, Math.max(0, x - Date.now()))
                        }
                        )];
                    case 1:
                        return E.sent(),
                        [2]
                    }
                })
            })
        }
        ,
        v.addToWaiting = function(x) {
            this.removeFromWaiting(x),
            v.waiters !== void 0 && v.waiters.push(x)
        }
        ,
        v.removeFromWaiting = function(x) {
            v.waiters !== void 0 && (v.waiters = v.waiters.filter(function(E) {
                return E !== x
            }))
        }
        ,
        v.notifyWaiters = function() {
            v.waiters !== void 0 && v.waiters.slice().forEach(function(x) {
                return x()
            })
        }
        ,
        v.prototype.releaseLock = function(x) {
            return t(this, void 0, void 0, function() {
                return o(this, function(E) {
                    switch (E.label) {
                    case 0:
                        return [4, this.releaseLock__private__(x)];
                    case 1:
                        return [2, E.sent()]
                    }
                })
            })
        }
        ,
        v.prototype.releaseLock__private__ = function(x) {
            return t(this, void 0, void 0, function() {
                var E, A, C;
                return o(this, function(I) {
                    switch (I.label) {
                    case 0:
                        return E = window.localStorage,
                        A = c + "-" + x,
                        (C = E.getItem(A)) === null ? [2] : (C = JSON.parse(C)).id !== this.id ? [3, 2] : [4, Du.default().lock(C.iat)];
                    case 1:
                        I.sent(),
                        this.acquiredIatSet.delete(C.iat),
                        E.removeItem(A),
                        Du.default().unlock(C.iat),
                        v.notifyWaiters(),
                        I.label = 2;
                    case 2:
                        return [2]
                    }
                })
            })
        }
        ,
        v.lockCorrector = function() {
            for (var x = Date.now() - 5e3, E = window.localStorage, A = Object.keys(E), C = !1, I = 0; I < A.length; I++) {
                var D = A[I];
                if (D.includes(c)) {
                    var P = E.getItem(D);
                    P !== null && ((P = JSON.parse(P)).timeRefreshed === void 0 && P.timeAcquired < x || P.timeRefreshed !== void 0 && P.timeRefreshed < x) && (E.removeItem(D),
                    C = !0)
                }
            }
            C && v.notifyWaiters()
        }
        ,
        v.waiters = void 0,
        v
    }();
    e.default = i
}))
  , uz = {
    timeoutInSeconds: 60
}
  , GA = {
    name: "auth0-spa-js",
    version: "2.0.1"
}
  , HA = ()=>Date.now()
  , no = class extends Error {
    constructor(e, t) {
        super(t),
        this.error = e,
        this.error_description = t,
        Object.setPrototypeOf(this, no.prototype)
    }
    static fromPayload({error: e, error_description: t}) {
        return new no(e,t)
    }
}
  , py = class extends no {
    constructor(e, t, o, c=null) {
        super(e, t),
        this.state = o,
        this.appState = c,
        Object.setPrototypeOf(this, py.prototype)
    }
}
  , Td = class extends no {
    constructor() {
        super("timeout", "Timeout"),
        Object.setPrototypeOf(this, Td.prototype)
    }
}
  , my = class extends Td {
    constructor(e) {
        super(),
        this.popup = e,
        Object.setPrototypeOf(this, my.prototype)
    }
}
  , gy = class extends no {
    constructor(e) {
        super("cancelled", "Popup closed"),
        this.popup = e,
        Object.setPrototypeOf(this, gy.prototype)
    }
}
  , _y = class extends no {
    constructor(e, t, o) {
        super(e, t),
        this.mfa_token = o,
        Object.setPrototypeOf(this, _y.prototype)
    }
}
  , yy = class extends no {
    constructor(e, t) {
        super("missing_refresh_token", `Missing Refresh Token (audience: '${WA(e, ["default"])}', scope: '${WA(t)}')`),
        this.audience = e,
        this.scope = t,
        Object.setPrototypeOf(this, yy.prototype)
    }
}
;
function WA(r, e=[]) {
    return r && !e.includes(r) ? r : ""
}
var xy = ()=>window.crypto
  , Jv = ()=>{
    let r = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_~."
      , e = "";
    return Array.from(xy().getRandomValues(new Uint8Array(43))).forEach(t=>e += r[t % r.length]),
    e
}
  , jA = r=>btoa(r)
  , $v = r=>{
    var {clientId: e} = r
      , t = ga(r, ["clientId"]);
    return new URLSearchParams((o=>Object.keys(o).filter(c=>o[c] !== void 0).reduce((c,d)=>Object.assign(Object.assign({}, c), {
        [d]: o[d]
    }), {}))(Object.assign({
        client_id: e
    }, t))).toString()
}
  , XA = r=>(e=>decodeURIComponent(atob(e).split("").map(t=>"%" + ("00" + t.charCodeAt(0).toString(16)).slice(-2)).join("")))(r.replace(/_/g, "/").replace(/-/g, "+"))
  , hz = async(r,e)=>{
    let t = await fetch(r, e);
    return {
        ok: t.ok,
        json: await t.json()
    }
}
  , dz = async(r,e,t)=>{
    let o = new AbortController, c;
    return e.signal = o.signal,
    Promise.race([hz(r, e), new Promise((d,p)=>{
        c = setTimeout(()=>{
            o.abort(),
            p(new Error("Timeout when executing 'fetch'"))
        }
        , t)
    }
    )]).finally(()=>{
        clearTimeout(c)
    }
    )
}
  , fz = async(r,e,t,o,c,d,p)=>{
    return i = {
        auth: {
            audience: e,
            scope: t
        },
        timeout: c,
        fetchUrl: r,
        fetchOptions: o,
        useFormData: p
    },
    v = d,
    new Promise(function(x, E) {
        let A = new MessageChannel;
        A.port1.onmessage = function(C) {
            C.data.error ? E(new Error(C.data.error)) : x(C.data),
            A.port1.close()
        }
        ,
        v.postMessage(i, [A.port2])
    }
    );
    var i, v
}
  , pz = async(r,e,t,o,c,d,p=1e4)=>c ? fz(r, e, t, o, p, c, d) : dz(r, o, p);
async function mz(r, e) {
    var {baseUrl: t, timeout: o, audience: c, scope: d, auth0Client: p, useFormData: i} = r
      , v = ga(r, ["baseUrl", "timeout", "audience", "scope", "auth0Client", "useFormData"]);
    let x = i ? $v(v) : JSON.stringify(v);
    return await async function(E, A, C, I, D, P, k) {
        let U, Z = null;
        for (let _e = 0; _e < 3; _e++)
            try {
                U = await pz(E, C, I, D, P, k, A),
                Z = null;
                break
            } catch (oe) {
                Z = oe
            }
        if (Z)
            throw Z;
        let K = U.json
          , {error: X, error_description: W} = K
          , fe = ga(K, ["error", "error_description"])
          , {ok: ce} = U;
        if (!ce) {
            let _e = W || `HTTP error. Unable to fetch ${E}`;
            throw X === "mfa_required" ? new _y(X,_e,fe.mfa_token) : new no(X || "request_error",_e)
        }
        return fe
    }(`${t}/oauth/token`, o, c || "default", d, {
        method: "POST",
        body: x,
        headers: {
            "Content-Type": i ? "application/x-www-form-urlencoded" : "application/json",
            "Auth0-Client": btoa(JSON.stringify(p || GA))
        }
    }, e, i)
}
var vy = (...r)=>{
    return (e = r.filter(Boolean).join(" ").trim().split(/\s+/),
    Array.from(new Set(e))).join(" ");
    var e
}
  , Fo = class {
    constructor(e, t="@@auth0spajs@@", o) {
        this.prefix = t,
        this.suffix = o,
        this.clientId = e.clientId,
        this.scope = e.scope,
        this.audience = e.audience
    }
    toKey() {
        return [this.prefix, this.clientId, this.audience, this.scope, this.suffix].filter(Boolean).join("::")
    }
    static fromKey(e) {
        let[t,o,c,d] = e.split("::");
        return new Fo({
            clientId: o,
            scope: d,
            audience: c
        },t)
    }
    static fromCacheEntry(e) {
        let {scope: t, audience: o, client_id: c} = e;
        return new Fo({
            scope: t,
            audience: o,
            clientId: c
        })
    }
}
  , ZA = class {
    set(e, t) {
        localStorage.setItem(e, JSON.stringify(t))
    }
    get(e) {
        let t = window.localStorage.getItem(e);
        if (t)
            try {
                return JSON.parse(t)
            } catch (o) {
                return
            }
    }
    remove(e) {
        localStorage.removeItem(e)
    }
    allKeys() {
        return Object.keys(window.localStorage).filter(e=>e.startsWith("@@auth0spajs@@"))
    }
}
  , Qv = class {
    constructor() {
        this.enclosedCache = function() {
            let e = {};
            return {
                set(t, o) {
                    e[t] = o
                },
                get(t) {
                    let o = e[t];
                    if (o)
                        return o
                },
                remove(t) {
                    delete e[t]
                },
                allKeys: ()=>Object.keys(e)
            }
        }()
    }
}
  , qA = class {
    constructor(e, t, o) {
        this.cache = e,
        this.keyManifest = t,
        this.nowProvider = o || HA
    }
    async setIdToken(e, t, o) {
        var c;
        let d = this.getIdTokenCacheKey(e);
        await this.cache.set(d, {
            id_token: t,
            decodedToken: o
        }),
        await ((c = this.keyManifest) === null || c === void 0 ? void 0 : c.add(d))
    }
    async getIdToken(e) {
        let t = await this.cache.get(this.getIdTokenCacheKey(e.clientId));
        if (!t && e.scope && e.audience) {
            let o = await this.get(e);
            return !o || !o.id_token || !o.decodedToken ? void 0 : {
                id_token: o.id_token,
                decodedToken: o.decodedToken
            }
        }
        if (t)
            return {
                id_token: t.id_token,
                decodedToken: t.decodedToken
            }
    }
    async get(e, t=0) {
        var o;
        let c = await this.cache.get(e.toKey());
        if (!c) {
            let i = await this.getCacheKeys();
            if (!i)
                return;
            let v = this.matchExistingCacheKey(e, i);
            v && (c = await this.cache.get(v))
        }
        if (!c)
            return;
        let d = await this.nowProvider()
          , p = Math.floor(d / 1e3);
        return c.expiresAt - t < p ? c.body.refresh_token ? (c.body = {
            refresh_token: c.body.refresh_token
        },
        await this.cache.set(e.toKey(), c),
        c.body) : (await this.cache.remove(e.toKey()),
        void await ((o = this.keyManifest) === null || o === void 0 ? void 0 : o.remove(e.toKey()))) : c.body
    }
    async set(e) {
        var t;
        let o = new Fo({
            clientId: e.client_id,
            scope: e.scope,
            audience: e.audience
        })
          , c = await this.wrapCacheEntry(e);
        await this.cache.set(o.toKey(), c),
        await ((t = this.keyManifest) === null || t === void 0 ? void 0 : t.add(o.toKey()))
    }
    async clear(e) {
        var t;
        let o = await this.getCacheKeys();
        o && (await o.filter(c=>!e || c.includes(e)).reduce(async(c,d)=>{
            await c,
            await this.cache.remove(d)
        }
        , Promise.resolve()),
        await ((t = this.keyManifest) === null || t === void 0 ? void 0 : t.clear()))
    }
    async wrapCacheEntry(e) {
        let t = await this.nowProvider();
        return {
            body: e,
            expiresAt: Math.floor(t / 1e3) + e.expires_in
        }
    }
    async getCacheKeys() {
        var e;
        return this.keyManifest ? (e = await this.keyManifest.get()) === null || e === void 0 ? void 0 : e.keys : this.cache.allKeys ? this.cache.allKeys() : void 0
    }
    getIdTokenCacheKey(e) {
        return new Fo({
            clientId: e
        },"@@auth0spajs@@","@@user@@").toKey()
    }
    matchExistingCacheKey(e, t) {
        return t.filter(o=>{
            var c;
            let d = Fo.fromKey(o)
              , p = new Set(d.scope && d.scope.split(" "))
              , i = ((c = e.scope) === null || c === void 0 ? void 0 : c.split(" ")) || []
              , v = d.scope && i.reduce((x,E)=>x && p.has(E), !0);
            return d.prefix === "@@auth0spajs@@" && d.clientId === e.clientId && d.audience === e.audience && v
        }
        )[0]
    }
}
  , KA = class {
    constructor(e, t) {
        this.storage = e,
        this.clientId = t,
        this.storageKey = `a0.spajs.txs.${this.clientId}`,
        this.transaction = this.storage.get(this.storageKey)
    }
    create(e) {
        this.transaction = e,
        this.storage.save(this.storageKey, e, {
            daysUntilExpire: 1
        })
    }
    get() {
        return this.transaction
    }
    remove() {
        delete this.transaction,
        this.storage.remove(this.storageKey)
    }
}
  , am = r=>typeof r == "number"
  , gz = ["iss", "aud", "exp", "nbf", "iat", "jti", "azp", "nonce", "auth_time", "at_hash", "c_hash", "acr", "amr", "sub_jwk", "cnf", "sip_from_tag", "sip_date", "sip_callid", "sip_cseq_num", "sip_via_branch", "orig", "dest", "mky", "events", "toe", "txn", "rph", "sid", "vot", "vtm"]
  , _z = r=>{
    if (!r.id_token)
        throw new Error("ID token is required but missing");
    let e = (d=>{
        let p = d.split(".")
          , [i,v,x] = p;
        if (p.length !== 3 || !i || !v || !x)
            throw new Error("ID token could not be decoded");
        let E = JSON.parse(XA(v))
          , A = {
            __raw: d
        }
          , C = {};
        return Object.keys(E).forEach(I=>{
            A[I] = E[I],
            gz.includes(I) || (C[I] = E[I])
        }
        ),
        {
            encoded: {
                header: i,
                payload: v,
                signature: x
            },
            header: JSON.parse(XA(i)),
            claims: A,
            user: C
        }
    }
    )(r.id_token);
    if (!e.claims.iss)
        throw new Error("Issuer (iss) claim must be a string present in the ID token");
    if (e.claims.iss !== r.iss)
        throw new Error(`Issuer (iss) claim mismatch in the ID token; expected "${r.iss}", found "${e.claims.iss}"`);
    if (!e.user.sub)
        throw new Error("Subject (sub) claim must be a string present in the ID token");
    if (e.header.alg !== "RS256")
        throw new Error(`Signature algorithm of "${e.header.alg}" is not supported. Expected the ID token to be signed with "RS256".`);
    if (!e.claims.aud || typeof e.claims.aud != "string" && !Array.isArray(e.claims.aud))
        throw new Error("Audience (aud) claim must be a string or array of strings present in the ID token");
    if (Array.isArray(e.claims.aud)) {
        if (!e.claims.aud.includes(r.aud))
            throw new Error(`Audience (aud) claim mismatch in the ID token; expected "${r.aud}" but was not one of "${e.claims.aud.join(", ")}"`);
        if (e.claims.aud.length > 1) {
            if (!e.claims.azp)
                throw new Error("Authorized Party (azp) claim must be a string present in the ID token when Audience (aud) claim has multiple values");
            if (e.claims.azp !== r.aud)
                throw new Error(`Authorized Party (azp) claim mismatch in the ID token; expected "${r.aud}", found "${e.claims.azp}"`)
        }
    } else if (e.claims.aud !== r.aud)
        throw new Error(`Audience (aud) claim mismatch in the ID token; expected "${r.aud}" but found "${e.claims.aud}"`);
    if (r.nonce) {
        if (!e.claims.nonce)
            throw new Error("Nonce (nonce) claim must be a string present in the ID token");
        if (e.claims.nonce !== r.nonce)
            throw new Error(`Nonce (nonce) claim mismatch in the ID token; expected "${r.nonce}", found "${e.claims.nonce}"`)
    }
    if (r.max_age && !am(e.claims.auth_time))
        throw new Error("Authentication Time (auth_time) claim must be a number present in the ID token when Max Age (max_age) is specified");
    if (e.claims.exp == null || !am(e.claims.exp))
        throw new Error("Expiration Time (exp) claim must be a number present in the ID token");
    if (!am(e.claims.iat))
        throw new Error("Issued At (iat) claim must be a number present in the ID token");
    let t = r.leeway || 60
      , o = new Date(r.now || Date.now())
      , c = new Date(0);
    if (c.setUTCSeconds(e.claims.exp + t),
    o > c)
        throw new Error(`Expiration Time (exp) claim error in the ID token; current time (${o}) is after expiration time (${c})`);
    if (e.claims.nbf != null && am(e.claims.nbf)) {
        let d = new Date(0);
        if (d.setUTCSeconds(e.claims.nbf - t),
        o < d)
            throw new Error(`Not Before time (nbf) claim in the ID token indicates that this token can't be used just yet. Current time (${o}) is before ${d}`)
    }
    if (e.claims.auth_time != null && am(e.claims.auth_time)) {
        let d = new Date(0);
        if (d.setUTCSeconds(parseInt(e.claims.auth_time) + r.max_age + t),
        o > d)
            throw new Error(`Authentication Time (auth_time) claim in the ID token indicates that too much time has passed since the last end-user authentication. Current time (${o}) is after last auth at ${d}`)
    }
    if (r.organizationId) {
        if (!e.claims.org_id)
            throw new Error("Organization ID (org_id) claim must be a string present in the ID token");
        if (r.organizationId !== e.claims.org_id)
            throw new Error(`Organization ID (org_id) claim mismatch in the ID token; expected "${r.organizationId}", found "${e.claims.org_id}"`)
    }
    return e
}
  , Lu = Yv(function(r, e) {
    var t = wd && wd.__assign || function() {
        return t = Object.assign || function(v) {
            for (var x, E = 1, A = arguments.length; E < A; E++)
                for (var C in x = arguments[E])
                    Object.prototype.hasOwnProperty.call(x, C) && (v[C] = x[C]);
            return v
        }
        ,
        t.apply(this, arguments)
    }
    ;
    function o(v, x) {
        if (!x)
            return "";
        var E = "; " + v;
        return x === !0 ? E : E + "=" + x
    }
    function c(v, x, E) {
        return encodeURIComponent(v).replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent).replace(/\(/g, "%28").replace(/\)/g, "%29") + "=" + encodeURIComponent(x).replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent) + function(A) {
            if (typeof A.expires == "number") {
                var C = new Date;
                C.setMilliseconds(C.getMilliseconds() + 864e5 * A.expires),
                A.expires = C
            }
            return o("Expires", A.expires ? A.expires.toUTCString() : "") + o("Domain", A.domain) + o("Path", A.path) + o("Secure", A.secure) + o("SameSite", A.sameSite)
        }(E)
    }
    function d(v) {
        for (var x = {}, E = v ? v.split("; ") : [], A = /(%[\dA-F]{2})+/gi, C = 0; C < E.length; C++) {
            var I = E[C].split("=")
              , D = I.slice(1).join("=");
            D.charAt(0) === '"' && (D = D.slice(1, -1));
            try {
                x[I[0].replace(A, decodeURIComponent)] = D.replace(A, decodeURIComponent)
            } catch (P) {}
        }
        return x
    }
    function p() {
        return d(document.cookie)
    }
    function i(v, x, E) {
        document.cookie = c(v, x, t({
            path: "/"
        }, E))
    }
    e.__esModule = !0,
    e.encode = c,
    e.parse = d,
    e.getAll = p,
    e.get = function(v) {
        return p()[v]
    }
    ,
    e.set = i,
    e.remove = function(v, x) {
        i(v, "", t(t({}, x), {
            expires: -1
        }))
    }
});
Kv(Lu),
Lu.encode,
Lu.parse,
Lu.getAll;
var yz = Lu.get
  , YA = Lu.set
  , JA = Lu.remove
  , Ed = {
    get(r) {
        let e = yz(r);
        if (e !== void 0)
            return JSON.parse(e)
    },
    save(r, e, t) {
        let o = {};
        window.location.protocol === "https:" && (o = {
            secure: !0,
            sameSite: "none"
        }),
        (t == null ? void 0 : t.daysUntilExpire) && (o.expires = t.daysUntilExpire),
        (t == null ? void 0 : t.cookieDomain) && (o.domain = t.cookieDomain),
        YA(r, JSON.stringify(e), o)
    },
    remove(r, e) {
        let t = {};
        (e == null ? void 0 : e.cookieDomain) && (t.domain = e.cookieDomain),
        JA(r, t)
    }
}
  , xz = {
    get(r) {
        return Ed.get(r) || Ed.get(`_legacy_ ${r}`)
    },
    save(r, e, t) {
        let o = {};
        window.location.protocol === "https:" && (o = {
            secure: !0
        }),
        (t == null ? void 0 : t.daysUntilExpire) && (o.expires = t.daysUntilExpire),
        YA(`_legacy_ ${r}`, JSON.stringify(e), o),
        Ed.save(r, e, t)
    },
    remove(r, e) {
        let t = {};
        (e == null ? void 0 : e.cookieDomain) && (t.domain = e.cookieDomain),
        JA(r, t),
        Ed.remove(r, e),
        Ed.remove(`_legacy_ ${r}`, e)
    }
}
  , vz = {
    get(r) {
        if (typeof sessionStorage == "undefined")
            return;
        let e = sessionStorage.getItem(r);
        return e != null ? JSON.parse(e) : void 0
    },
    save(r, e) {
        sessionStorage.setItem(r, JSON.stringify(e))
    },
    remove(r) {
        sessionStorage.removeItem(r)
    }
};
function bz(r, e, t) {
    var o = e === void 0 ? null : e
      , c = function(v, x) {
        var E = atob(v);
        if (x) {
            for (var A = new Uint8Array(E.length), C = 0, I = E.length; C < I; ++C)
                A[C] = E.charCodeAt(C);
            return String.fromCharCode.apply(null, new Uint16Array(A.buffer))
        }
        return E
    }(r, t !== void 0 && t)
      , d = c.indexOf(`
`, 10) + 1
      , p = c.substring(d) + (o ? "//# sourceMappingURL=" + o : "")
      , i = new Blob([p],{
        type: "application/javascript"
    });
    return URL.createObjectURL(i)
}
var $A, QA, eM, e1, wz = ($A = "Lyogcm9sbHVwLXBsdWdpbi13ZWItd29ya2VyLWxvYWRlciAqLwohZnVuY3Rpb24oKXsidXNlIHN0cmljdCI7Y2xhc3MgZSBleHRlbmRzIEVycm9ye2NvbnN0cnVjdG9yKHQscil7c3VwZXIociksdGhpcy5lcnJvcj10LHRoaXMuZXJyb3JfZGVzY3JpcHRpb249cixPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcyxlLnByb3RvdHlwZSl9c3RhdGljIGZyb21QYXlsb2FkKHtlcnJvcjp0LGVycm9yX2Rlc2NyaXB0aW9uOnJ9KXtyZXR1cm4gbmV3IGUodCxyKX19Y2xhc3MgdCBleHRlbmRzIGV7Y29uc3RydWN0b3IoZSxzKXtzdXBlcigibWlzc2luZ19yZWZyZXNoX3Rva2VuIixgTWlzc2luZyBSZWZyZXNoIFRva2VuIChhdWRpZW5jZTogJyR7cihlLFsiZGVmYXVsdCJdKX0nLCBzY29wZTogJyR7cihzKX0nKWApLHRoaXMuYXVkaWVuY2U9ZSx0aGlzLnNjb3BlPXMsT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsdC5wcm90b3R5cGUpfX1mdW5jdGlvbiByKGUsdD1bXSl7cmV0dXJuIGUmJiF0LmluY2x1ZGVzKGUpP2U6IiJ9Y29uc3Qgcz1lPT57dmFye2NsaWVudElkOnR9PWUscj1mdW5jdGlvbihlLHQpe3ZhciByPXt9O2Zvcih2YXIgcyBpbiBlKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHMpJiZ0LmluZGV4T2Yocyk8MCYmKHJbc109ZVtzXSk7aWYobnVsbCE9ZSYmImZ1bmN0aW9uIj09dHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpe3ZhciBvPTA7Zm9yKHM9T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTtvPHMubGVuZ3RoO28rKyl0LmluZGV4T2Yoc1tvXSk8MCYmT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKGUsc1tvXSkmJihyW3Nbb11dPWVbc1tvXV0pfXJldHVybiByfShlLFsiY2xpZW50SWQiXSk7cmV0dXJuIG5ldyBVUkxTZWFyY2hQYXJhbXMoKGU9Pk9iamVjdC5rZXlzKGUpLmZpbHRlcigodD0+dm9pZCAwIT09ZVt0XSkpLnJlZHVjZSgoKHQscik9Pk9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx0KSx7W3JdOmVbcl19KSkse30pKShPYmplY3QuYXNzaWduKHtjbGllbnRfaWQ6dH0scikpKS50b1N0cmluZygpfTtsZXQgbz17fTtjb25zdCBuPShlLHQpPT5gJHtlfXwke3R9YDthZGRFdmVudExpc3RlbmVyKCJtZXNzYWdlIiwoYXN5bmMoe2RhdGE6e3RpbWVvdXQ6ZSxhdXRoOnIsZmV0Y2hVcmw6aSxmZXRjaE9wdGlvbnM6Yyx1c2VGb3JtRGF0YTphfSxwb3J0czpbZl19KT0+e2xldCBwO2NvbnN0e2F1ZGllbmNlOmwsc2NvcGU6dX09cnx8e307dHJ5e2NvbnN0IHI9YT8oZT0+e2NvbnN0IHQ9bmV3IFVSTFNlYXJjaFBhcmFtcyhlKSxyPXt9O3JldHVybiB0LmZvckVhY2goKChlLHQpPT57clt0XT1lfSkpLHJ9KShjLmJvZHkpOkpTT04ucGFyc2UoYy5ib2R5KTtpZighci5yZWZyZXNoX3Rva2VuJiYicmVmcmVzaF90b2tlbiI9PT1yLmdyYW50X3R5cGUpe2NvbnN0IGU9KChlLHQpPT5vW24oZSx0KV0pKGwsdSk7aWYoIWUpdGhyb3cgbmV3IHQobCx1KTtjLmJvZHk9YT9zKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxyKSx7cmVmcmVzaF90b2tlbjplfSkpOkpTT04uc3RyaW5naWZ5KE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxyKSx7cmVmcmVzaF90b2tlbjplfSkpfWxldCBkLGc7ImZ1bmN0aW9uIj09dHlwZW9mIEFib3J0Q29udHJvbGxlciYmKGQ9bmV3IEFib3J0Q29udHJvbGxlcixjLnNpZ25hbD1kLnNpZ25hbCk7dHJ5e2c9YXdhaXQgUHJvbWlzZS5yYWNlKFsoaD1lLG5ldyBQcm9taXNlKChlPT5zZXRUaW1lb3V0KGUsaCkpKSksZmV0Y2goaSxPYmplY3QuYXNzaWduKHt9LGMpKV0pfWNhdGNoKGUpe3JldHVybiB2b2lkIGYucG9zdE1lc3NhZ2Uoe2Vycm9yOmUubWVzc2FnZX0pfWlmKCFnKXJldHVybiBkJiZkLmFib3J0KCksdm9pZCBmLnBvc3RNZXNzYWdlKHtlcnJvcjoiVGltZW91dCB3aGVuIGV4ZWN1dGluZyAnZmV0Y2gnIn0pO3A9YXdhaXQgZy5qc29uKCkscC5yZWZyZXNoX3Rva2VuPygoKGUsdCxyKT0+e29bbih0LHIpXT1lfSkocC5yZWZyZXNoX3Rva2VuLGwsdSksZGVsZXRlIHAucmVmcmVzaF90b2tlbik6KChlLHQpPT57ZGVsZXRlIG9bbihlLHQpXX0pKGwsdSksZi5wb3N0TWVzc2FnZSh7b2s6Zy5vayxqc29uOnB9KX1jYXRjaChlKXtmLnBvc3RNZXNzYWdlKHtvazohMSxqc29uOntlcnJvcl9kZXNjcmlwdGlvbjplLm1lc3NhZ2V9fSl9dmFyIGh9KSl9KCk7Cgo=",
QA = null,
eM = !1,
function(r) {
    return e1 = e1 || bz($A, QA, eM),
    new Worker(e1,r)
}
), t1 = {}, tM = class {
    constructor(e, t) {
        this.cache = e,
        this.clientId = t,
        this.manifestKey = this.createManifestKeyFrom(this.clientId)
    }
    async add(e) {
        var t;
        let o = new Set(((t = await this.cache.get(this.manifestKey)) === null || t === void 0 ? void 0 : t.keys) || []);
        o.add(e),
        await this.cache.set(this.manifestKey, {
            keys: [...o]
        })
    }
    async remove(e) {
        let t = await this.cache.get(this.manifestKey);
        if (t) {
            let o = new Set(t.keys);
            return o.delete(e),
            o.size > 0 ? await this.cache.set(this.manifestKey, {
                keys: [...o]
            }) : await this.cache.remove(this.manifestKey)
        }
    }
    get() {
        return this.cache.get(this.manifestKey)
    }
    clear() {
        return this.cache.remove(this.manifestKey)
    }
    createManifestKeyFrom(e) {
        return `@@auth0spajs@@::${e}`
    }
}
, Tz = {
    memory: ()=>new Qv().enclosedCache,
    localstorage: ()=>new ZA
}, nM = r=>Tz[r], iM = r=>{
    let {openUrl: e, onRedirect: t} = r
      , o = ga(r, ["openUrl", "onRedirect"]);
    return Object.assign(Object.assign({}, o), {
        openUrl: e === !1 || e ? e : t
    })
}
, n1 = new cz, rM = class {
    constructor(e) {
        let t, o;
        if (this.userCache = new Qv().enclosedCache,
        this.defaultOptions = {
            authorizationParams: {
                scope: "openid profile email"
            },
            useRefreshTokensFallback: !1,
            useFormData: !0
        },
        this._releaseLockOnPageHide = async()=>{
            await n1.releaseLock("auth0.lock.getTokenSilently"),
            window.removeEventListener("pagehide", this._releaseLockOnPageHide)
        }
        ,
        this.options = Object.assign(Object.assign(Object.assign({}, this.defaultOptions), e), {
            authorizationParams: Object.assign(Object.assign({}, this.defaultOptions.authorizationParams), e.authorizationParams)
        }),
        typeof window != "undefined" && (()=>{
            if (!xy())
                throw new Error("For security reasons, `window.crypto` is required to run `auth0-spa-js`.");
            if (xy().subtle === void 0)
                throw new Error(`
      auth0-spa-js must run on a secure origin. See https://github.com/auth0/auth0-spa-js/blob/master/FAQ.md#why-do-i-get-auth0-spa-js-must-run-on-a-secure-origin for more information.
    `)
        }
        )(),
        e.cache && e.cacheLocation && console.warn("Both `cache` and `cacheLocation` options have been specified in the Auth0Client configuration; ignoring `cacheLocation` and using `cache`."),
        e.cache)
            o = e.cache;
        else {
            if (t = e.cacheLocation || "memory",
            !nM(t))
                throw new Error(`Invalid cache location "${t}"`);
            o = nM(t)()
        }
        this.httpTimeoutMs = e.httpTimeoutInSeconds ? 1e3 * e.httpTimeoutInSeconds : 1e4,
        this.cookieStorage = e.legacySameSiteCookie === !1 ? Ed : xz,
        this.orgHintCookieName = `auth0.${this.options.clientId}.organization_hint`,
        this.isAuthenticatedCookieName = (p=>`auth0.${p}.is.authenticated`)(this.options.clientId),
        this.sessionCheckExpiryDays = e.sessionCheckExpiryDays || 1;
        let c = e.useCookiesForTransactions ? this.cookieStorage : vz;
        var d;
        this.scope = vy("openid", this.options.authorizationParams.scope, this.options.useRefreshTokens ? "offline_access" : ""),
        this.transactionManager = new KA(c,this.options.clientId),
        this.nowProvider = this.options.nowProvider || HA,
        this.cacheManager = new qA(o,o.allKeys ? void 0 : new tM(o,this.options.clientId),this.nowProvider),
        this.domainUrl = (d = this.options.domain,
        /^https?:\/\//.test(d) ? d : `https://${d}`),
        this.tokenIssuer = ((p,i)=>p ? p.startsWith("https://") ? p : `https://${p}/` : `${i}/`)(this.options.issuer, this.domainUrl),
        typeof window != "undefined" && window.Worker && this.options.useRefreshTokens && t === "memory" && (this.worker = new wz)
    }
    _url(e) {
        let t = encodeURIComponent(btoa(JSON.stringify(this.options.auth0Client || GA)));
        return `${this.domainUrl}${e}&auth0Client=${t}`
    }
    _authorizeUrl(e) {
        return this._url(`/authorize?${$v(e)}`)
    }
    async _verifyIdToken(e, t, o) {
        let c = await this.nowProvider();
        return _z({
            iss: this.tokenIssuer,
            aud: this.options.clientId,
            id_token: e,
            nonce: t,
            organizationId: o,
            leeway: this.options.leeway,
            max_age: (d = this.options.authorizationParams.max_age,
            typeof d != "string" ? d : parseInt(d, 10) || void 0),
            now: c
        });
        var d
    }
    _processOrgIdHint(e) {
        e ? this.cookieStorage.save(this.orgHintCookieName, e, {
            daysUntilExpire: this.sessionCheckExpiryDays,
            cookieDomain: this.options.cookieDomain
        }) : this.cookieStorage.remove(this.orgHintCookieName, {
            cookieDomain: this.options.cookieDomain
        })
    }
    async _prepareAuthorizeUrl(e, t, o) {
        let c = jA(Jv())
          , d = jA(Jv())
          , p = Jv()
          , i = (E=>{
            let A = new Uint8Array(E);
            return (C=>{
                let I = {
                    "+": "-",
                    "/": "_",
                    "=": ""
                };
                return C.replace(/[+/=]/g, D=>I[D])
            }
            )(window.btoa(String.fromCharCode(...Array.from(A))))
        }
        )(await (async E=>await xy().subtle.digest({
            name: "SHA-256"
        }, new TextEncoder().encode(E)))(p))
          , v = ((E,A,C,I,D,P,k,U)=>Object.assign(Object.assign(Object.assign({
            client_id: E.clientId
        }, E.authorizationParams), C), {
            scope: vy(A, C.scope),
            response_type: "code",
            response_mode: U || "query",
            state: I,
            nonce: D,
            redirect_uri: k || E.authorizationParams.redirect_uri,
            code_challenge: P,
            code_challenge_method: "S256"
        }))(this.options, this.scope, e, c, d, i, e.redirect_uri || this.options.authorizationParams.redirect_uri || o, t == null ? void 0 : t.response_mode)
          , x = this._authorizeUrl(v);
        return {
            nonce: d,
            code_verifier: p,
            scope: v.scope,
            audience: v.audience || "default",
            redirect_uri: v.redirect_uri,
            state: c,
            url: x
        }
    }
    async loginWithPopup(e, t) {
        var o;
        if (e = e || {},
        !(t = t || {}).popup && (t.popup = (i=>{
            let v = window.screenX + (window.innerWidth - 400) / 2
              , x = window.screenY + (window.innerHeight - 600) / 2;
            return window.open(i, "auth0:authorize:popup", `left=${v},top=${x},width=400,height=600,resizable,scrollbars=yes,status=1`)
        }
        )(""),
        !t.popup))
            throw new Error("Unable to open a popup for loginWithPopup - window.open returned `null`");
        let c = await this._prepareAuthorizeUrl(e.authorizationParams || {}, {
            response_mode: "web_message"
        }, window.location.origin);
        t.popup.location.href = c.url;
        let d = await (i=>new Promise((v,x)=>{
            let E, A = setInterval(()=>{
                i.popup && i.popup.closed && (clearInterval(A),
                clearTimeout(C),
                window.removeEventListener("message", E, !1),
                x(new gy(i.popup)))
            }
            , 1e3), C = setTimeout(()=>{
                clearInterval(A),
                x(new my(i.popup)),
                window.removeEventListener("message", E, !1)
            }
            , 1e3 * (i.timeoutInSeconds || 60));
            E = function(I) {
                if (I.data && I.data.type === "authorization_response") {
                    if (clearTimeout(C),
                    clearInterval(A),
                    window.removeEventListener("message", E, !1),
                    i.popup.close(),
                    I.data.response.error)
                        return x(no.fromPayload(I.data.response));
                    v(I.data.response)
                }
            }
            ,
            window.addEventListener("message", E)
        }
        ))(Object.assign(Object.assign({}, t), {
            timeoutInSeconds: t.timeoutInSeconds || this.options.authorizeTimeoutInSeconds || 60
        }));
        if (c.state !== d.state)
            throw new Error("Invalid state");
        let p = ((o = e.authorizationParams) === null || o === void 0 ? void 0 : o.organization) || this.options.authorizationParams.organization;
        await this._requestToken({
            audience: c.audience,
            scope: c.scope,
            code_verifier: c.code_verifier,
            grant_type: "authorization_code",
            code: d.code,
            redirect_uri: c.redirect_uri
        }, {
            nonceIn: c.nonce,
            organizationId: p
        })
    }
    async getUser() {
        var e;
        let t = await this._getIdTokenFromCache();
        return (e = t == null ? void 0 : t.decodedToken) === null || e === void 0 ? void 0 : e.user
    }
    async getIdTokenClaims() {
        var e;
        let t = await this._getIdTokenFromCache();
        return (e = t == null ? void 0 : t.decodedToken) === null || e === void 0 ? void 0 : e.claims
    }
    async loginWithRedirect(e={}) {
        var t;
        let o = iM(e)
          , {openUrl: c, fragment: d, appState: p} = o
          , i = ga(o, ["openUrl", "fragment", "appState"])
          , v = ((t = i.authorizationParams) === null || t === void 0 ? void 0 : t.organization) || this.options.authorizationParams.organization
          , x = await this._prepareAuthorizeUrl(i.authorizationParams || {})
          , {url: E} = x
          , A = ga(x, ["url"]);
        this.transactionManager.create(Object.assign(Object.assign(Object.assign({}, A), {
            appState: p
        }), v && {
            organizationId: v
        }));
        let C = d ? `${E}#${d}` : E;
        c ? await c(C) : window.location.assign(C)
    }
    async handleRedirectCallback(e=window.location.href) {
        let t = e.split("?").slice(1);
        if (t.length === 0)
            throw new Error("There are no query params available for parsing.");
        let {state: o, code: c, error: d, error_description: p} = (A=>{
            A.indexOf("#") > -1 && (A = A.substr(0, A.indexOf("#")));
            let C = A.split("&")
              , I = {};
            return C.forEach(D=>{
                let[P,k] = D.split("=");
                I[P] = decodeURIComponent(k)
            }
            ),
            I.expires_in && (I.expires_in = parseInt(I.expires_in)),
            I
        }
        )(t.join(""))
          , i = this.transactionManager.get();
        if (!i)
            throw new Error("Invalid state");
        if (this.transactionManager.remove(),
        d)
            throw new py(d,p || d,o,i.appState);
        if (!i.code_verifier || i.state && i.state !== o)
            throw new Error("Invalid state");
        let v = i.organizationId
          , x = i.nonce
          , E = i.redirect_uri;
        return await this._requestToken(Object.assign({
            audience: i.audience,
            scope: i.scope,
            code_verifier: i.code_verifier,
            grant_type: "authorization_code",
            code: c
        }, E ? {
            redirect_uri: E
        } : {}), {
            nonceIn: x,
            organizationId: v
        }),
        {
            appState: i.appState
        }
    }
    async checkSession(e) {
        if (!this.cookieStorage.get(this.isAuthenticatedCookieName)) {
            if (!this.cookieStorage.get("auth0.is.authenticated"))
                return;
            this.cookieStorage.save(this.isAuthenticatedCookieName, !0, {
                daysUntilExpire: this.sessionCheckExpiryDays,
                cookieDomain: this.options.cookieDomain
            }),
            this.cookieStorage.remove("auth0.is.authenticated")
        }
        try {
            await this.getTokenSilently(e)
        } catch (t) {}
    }
    async getTokenSilently(e={}) {
        var t;
        let o = Object.assign(Object.assign({
            cacheMode: "on"
        }, e), {
            authorizationParams: Object.assign(Object.assign(Object.assign({}, this.options.authorizationParams), e.authorizationParams), {
                scope: vy(this.scope, (t = e.authorizationParams) === null || t === void 0 ? void 0 : t.scope)
            })
        })
          , c = await ((d,p)=>{
            let i = t1[p];
            return i || (i = d().finally(()=>{
                delete t1[p],
                i = null
            }
            ),
            t1[p] = i),
            i
        }
        )(()=>this._getTokenSilently(o), `${this.options.clientId}::${o.authorizationParams.audience}::${o.authorizationParams.scope}`);
        return e.detailedResponse ? c : c == null ? void 0 : c.access_token
    }
    async _getTokenSilently(e) {
        let {cacheMode: t} = e
          , o = ga(e, ["cacheMode"]);
        if (t !== "off") {
            let c = await this._getEntryFromCache({
                scope: o.authorizationParams.scope,
                audience: o.authorizationParams.audience || "default",
                clientId: this.options.clientId
            });
            if (c)
                return c
        }
        if (t !== "cache-only") {
            if (!await (async(c,d=3)=>{
                for (let p = 0; p < d; p++)
                    if (await c())
                        return !0;
                return !1
            }
            )(()=>n1.acquireLock("auth0.lock.getTokenSilently", 5e3), 10))
                throw new Td;
            try {
                if (window.addEventListener("pagehide", this._releaseLockOnPageHide),
                t !== "off") {
                    let x = await this._getEntryFromCache({
                        scope: o.authorizationParams.scope,
                        audience: o.authorizationParams.audience || "default",
                        clientId: this.options.clientId
                    });
                    if (x)
                        return x
                }
                let c = this.options.useRefreshTokens ? await this._getTokenUsingRefreshToken(o) : await this._getTokenFromIFrame(o)
                  , {id_token: d, access_token: p, oauthTokenScope: i, expires_in: v} = c;
                return Object.assign(Object.assign({
                    id_token: d,
                    access_token: p
                }, i ? {
                    scope: i
                } : null), {
                    expires_in: v
                })
            } finally {
                await n1.releaseLock("auth0.lock.getTokenSilently"),
                window.removeEventListener("pagehide", this._releaseLockOnPageHide)
            }
        }
    }
    async getTokenWithPopup(e={}, t={}) {
        var o;
        let c = Object.assign(Object.assign({}, e), {
            authorizationParams: Object.assign(Object.assign(Object.assign({}, this.options.authorizationParams), e.authorizationParams), {
                scope: vy(this.scope, (o = e.authorizationParams) === null || o === void 0 ? void 0 : o.scope)
            })
        });
        return t = Object.assign(Object.assign({}, uz), t),
        await this.loginWithPopup(c, t),
        (await this.cacheManager.get(new Fo({
            scope: c.authorizationParams.scope,
            audience: c.authorizationParams.audience || "default",
            clientId: this.options.clientId
        }))).access_token
    }
    async isAuthenticated() {
        return !!await this.getUser()
    }
    _buildLogoutUrl(e) {
        e.clientId !== null ? e.clientId = e.clientId || this.options.clientId : delete e.clientId;
        let t = e.logoutParams || {}
          , {federated: o} = t
          , c = ga(t, ["federated"])
          , d = o ? "&federated" : "";
        return this._url(`/v2/logout?${$v(Object.assign({
            clientId: e.clientId
        }, c))}`) + d
    }
    async logout(e={}) {
        let t = iM(e)
          , {openUrl: o} = t
          , c = ga(t, ["openUrl"]);
        await this.cacheManager.clear(),
        this.cookieStorage.remove(this.orgHintCookieName, {
            cookieDomain: this.options.cookieDomain
        }),
        this.cookieStorage.remove(this.isAuthenticatedCookieName, {
            cookieDomain: this.options.cookieDomain
        }),
        this.userCache.remove("@@user@@");
        let d = this._buildLogoutUrl(c);
        o ? await o(d) : o !== !1 && window.location.assign(d)
    }
    async _getTokenFromIFrame(e) {
        let t = Object.assign(Object.assign({}, e.authorizationParams), {
            prompt: "none"
        })
          , o = this.cookieStorage.get(this.orgHintCookieName);
        o && !t.organization && (t.organization = o);
        let {url: c, state: d, nonce: p, code_verifier: i, redirect_uri: v, scope: x, audience: E} = await this._prepareAuthorizeUrl(t, {
            response_mode: "web_message"
        }, window.location.origin);
        try {
            if (window.crossOriginIsolated)
                throw new no("login_required","The application is running in a Cross-Origin Isolated context, silently retrieving a token without refresh token is not possible.");
            let A = e.timeoutInSeconds || this.options.authorizeTimeoutInSeconds
              , C = await ((D,P,k=60)=>new Promise((U,Z)=>{
                let K = window.document.createElement("iframe");
                K.setAttribute("width", "0"),
                K.setAttribute("height", "0"),
                K.style.display = "none";
                let X = ()=>{
                    window.document.body.contains(K) && (window.document.body.removeChild(K),
                    window.removeEventListener("message", W, !1))
                }
                , W, fe = setTimeout(()=>{
                    Z(new Td),
                    X()
                }
                , 1e3 * k);
                W = function(ce) {
                    if (ce.origin != P || !ce.data || ce.data.type !== "authorization_response")
                        return;
                    let _e = ce.source;
                    _e && _e.close(),
                    ce.data.response.error ? Z(no.fromPayload(ce.data.response)) : U(ce.data.response),
                    clearTimeout(fe),
                    window.removeEventListener("message", W, !1),
                    setTimeout(X, 2e3)
                }
                ,
                window.addEventListener("message", W, !1),
                window.document.body.appendChild(K),
                K.setAttribute("src", D)
            }
            ))(c, this.domainUrl, A);
            if (d !== C.state)
                throw new Error("Invalid state");
            let I = await this._requestToken(Object.assign(Object.assign({}, e.authorizationParams), {
                code_verifier: i,
                code: C.code,
                grant_type: "authorization_code",
                redirect_uri: v,
                timeout: e.authorizationParams.timeout || this.httpTimeoutMs
            }), {
                nonceIn: p
            });
            return Object.assign(Object.assign({}, I), {
                scope: x,
                oauthTokenScope: I.scope,
                audience: E
            })
        } catch (A) {
            throw A.error === "login_required" && this.logout({
                openUrl: !1
            }),
            A
        }
    }
    async _getTokenUsingRefreshToken(e) {
        let t = await this.cacheManager.get(new Fo({
            scope: e.authorizationParams.scope,
            audience: e.authorizationParams.audience || "default",
            clientId: this.options.clientId
        }));
        if (!(t && t.refresh_token || this.worker)) {
            if (this.options.useRefreshTokensFallback)
                return await this._getTokenFromIFrame(e);
            throw new yy(e.authorizationParams.audience || "default",e.authorizationParams.scope)
        }
        let o = e.authorizationParams.redirect_uri || this.options.authorizationParams.redirect_uri || window.location.origin
          , c = typeof e.timeoutInSeconds == "number" ? 1e3 * e.timeoutInSeconds : null;
        try {
            let d = await this._requestToken(Object.assign(Object.assign(Object.assign({}, e.authorizationParams), {
                grant_type: "refresh_token",
                refresh_token: t && t.refresh_token,
                redirect_uri: o
            }), c && {
                timeout: c
            }));
            return Object.assign(Object.assign({}, d), {
                scope: e.authorizationParams.scope,
                oauthTokenScope: d.scope,
                audience: e.authorizationParams.audience || "default"
            })
        } catch (d) {
            if ((d.message.indexOf("Missing Refresh Token") > -1 || d.message && d.message.indexOf("invalid refresh token") > -1) && this.options.useRefreshTokensFallback)
                return await this._getTokenFromIFrame(e);
            throw d
        }
    }
    async _saveEntryInCache(e) {
        let {id_token: t, decodedToken: o} = e
          , c = ga(e, ["id_token", "decodedToken"]);
        this.userCache.set("@@user@@", {
            id_token: t,
            decodedToken: o
        }),
        await this.cacheManager.setIdToken(this.options.clientId, e.id_token, e.decodedToken),
        await this.cacheManager.set(c)
    }
    async _getIdTokenFromCache() {
        let e = this.options.authorizationParams.audience || "default"
          , t = await this.cacheManager.getIdToken(new Fo({
            clientId: this.options.clientId,
            audience: e,
            scope: this.scope
        }))
          , o = this.userCache.get("@@user@@");
        return t && t.id_token === (o == null ? void 0 : o.id_token) ? o : (this.userCache.set("@@user@@", t),
        t)
    }
    async _getEntryFromCache({scope: e, audience: t, clientId: o}) {
        let c = await this.cacheManager.get(new Fo({
            scope: e,
            audience: t,
            clientId: o
        }), 60);
        if (c && c.access_token) {
            let {access_token: d, oauthTokenScope: p, expires_in: i} = c
              , v = await this._getIdTokenFromCache();
            return v && Object.assign(Object.assign({
                id_token: v.id_token,
                access_token: d
            }, p ? {
                scope: p
            } : null), {
                expires_in: i
            })
        }
    }
    async _requestToken(e, t) {
        let {nonceIn: o, organizationId: c} = t || {}
          , d = await mz(Object.assign({
            baseUrl: this.domainUrl,
            client_id: this.options.clientId,
            auth0Client: this.options.auth0Client,
            useFormData: this.options.useFormData,
            timeout: this.httpTimeoutMs
        }, e), this.worker)
          , p = await this._verifyIdToken(d.id_token, o, c);
        return await this._saveEntryInCache(Object.assign(Object.assign(Object.assign(Object.assign({}, d), {
            decodedToken: p,
            scope: e.scope,
            audience: e.audience || "default"
        }), d.scope ? {
            oauthTokenScope: d.scope
        } : null), {
            client_id: this.options.clientId
        })),
        this.cookieStorage.save(this.isAuthenticatedCookieName, !0, {
            daysUntilExpire: this.sessionCheckExpiryDays,
            cookieDomain: this.options.cookieDomain
        }),
        this._processOrgIdHint(p.claims.org_id),
        Object.assign(Object.assign({}, d), {
            decodedToken: p
        })
    }
}
;
async function sM(r) {
    let e = new rM(r);
    return await e.checkSession(),
    e
}
import.meta.env = Up;
function oM() {
    let r = null
      , e = ()=>fetch("/auth_config.json")
      , t = async()=>{
        let E = await (await e()).json();
        r = await sM({
            domain: E.domain,
            clientId: E.clientId,
            authorizationParams: {
                audience: E.audience
            },
            useRefreshTokens: !0,
            cacheLocation: "localstorage"
        }),
        await c() ? Sd.set(!0) : Sd.set(!1)
    }
    ;
    async function o() {
        await t();
        let x = window.location.search;
        if (x.includes("error=")) {
            let E = new URL(document.location).searchParams
              , A = E.get("error")
              , C = E.get("error_description");
            Yi.update(I=>(I.error = !0,
            I.message = "A verification email has been sent to the email provided. Click the link in the email to complete account creation.",
            I.header = "Email not verified",
            I.color = "normal",
            I)),
            window.history.replaceState({}, document.title, "/")
        } else
            x.includes("code=") && x.includes("state=") && (await r.handleRedirectCallback(),
            window.history.replaceState({}, document.title, "/"),
            Sd.set(!0))
    }
    o();
    async function c() {
        return await r.isAuthenticated()
    }
    async function d() {
        let x;
        if (Ev != "null")
            x = Ev;
        else
            try {
                x = await r.getTokenSilently()
            } catch (E) {
                v()
            }
        return x
    }
    async function p() {
        return await r.getUser()
    }
    let i = async()=>{
        await r.loginWithRedirect({
            authorizationParams: {
                redirect_uri: window.location.origin
            }
        })
    }
      , v = ()=>{
        r.logout({
            logoutParams: {
                returnTo: window.location.origin
            }
        })
    }
    ;
    return {
        isAuthenticated: c,
        login: i,
        logout: v,
        getToken: d,
        getUser: p
    }
}
var aM = {
    type: "FeatureCollection",
    features: [{
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-124.1069, 47.1158]
        },
        properties: {
            STATION_ID: "NEXRAD:KLGX",
            STATION_NAME: "LANGLEY HILL NW WASHIN",
            STATE: "WA"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-86.76972, 33.17194]
        },
        properties: {
            STATION_ID: "NEXRAD:KBMX",
            STATION_NAME: "BIRMINGHAM",
            STATE: "AL"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-78.73694, 42.94861]
        },
        properties: {
            STATION_ID: "NEXRAD:KBUF",
            STATION_NAME: "BUFFALO",
            STATE: "NY"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-116.23444, 43.49083]
        },
        properties: {
            STATION_ID: "NEXRAD:KCBX",
            STATION_NAME: "BOISE",
            STATE: "ID"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-74.41111, 39.94694]
        },
        properties: {
            STATION_ID: "NEXRAD:KDIX",
            STATION_NAME: "PHILADELPHIA",
            STATE: "NJ"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-110.63028, 31.89361]
        },
        properties: {
            STATION_ID: "NEXRAD:KEMX",
            STATION_NAME: "TUCSON",
            STATE: "AZ"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-114.89139, 35.70111]
        },
        properties: {
            STATION_ID: "NEXRAD:KESX",
            STATION_NAME: "LAS VEGAS",
            STATE: "NV"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-98.97611, 34.36222]
        },
        properties: {
            STATION_ID: "NEXRAD:KFDR",
            STATION_NAME: "ALTUS AFB",
            STATE: "OK"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-101.81361, 33.65417]
        },
        properties: {
            STATION_ID: "NEXRAD:KLBB",
            STATION_NAME: "LUBBOCK",
            STATE: "TX"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-89.87333, 35.34472]
        },
        properties: {
            STATION_ID: "NEXRAD:KNQA",
            STATION_NAME: "MEMPHIS",
            STATE: "TN"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-88.77194, 37.06833]
        },
        properties: {
            STATION_ID: "NEXRAD:KPAH",
            STATION_NAME: "PADUCAH",
            STATE: "KY"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-104.18139, 38.45944]
        },
        properties: {
            STATION_ID: "NEXRAD:KPUX",
            STATION_NAME: "PUEBLO",
            STATE: "CO"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-122.96417, 45.715]
        },
        properties: {
            STATION_ID: "NEXRAD:KRTX",
            STATION_NAME: "PORTLAND",
            STATE: "OR"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-111.38444, 47.45972]
        },
        properties: {
            STATION_ID: "NEXRAD:KTFX",
            STATION_NAME: "GREAT FALLS",
            STATE: "MT"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-98.1275, 36.74083]
        },
        properties: {
            STATION_ID: "NEXRAD:KVNX",
            STATION_NAME: "VANCE AFB",
            STATE: "OK"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-159.55222, 21.89417]
        },
        properties: {
            STATION_ID: "NEXRAD:PHKI",
            STATION_NAME: "SOUTH KAUAI",
            STATE: "HI"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-155.77778, 20.12556]
        },
        properties: {
            STATION_ID: "NEXRAD:PHKM",
            STATION_NAME: "KAMUELA",
            STATE: "HI"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-98.41306, 45.45583]
        },
        properties: {
            STATION_ID: "NEXRAD:KABR",
            STATION_NAME: "ABERDEEN",
            STATE: "SD"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-122.49444, 48.19472]
        },
        properties: {
            STATION_ID: "NEXRAD:KATX",
            STATION_NAME: "SEATTLE",
            STATE: "WA"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-92.20972, 46.83694]
        },
        properties: {
            STATION_ID: "NEXRAD:KDLH",
            STATION_NAME: "DULUTH",
            STATE: "MN"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-75.44, 38.82556]
        },
        properties: {
            STATION_ID: "NEXRAD:KDOX",
            STATION_NAME: "DOVER AFB",
            STATE: "DE"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-101.7, 39.36694]
        },
        properties: {
            STATION_ID: "NEXRAD:KGLD",
            STATION_NAME: "GOODLAND",
            STATE: "KS"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-119.63111, 36.31417]
        },
        properties: {
            STATION_ID: "NEXRAD:KHNX",
            STATION_NAME: "SAN JOAQUIN VALLEY",
            STATE: "CA"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-97.4425, 37.65444]
        },
        properties: {
            STATION_ID: "NEXRAD:KICT",
            STATION_NAME: "WICHITA",
            STATE: "KS"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-100.57583, 41.95778]
        },
        properties: {
            STATION_ID: "NEXRAD:KLNX",
            STATION_NAME: "NORTH PLATTE",
            STATE: "NE"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-90.68278, 38.69889]
        },
        properties: {
            STATION_ID: "NEXRAD:KLSX",
            STATION_NAME: "ST LOUIS",
            STATE: "MO"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-112.68528, 43.10583]
        },
        properties: {
            STATION_ID: "NEXRAD:KSFX",
            STATION_NAME: "POCATELLO",
            STATE: "ID"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-96.2325, 38.99694]
        },
        properties: {
            STATION_ID: "NEXRAD:KTWX",
            STATION_NAME: "TOPEKA",
            STATE: "KS"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-87.7247, 38.26]
        },
        properties: {
            STATION_ID: "NEXRAD:KVWX",
            STATION_NAME: "EVANSVILLE",
            STATE: "IN"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-91.19111, 43.82278]
        },
        properties: {
            STATION_ID: "NEXRAD:KARX",
            STATION_NAME: "LA CROSSE",
            STATE: "WI"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-108.60611, 45.85389]
        },
        properties: {
            STATION_ID: "NEXRAD:KBLX",
            STATION_NAME: "BILLINGS",
            STATE: "MT"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-81.70333, 24.59694]
        },
        properties: {
            STATION_ID: "NEXRAD:KBYX",
            STATION_NAME: "KEY WEST",
            STATE: "FL"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-104.80611, 41.15194]
        },
        properties: {
            STATION_ID: "NEXRAD:KCYS",
            STATION_NAME: "CHEYENNE",
            STATE: "WY"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-83.47167, 42.69972]
        },
        properties: {
            STATION_ID: "NEXRAD:KDTX",
            STATION_NAME: "DETROIT",
            STATE: "MI"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-111.19833, 34.57444]
        },
        properties: {
            STATION_ID: "NEXRAD:KFSX",
            STATION_NAME: "FLAGSTAFF",
            STATE: "AZ"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-88.11111, 44.49833]
        },
        properties: {
            STATION_ID: "NEXRAD:KGRB",
            STATION_NAME: "GREEN BAY",
            STATE: "WI"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-88.55056, 42.96778]
        },
        properties: {
            STATION_ID: "NEXRAD:KMKX",
            STATION_NAME: "MILWAUKEE",
            STATE: "WI"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-80.65444, 28.11306]
        },
        properties: {
            STATION_ID: "NEXRAD:KMLB",
            STATION_NAME: "MELBOURNE",
            STATE: "FL"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-78.49, 35.66528]
        },
        properties: {
            STATION_ID: "NEXRAD:KRAX",
            STATION_NAME: "RALEIGH DURHAM",
            STATE: "NC"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-100.49222, 31.37111]
        },
        properties: {
            STATION_ID: "NEXRAD:KSJT",
            STATION_NAME: "SAN ANGELO",
            STATE: "TX"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-83.00194, 30.89]
        },
        properties: {
            STATION_ID: "NEXRAD:KVAX",
            STATION_NAME: "MOODY AFB",
            STATE: "GA"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-147.49917, 65.03556]
        },
        properties: {
            STATION_ID: "NEXRAD:PAPD",
            STATION_NAME: "FAIRBANKS",
            STATE: "AK"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-157.18, 21.13278]
        },
        properties: {
            STATION_ID: "NEXRAD:PHMO",
            STATION_NAME: "MOLOKAI",
            STATE: "HI"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-155.56889, 19.095]
        },
        properties: {
            STATION_ID: "NEXRAD:PHWA",
            STATION_NAME: "SOUTH SHORE",
            STATE: "HI"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-106.82333, 35.14972]
        },
        properties: {
            STATION_ID: "NEXRAD:KABX",
            STATION_NAME: "ALBUQUERQUE",
            STATE: "NM"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-73.16639, 44.51111]
        },
        properties: {
            STATION_ID: "NEXRAD:KCXX",
            STATION_NAME: "BURLINGTON",
            STATE: "VT"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-111.19833, 34.57444]
        },
        properties: {
            STATION_ID: "NEXRAD:KFSX",
            STATION_NAME: "FLAGSTAFF",
            STATE: "AZ"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-104.54528, 39.78667]
        },
        properties: {
            STATION_ID: "NEXRAD:KFTG",
            STATION_NAME: "DENVER FRONT RANGE AP",
            STATE: "CO"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-106.62417, 48.20639]
        },
        properties: {
            STATION_ID: "NEXRAD:KGGW",
            STATION_NAME: "GLASGOW",
            STATE: "MT"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-82.22028, 34.88306]
        },
        properties: {
            STATION_ID: "NEXRAD:KGSP",
            STATION_NAME: "GREER",
            STATE: "SC"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-87.285, 36.73667]
        },
        properties: {
            STATION_ID: "NEXRAD:KHPX",
            STATION_NAME: "FT CAMPBELL",
            STATE: "KY"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-86.28028, 39.7075]
        },
        properties: {
            STATION_ID: "NEXRAD:KIND",
            STATION_NAME: "INDIANAPOLIS",
            STATE: "IN"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-81.70194, 30.48444]
        },
        properties: {
            STATION_ID: "NEXRAD:KJAX",
            STATION_NAME: "JACKSONVILLE",
            STATE: "FL"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-83.35111, 32.675]
        },
        properties: {
            STATION_ID: "NEXRAD:KJGX",
            STATION_NAME: "ROBINS AFB",
            STATE: "GA"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-83.31306, 37.59083]
        },
        properties: {
            STATION_ID: "NEXRAD:KJKL",
            STATION_NAME: "JACKSON",
            STATE: "KY"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-88.08472, 41.60444]
        },
        properties: {
            STATION_ID: "NEXRAD:KLOT",
            STATION_NAME: "CHICAGO",
            STATE: "IL"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-77.47806, 38.97528]
        },
        properties: {
            STATION_ID: "NEXRAD:KLWX",
            STATION_NAME: "STERLING",
            STATE: "VA"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-97.325, 47.52806]
        },
        properties: {
            STATION_ID: "NEXRAD:KMVX",
            STATION_NAME: "GRAND FORKS",
            STATE: "ND"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-72.86444, 40.86556]
        },
        properties: {
            STATION_ID: "NEXRAD:KOKX",
            STATION_NAME: "NEW YORK CITY",
            STATE: "NY"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-93.84111, 32.45056]
        },
        properties: {
            STATION_ID: "NEXRAD:KSHV",
            STATION_NAME: "SHREVEPORT",
            STATE: "LA"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-102.82944, 44.125]
        },
        properties: {
            STATION_ID: "NEXRAD:KUDX",
            STATION_NAME: "RAPID CITY",
            STATE: "SD"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-114.65583, 32.49528]
        },
        properties: {
            STATION_ID: "NEXRAD:KYUX",
            STATION_NAME: "YUMA",
            STATE: "AZ"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-67.80694, 46.03917]
        },
        properties: {
            STATION_ID: "NEXRAD:KCBW",
            STATION_NAME: "HOULTON",
            STATE: "ME"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-71.1375, 41.95583]
        },
        properties: {
            STATION_ID: "NEXRAD:KBOX",
            STATION_NAME: "BOSTON",
            STATE: "MA"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-81.86, 41.41306]
        },
        properties: {
            STATION_ID: "NEXRAD:KCLE",
            STATION_NAME: "CLEVELAND",
            STATE: "OH"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-85.45944, 31.46028]
        },
        properties: {
            STATION_ID: "NEXRAD:KEOX",
            STATION_NAME: "FT RUCKER",
            STATE: "AL"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-85.54472, 42.89389]
        },
        properties: {
            STATION_ID: "NEXRAD:KGRR",
            STATION_NAME: "GRAND RAPIDS",
            STATE: "MI"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-83.82167, 39.42028]
        },
        properties: {
            STATION_ID: "NEXRAD:KILN",
            STATION_NAME: "CINCINNATI",
            STATE: "OH"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-85.7, 41.40861]
        },
        properties: {
            STATION_ID: "NEXRAD:KIWX",
            STATION_NAME: "FT WAYNE",
            STATE: "IN"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-102.18889, 31.94333]
        },
        properties: {
            STATION_ID: "NEXRAD:KMAF",
            STATION_NAME: "MIDLAND ODESSA",
            STATE: "TX"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-113.98611, 47.04111]
        },
        properties: {
            STATION_ID: "NEXRAD:KMSX",
            STATION_NAME: "MISSOULA",
            STATE: "MT"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-112.44694, 41.26278]
        },
        properties: {
            STATION_ID: "NEXRAD:KMTX",
            STATION_NAME: "SALT LAKE CITY",
            STATE: "UT"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-84.32889, 30.3975]
        },
        properties: {
            STATION_ID: "NEXRAD:KTLH",
            STATION_NAME: "TALLAHASSEE",
            STATE: "FL"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-120.39583, 34.83806]
        },
        properties: {
            STATION_ID: "NEXRAD:KVBX",
            STATION_NAME: "VANDENBERG AFB",
            STATE: "CA"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-161.87417, 60.79278]
        },
        properties: {
            STATION_ID: "NEXRAD:PABC",
            STATION_NAME: "BETHEL FAA",
            STATE: "AK"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [144.80833, 13.45444]
        },
        properties: {
            STATION_ID: "NEXRAD:PGUA",
            STATION_NAME: "ANDERSEN AFB AGANA",
            STATE: "GU"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-80.27417, 37.02417]
        },
        properties: {
            STATION_ID: "NEXRAD:KFCX",
            STATION_NAME: "ROANOKE",
            STATE: "VA"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-95.07889, 29.47194]
        },
        properties: {
            STATION_ID: "NEXRAD:KHGX",
            STATION_NAME: "HOUSTON",
            STATE: "TX"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-89.33667, 40.15056]
        },
        properties: {
            STATION_ID: "NEXRAD:KILX",
            STATION_NAME: "LINCOLN",
            STATE: "IL"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-89.82528, 30.33667]
        },
        properties: {
            STATION_ID: "NEXRAD:KLIX",
            STATION_NAME: "NEW ORLEANS",
            STATE: "LA"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-78.42917, 33.98917]
        },
        properties: {
            STATION_ID: "NEXRAD:KLTX",
            STATION_NAME: "WILMINGTON",
            STATE: "NC"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-87.54833, 46.53111]
        },
        properties: {
            STATION_ID: "NEXRAD:KMQT",
            STATION_NAME: "MARQUETTE",
            STATE: "MI"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-121.8975, 37.15528]
        },
        properties: {
            STATION_ID: "NEXRAD:KMUX",
            STATION_NAME: "SAN FRANCISCO",
            STATE: "CA"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-85.78972, 32.53667]
        },
        properties: {
            STATION_ID: "NEXRAD:KMXX",
            STATION_NAME: "MAXWELL AFB",
            STATE: "AL"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-118.85278, 45.69056]
        },
        properties: {
            STATION_ID: "NEXRAD:KPDT",
            STATION_NAME: "PENDLETON",
            STATE: "OR"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-92.97583, 31.15528]
        },
        properties: {
            STATION_ID: "NEXRAD:KPOE",
            STATION_NAME: "FT POLK",
            STATE: "LA"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-117.635, 33.81778]
        },
        properties: {
            STATION_ID: "NEXRAD:KSOX",
            STATION_NAME: "SANTA ANA MOUNTAINS",
            STATE: "CA"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-119.17861, 34.41167]
        },
        properties: {
            STATION_ID: "NEXRAD:KVTX",
            STATION_NAME: "LOS ANGELES",
            STATE: "CA"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-146.30111, 59.46194]
        },
        properties: {
            STATION_ID: "NEXRAD:PAIH",
            STATION_NAME: "MIDDLETON ISLAND",
            STATE: "AK"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-78.00389, 40.92306]
        },
        properties: {
            STATION_ID: "NEXRAD:KCCX",
            STATION_NAME: "STATE COLLEGE",
            STATE: "PA"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-121.63167, 39.49611]
        },
        properties: {
            STATION_ID: "NEXRAD:KBBX",
            STATION_NAME: "BEALE AFB",
            STATE: "CA"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-75.985, 42.19972]
        },
        properties: {
            STATION_ID: "NEXRAD:KBGM",
            STATION_NAME: "BINGHAMTON",
            STATE: "NY"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-124.29194, 40.49833]
        },
        properties: {
            STATION_ID: "NEXRAD:KBHX",
            STATION_NAME: "EUREKA",
            STATE: "CA"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-97.51083, 27.78389]
        },
        properties: {
            STATION_ID: "NEXRAD:KCRP",
            STATION_NAME: "CORPUS CHRISTI",
            STATE: "TX"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-121.67667, 38.50111]
        },
        properties: {
            STATION_ID: "NEXRAD:KDAX",
            STATION_NAME: "SACRAMENTO",
            STATE: "CA"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-93.72278, 41.73111]
        },
        properties: {
            STATION_ID: "NEXRAD:KDMX",
            STATION_NAME: "DES MOINES",
            STATE: "IA"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-94.26417, 38.81028]
        },
        properties: {
            STATION_ID: "NEXRAD:KEAX",
            STATION_NAME: "KANSAS CITY",
            STATE: "MO"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-85.92139, 30.56417]
        },
        properties: {
            STATION_ID: "NEXRAD:KEVX",
            STATION_NAME: "EGLIN AFB",
            STATE: "FL"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-98.02806, 29.70361]
        },
        properties: {
            STATION_ID: "NEXRAD:KEWX",
            STATION_NAME: "AUSTIN SAN ANTONIO",
            STATE: "TX"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-84.71972, 44.90722]
        },
        properties: {
            STATION_ID: "NEXRAD:KAPX",
            STATION_NAME: "GAYLORD",
            STATE: "MI"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-97.41861, 25.91556]
        },
        properties: {
            STATION_ID: "NEXRAD:KBRO",
            STATION_NAME: "BROWNSVILLE",
            STATE: "TX"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-81.04222, 32.65556]
        },
        properties: {
            STATION_ID: "NEXRAD:KCLX",
            STATION_NAME: "CHARLESTON",
            STATE: "SC"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-99.96833, 37.76083]
        },
        properties: {
            STATION_ID: "NEXRAD:KDDC",
            STATION_NAME: "DODGE CITY",
            STATE: "KS"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-90.58083, 41.61167]
        },
        properties: {
            STATION_ID: "NEXRAD:KDVN",
            STATION_NAME: "DAVENPORT",
            STATE: "IA"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-97.30278, 32.57278]
        },
        properties: {
            STATION_ID: "NEXRAD:KFWS",
            STATION_NAME: "DALLAS",
            STATE: "TX"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-97.38278, 30.72167]
        },
        properties: {
            STATION_ID: "NEXRAD:KGRK",
            STATION_NAME: "FT HOOD",
            STATE: "TX"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-70.25694, 43.89139]
        },
        properties: {
            STATION_ID: "NEXRAD:KGYX",
            STATION_NAME: "PORTLAND",
            STATE: "ME"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-111.66917, 33.28917]
        },
        properties: {
            STATION_ID: "NEXRAD:KIWA",
            STATION_NAME: "PHOENIX",
            STATE: "AZ"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-85.94389, 37.97528]
        },
        properties: {
            STATION_ID: "NEXRAD:KLVX",
            STATION_NAME: "LOUISVILLE",
            STATE: "KY"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-77.48751, 38.97628]
        },
        properties: {
            STATION_ID: "NEXRAD:KLWX",
            STATION_NAME: "STERLING",
            STATE: "VA"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-122.71611, 42.08111]
        },
        properties: {
            STATION_ID: "NEXRAD:KMAX",
            STATION_NAME: "MEDFORD",
            STATE: "OR"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-76.87639, 34.77583]
        },
        properties: {
            STATION_ID: "NEXRAD:KMHX",
            STATION_NAME: "MOREHEAD CITY",
            STATE: "NC"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-88.23972, 30.67944]
        },
        properties: {
            STATION_ID: "NEXRAD:KMOB",
            STATION_NAME: "MOBILE",
            STATE: "AL"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-93.56528, 44.84889]
        },
        properties: {
            STATION_ID: "NEXRAD:KMPX",
            STATION_NAME: "MINNEAPOLIS",
            STATE: "MN"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-86.5625, 36.24722]
        },
        properties: {
            STATION_ID: "NEXRAD:KOHX",
            STATION_NAME: "NASHVILLE",
            STATE: "TN"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-80.21833, 40.53167]
        },
        properties: {
            STATION_ID: "NEXRAD:KPBZ",
            STATION_NAME: "PITTSBURGH",
            STATE: "PA"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-93.40028, 37.23528]
        },
        properties: {
            STATION_ID: "NEXRAD:KSGF",
            STATION_NAME: "SPRINGFIELD",
            STATE: "MO"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-97.2775, 35.33306]
        },
        properties: {
            STATION_ID: "NEXRAD:KTLX",
            STATION_NAME: "OKLAHOMA CITY",
            STATE: "OK"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-151.351467, 60.725914]
        },
        properties: {
            STATION_ID: "NEXRAD:PAHG",
            STATION_NAME: "ANCHORAGE",
            STATE: "AK"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-77.0075, 36.98389]
        },
        properties: {
            STATION_ID: "NEXRAD:KAKQ",
            STATION_NAME: "NORFOLK RICH",
            STATE: "VA"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-101.70889, 35.23333]
        },
        properties: {
            STATION_ID: "NEXRAD:KAMA",
            STATION_NAME: "AMARILLO",
            STATE: "TX"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-80.41306, 25.61056]
        },
        properties: {
            STATION_ID: "NEXRAD:KAMX",
            STATION_NAME: "MIAMI",
            STATE: "FL"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-100.76028, 46.77083]
        },
        properties: {
            STATION_ID: "NEXRAD:KBIS",
            STATION_NAME: "BISMARCK",
            STATE: "ND"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-89.98444, 32.28]
        },
        properties: {
            STATION_ID: "NEXRAD:KDGX",
            STATION_NAME: "JACKSON BRANDON",
            STATE: "MS"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-74.06444, 42.58639]
        },
        properties: {
            STATION_ID: "NEXRAD:KENX",
            STATION_NAME: "ALBANY",
            STATE: "NY"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-103.62944, 34.63528]
        },
        properties: {
            STATION_ID: "NEXRAD:KFDX",
            STATION_NAME: "CANNON AFB",
            STATE: "NM"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-84.56583, 33.36333]
        },
        properties: {
            STATION_ID: "NEXRAD:KFFC",
            STATION_NAME: "ATLANTA",
            STATE: "GA"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-95.56444, 36.175]
        },
        properties: {
            STATION_ID: "NEXRAD:KINX",
            STATION_NAME: "TULSA",
            STATE: "OK"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-92.26194, 34.83639]
        },
        properties: {
            STATION_ID: "NEXRAD:KLZK",
            STATION_NAME: "LITTLE ROCK",
            STATE: "AR"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-100.86444, 48.3925]
        },
        properties: {
            STATION_ID: "NEXRAD:KMBX",
            STATION_NAME: "MINOT AFB",
            STATE: "ND"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-83.40194, 36.16833]
        },
        properties: {
            STATION_ID: "NEXRAD:KMRX",
            STATION_NAME: "KNOXVILLE",
            STATE: "TN"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-117.62583, 47.68056]
        },
        properties: {
            STATION_ID: "NEXRAD:KOTX",
            STATION_NAME: "SPOKANE",
            STATE: "WA"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-119.46111, 39.75417]
        },
        properties: {
            STATION_ID: "NEXRAD:KRGX",
            STATION_NAME: "RENO",
            STATE: "NV"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-108.47667, 43.06611]
        },
        properties: {
            STATION_ID: "NEXRAD:KRIW",
            STATION_NAME: "RIVERTON",
            STATE: "WY"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-98.44167, 40.32083]
        },
        properties: {
            STATION_ID: "NEXRAD:KUEX",
            STATION_NAME: "HASTINGS",
            STATE: "NE"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-135.52917, 56.85278]
        },
        properties: {
            STATION_ID: "NEXRAD:PACG",
            STATION_NAME: "SITKA",
            STATE: "AK"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-96.72889, 43.58778]
        },
        properties: {
            STATION_ID: "NEXRAD:KFSD",
            STATION_NAME: "SIOUX FALLS",
            STATE: "SD"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-94.36167, 35.29056]
        },
        properties: {
            STATION_ID: "NEXRAD:KSRX",
            STATION_NAME: "FT SMITH",
            STATE: "AR"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-108.21306, 39.06222]
        },
        properties: {
            STATION_ID: "NEXRAD:KGJX",
            STATION_NAME: "GRAND JUNCTION",
            STATE: "CO"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-93.21583, 30.125]
        },
        properties: {
            STATION_ID: "NEXRAD:KLCH",
            STATION_NAME: "LAKE CHARLES",
            STATE: "LA"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-156.62944, 58.67944]
        },
        properties: {
            STATION_ID: "NEXRAD:PAKC",
            STATION_NAME: "KING SALMON",
            STATE: "AK"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-81.11861, 33.94861]
        },
        properties: {
            STATION_ID: "NEXRAD:KCAE",
            STATION_NAME: "COLUMBIA",
            STATE: "SC"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-100.28028, 29.2725]
        },
        properties: {
            STATION_ID: "NEXRAD:KDFX",
            STATION_NAME: "LAUGHLIN AFB",
            STATE: "TX"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-88.32889, 33.89667]
        },
        properties: {
            STATION_ID: "NEXRAD:KGWX",
            STATION_NAME: "COLUMBUS AFB",
            STATE: "MS"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-117.56, 35.09778]
        },
        properties: {
            STATION_ID: "NEXRAD:KEYX",
            STATION_NAME: "EDWARDS",
            STATE: "CA"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-106.6975, 31.87306]
        },
        properties: {
            STATION_ID: "NEXRAD:KEPZ",
            STATION_NAME: "EL PASO",
            STATE: "NM"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-116.80278, 40.73972]
        },
        properties: {
            STATION_ID: "NEXRAD:KLRX",
            STATION_NAME: "ELKO",
            STATE: "NV"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-81.72389, 38.31194]
        },
        properties: {
            STATION_ID: "NEXRAD:KRLX",
            STATION_NAME: "CHARLESTON",
            STATE: "WV"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-106.12222, 33.07639]
        },
        properties: {
            STATION_ID: "NEXRAD:KHDX",
            STATION_NAME: "HOLLOMAN AFB",
            STATE: "NM"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-112.86222, 37.59083]
        },
        properties: {
            STATION_ID: "NEXRAD:KICX",
            STATION_NAME: "CEDAR CITY",
            STATE: "UT"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-80.65444, 28.11306]
        },
        properties: {
            STATION_ID: "NEXRAD:KMLB",
            STATION_NAME: "MELBOURNE",
            STATE: "FL"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-117.04194, 32.91889]
        },
        properties: {
            STATION_ID: "NEXRAD:KNKX",
            STATION_NAME: "SAN DIEGO",
            STATE: "CA"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-165.295, 64.51139]
        },
        properties: {
            STATION_ID: "NEXRAD:PAEC",
            STATION_NAME: "NOME",
            STATE: "AK"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-99.25417, 32.53833]
        },
        properties: {
            STATION_ID: "NEXRAD:KDYX",
            STATION_NAME: "DYESS AFB",
            STATE: "TX"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-86.08361, 34.93056]
        },
        properties: {
            STATION_ID: "NEXRAD:KHTX",
            STATION_NAME: "HUNTSVILLE",
            STATE: "AL"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-96.36639, 41.32028]
        },
        properties: {
            STATION_ID: "NEXRAD:KOAX",
            STATION_NAME: "OMAHA",
            STATE: "NE"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-82.40194, 27.70528]
        },
        properties: {
            STATION_ID: "NEXRAD:KTBW",
            STATION_NAME: "TAMPA",
            STATE: "FL"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-75.68, 43.75583]
        },
        properties: {
            STATION_ID: "NEXRAD:KTYX",
            STATION_NAME: "FT DRUM",
            STATE: "NY"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-76.845, 38.695]
        },
        properties: {
            STATION_ID: "NEXRAD:TADW",
            STATION_NAME: "ANDREWS AFB",
            STATE: "MD"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-84.261944, 33.646944]
        },
        properties: {
            STATION_ID: "NEXRAD:TATL",
            STATION_NAME: "ATLANTA",
            STATE: "GA"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-86.661944, 35.98]
        },
        properties: {
            STATION_ID: "NEXRAD:TBNA",
            STATION_NAME: "NASHVILLE",
            STATE: "TN"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-70.933056, 42.158056]
        },
        properties: {
            STATION_ID: "NEXRAD:TBOS",
            STATION_NAME: "BOSTON",
            STATE: "MA"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-76.63, 39.09]
        },
        properties: {
            STATION_ID: "NEXRAD:TBWI",
            STATION_NAME: "BALTIMORE WASHINGTON",
            STATE: "MD"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-80.885, 35.336944]
        },
        properties: {
            STATION_ID: "NEXRAD:TCLT",
            STATION_NAME: "CHARLOTTE",
            STATE: "NC"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-82.715, 40.006111]
        },
        properties: {
            STATION_ID: "NEXRAD:TCMH",
            STATION_NAME: "COLUMBUS",
            STATE: "OH"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-84.58, 38.898056]
        },
        properties: {
            STATION_ID: "NEXRAD:TCVG",
            STATION_NAME: "COVINGTON",
            STATE: "KY"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-96.968056, 32.926111]
        },
        properties: {
            STATION_ID: "NEXRAD:TDAL",
            STATION_NAME: "DALLAS LOVE FLD",
            STATE: "TX"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-84.123056, 40.021944]
        },
        properties: {
            STATION_ID: "NEXRAD:TDAY",
            STATION_NAME: "DAYTON",
            STATE: "OH"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-76.961944, 38.758889]
        },
        properties: {
            STATION_ID: "NEXRAD:TDCA",
            STATION_NAME: "WASHINGTON NATL",
            STATE: "MD"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-104.526111, 39.728056]
        },
        properties: {
            STATION_ID: "NEXRAD:TDEN",
            STATION_NAME: "DENVER",
            STATE: "CO"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-96.918056, 33.065]
        },
        properties: {
            STATION_ID: "NEXRAD:TDFW",
            STATION_NAME: "DALLAS FT WORTH",
            STATE: "TX"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-83.515, 42.111111]
        },
        properties: {
            STATION_ID: "NEXRAD:TDTW",
            STATION_NAME: "DETROIT",
            STATE: "MI"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-74.27, 40.593056]
        },
        properties: {
            STATION_ID: "NEXRAD:TEWR",
            STATION_NAME: "NEWARK",
            STATE: "NJ"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-80.343889, 26.143056]
        },
        properties: {
            STATION_ID: "NEXRAD:TFLL",
            STATION_NAME: "FT LAUDERDALE",
            STATE: "FL"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-95.241944, 29.516111]
        },
        properties: {
            STATION_ID: "NEXRAD:THOU",
            STATION_NAME: "HOUSTON HOBBY",
            STATE: "TX"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-77.528889, 39.083889]
        },
        properties: {
            STATION_ID: "NEXRAD:TIAD",
            STATION_NAME: "WASHINGTON DULLES",
            STATE: "VA"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-95.566944, 30.065]
        },
        properties: {
            STATION_ID: "NEXRAD:TIAH",
            STATION_NAME: "HOUSTON INTL",
            STATE: "TX"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-97.436944, 37.506944]
        },
        properties: {
            STATION_ID: "NEXRAD:TICH",
            STATION_NAME: "WICHITA",
            STATE: "KS"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-86.436111, 39.636944]
        },
        properties: {
            STATION_ID: "NEXRAD:TIDS",
            STATION_NAME: "INDIANAPOLIS",
            STATE: "IN"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-73.881111, 40.588889]
        },
        properties: {
            STATION_ID: "NEXRAD:TJFK",
            STATION_NAME: "NYC JFK",
            STATE: "NY"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-66.07861, 18.1175]
        },
        properties: {
            STATION_ID: "NEXRAD:TJUA",
            STATION_NAME: "SAN JUAN",
            STATE: "PR"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-115.006944, 36.143889]
        },
        properties: {
            STATION_ID: "NEXRAD:TLAS",
            STATION_NAME: "LAS VEGAS",
            STATE: "NV"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-82.008056, 41.29]
        },
        properties: {
            STATION_ID: "NEXRAD:TLVE",
            STATION_NAME: "CLEVELAND",
            STATE: "OH"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-94.741944, 39.498056]
        },
        properties: {
            STATION_ID: "NEXRAD:TMCI",
            STATION_NAME: "KANSAS CITY",
            STATE: "MO"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-81.326111, 28.343889]
        },
        properties: {
            STATION_ID: "NEXRAD:TMCO",
            STATION_NAME: "ORLANDO INTL",
            STATE: "FL"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-87.713333, 41.651111]
        },
        properties: {
            STATION_ID: "NEXRAD:TMDW",
            STATION_NAME: "CHICAGO MIDWAY",
            STATE: "IL"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-89.993056, 34.896111]
        },
        properties: {
            STATION_ID: "NEXRAD:TMEM",
            STATION_NAME: "MEMPHIS",
            STATE: "MS"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-80.491111, 25.758056]
        },
        properties: {
            STATION_ID: "NEXRAD:TMIA",
            STATION_NAME: "MIAMI",
            STATE: "FL"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-88.046111, 42.818889]
        },
        properties: {
            STATION_ID: "NEXRAD:TMKE",
            STATION_NAME: "MILWAUKEE",
            STATE: "WI"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-92.933056, 44.871111]
        },
        properties: {
            STATION_ID: "NEXRAD:TMSP",
            STATION_NAME: "MINNEAPOLIS",
            STATE: "MN"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-90.403056, 30.021944]
        },
        properties: {
            STATION_ID: "NEXRAD:TMSY",
            STATION_NAME: "NEW ORLEANS",
            STATE: "LA"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-97.51, 35.276111]
        },
        properties: {
            STATION_ID: "NEXRAD:TOKC",
            STATION_NAME: "NORMAN WFO",
            STATE: "OK"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-87.858056, 41.796944]
        },
        properties: {
            STATION_ID: "NEXRAD:TORD",
            STATION_NAME: "CHICAGO OHARE",
            STATE: "IL"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-80.273056, 26.688056]
        },
        properties: {
            STATION_ID: "NEXRAD:TPBI",
            STATION_NAME: "W PALM BEACH",
            STATE: "FL"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-75.068889, 39.948889]
        },
        properties: {
            STATION_ID: "NEXRAD:TPHL",
            STATION_NAME: "PHILA",
            STATE: "NJ"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-112.163056, 33.421111]
        },
        properties: {
            STATION_ID: "NEXRAD:TPHX",
            STATION_NAME: "PHOENIX",
            STATE: "AZ"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-80.486111, 40.501111]
        },
        properties: {
            STATION_ID: "NEXRAD:TPIT",
            STATION_NAME: "PITTSBURGH",
            STATE: "PA"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-78.696944, 36.001944]
        },
        properties: {
            STATION_ID: "NEXRAD:TRDU",
            STATION_NAME: "RALEIGH",
            STATE: "NC"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-85.61, 38.046111]
        },
        properties: {
            STATION_ID: "NEXRAD:TSDF",
            STATION_NAME: "LOUISVILLE",
            STATE: "KY"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-66.178889, 18.473889]
        },
        properties: {
            STATION_ID: "NEXRAD:TSJU",
            STATION_NAME: "SAN JUAN",
            STATE: "PR"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-111.93, 40.966944]
        },
        properties: {
            STATION_ID: "NEXRAD:TSLC",
            STATION_NAME: "SALT LAKE CITY",
            STATE: "UT"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-90.488889, 38.805]
        },
        properties: {
            STATION_ID: "NEXRAD:TSTL",
            STATION_NAME: "ST LOUIS",
            STATE: "MO"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-82.518056, 27.86]
        },
        properties: {
            STATION_ID: "NEXRAD:TTPA",
            STATION_NAME: "TAMPA",
            STATE: "FL"
        }
    }, {
        type: "Feature",
        geometry: {
            type: "Point",
            coordinates: [-95.826944, 36.071111]
        },
        properties: {
            STATION_ID: "NEXRAD:TTUL",
            STATION_NAME: "TULSA",
            STATE: "OK"
        }
    }]
};
var {DEALIASED: Ez} = da
  , {READING: Sz} = Yr
  , {ELEVATION: Az} = pd
  , {HISTORICAL: Mz} = Gs
  , Yi = yi({})
  , Ja = yi({})
  , Xa = yi(!1)
  , by = yi(!1)
  , Qr = yi(!1)
  , md = yi(!0)
  , _o = yi(!1)
  , Ql = yi(!1)
  , ec = yi(!1)
  , Ru = yi(!1)
  , Pu = yi(!1)
  , Sd = yi(!1)
  , ku = yi({
    value: "monochrome",
    styleid: "mapbox://styles/quadweather/cksxhy0l281db18nvnnfvdigv",
    layer: "land-structure-line"
})
  , lm = yi({
    opacity: 1
})
  , Jr = yi(Y_)
  , wy = yi("closed")
  , Za = yi(Ez)
  , zr = yi(Sz)
  , cm = yi(Az)
  , js = yi(Mz)
  , Ws = yi(null)
  , ai = yi(Array.apply(null, Array(5)).map(function() {}))
  , $r = dS(ai, r=>{
    let e = {
        fileNames: [],
        elevations: [],
        stations: [],
        scans: []
    }
      , t = r;
    e.fileNames = [],
    e.stations = [],
    e.scans = {},
    e.elevations = {};
    let o = {}
      , c = {};
    for (let d = 0; d < t.length; d++)
        t[d] != null && t[d].idxs && (e.fileNames.push(t[d].fileName),
        e.stations.indexOf(t[d].station) < 0 && e.stations.push(t[d].station),
        t[d].station in o ? o[t[d].station] = o[t[d].station].concat(Object.keys(t[d].idxs)) : o[t[d].station] = Object.keys(t[d].idxs),
        t[d].station in c ? c[t[d].station] = c[t[d].station].concat(t[d].scans) : c[t[d].station] = t[d].scans);
    for (let d = 0; d < e.stations.length; d++) {
        let p = e.stations[d];
        e.elevations[p] = [],
        e.scans[p] = {},
        e.elevations[p] = Array.from(new Set(o[p])).sort(function(v, x) {
            return +v - +x
        });
        let i = c[p];
        for (let v = 0; v < e.elevations[p].length; v++)
            e.scans[p][e.elevations[p][v]] = [];
        for (let v = 0; v < i.length; v++)
            e.scans[p][i[v][0][0].rounded].push(...i[v]);
        for (let v in e.scans[p])
            e.scans[p][v] = e.scans[p][v].sort(function(x, E) {
                return x[0].date - E[0].date
            })
    }
    return e
}
)
  , Ms = yi(Array.apply(null, Array(5)).map(function() {}))
  , bs = yi(Array.apply(null, Array(5)).map(function() {}))
  , Hs = yi({})
  , AG = yi(null)
  , zu = yi(null)
  , Ou = yi(null)
  , ui = yi([{
    elevation: null,
    file: null,
    type: null,
    dealiased: null,
    scan: null
}, {
    elevation: null,
    file: null,
    type: null,
    dealiased: null,
    scan: null
}])
  , ws = yi(Array.apply(null, Array(2)))
  , ji = mS()
  , Tu = gS()
  , Nr = xS()
  , es = oM()
  , Is = K_(null, r=>{
    let e = fS();
    return e.setOnMessage(ai, bs, Hs, ui, Ms, $r, Yi, by, ji, Tu),
    r(e.worker),
    function() {
        console.log("stopping")
    }
}
)
  , MG = yi(null, r=>{
    r(VA())
}
)
  , Vp = yi({
    type: "FeatureCollection",
    features: []
})
  , Gp = yi({
    type: "FeatureCollection",
    features: []
})
  , lM = K_(aM);
function cM(r) {
    let e, t, o, c = Math.min(r[1] + 1, r[0]) + "", d, p, i, v, x;
    return {
        c() {
            e = qe("div"),
            t = qe("div"),
            o = Un("Reading "),
            d = Un(c),
            p = Un(" of "),
            i = Un(r[0]),
            v = It(),
            x = qe("div"),
            je(t, "class", "of svelte-18cfpa4"),
            je(x, "class", "lds-dual-ring svelte-18cfpa4"),
            je(e, "class", "loadingWrapper svelte-18cfpa4")
        },
        m(E, A) {
            yn(E, e, A),
            Se(e, t),
            Se(t, o),
            Se(t, d),
            Se(t, p),
            Se(t, i),
            Se(e, v),
            Se(e, x)
        },
        p(E, A) {
            A & 3 && c !== (c = Math.min(E[1] + 1, E[0]) + "") && gi(d, c),
            A & 1 && gi(i, E[0])
        },
        d(E) {
            E && mn(e)
        }
    }
}
function Cz(r) {
    let e, t, o, c, d, p, i, v, x, E, A = r[0] && cM(r);
    return {
        c() {
            e = qe("div"),
            t = qe("div"),
            o = qe("input"),
            c = It(),
            d = qe("label"),
            p = qe("input"),
            i = Un(`
            Add Level II files`),
            v = It(),
            A && A.c(),
            je(o, "type", "file"),
            je(o, "id", "input"),
            o.multiple = !0,
            je(o, "class", "svelte-18cfpa4"),
            je(p, "type", "file"),
            p.multiple = !0,
            je(p, "class", "svelte-18cfpa4"),
            je(d, "class", "custom-file-upload svelte-18cfpa4"),
            je(t, "class", "dragover svelte-18cfpa4"),
            Gn(t, "active", r[2]),
            je(e, "class", "dragoverContainer svelte-18cfpa4")
        },
        m(C, I) {
            yn(C, e, I),
            Se(e, t),
            Se(t, o),
            Se(t, c),
            Se(t, d),
            Se(d, p),
            r[10](p),
            Se(d, i),
            r[11](d),
            Se(e, v),
            A && A.m(e, null),
            x || (E = [wn(p, "change", r[8]), wn(t, "dragenter", r[5]), wn(t, "dragover", Iz), wn(t, "dragleave", r[6]), wn(t, "drop", r[7])],
            x = !0)
        },
        p(C, [I]) {
            I & 4 && Gn(t, "active", C[2]),
            C[0] ? A ? A.p(C, I) : (A = cM(C),
            A.c(),
            A.m(e, null)) : A && (A.d(1),
            A = null)
        },
        i: Hn,
        o: Hn,
        d(C) {
            C && mn(e),
            r[10](null),
            r[11](null),
            A && A.d(),
            x = !1,
            Wi(E)
        }
    }
}
function Iz(r) {
    r.preventDefault()
}
function Dz(r, e, t) {
    let o, c, d, p, i;
    Ht(r, ai, oe=>t(9, o = oe)),
    Ht(r, $r, oe=>t(13, c = oe)),
    Ht(r, ui, oe=>t(14, d = oe)),
    Ht(r, Yi, oe=>t(15, p = oe)),
    Ht(r, Is, oe=>t(16, i = oe));
    let v = go(), x = new J_([],function(oe, ee) {
        return ee.time - oe.time
    }
    ), E = 0, A = 0, C = !1, I, D, P;
    function k() {
        for (; x.length; ) {
            let oe = new FileReader
              , ee = x.pop();
            oe.onload = function(j) {
                let ne = j.target.result
                  , be = new Uint8Array(ne);
                try {
                    be = fy(be)
                } catch (ae) {}
                let te = "";
                for (let ae = 0; ae < 6; ae++)
                    te = te + String.fromCharCode(be[ae]);
                if (te != "AR2V00" && te != "ARCHIV") {
                    t(0, E -= 1),
                    te === "ARCHIV" ? bn(Yi, p = {
                        error: !0,
                        message: "The application cannot yet read files in an old format like " + ee.name + ".",
                        header: "Old format"
                    }, p) : bn(Yi, p = {
                        error: !0,
                        message: "The file " + ee.name + " could not be read due to an unexpected format.",
                        header: "Unexpected format"
                    }, p);
                    return
                }
                i.postMessage({
                    message: "initialize",
                    fileName: ee.name,
                    buffer: be.buffer
                }, [be.buffer])
            }
            ,
            oe.readAsArrayBuffer(ee)
        }
    }
    function U(oe) {
        oe.preventDefault(),
        t(2, C = !0),
        t(3, D.style.pointerEvents = "none", D)
    }
    function Z(oe) {
        oe.preventDefault(),
        t(2, C = !1),
        t(3, D.style.pointerEvents = "", D)
    }
    function K(oe) {
        let ee = 0;
        for (let be = 0; be < o.length; be++)
            o[be] && ee++;
        let j = o.filter(be=>be != null).map(be=>be.fileName)
          , ne = [];
        for (let be = 0; be < oe.length; be++) {
            let te = oe[be];
            if (j.indexOf(te.name) >= 0) {
                bn(Yi, p = {
                    error: !0,
                    message: "A file already exists with the name " + te.name,
                    header: "Duplicate file"
                }, p),
                t(4, P.value = null, P);
                return
            }
            ne.push(te)
        }
        if (E + oe.length > 5 || oe.length + ee > 5) {
            bn(Yi, p = {
                error: !0,
                message: "The application cannot load more than 5 files. Remove a file by clicking the trashcan icon in the File View before loading another.",
                header: "Too many files"
            }, p),
            t(4, P.value = null, P);
            return
        }
        for (let be = 0; be < ne.length; be++)
            x.push(ne[be]);
        t(0, E = E + ne.length),
        k(),
        t(4, P.value = null, P)
    }
    function X(oe) {
        if (t(3, D.style.pointerEvents = "", D),
        oe.preventDefault(),
        t(2, C = !1),
        oe.dataTransfer.items) {
            let ee = [];
            for (let j = 0; j < oe.dataTransfer.items.length; j++)
                if (oe.dataTransfer.items[j].kind === "file") {
                    let ne = oe.dataTransfer.items[j].getAsFile();
                    ne.time = Date.now(),
                    ee.push(ne)
                }
            K(ee)
        }
    }
    function W() {
        if (!!E) {
            if (o.finished === 1 && (I = 1,
            t(1, A += 1)),
            A === E) {
                if (I = -1,
                t(1, A = 0),
                t(0, E = 0),
                !d[0].scan) {
                    let oe = {
                        elevation: c.elevations[c.stations[0]][0],
                        station: c.stations[0]
                    }
                      , ee = c.scans[oe.station][oe.elevation]
                      , j = {
                        fileNumber: ee[0][0].fileNumber,
                        scan: ee[0],
                        fileName: ee[0][0].fileName,
                        station: oe.station
                    };
                    v.logStore(j),
                    Nr.setStates(),
                    Nr.setSites()
                }
            } else if (o[o.loading]) {
                let oe = o.loading
                  , ee = o[oe].percent;
                ee != null && (I = ee)
            }
        }
    }
    function fe() {
        let oe = this.files
          , ee = [];
        for (let j = 0, ne = oe.length; j < ne; j++) {
            let be = oe[j];
            be.time = Date.now(),
            ee.push(be)
        }
        K(ee)
    }
    function ce(oe) {
        Bi[oe ? "unshift" : "push"](()=>{
            P = oe,
            t(4, P)
        }
        )
    }
    function _e(oe) {
        Bi[oe ? "unshift" : "push"](()=>{
            D = oe,
            t(3, D)
        }
        )
    }
    return r.$$.update = ()=>{
        if (r.$$.dirty & 512) {
            e: W()
        }
    }
    ,
    [E, A, C, D, P, U, Z, X, fe, o, ce, _e]
}
var uM = class extends mi {
    constructor(e) {
        super();
        _i(this, e, Dz, Cz, di, {})
    }
}
  , hM = uM;
var Ty = "139"
  , tc = {
    LEFT: 0,
    MIDDLE: 1,
    RIGHT: 2,
    ROTATE: 0,
    DOLLY: 1,
    PAN: 2
}
  , nc = {
    ROTATE: 0,
    PAN: 1,
    DOLLY_PAN: 2,
    DOLLY_ROTATE: 3
}
  , dM = 0
  , i1 = 1
  , fM = 2;
var r1 = 1
  , pM = 2
  , Ad = 3
  , Md = 0
  , Zs = 1
  , $a = 2
  , s1 = 1;
var Qa = 0
  , Nu = 1
  , o1 = 2
  , a1 = 3
  , l1 = 4
  , mM = 5
  , Fu = 100
  , gM = 101
  , _M = 102
  , c1 = 103
  , u1 = 104
  , yM = 200
  , xM = 201
  , vM = 202
  , bM = 203
  , h1 = 204
  , d1 = 205
  , wM = 206
  , TM = 207
  , EM = 208
  , SM = 209
  , AM = 210
  , MM = 0
  , IM = 1
  , CM = 2
  , Ey = 3
  , DM = 4
  , LM = 5
  , RM = 6
  , PM = 7
  , um = 0
  , kM = 1
  , zM = 2
  , _a = 0
  , OM = 1
  , NM = 2
  , FM = 3
  , BM = 4
  , UM = 5
  , f1 = 300
  , Bu = 301
  , Uu = 302
  , Sy = 303
  , Ay = 304
  , hm = 306
  , Vu = 1e3
  , vo = 1001
  , My = 1002
  , Di = 1003
  , p1 = 1004;
var m1 = 1005;
var ns = 1006
  , VM = 1007;
var dm = 1008;
var ic = 1009
  , GM = 1010
  , HM = 1011
  , Id = 1012
  , WM = 1013
  , fm = 1014
  , rc = 1015
  , Gu = 1016
  , jM = 1017
  , XM = 1018
  , Hu = 1020
  , ZM = 1021
  , qM = 1022
  , is = 1023
  , KM = 1024
  , YM = 1025
  , sc = 1026
  , Wu = 1027
  , pm = 1028
  , JM = 1029
  , $M = 1030
  , QM = 1031
  , e2 = 1033
  , Iy = 33776
  , Cy = 33777
  , Dy = 33778
  , Ly = 33779
  , g1 = 35840
  , _1 = 35841
  , y1 = 35842
  , x1 = 35843
  , t2 = 36196
  , v1 = 37492
  , b1 = 37496
  , w1 = 37808
  , T1 = 37809
  , E1 = 37810
  , S1 = 37811
  , A1 = 37812
  , M1 = 37813
  , I1 = 37814
  , C1 = 37815
  , D1 = 37816
  , L1 = 37817
  , R1 = 37818
  , P1 = 37819
  , k1 = 37820
  , z1 = 37821
  , O1 = 36492
  , n2 = 2200
  , i2 = 2201
  , r2 = 2202
  , mm = 2300
  , gm = 2301
  , Ry = 2302
  , ju = 2400
  , Xu = 2401
  , _m = 2402
  , Py = 2500
  , N1 = 2501
  , s2 = 0;
var ya = 3e3
  , er = 3001
  , o2 = 3200
  , a2 = 3201
  , Zu = 0
  , l2 = 1;
var xa = "srgb"
  , oc = "srgb-linear";
var ky = 7680;
var c2 = 519
  , Cd = 35044
  , ym = 35048;
var Dd = "300 es"
  , zy = 1035
  , Bo = class {
    addEventListener(e, t) {
        this._listeners === void 0 && (this._listeners = {});
        let o = this._listeners;
        o[e] === void 0 && (o[e] = []),
        o[e].indexOf(t) === -1 && o[e].push(t)
    }
    hasEventListener(e, t) {
        if (this._listeners === void 0)
            return !1;
        let o = this._listeners;
        return o[e] !== void 0 && o[e].indexOf(t) !== -1
    }
    removeEventListener(e, t) {
        if (this._listeners === void 0)
            return;
        let c = this._listeners[e];
        if (c !== void 0) {
            let d = c.indexOf(t);
            d !== -1 && c.splice(d, 1)
        }
    }
    dispatchEvent(e) {
        if (this._listeners === void 0)
            return;
        let o = this._listeners[e.type];
        if (o !== void 0) {
            e.target = this;
            let c = o.slice(0);
            for (let d = 0, p = c.length; d < p; d++)
                c[d].call(this, e);
            e.target = null
        }
    }
}
  , hs = [];
for (let r = 0; r < 256; r++)
    hs[r] = (r < 16 ? "0" : "") + r.toString(16);
var F1 = Math.PI / 180
  , B1 = 180 / Math.PI;
function Uo() {
    let r = Math.random() * 4294967295 | 0
      , e = Math.random() * 4294967295 | 0
      , t = Math.random() * 4294967295 | 0
      , o = Math.random() * 4294967295 | 0;
    return (hs[r & 255] + hs[r >> 8 & 255] + hs[r >> 16 & 255] + hs[r >> 24 & 255] + "-" + hs[e & 255] + hs[e >> 8 & 255] + "-" + hs[e >> 16 & 15 | 64] + hs[e >> 24 & 255] + "-" + hs[t & 63 | 128] + hs[t >> 8 & 255] + "-" + hs[t >> 16 & 255] + hs[t >> 24 & 255] + hs[o & 255] + hs[o >> 8 & 255] + hs[o >> 16 & 255] + hs[o >> 24 & 255]).toLowerCase()
}
function rs(r, e, t) {
    return Math.max(e, Math.min(t, r))
}
function Lz(r, e) {
    return (r % e + e) % e
}
function U1(r, e, t) {
    return (1 - t) * r + t * e
}
function u2(r) {
    return (r & r - 1) == 0 && r !== 0
}
function V1(r) {
    return Math.pow(2, Math.floor(Math.log(r) / Math.LN2))
}
var zt = class {
    constructor(e=0, t=0) {
        this.x = e,
        this.y = t
    }
    get width() {
        return this.x
    }
    set width(e) {
        this.x = e
    }
    get height() {
        return this.y
    }
    set height(e) {
        this.y = e
    }
    set(e, t) {
        return this.x = e,
        this.y = t,
        this
    }
    setScalar(e) {
        return this.x = e,
        this.y = e,
        this
    }
    setX(e) {
        return this.x = e,
        this
    }
    setY(e) {
        return this.y = e,
        this
    }
    setComponent(e, t) {
        switch (e) {
        case 0:
            this.x = t;
            break;
        case 1:
            this.y = t;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this
    }
    add(e, t) {
        return t !== void 0 ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
        this.addVectors(e, t)) : (this.x += e.x,
        this.y += e.y,
        this)
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x,
        this.y = e.y + t.y,
        this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t,
        this.y += e.y * t,
        this
    }
    sub(e, t) {
        return t !== void 0 ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
        this.subVectors(e, t)) : (this.x -= e.x,
        this.y -= e.y,
        this)
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x,
        this.y = e.y - t.y,
        this
    }
    multiply(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this
    }
    multiplyScalar(e) {
        return this.x *= e,
        this.y *= e,
        this
    }
    divide(e) {
        return this.x /= e.x,
        this.y /= e.y,
        this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    applyMatrix3(e) {
        let t = this.x
          , o = this.y
          , c = e.elements;
        return this.x = c[0] * t + c[3] * o + c[6],
        this.y = c[1] * t + c[4] * o + c[7],
        this
    }
    min(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this
    }
    clamp(e, t) {
        return this.x = Math.max(e.x, Math.min(t.x, this.x)),
        this.y = Math.max(e.y, Math.min(t.y, this.y)),
        this
    }
    clampScalar(e, t) {
        return this.x = Math.max(e, Math.min(t, this.x)),
        this.y = Math.max(e, Math.min(t, this.y)),
        this
    }
    clampLength(e, t) {
        let o = this.length();
        return this.divideScalar(o || 1).multiplyScalar(Math.max(e, Math.min(t, o)))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this
    }
    roundToZero() {
        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y
    }
    cross(e) {
        return this.x * e.y - this.y * e.x
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    angle() {
        return Math.atan2(-this.y, -this.x) + Math.PI
    }
    distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e))
    }
    distanceToSquared(e) {
        let t = this.x - e.x
          , o = this.y - e.y;
        return t * t + o * o
    }
    manhattanDistanceTo(e) {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t,
        this.y += (e.y - this.y) * t,
        this
    }
    lerpVectors(e, t, o) {
        return this.x = e.x + (t.x - e.x) * o,
        this.y = e.y + (t.y - e.y) * o,
        this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y
    }
    fromArray(e, t=0) {
        return this.x = e[t],
        this.y = e[t + 1],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.x,
        e[t + 1] = this.y,
        e
    }
    fromBufferAttribute(e, t, o) {
        return o !== void 0 && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),
        this.x = e.getX(t),
        this.y = e.getY(t),
        this
    }
    rotateAround(e, t) {
        let o = Math.cos(t)
          , c = Math.sin(t)
          , d = this.x - e.x
          , p = this.y - e.y;
        return this.x = d * o - p * c + e.x,
        this.y = d * c + p * o + e.y,
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y
    }
}
;
zt.prototype.isVector2 = !0;
var Fr = class {
    constructor() {
        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1],
        arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
    }
    set(e, t, o, c, d, p, i, v, x) {
        let E = this.elements;
        return E[0] = e,
        E[1] = c,
        E[2] = i,
        E[3] = t,
        E[4] = d,
        E[5] = v,
        E[6] = o,
        E[7] = p,
        E[8] = x,
        this
    }
    identity() {
        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1),
        this
    }
    copy(e) {
        let t = this.elements
          , o = e.elements;
        return t[0] = o[0],
        t[1] = o[1],
        t[2] = o[2],
        t[3] = o[3],
        t[4] = o[4],
        t[5] = o[5],
        t[6] = o[6],
        t[7] = o[7],
        t[8] = o[8],
        this
    }
    extractBasis(e, t, o) {
        return e.setFromMatrix3Column(this, 0),
        t.setFromMatrix3Column(this, 1),
        o.setFromMatrix3Column(this, 2),
        this
    }
    setFromMatrix4(e) {
        let t = e.elements;
        return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]),
        this
    }
    multiply(e) {
        return this.multiplyMatrices(this, e)
    }
    premultiply(e) {
        return this.multiplyMatrices(e, this)
    }
    multiplyMatrices(e, t) {
        let o = e.elements
          , c = t.elements
          , d = this.elements
          , p = o[0]
          , i = o[3]
          , v = o[6]
          , x = o[1]
          , E = o[4]
          , A = o[7]
          , C = o[2]
          , I = o[5]
          , D = o[8]
          , P = c[0]
          , k = c[3]
          , U = c[6]
          , Z = c[1]
          , K = c[4]
          , X = c[7]
          , W = c[2]
          , fe = c[5]
          , ce = c[8];
        return d[0] = p * P + i * Z + v * W,
        d[3] = p * k + i * K + v * fe,
        d[6] = p * U + i * X + v * ce,
        d[1] = x * P + E * Z + A * W,
        d[4] = x * k + E * K + A * fe,
        d[7] = x * U + E * X + A * ce,
        d[2] = C * P + I * Z + D * W,
        d[5] = C * k + I * K + D * fe,
        d[8] = C * U + I * X + D * ce,
        this
    }
    multiplyScalar(e) {
        let t = this.elements;
        return t[0] *= e,
        t[3] *= e,
        t[6] *= e,
        t[1] *= e,
        t[4] *= e,
        t[7] *= e,
        t[2] *= e,
        t[5] *= e,
        t[8] *= e,
        this
    }
    determinant() {
        let e = this.elements
          , t = e[0]
          , o = e[1]
          , c = e[2]
          , d = e[3]
          , p = e[4]
          , i = e[5]
          , v = e[6]
          , x = e[7]
          , E = e[8];
        return t * p * E - t * i * x - o * d * E + o * i * v + c * d * x - c * p * v
    }
    invert() {
        let e = this.elements
          , t = e[0]
          , o = e[1]
          , c = e[2]
          , d = e[3]
          , p = e[4]
          , i = e[5]
          , v = e[6]
          , x = e[7]
          , E = e[8]
          , A = E * p - i * x
          , C = i * v - E * d
          , I = x * d - p * v
          , D = t * A + o * C + c * I;
        if (D === 0)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        let P = 1 / D;
        return e[0] = A * P,
        e[1] = (c * x - E * o) * P,
        e[2] = (i * o - c * p) * P,
        e[3] = C * P,
        e[4] = (E * t - c * v) * P,
        e[5] = (c * d - i * t) * P,
        e[6] = I * P,
        e[7] = (o * v - x * t) * P,
        e[8] = (p * t - o * d) * P,
        this
    }
    transpose() {
        let e, t = this.elements;
        return e = t[1],
        t[1] = t[3],
        t[3] = e,
        e = t[2],
        t[2] = t[6],
        t[6] = e,
        e = t[5],
        t[5] = t[7],
        t[7] = e,
        this
    }
    getNormalMatrix(e) {
        return this.setFromMatrix4(e).invert().transpose()
    }
    transposeIntoArray(e) {
        let t = this.elements;
        return e[0] = t[0],
        e[1] = t[3],
        e[2] = t[6],
        e[3] = t[1],
        e[4] = t[4],
        e[5] = t[7],
        e[6] = t[2],
        e[7] = t[5],
        e[8] = t[8],
        this
    }
    setUvTransform(e, t, o, c, d, p, i) {
        let v = Math.cos(d)
          , x = Math.sin(d);
        return this.set(o * v, o * x, -o * (v * p + x * i) + p + e, -c * x, c * v, -c * (-x * p + v * i) + i + t, 0, 0, 1),
        this
    }
    scale(e, t) {
        let o = this.elements;
        return o[0] *= e,
        o[3] *= e,
        o[6] *= e,
        o[1] *= t,
        o[4] *= t,
        o[7] *= t,
        this
    }
    rotate(e) {
        let t = Math.cos(e)
          , o = Math.sin(e)
          , c = this.elements
          , d = c[0]
          , p = c[3]
          , i = c[6]
          , v = c[1]
          , x = c[4]
          , E = c[7];
        return c[0] = t * d + o * v,
        c[3] = t * p + o * x,
        c[6] = t * i + o * E,
        c[1] = -o * d + t * v,
        c[4] = -o * p + t * x,
        c[7] = -o * i + t * E,
        this
    }
    translate(e, t) {
        let o = this.elements;
        return o[0] += e * o[2],
        o[3] += e * o[5],
        o[6] += e * o[8],
        o[1] += t * o[2],
        o[4] += t * o[5],
        o[7] += t * o[8],
        this
    }
    equals(e) {
        let t = this.elements
          , o = e.elements;
        for (let c = 0; c < 9; c++)
            if (t[c] !== o[c])
                return !1;
        return !0
    }
    fromArray(e, t=0) {
        for (let o = 0; o < 9; o++)
            this.elements[o] = e[o + t];
        return this
    }
    toArray(e=[], t=0) {
        let o = this.elements;
        return e[t] = o[0],
        e[t + 1] = o[1],
        e[t + 2] = o[2],
        e[t + 3] = o[3],
        e[t + 4] = o[4],
        e[t + 5] = o[5],
        e[t + 6] = o[6],
        e[t + 7] = o[7],
        e[t + 8] = o[8],
        e
    }
    clone() {
        return new this.constructor().fromArray(this.elements)
    }
}
;
Fr.prototype.isMatrix3 = !0;
function h2(r) {
    for (let e = r.length - 1; e >= 0; --e)
        if (r[e] > 65535)
            return !0;
    return !1
}
function xm(r) {
    return document.createElementNS("http://www.w3.org/1999/xhtml", r)
}
function qu(r) {
    return r < .04045 ? r * .0773993808 : Math.pow(r * .9478672986 + .0521327014, 2.4)
}
function Oy(r) {
    return r < .0031308 ? r * 12.92 : 1.055 * Math.pow(r, .41666) - .055
}
var G1 = {
    [xa]: {
        [oc]: qu
    },
    [oc]: {
        [xa]: Oy
    }
}
  , bo = {
    legacyMode: !0,
    get workingColorSpace() {
        return oc
    },
    set workingColorSpace(r) {
        console.warn("THREE.ColorManagement: .workingColorSpace is readonly.")
    },
    convert: function(r, e, t) {
        if (this.legacyMode || e === t || !e || !t)
            return r;
        if (G1[e] && G1[e][t] !== void 0) {
            let o = G1[e][t];
            return r.r = o(r.r),
            r.g = o(r.g),
            r.b = o(r.b),
            r
        }
        throw new Error("Unsupported color space conversion.")
    },
    fromWorkingColorSpace: function(r, e) {
        return this.convert(r, this.workingColorSpace, e)
    },
    toWorkingColorSpace: function(r, e) {
        return this.convert(r, e, this.workingColorSpace)
    }
}
  , d2 = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
}
  , Br = {
    r: 0,
    g: 0,
    b: 0
}
  , Vo = {
    h: 0,
    s: 0,
    l: 0
}
  , Ny = {
    h: 0,
    s: 0,
    l: 0
};
function H1(r, e, t) {
    return t < 0 && (t += 1),
    t > 1 && (t -= 1),
    t < 1 / 6 ? r + (e - r) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? r + (e - r) * 6 * (2 / 3 - t) : r
}
function Fy(r, e) {
    return e.r = r.r,
    e.g = r.g,
    e.b = r.b,
    e
}
var In = class {
    constructor(e, t, o) {
        return t === void 0 && o === void 0 ? this.set(e) : this.setRGB(e, t, o)
    }
    set(e) {
        return e && e.isColor ? this.copy(e) : typeof e == "number" ? this.setHex(e) : typeof e == "string" && this.setStyle(e),
        this
    }
    setScalar(e) {
        return this.r = e,
        this.g = e,
        this.b = e,
        this
    }
    setHex(e, t=xa) {
        return e = Math.floor(e),
        this.r = (e >> 16 & 255) / 255,
        this.g = (e >> 8 & 255) / 255,
        this.b = (e & 255) / 255,
        bo.toWorkingColorSpace(this, t),
        this
    }
    setRGB(e, t, o, c=oc) {
        return this.r = e,
        this.g = t,
        this.b = o,
        bo.toWorkingColorSpace(this, c),
        this
    }
    setHSL(e, t, o, c=oc) {
        if (e = Lz(e, 1),
        t = rs(t, 0, 1),
        o = rs(o, 0, 1),
        t === 0)
            this.r = this.g = this.b = o;
        else {
            let d = o <= .5 ? o * (1 + t) : o + t - o * t
              , p = 2 * o - d;
            this.r = H1(p, d, e + 1 / 3),
            this.g = H1(p, d, e),
            this.b = H1(p, d, e - 1 / 3)
        }
        return bo.toWorkingColorSpace(this, c),
        this
    }
    setStyle(e, t=xa) {
        function o(d) {
            d !== void 0 && parseFloat(d) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
        }
        let c;
        if (c = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)) {
            let d, p = c[1], i = c[2];
            switch (p) {
            case "rgb":
            case "rgba":
                if (d = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(i))
                    return this.r = Math.min(255, parseInt(d[1], 10)) / 255,
                    this.g = Math.min(255, parseInt(d[2], 10)) / 255,
                    this.b = Math.min(255, parseInt(d[3], 10)) / 255,
                    bo.toWorkingColorSpace(this, t),
                    o(d[4]),
                    this;
                if (d = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(i))
                    return this.r = Math.min(100, parseInt(d[1], 10)) / 100,
                    this.g = Math.min(100, parseInt(d[2], 10)) / 100,
                    this.b = Math.min(100, parseInt(d[3], 10)) / 100,
                    bo.toWorkingColorSpace(this, t),
                    o(d[4]),
                    this;
                break;
            case "hsl":
            case "hsla":
                if (d = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(i)) {
                    let v = parseFloat(d[1]) / 360
                      , x = parseInt(d[2], 10) / 100
                      , E = parseInt(d[3], 10) / 100;
                    return o(d[4]),
                    this.setHSL(v, x, E, t)
                }
                break
            }
        } else if (c = /^\#([A-Fa-f\d]+)$/.exec(e)) {
            let d = c[1]
              , p = d.length;
            if (p === 3)
                return this.r = parseInt(d.charAt(0) + d.charAt(0), 16) / 255,
                this.g = parseInt(d.charAt(1) + d.charAt(1), 16) / 255,
                this.b = parseInt(d.charAt(2) + d.charAt(2), 16) / 255,
                bo.toWorkingColorSpace(this, t),
                this;
            if (p === 6)
                return this.r = parseInt(d.charAt(0) + d.charAt(1), 16) / 255,
                this.g = parseInt(d.charAt(2) + d.charAt(3), 16) / 255,
                this.b = parseInt(d.charAt(4) + d.charAt(5), 16) / 255,
                bo.toWorkingColorSpace(this, t),
                this
        }
        return e && e.length > 0 ? this.setColorName(e, t) : this
    }
    setColorName(e, t=xa) {
        let o = d2[e.toLowerCase()];
        return o !== void 0 ? this.setHex(o, t) : console.warn("THREE.Color: Unknown color " + e),
        this
    }
    clone() {
        return new this.constructor(this.r,this.g,this.b)
    }
    copy(e) {
        return this.r = e.r,
        this.g = e.g,
        this.b = e.b,
        this
    }
    copySRGBToLinear(e) {
        return this.r = qu(e.r),
        this.g = qu(e.g),
        this.b = qu(e.b),
        this
    }
    copyLinearToSRGB(e) {
        return this.r = Oy(e.r),
        this.g = Oy(e.g),
        this.b = Oy(e.b),
        this
    }
    convertSRGBToLinear() {
        return this.copySRGBToLinear(this),
        this
    }
    convertLinearToSRGB() {
        return this.copyLinearToSRGB(this),
        this
    }
    getHex(e=xa) {
        return bo.fromWorkingColorSpace(Fy(this, Br), e),
        rs(Br.r * 255, 0, 255) << 16 ^ rs(Br.g * 255, 0, 255) << 8 ^ rs(Br.b * 255, 0, 255) << 0
    }
    getHexString(e=xa) {
        return ("000000" + this.getHex(e).toString(16)).slice(-6)
    }
    getHSL(e, t=oc) {
        bo.fromWorkingColorSpace(Fy(this, Br), t);
        let o = Br.r, c = Br.g, d = Br.b, p = Math.max(o, c, d), i = Math.min(o, c, d), v, x, E = (i + p) / 2;
        if (i === p)
            v = 0,
            x = 0;
        else {
            let A = p - i;
            switch (x = E <= .5 ? A / (p + i) : A / (2 - p - i),
            p) {
            case o:
                v = (c - d) / A + (c < d ? 6 : 0);
                break;
            case c:
                v = (d - o) / A + 2;
                break;
            case d:
                v = (o - c) / A + 4;
                break
            }
            v /= 6
        }
        return e.h = v,
        e.s = x,
        e.l = E,
        e
    }
    getRGB(e, t=oc) {
        return bo.fromWorkingColorSpace(Fy(this, Br), t),
        e.r = Br.r,
        e.g = Br.g,
        e.b = Br.b,
        e
    }
    getStyle(e=xa) {
        return bo.fromWorkingColorSpace(Fy(this, Br), e),
        e !== xa ? `color(${e} ${Br.r} ${Br.g} ${Br.b})` : `rgb(${Br.r * 255 | 0},${Br.g * 255 | 0},${Br.b * 255 | 0})`
    }
    offsetHSL(e, t, o) {
        return this.getHSL(Vo),
        Vo.h += e,
        Vo.s += t,
        Vo.l += o,
        this.setHSL(Vo.h, Vo.s, Vo.l),
        this
    }
    add(e) {
        return this.r += e.r,
        this.g += e.g,
        this.b += e.b,
        this
    }
    addColors(e, t) {
        return this.r = e.r + t.r,
        this.g = e.g + t.g,
        this.b = e.b + t.b,
        this
    }
    addScalar(e) {
        return this.r += e,
        this.g += e,
        this.b += e,
        this
    }
    sub(e) {
        return this.r = Math.max(0, this.r - e.r),
        this.g = Math.max(0, this.g - e.g),
        this.b = Math.max(0, this.b - e.b),
        this
    }
    multiply(e) {
        return this.r *= e.r,
        this.g *= e.g,
        this.b *= e.b,
        this
    }
    multiplyScalar(e) {
        return this.r *= e,
        this.g *= e,
        this.b *= e,
        this
    }
    lerp(e, t) {
        return this.r += (e.r - this.r) * t,
        this.g += (e.g - this.g) * t,
        this.b += (e.b - this.b) * t,
        this
    }
    lerpColors(e, t, o) {
        return this.r = e.r + (t.r - e.r) * o,
        this.g = e.g + (t.g - e.g) * o,
        this.b = e.b + (t.b - e.b) * o,
        this
    }
    lerpHSL(e, t) {
        this.getHSL(Vo),
        e.getHSL(Ny);
        let o = U1(Vo.h, Ny.h, t)
          , c = U1(Vo.s, Ny.s, t)
          , d = U1(Vo.l, Ny.l, t);
        return this.setHSL(o, c, d),
        this
    }
    equals(e) {
        return e.r === this.r && e.g === this.g && e.b === this.b
    }
    fromArray(e, t=0) {
        return this.r = e[t],
        this.g = e[t + 1],
        this.b = e[t + 2],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.r,
        e[t + 1] = this.g,
        e[t + 2] = this.b,
        e
    }
    fromBufferAttribute(e, t) {
        return this.r = e.getX(t),
        this.g = e.getY(t),
        this.b = e.getZ(t),
        e.normalized === !0 && (this.r /= 255,
        this.g /= 255,
        this.b /= 255),
        this
    }
    toJSON() {
        return this.getHex()
    }
}
;
In.NAMES = d2;
In.prototype.isColor = !0;
In.prototype.r = 1;
In.prototype.g = 1;
In.prototype.b = 1;
var Ld, el = class {
    static getDataURL(e) {
        if (/^data:/i.test(e.src) || typeof HTMLCanvasElement == "undefined")
            return e.src;
        let t;
        if (e instanceof HTMLCanvasElement)
            t = e;
        else {
            Ld === void 0 && (Ld = xm("canvas")),
            Ld.width = e.width,
            Ld.height = e.height;
            let o = Ld.getContext("2d");
            e instanceof ImageData ? o.putImageData(e, 0, 0) : o.drawImage(e, 0, 0, e.width, e.height),
            t = Ld
        }
        return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e),
        t.toDataURL("image/jpeg", .6)) : t.toDataURL("image/png")
    }
    static sRGBToLinear(e) {
        if (typeof HTMLImageElement != "undefined" && e instanceof HTMLImageElement || typeof HTMLCanvasElement != "undefined" && e instanceof HTMLCanvasElement || typeof ImageBitmap != "undefined" && e instanceof ImageBitmap) {
            let t = xm("canvas");
            t.width = e.width,
            t.height = e.height;
            let o = t.getContext("2d");
            o.drawImage(e, 0, 0, e.width, e.height);
            let c = o.getImageData(0, 0, e.width, e.height)
              , d = c.data;
            for (let p = 0; p < d.length; p++)
                d[p] = qu(d[p] / 255) * 255;
            return o.putImageData(c, 0, 0),
            t
        } else if (e.data) {
            let t = e.data.slice(0);
            for (let o = 0; o < t.length; o++)
                t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[o] = Math.floor(qu(t[o] / 255) * 255) : t[o] = qu(t[o]);
            return {
                data: t,
                width: e.width,
                height: e.height
            }
        } else
            return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),
            e
    }
}
, By = class {
    constructor(e=null) {
        this.uuid = Uo(),
        this.data = e,
        this.version = 0
    }
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    toJSON(e) {
        let t = e === void 0 || typeof e == "string";
        if (!t && e.images[this.uuid] !== void 0)
            return e.images[this.uuid];
        let o = {
            uuid: this.uuid,
            url: ""
        }
          , c = this.data;
        if (c !== null) {
            let d;
            if (Array.isArray(c)) {
                d = [];
                for (let p = 0, i = c.length; p < i; p++)
                    c[p].isDataTexture ? d.push(W1(c[p].image)) : d.push(W1(c[p]))
            } else
                d = W1(c);
            o.url = d
        }
        return t || (e.images[this.uuid] = o),
        o
    }
}
;
function W1(r) {
    return typeof HTMLImageElement != "undefined" && r instanceof HTMLImageElement || typeof HTMLCanvasElement != "undefined" && r instanceof HTMLCanvasElement || typeof ImageBitmap != "undefined" && r instanceof ImageBitmap ? el.getDataURL(r) : r.data ? {
        data: Array.prototype.slice.call(r.data),
        width: r.width,
        height: r.height,
        type: r.data.constructor.name
    } : (console.warn("THREE.Texture: Unable to serialize Texture."),
    {})
}
By.prototype.isSource = !0;
var Rz = 0
  , Ar = class extends Bo {
    constructor(e=Ar.DEFAULT_IMAGE, t=Ar.DEFAULT_MAPPING, o=vo, c=vo, d=ns, p=dm, i=is, v=ic, x=1, E=ya) {
        super();
        Object.defineProperty(this, "id", {
            value: Rz++
        }),
        this.uuid = Uo(),
        this.name = "",
        this.source = new By(e),
        this.mipmaps = [],
        this.mapping = t,
        this.wrapS = o,
        this.wrapT = c,
        this.magFilter = d,
        this.minFilter = p,
        this.anisotropy = x,
        this.format = i,
        this.internalFormat = null,
        this.type = v,
        this.offset = new zt(0,0),
        this.repeat = new zt(1,1),
        this.center = new zt(0,0),
        this.rotation = 0,
        this.matrixAutoUpdate = !0,
        this.matrix = new Fr,
        this.generateMipmaps = !0,
        this.premultiplyAlpha = !1,
        this.flipY = !0,
        this.unpackAlignment = 4,
        this.encoding = E,
        this.userData = {},
        this.version = 0,
        this.onUpdate = null,
        this.isRenderTargetTexture = !1,
        this.needsPMREMUpdate = !1
    }
    get image() {
        return this.source.data
    }
    set image(e) {
        this.source.data = e
    }
    updateMatrix() {
        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.name = e.name,
        this.source = e.source,
        this.mipmaps = e.mipmaps.slice(0),
        this.mapping = e.mapping,
        this.wrapS = e.wrapS,
        this.wrapT = e.wrapT,
        this.magFilter = e.magFilter,
        this.minFilter = e.minFilter,
        this.anisotropy = e.anisotropy,
        this.format = e.format,
        this.internalFormat = e.internalFormat,
        this.type = e.type,
        this.offset.copy(e.offset),
        this.repeat.copy(e.repeat),
        this.center.copy(e.center),
        this.rotation = e.rotation,
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this.matrix.copy(e.matrix),
        this.generateMipmaps = e.generateMipmaps,
        this.premultiplyAlpha = e.premultiplyAlpha,
        this.flipY = e.flipY,
        this.unpackAlignment = e.unpackAlignment,
        this.encoding = e.encoding,
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        this.needsUpdate = !0,
        this
    }
    toJSON(e) {
        let t = e === void 0 || typeof e == "string";
        if (!t && e.textures[this.uuid] !== void 0)
            return e.textures[this.uuid];
        let o = {
            metadata: {
                version: 4.5,
                type: "Texture",
                generator: "Texture.toJSON"
            },
            uuid: this.uuid,
            name: this.name,
            image: this.source.toJSON(e).uuid,
            mapping: this.mapping,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            center: [this.center.x, this.center.y],
            rotation: this.rotation,
            wrap: [this.wrapS, this.wrapT],
            format: this.format,
            type: this.type,
            encoding: this.encoding,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment
        };
        return JSON.stringify(this.userData) !== "{}" && (o.userData = this.userData),
        t || (e.textures[this.uuid] = o),
        o
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
    transformUv(e) {
        if (this.mapping !== f1)
            return e;
        if (e.applyMatrix3(this.matrix),
        e.x < 0 || e.x > 1)
            switch (this.wrapS) {
            case Vu:
                e.x = e.x - Math.floor(e.x);
                break;
            case vo:
                e.x = e.x < 0 ? 0 : 1;
                break;
            case My:
                Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
                break
            }
        if (e.y < 0 || e.y > 1)
            switch (this.wrapT) {
            case Vu:
                e.y = e.y - Math.floor(e.y);
                break;
            case vo:
                e.y = e.y < 0 ? 0 : 1;
                break;
            case My:
                Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
                break
            }
        return this.flipY && (e.y = 1 - e.y),
        e
    }
    set needsUpdate(e) {
        e === !0 && (this.version++,
        this.source.needsUpdate = !0)
    }
}
;
Ar.DEFAULT_IMAGE = null;
Ar.DEFAULT_MAPPING = f1;
Ar.prototype.isTexture = !0;
var Ui = class {
    constructor(e=0, t=0, o=0, c=1) {
        this.x = e,
        this.y = t,
        this.z = o,
        this.w = c
    }
    get width() {
        return this.z
    }
    set width(e) {
        this.z = e
    }
    get height() {
        return this.w
    }
    set height(e) {
        this.w = e
    }
    set(e, t, o, c) {
        return this.x = e,
        this.y = t,
        this.z = o,
        this.w = c,
        this
    }
    setScalar(e) {
        return this.x = e,
        this.y = e,
        this.z = e,
        this.w = e,
        this
    }
    setX(e) {
        return this.x = e,
        this
    }
    setY(e) {
        return this.y = e,
        this
    }
    setZ(e) {
        return this.z = e,
        this
    }
    setW(e) {
        return this.w = e,
        this
    }
    setComponent(e, t) {
        switch (e) {
        case 0:
            this.x = t;
            break;
        case 1:
            this.y = t;
            break;
        case 2:
            this.z = t;
            break;
        case 3:
            this.w = t;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        case 2:
            return this.z;
        case 3:
            return this.w;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y,this.z,this.w)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this.z = e.z,
        this.w = e.w !== void 0 ? e.w : 1,
        this
    }
    add(e, t) {
        return t !== void 0 ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
        this.addVectors(e, t)) : (this.x += e.x,
        this.y += e.y,
        this.z += e.z,
        this.w += e.w,
        this)
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this.z += e,
        this.w += e,
        this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x,
        this.y = e.y + t.y,
        this.z = e.z + t.z,
        this.w = e.w + t.w,
        this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t,
        this.y += e.y * t,
        this.z += e.z * t,
        this.w += e.w * t,
        this
    }
    sub(e, t) {
        return t !== void 0 ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
        this.subVectors(e, t)) : (this.x -= e.x,
        this.y -= e.y,
        this.z -= e.z,
        this.w -= e.w,
        this)
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this.z -= e,
        this.w -= e,
        this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x,
        this.y = e.y - t.y,
        this.z = e.z - t.z,
        this.w = e.w - t.w,
        this
    }
    multiply(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this.z *= e.z,
        this.w *= e.w,
        this
    }
    multiplyScalar(e) {
        return this.x *= e,
        this.y *= e,
        this.z *= e,
        this.w *= e,
        this
    }
    applyMatrix4(e) {
        let t = this.x
          , o = this.y
          , c = this.z
          , d = this.w
          , p = e.elements;
        return this.x = p[0] * t + p[4] * o + p[8] * c + p[12] * d,
        this.y = p[1] * t + p[5] * o + p[9] * c + p[13] * d,
        this.z = p[2] * t + p[6] * o + p[10] * c + p[14] * d,
        this.w = p[3] * t + p[7] * o + p[11] * c + p[15] * d,
        this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    setAxisAngleFromQuaternion(e) {
        this.w = 2 * Math.acos(e.w);
        let t = Math.sqrt(1 - e.w * e.w);
        return t < 1e-4 ? (this.x = 1,
        this.y = 0,
        this.z = 0) : (this.x = e.x / t,
        this.y = e.y / t,
        this.z = e.z / t),
        this
    }
    setAxisAngleFromRotationMatrix(e) {
        let t, o, c, d, p = .01, i = .1, v = e.elements, x = v[0], E = v[4], A = v[8], C = v[1], I = v[5], D = v[9], P = v[2], k = v[6], U = v[10];
        if (Math.abs(E - C) < p && Math.abs(A - P) < p && Math.abs(D - k) < p) {
            if (Math.abs(E + C) < i && Math.abs(A + P) < i && Math.abs(D + k) < i && Math.abs(x + I + U - 3) < i)
                return this.set(1, 0, 0, 0),
                this;
            t = Math.PI;
            let K = (x + 1) / 2
              , X = (I + 1) / 2
              , W = (U + 1) / 2
              , fe = (E + C) / 4
              , ce = (A + P) / 4
              , _e = (D + k) / 4;
            return K > X && K > W ? K < p ? (o = 0,
            c = .707106781,
            d = .707106781) : (o = Math.sqrt(K),
            c = fe / o,
            d = ce / o) : X > W ? X < p ? (o = .707106781,
            c = 0,
            d = .707106781) : (c = Math.sqrt(X),
            o = fe / c,
            d = _e / c) : W < p ? (o = .707106781,
            c = .707106781,
            d = 0) : (d = Math.sqrt(W),
            o = ce / d,
            c = _e / d),
            this.set(o, c, d, t),
            this
        }
        let Z = Math.sqrt((k - D) * (k - D) + (A - P) * (A - P) + (C - E) * (C - E));
        return Math.abs(Z) < .001 && (Z = 1),
        this.x = (k - D) / Z,
        this.y = (A - P) / Z,
        this.z = (C - E) / Z,
        this.w = Math.acos((x + I + U - 1) / 2),
        this
    }
    min(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this.z = Math.min(this.z, e.z),
        this.w = Math.min(this.w, e.w),
        this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this.z = Math.max(this.z, e.z),
        this.w = Math.max(this.w, e.w),
        this
    }
    clamp(e, t) {
        return this.x = Math.max(e.x, Math.min(t.x, this.x)),
        this.y = Math.max(e.y, Math.min(t.y, this.y)),
        this.z = Math.max(e.z, Math.min(t.z, this.z)),
        this.w = Math.max(e.w, Math.min(t.w, this.w)),
        this
    }
    clampScalar(e, t) {
        return this.x = Math.max(e, Math.min(t, this.x)),
        this.y = Math.max(e, Math.min(t, this.y)),
        this.z = Math.max(e, Math.min(t, this.z)),
        this.w = Math.max(e, Math.min(t, this.w)),
        this
    }
    clampLength(e, t) {
        let o = this.length();
        return this.divideScalar(o || 1).multiplyScalar(Math.max(e, Math.min(t, o)))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this.z = Math.floor(this.z),
        this.w = Math.floor(this.w),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this.z = Math.ceil(this.z),
        this.w = Math.ceil(this.w),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this.z = Math.round(this.z),
        this.w = Math.round(this.w),
        this
    }
    roundToZero() {
        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
        this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
        this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this.z = -this.z,
        this.w = -this.w,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t,
        this.y += (e.y - this.y) * t,
        this.z += (e.z - this.z) * t,
        this.w += (e.w - this.w) * t,
        this
    }
    lerpVectors(e, t, o) {
        return this.x = e.x + (t.x - e.x) * o,
        this.y = e.y + (t.y - e.y) * o,
        this.z = e.z + (t.z - e.z) * o,
        this.w = e.w + (t.w - e.w) * o,
        this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
    }
    fromArray(e, t=0) {
        return this.x = e[t],
        this.y = e[t + 1],
        this.z = e[t + 2],
        this.w = e[t + 3],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.x,
        e[t + 1] = this.y,
        e[t + 2] = this.z,
        e[t + 3] = this.w,
        e
    }
    fromBufferAttribute(e, t, o) {
        return o !== void 0 && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),
        this.x = e.getX(t),
        this.y = e.getY(t),
        this.z = e.getZ(t),
        this.w = e.getW(t),
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this.z = Math.random(),
        this.w = Math.random(),
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y,
        yield this.z,
        yield this.w
    }
}
;
Ui.prototype.isVector4 = !0;
var Cs = class extends Bo {
    constructor(e, t, o={}) {
        super();
        this.width = e,
        this.height = t,
        this.depth = 1,
        this.scissor = new Ui(0,0,e,t),
        this.scissorTest = !1,
        this.viewport = new Ui(0,0,e,t);
        let c = {
            width: e,
            height: t,
            depth: 1
        };
        this.texture = new Ar(c,o.mapping,o.wrapS,o.wrapT,o.magFilter,o.minFilter,o.format,o.type,o.anisotropy,o.encoding),
        this.texture.isRenderTargetTexture = !0,
        this.texture.flipY = !1,
        this.texture.generateMipmaps = o.generateMipmaps !== void 0 ? o.generateMipmaps : !1,
        this.texture.internalFormat = o.internalFormat !== void 0 ? o.internalFormat : null,
        this.texture.minFilter = o.minFilter !== void 0 ? o.minFilter : ns,
        this.depthBuffer = o.depthBuffer !== void 0 ? o.depthBuffer : !0,
        this.stencilBuffer = o.stencilBuffer !== void 0 ? o.stencilBuffer : !1,
        this.depthTexture = o.depthTexture !== void 0 ? o.depthTexture : null,
        this.samples = o.samples !== void 0 ? o.samples : 0
    }
    setSize(e, t, o=1) {
        (this.width !== e || this.height !== t || this.depth !== o) && (this.width = e,
        this.height = t,
        this.depth = o,
        this.texture.image.width = e,
        this.texture.image.height = t,
        this.texture.image.depth = o,
        this.dispose()),
        this.viewport.set(0, 0, e, t),
        this.scissor.set(0, 0, e, t)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.width = e.width,
        this.height = e.height,
        this.depth = e.depth,
        this.viewport.copy(e.viewport),
        this.texture = e.texture.clone(),
        this.texture.isRenderTargetTexture = !0,
        this.texture.image = Object.assign({}, e.texture.image),
        this.depthBuffer = e.depthBuffer,
        this.stencilBuffer = e.stencilBuffer,
        e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
        this.samples = e.samples,
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
;
Cs.prototype.isWebGLRenderTarget = !0;
var Rd = class extends Ar {
    constructor(e=null, t=1, o=1, c=1) {
        super(null);
        this.image = {
            data: e,
            width: t,
            height: o,
            depth: c
        },
        this.magFilter = Di,
        this.minFilter = Di,
        this.wrapR = vo,
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1
    }
}
;
Rd.prototype.isDataArrayTexture = !0;
var j1 = class extends Cs {
    constructor(e, t, o) {
        super(e, t);
        this.depth = o,
        this.texture = new Rd(null,e,t,o),
        this.texture.isRenderTargetTexture = !0
    }
}
;
j1.prototype.isWebGLArrayRenderTarget = !0;
var ac = class extends Ar {
    constructor(e=null, t=1, o=1, c=1) {
        super(null);
        this.image = {
            data: e,
            width: t,
            height: o,
            depth: c
        },
        this.magFilter = Di,
        this.minFilter = Di,
        this.wrapR = vo,
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1
    }
}
;
ac.prototype.isData3DTexture = !0;
var X1 = class extends Cs {
    constructor(e, t, o) {
        super(e, t);
        this.depth = o,
        this.texture = new ac(null,e,t,o),
        this.texture.isRenderTargetTexture = !0
    }
}
;
X1.prototype.isWebGL3DRenderTarget = !0;
var Z1 = class extends Cs {
    constructor(e, t, o, c={}) {
        super(e, t, c);
        let d = this.texture;
        this.texture = [];
        for (let p = 0; p < o; p++)
            this.texture[p] = d.clone(),
            this.texture[p].isRenderTargetTexture = !0
    }
    setSize(e, t, o=1) {
        if (this.width !== e || this.height !== t || this.depth !== o) {
            this.width = e,
            this.height = t,
            this.depth = o;
            for (let c = 0, d = this.texture.length; c < d; c++)
                this.texture[c].image.width = e,
                this.texture[c].image.height = t,
                this.texture[c].image.depth = o;
            this.dispose()
        }
        return this.viewport.set(0, 0, e, t),
        this.scissor.set(0, 0, e, t),
        this
    }
    copy(e) {
        this.dispose(),
        this.width = e.width,
        this.height = e.height,
        this.depth = e.depth,
        this.viewport.set(0, 0, this.width, this.height),
        this.scissor.set(0, 0, this.width, this.height),
        this.depthBuffer = e.depthBuffer,
        this.stencilBuffer = e.stencilBuffer,
        this.depthTexture = e.depthTexture,
        this.texture.length = 0;
        for (let t = 0, o = e.texture.length; t < o; t++)
            this.texture[t] = e.texture[t].clone();
        return this
    }
}
;
Z1.prototype.isWebGLMultipleRenderTargets = !0;
var Ur = class {
    constructor(e=0, t=0, o=0, c=1) {
        this._x = e,
        this._y = t,
        this._z = o,
        this._w = c
    }
    static slerp(e, t, o, c) {
        return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."),
        o.slerpQuaternions(e, t, c)
    }
    static slerpFlat(e, t, o, c, d, p, i) {
        let v = o[c + 0]
          , x = o[c + 1]
          , E = o[c + 2]
          , A = o[c + 3]
          , C = d[p + 0]
          , I = d[p + 1]
          , D = d[p + 2]
          , P = d[p + 3];
        if (i === 0) {
            e[t + 0] = v,
            e[t + 1] = x,
            e[t + 2] = E,
            e[t + 3] = A;
            return
        }
        if (i === 1) {
            e[t + 0] = C,
            e[t + 1] = I,
            e[t + 2] = D,
            e[t + 3] = P;
            return
        }
        if (A !== P || v !== C || x !== I || E !== D) {
            let k = 1 - i
              , U = v * C + x * I + E * D + A * P
              , Z = U >= 0 ? 1 : -1
              , K = 1 - U * U;
            if (K > Number.EPSILON) {
                let W = Math.sqrt(K)
                  , fe = Math.atan2(W, U * Z);
                k = Math.sin(k * fe) / W,
                i = Math.sin(i * fe) / W
            }
            let X = i * Z;
            if (v = v * k + C * X,
            x = x * k + I * X,
            E = E * k + D * X,
            A = A * k + P * X,
            k === 1 - i) {
                let W = 1 / Math.sqrt(v * v + x * x + E * E + A * A);
                v *= W,
                x *= W,
                E *= W,
                A *= W
            }
        }
        e[t] = v,
        e[t + 1] = x,
        e[t + 2] = E,
        e[t + 3] = A
    }
    static multiplyQuaternionsFlat(e, t, o, c, d, p) {
        let i = o[c]
          , v = o[c + 1]
          , x = o[c + 2]
          , E = o[c + 3]
          , A = d[p]
          , C = d[p + 1]
          , I = d[p + 2]
          , D = d[p + 3];
        return e[t] = i * D + E * A + v * I - x * C,
        e[t + 1] = v * D + E * C + x * A - i * I,
        e[t + 2] = x * D + E * I + i * C - v * A,
        e[t + 3] = E * D - i * A - v * C - x * I,
        e
    }
    get x() {
        return this._x
    }
    set x(e) {
        this._x = e,
        this._onChangeCallback()
    }
    get y() {
        return this._y
    }
    set y(e) {
        this._y = e,
        this._onChangeCallback()
    }
    get z() {
        return this._z
    }
    set z(e) {
        this._z = e,
        this._onChangeCallback()
    }
    get w() {
        return this._w
    }
    set w(e) {
        this._w = e,
        this._onChangeCallback()
    }
    set(e, t, o, c) {
        return this._x = e,
        this._y = t,
        this._z = o,
        this._w = c,
        this._onChangeCallback(),
        this
    }
    clone() {
        return new this.constructor(this._x,this._y,this._z,this._w)
    }
    copy(e) {
        return this._x = e.x,
        this._y = e.y,
        this._z = e.z,
        this._w = e.w,
        this._onChangeCallback(),
        this
    }
    setFromEuler(e, t) {
        if (!(e && e.isEuler))
            throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
        let o = e._x
          , c = e._y
          , d = e._z
          , p = e._order
          , i = Math.cos
          , v = Math.sin
          , x = i(o / 2)
          , E = i(c / 2)
          , A = i(d / 2)
          , C = v(o / 2)
          , I = v(c / 2)
          , D = v(d / 2);
        switch (p) {
        case "XYZ":
            this._x = C * E * A + x * I * D,
            this._y = x * I * A - C * E * D,
            this._z = x * E * D + C * I * A,
            this._w = x * E * A - C * I * D;
            break;
        case "YXZ":
            this._x = C * E * A + x * I * D,
            this._y = x * I * A - C * E * D,
            this._z = x * E * D - C * I * A,
            this._w = x * E * A + C * I * D;
            break;
        case "ZXY":
            this._x = C * E * A - x * I * D,
            this._y = x * I * A + C * E * D,
            this._z = x * E * D + C * I * A,
            this._w = x * E * A - C * I * D;
            break;
        case "ZYX":
            this._x = C * E * A - x * I * D,
            this._y = x * I * A + C * E * D,
            this._z = x * E * D - C * I * A,
            this._w = x * E * A + C * I * D;
            break;
        case "YZX":
            this._x = C * E * A + x * I * D,
            this._y = x * I * A + C * E * D,
            this._z = x * E * D - C * I * A,
            this._w = x * E * A - C * I * D;
            break;
        case "XZY":
            this._x = C * E * A - x * I * D,
            this._y = x * I * A - C * E * D,
            this._z = x * E * D + C * I * A,
            this._w = x * E * A + C * I * D;
            break;
        default:
            console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + p)
        }
        return t !== !1 && this._onChangeCallback(),
        this
    }
    setFromAxisAngle(e, t) {
        let o = t / 2
          , c = Math.sin(o);
        return this._x = e.x * c,
        this._y = e.y * c,
        this._z = e.z * c,
        this._w = Math.cos(o),
        this._onChangeCallback(),
        this
    }
    setFromRotationMatrix(e) {
        let t = e.elements
          , o = t[0]
          , c = t[4]
          , d = t[8]
          , p = t[1]
          , i = t[5]
          , v = t[9]
          , x = t[2]
          , E = t[6]
          , A = t[10]
          , C = o + i + A;
        if (C > 0) {
            let I = .5 / Math.sqrt(C + 1);
            this._w = .25 / I,
            this._x = (E - v) * I,
            this._y = (d - x) * I,
            this._z = (p - c) * I
        } else if (o > i && o > A) {
            let I = 2 * Math.sqrt(1 + o - i - A);
            this._w = (E - v) / I,
            this._x = .25 * I,
            this._y = (c + p) / I,
            this._z = (d + x) / I
        } else if (i > A) {
            let I = 2 * Math.sqrt(1 + i - o - A);
            this._w = (d - x) / I,
            this._x = (c + p) / I,
            this._y = .25 * I,
            this._z = (v + E) / I
        } else {
            let I = 2 * Math.sqrt(1 + A - o - i);
            this._w = (p - c) / I,
            this._x = (d + x) / I,
            this._y = (v + E) / I,
            this._z = .25 * I
        }
        return this._onChangeCallback(),
        this
    }
    setFromUnitVectors(e, t) {
        let o = e.dot(t) + 1;
        return o < Number.EPSILON ? (o = 0,
        Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y,
        this._y = e.x,
        this._z = 0,
        this._w = o) : (this._x = 0,
        this._y = -e.z,
        this._z = e.y,
        this._w = o)) : (this._x = e.y * t.z - e.z * t.y,
        this._y = e.z * t.x - e.x * t.z,
        this._z = e.x * t.y - e.y * t.x,
        this._w = o),
        this.normalize()
    }
    angleTo(e) {
        return 2 * Math.acos(Math.abs(rs(this.dot(e), -1, 1)))
    }
    rotateTowards(e, t) {
        let o = this.angleTo(e);
        if (o === 0)
            return this;
        let c = Math.min(1, t / o);
        return this.slerp(e, c),
        this
    }
    identity() {
        return this.set(0, 0, 0, 1)
    }
    invert() {
        return this.conjugate()
    }
    conjugate() {
        return this._x *= -1,
        this._y *= -1,
        this._z *= -1,
        this._onChangeCallback(),
        this
    }
    dot(e) {
        return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
    }
    lengthSq() {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
    }
    length() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
    }
    normalize() {
        let e = this.length();
        return e === 0 ? (this._x = 0,
        this._y = 0,
        this._z = 0,
        this._w = 1) : (e = 1 / e,
        this._x = this._x * e,
        this._y = this._y * e,
        this._z = this._z * e,
        this._w = this._w * e),
        this._onChangeCallback(),
        this
    }
    multiply(e, t) {
        return t !== void 0 ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),
        this.multiplyQuaternions(e, t)) : this.multiplyQuaternions(this, e)
    }
    premultiply(e) {
        return this.multiplyQuaternions(e, this)
    }
    multiplyQuaternions(e, t) {
        let o = e._x
          , c = e._y
          , d = e._z
          , p = e._w
          , i = t._x
          , v = t._y
          , x = t._z
          , E = t._w;
        return this._x = o * E + p * i + c * x - d * v,
        this._y = c * E + p * v + d * i - o * x,
        this._z = d * E + p * x + o * v - c * i,
        this._w = p * E - o * i - c * v - d * x,
        this._onChangeCallback(),
        this
    }
    slerp(e, t) {
        if (t === 0)
            return this;
        if (t === 1)
            return this.copy(e);
        let o = this._x
          , c = this._y
          , d = this._z
          , p = this._w
          , i = p * e._w + o * e._x + c * e._y + d * e._z;
        if (i < 0 ? (this._w = -e._w,
        this._x = -e._x,
        this._y = -e._y,
        this._z = -e._z,
        i = -i) : this.copy(e),
        i >= 1)
            return this._w = p,
            this._x = o,
            this._y = c,
            this._z = d,
            this;
        let v = 1 - i * i;
        if (v <= Number.EPSILON) {
            let I = 1 - t;
            return this._w = I * p + t * this._w,
            this._x = I * o + t * this._x,
            this._y = I * c + t * this._y,
            this._z = I * d + t * this._z,
            this.normalize(),
            this._onChangeCallback(),
            this
        }
        let x = Math.sqrt(v)
          , E = Math.atan2(x, i)
          , A = Math.sin((1 - t) * E) / x
          , C = Math.sin(t * E) / x;
        return this._w = p * A + this._w * C,
        this._x = o * A + this._x * C,
        this._y = c * A + this._y * C,
        this._z = d * A + this._z * C,
        this._onChangeCallback(),
        this
    }
    slerpQuaternions(e, t, o) {
        return this.copy(e).slerp(t, o)
    }
    random() {
        let e = Math.random()
          , t = Math.sqrt(1 - e)
          , o = Math.sqrt(e)
          , c = 2 * Math.PI * Math.random()
          , d = 2 * Math.PI * Math.random();
        return this.set(t * Math.cos(c), o * Math.sin(d), o * Math.cos(d), t * Math.sin(c))
    }
    equals(e) {
        return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
    }
    fromArray(e, t=0) {
        return this._x = e[t],
        this._y = e[t + 1],
        this._z = e[t + 2],
        this._w = e[t + 3],
        this._onChangeCallback(),
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this._x,
        e[t + 1] = this._y,
        e[t + 2] = this._z,
        e[t + 3] = this._w,
        e
    }
    fromBufferAttribute(e, t) {
        return this._x = e.getX(t),
        this._y = e.getY(t),
        this._z = e.getZ(t),
        this._w = e.getW(t),
        this
    }
    _onChange(e) {
        return this._onChangeCallback = e,
        this
    }
    _onChangeCallback() {}
}
;
Ur.prototype.isQuaternion = !0;
var Oe = class {
    constructor(e=0, t=0, o=0) {
        this.x = e,
        this.y = t,
        this.z = o
    }
    set(e, t, o) {
        return o === void 0 && (o = this.z),
        this.x = e,
        this.y = t,
        this.z = o,
        this
    }
    setScalar(e) {
        return this.x = e,
        this.y = e,
        this.z = e,
        this
    }
    setX(e) {
        return this.x = e,
        this
    }
    setY(e) {
        return this.y = e,
        this
    }
    setZ(e) {
        return this.z = e,
        this
    }
    setComponent(e, t) {
        switch (e) {
        case 0:
            this.x = t;
            break;
        case 1:
            this.y = t;
            break;
        case 2:
            this.z = t;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        case 2:
            return this.z;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y,this.z)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this.z = e.z,
        this
    }
    add(e, t) {
        return t !== void 0 ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
        this.addVectors(e, t)) : (this.x += e.x,
        this.y += e.y,
        this.z += e.z,
        this)
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this.z += e,
        this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x,
        this.y = e.y + t.y,
        this.z = e.z + t.z,
        this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t,
        this.y += e.y * t,
        this.z += e.z * t,
        this
    }
    sub(e, t) {
        return t !== void 0 ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
        this.subVectors(e, t)) : (this.x -= e.x,
        this.y -= e.y,
        this.z -= e.z,
        this)
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this.z -= e,
        this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x,
        this.y = e.y - t.y,
        this.z = e.z - t.z,
        this
    }
    multiply(e, t) {
        return t !== void 0 ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),
        this.multiplyVectors(e, t)) : (this.x *= e.x,
        this.y *= e.y,
        this.z *= e.z,
        this)
    }
    multiplyScalar(e) {
        return this.x *= e,
        this.y *= e,
        this.z *= e,
        this
    }
    multiplyVectors(e, t) {
        return this.x = e.x * t.x,
        this.y = e.y * t.y,
        this.z = e.z * t.z,
        this
    }
    applyEuler(e) {
        return e && e.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),
        this.applyQuaternion(f2.setFromEuler(e))
    }
    applyAxisAngle(e, t) {
        return this.applyQuaternion(f2.setFromAxisAngle(e, t))
    }
    applyMatrix3(e) {
        let t = this.x
          , o = this.y
          , c = this.z
          , d = e.elements;
        return this.x = d[0] * t + d[3] * o + d[6] * c,
        this.y = d[1] * t + d[4] * o + d[7] * c,
        this.z = d[2] * t + d[5] * o + d[8] * c,
        this
    }
    applyNormalMatrix(e) {
        return this.applyMatrix3(e).normalize()
    }
    applyMatrix4(e) {
        let t = this.x
          , o = this.y
          , c = this.z
          , d = e.elements
          , p = 1 / (d[3] * t + d[7] * o + d[11] * c + d[15]);
        return this.x = (d[0] * t + d[4] * o + d[8] * c + d[12]) * p,
        this.y = (d[1] * t + d[5] * o + d[9] * c + d[13]) * p,
        this.z = (d[2] * t + d[6] * o + d[10] * c + d[14]) * p,
        this
    }
    applyQuaternion(e) {
        let t = this.x
          , o = this.y
          , c = this.z
          , d = e.x
          , p = e.y
          , i = e.z
          , v = e.w
          , x = v * t + p * c - i * o
          , E = v * o + i * t - d * c
          , A = v * c + d * o - p * t
          , C = -d * t - p * o - i * c;
        return this.x = x * v + C * -d + E * -i - A * -p,
        this.y = E * v + C * -p + A * -d - x * -i,
        this.z = A * v + C * -i + x * -p - E * -d,
        this
    }
    project(e) {
        return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
    }
    unproject(e) {
        return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
    }
    transformDirection(e) {
        let t = this.x
          , o = this.y
          , c = this.z
          , d = e.elements;
        return this.x = d[0] * t + d[4] * o + d[8] * c,
        this.y = d[1] * t + d[5] * o + d[9] * c,
        this.z = d[2] * t + d[6] * o + d[10] * c,
        this.normalize()
    }
    divide(e) {
        return this.x /= e.x,
        this.y /= e.y,
        this.z /= e.z,
        this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    min(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this.z = Math.min(this.z, e.z),
        this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this.z = Math.max(this.z, e.z),
        this
    }
    clamp(e, t) {
        return this.x = Math.max(e.x, Math.min(t.x, this.x)),
        this.y = Math.max(e.y, Math.min(t.y, this.y)),
        this.z = Math.max(e.z, Math.min(t.z, this.z)),
        this
    }
    clampScalar(e, t) {
        return this.x = Math.max(e, Math.min(t, this.x)),
        this.y = Math.max(e, Math.min(t, this.y)),
        this.z = Math.max(e, Math.min(t, this.z)),
        this
    }
    clampLength(e, t) {
        let o = this.length();
        return this.divideScalar(o || 1).multiplyScalar(Math.max(e, Math.min(t, o)))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this.z = Math.floor(this.z),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this.z = Math.ceil(this.z),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this.z = Math.round(this.z),
        this
    }
    roundToZero() {
        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
        this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this.z = -this.z,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t,
        this.y += (e.y - this.y) * t,
        this.z += (e.z - this.z) * t,
        this
    }
    lerpVectors(e, t, o) {
        return this.x = e.x + (t.x - e.x) * o,
        this.y = e.y + (t.y - e.y) * o,
        this.z = e.z + (t.z - e.z) * o,
        this
    }
    cross(e, t) {
        return t !== void 0 ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),
        this.crossVectors(e, t)) : this.crossVectors(this, e)
    }
    crossVectors(e, t) {
        let o = e.x
          , c = e.y
          , d = e.z
          , p = t.x
          , i = t.y
          , v = t.z;
        return this.x = c * v - d * i,
        this.y = d * p - o * v,
        this.z = o * i - c * p,
        this
    }
    projectOnVector(e) {
        let t = e.lengthSq();
        if (t === 0)
            return this.set(0, 0, 0);
        let o = e.dot(this) / t;
        return this.copy(e).multiplyScalar(o)
    }
    projectOnPlane(e) {
        return q1.copy(this).projectOnVector(e),
        this.sub(q1)
    }
    reflect(e) {
        return this.sub(q1.copy(e).multiplyScalar(2 * this.dot(e)))
    }
    angleTo(e) {
        let t = Math.sqrt(this.lengthSq() * e.lengthSq());
        if (t === 0)
            return Math.PI / 2;
        let o = this.dot(e) / t;
        return Math.acos(rs(o, -1, 1))
    }
    distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e))
    }
    distanceToSquared(e) {
        let t = this.x - e.x
          , o = this.y - e.y
          , c = this.z - e.z;
        return t * t + o * o + c * c
    }
    manhattanDistanceTo(e) {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
    }
    setFromSpherical(e) {
        return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
    }
    setFromSphericalCoords(e, t, o) {
        let c = Math.sin(t) * e;
        return this.x = c * Math.sin(o),
        this.y = Math.cos(t) * e,
        this.z = c * Math.cos(o),
        this
    }
    setFromCylindrical(e) {
        return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
    }
    setFromCylindricalCoords(e, t, o) {
        return this.x = e * Math.sin(t),
        this.y = o,
        this.z = e * Math.cos(t),
        this
    }
    setFromMatrixPosition(e) {
        let t = e.elements;
        return this.x = t[12],
        this.y = t[13],
        this.z = t[14],
        this
    }
    setFromMatrixScale(e) {
        let t = this.setFromMatrixColumn(e, 0).length()
          , o = this.setFromMatrixColumn(e, 1).length()
          , c = this.setFromMatrixColumn(e, 2).length();
        return this.x = t,
        this.y = o,
        this.z = c,
        this
    }
    setFromMatrixColumn(e, t) {
        return this.fromArray(e.elements, t * 4)
    }
    setFromMatrix3Column(e, t) {
        return this.fromArray(e.elements, t * 3)
    }
    setFromEuler(e) {
        return this.x = e._x,
        this.y = e._y,
        this.z = e._z,
        this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z
    }
    fromArray(e, t=0) {
        return this.x = e[t],
        this.y = e[t + 1],
        this.z = e[t + 2],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.x,
        e[t + 1] = this.y,
        e[t + 2] = this.z,
        e
    }
    fromBufferAttribute(e, t, o) {
        return o !== void 0 && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),
        this.x = e.getX(t),
        this.y = e.getY(t),
        this.z = e.getZ(t),
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this.z = Math.random(),
        this
    }
    randomDirection() {
        let e = (Math.random() - .5) * 2
          , t = Math.random() * Math.PI * 2
          , o = Math.sqrt(1 - e ** 2);
        return this.x = o * Math.cos(t),
        this.y = o * Math.sin(t),
        this.z = e,
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y,
        yield this.z
    }
}
;
Oe.prototype.isVector3 = !0;
var q1 = new Oe
  , f2 = new Ur
  , io = class {
    constructor(e=new Oe(Infinity,Infinity,Infinity), t=new Oe(-Infinity,-Infinity,-Infinity)) {
        this.min = e,
        this.max = t
    }
    set(e, t) {
        return this.min.copy(e),
        this.max.copy(t),
        this
    }
    setFromArray(e) {
        let t = Infinity
          , o = Infinity
          , c = Infinity
          , d = -Infinity
          , p = -Infinity
          , i = -Infinity;
        for (let v = 0, x = e.length; v < x; v += 3) {
            let E = e[v]
              , A = e[v + 1]
              , C = e[v + 2];
            E < t && (t = E),
            A < o && (o = A),
            C < c && (c = C),
            E > d && (d = E),
            A > p && (p = A),
            C > i && (i = C)
        }
        return this.min.set(t, o, c),
        this.max.set(d, p, i),
        this
    }
    setFromBufferAttribute(e) {
        let t = Infinity
          , o = Infinity
          , c = Infinity
          , d = -Infinity
          , p = -Infinity
          , i = -Infinity;
        for (let v = 0, x = e.count; v < x; v++) {
            let E = e.getX(v)
              , A = e.getY(v)
              , C = e.getZ(v);
            E < t && (t = E),
            A < o && (o = A),
            C < c && (c = C),
            E > d && (d = E),
            A > p && (p = A),
            C > i && (i = C)
        }
        return this.min.set(t, o, c),
        this.max.set(d, p, i),
        this
    }
    setFromPoints(e) {
        this.makeEmpty();
        for (let t = 0, o = e.length; t < o; t++)
            this.expandByPoint(e[t]);
        return this
    }
    setFromCenterAndSize(e, t) {
        let o = Ku.copy(t).multiplyScalar(.5);
        return this.min.copy(e).sub(o),
        this.max.copy(e).add(o),
        this
    }
    setFromObject(e, t=!1) {
        return this.makeEmpty(),
        this.expandByObject(e, t)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.min.copy(e.min),
        this.max.copy(e.max),
        this
    }
    makeEmpty() {
        return this.min.x = this.min.y = this.min.z = Infinity,
        this.max.x = this.max.y = this.max.z = -Infinity,
        this
    }
    isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
    }
    getCenter(e) {
        return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
    }
    getSize(e) {
        return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
    }
    expandByPoint(e) {
        return this.min.min(e),
        this.max.max(e),
        this
    }
    expandByVector(e) {
        return this.min.sub(e),
        this.max.add(e),
        this
    }
    expandByScalar(e) {
        return this.min.addScalar(-e),
        this.max.addScalar(e),
        this
    }
    expandByObject(e, t=!1) {
        e.updateWorldMatrix(!1, !1);
        let o = e.geometry;
        if (o !== void 0)
            if (t && o.attributes != null && o.attributes.position !== void 0) {
                let d = o.attributes.position;
                for (let p = 0, i = d.count; p < i; p++)
                    Ku.fromBufferAttribute(d, p).applyMatrix4(e.matrixWorld),
                    this.expandByPoint(Ku)
            } else
                o.boundingBox === null && o.computeBoundingBox(),
                K1.copy(o.boundingBox),
                K1.applyMatrix4(e.matrixWorld),
                this.union(K1);
        let c = e.children;
        for (let d = 0, p = c.length; d < p; d++)
            this.expandByObject(c[d], t);
        return this
    }
    containsPoint(e) {
        return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z)
    }
    containsBox(e) {
        return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
    }
    getParameter(e, t) {
        return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
    }
    intersectsBox(e) {
        return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z)
    }
    intersectsSphere(e) {
        return this.clampPoint(e.center, Ku),
        Ku.distanceToSquared(e.center) <= e.radius * e.radius
    }
    intersectsPlane(e) {
        let t, o;
        return e.normal.x > 0 ? (t = e.normal.x * this.min.x,
        o = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x,
        o = e.normal.x * this.min.x),
        e.normal.y > 0 ? (t += e.normal.y * this.min.y,
        o += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y,
        o += e.normal.y * this.min.y),
        e.normal.z > 0 ? (t += e.normal.z * this.min.z,
        o += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z,
        o += e.normal.z * this.min.z),
        t <= -e.constant && o >= -e.constant
    }
    intersectsTriangle(e) {
        if (this.isEmpty())
            return !1;
        this.getCenter(vm),
        Uy.subVectors(this.max, vm),
        Pd.subVectors(e.a, vm),
        kd.subVectors(e.b, vm),
        zd.subVectors(e.c, vm),
        lc.subVectors(kd, Pd),
        cc.subVectors(zd, kd),
        Yu.subVectors(Pd, zd);
        let t = [0, -lc.z, lc.y, 0, -cc.z, cc.y, 0, -Yu.z, Yu.y, lc.z, 0, -lc.x, cc.z, 0, -cc.x, Yu.z, 0, -Yu.x, -lc.y, lc.x, 0, -cc.y, cc.x, 0, -Yu.y, Yu.x, 0];
        return !Y1(t, Pd, kd, zd, Uy) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1],
        !Y1(t, Pd, kd, zd, Uy)) ? !1 : (Vy.crossVectors(lc, cc),
        t = [Vy.x, Vy.y, Vy.z],
        Y1(t, Pd, kd, zd, Uy))
    }
    clampPoint(e, t) {
        return t.copy(e).clamp(this.min, this.max)
    }
    distanceToPoint(e) {
        return Ku.copy(e).clamp(this.min, this.max).sub(e).length()
    }
    getBoundingSphere(e) {
        return this.getCenter(e.center),
        e.radius = this.getSize(Ku).length() * .5,
        e
    }
    intersect(e) {
        return this.min.max(e.min),
        this.max.min(e.max),
        this.isEmpty() && this.makeEmpty(),
        this
    }
    union(e) {
        return this.min.min(e.min),
        this.max.max(e.max),
        this
    }
    applyMatrix4(e) {
        return this.isEmpty() ? this : (tl[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
        tl[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
        tl[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
        tl[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
        tl[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
        tl[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
        tl[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
        tl[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
        this.setFromPoints(tl),
        this)
    }
    translate(e) {
        return this.min.add(e),
        this.max.add(e),
        this
    }
    equals(e) {
        return e.min.equals(this.min) && e.max.equals(this.max)
    }
}
;
io.prototype.isBox3 = !0;
var tl = [new Oe, new Oe, new Oe, new Oe, new Oe, new Oe, new Oe, new Oe]
  , Ku = new Oe
  , K1 = new io
  , Pd = new Oe
  , kd = new Oe
  , zd = new Oe
  , lc = new Oe
  , cc = new Oe
  , Yu = new Oe
  , vm = new Oe
  , Uy = new Oe
  , Vy = new Oe
  , Ju = new Oe;
function Y1(r, e, t, o, c) {
    for (let d = 0, p = r.length - 3; d <= p; d += 3) {
        Ju.fromArray(r, d);
        let i = c.x * Math.abs(Ju.x) + c.y * Math.abs(Ju.y) + c.z * Math.abs(Ju.z)
          , v = e.dot(Ju)
          , x = t.dot(Ju)
          , E = o.dot(Ju);
        if (Math.max(-Math.max(v, x, E), Math.min(v, x, E)) > i)
            return !1
    }
    return !0
}
var Pz = new io
  , p2 = new Oe
  , Gy = new Oe
  , J1 = new Oe
  , uc = class {
    constructor(e=new Oe, t=-1) {
        this.center = e,
        this.radius = t
    }
    set(e, t) {
        return this.center.copy(e),
        this.radius = t,
        this
    }
    setFromPoints(e, t) {
        let o = this.center;
        t !== void 0 ? o.copy(t) : Pz.setFromPoints(e).getCenter(o);
        let c = 0;
        for (let d = 0, p = e.length; d < p; d++)
            c = Math.max(c, o.distanceToSquared(e[d]));
        return this.radius = Math.sqrt(c),
        this
    }
    copy(e) {
        return this.center.copy(e.center),
        this.radius = e.radius,
        this
    }
    isEmpty() {
        return this.radius < 0
    }
    makeEmpty() {
        return this.center.set(0, 0, 0),
        this.radius = -1,
        this
    }
    containsPoint(e) {
        return e.distanceToSquared(this.center) <= this.radius * this.radius
    }
    distanceToPoint(e) {
        return e.distanceTo(this.center) - this.radius
    }
    intersectsSphere(e) {
        let t = this.radius + e.radius;
        return e.center.distanceToSquared(this.center) <= t * t
    }
    intersectsBox(e) {
        return e.intersectsSphere(this)
    }
    intersectsPlane(e) {
        return Math.abs(e.distanceToPoint(this.center)) <= this.radius
    }
    clampPoint(e, t) {
        let o = this.center.distanceToSquared(e);
        return t.copy(e),
        o > this.radius * this.radius && (t.sub(this.center).normalize(),
        t.multiplyScalar(this.radius).add(this.center)),
        t
    }
    getBoundingBox(e) {
        return this.isEmpty() ? (e.makeEmpty(),
        e) : (e.set(this.center, this.center),
        e.expandByScalar(this.radius),
        e)
    }
    applyMatrix4(e) {
        return this.center.applyMatrix4(e),
        this.radius = this.radius * e.getMaxScaleOnAxis(),
        this
    }
    translate(e) {
        return this.center.add(e),
        this
    }
    expandByPoint(e) {
        J1.subVectors(e, this.center);
        let t = J1.lengthSq();
        if (t > this.radius * this.radius) {
            let o = Math.sqrt(t)
              , c = (o - this.radius) * .5;
            this.center.add(J1.multiplyScalar(c / o)),
            this.radius += c
        }
        return this
    }
    union(e) {
        return this.center.equals(e.center) === !0 ? Gy.set(0, 0, 1).multiplyScalar(e.radius) : Gy.subVectors(e.center, this.center).normalize().multiplyScalar(e.radius),
        this.expandByPoint(p2.copy(e.center).add(Gy)),
        this.expandByPoint(p2.copy(e.center).sub(Gy)),
        this
    }
    equals(e) {
        return e.center.equals(this.center) && e.radius === this.radius
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
  , nl = new Oe
  , $1 = new Oe
  , Hy = new Oe
  , hc = new Oe
  , Q1 = new Oe
  , Wy = new Oe
  , eb = new Oe
  , dc = class {
    constructor(e=new Oe, t=new Oe(0,0,-1)) {
        this.origin = e,
        this.direction = t
    }
    set(e, t) {
        return this.origin.copy(e),
        this.direction.copy(t),
        this
    }
    copy(e) {
        return this.origin.copy(e.origin),
        this.direction.copy(e.direction),
        this
    }
    at(e, t) {
        return t.copy(this.direction).multiplyScalar(e).add(this.origin)
    }
    lookAt(e) {
        return this.direction.copy(e).sub(this.origin).normalize(),
        this
    }
    recast(e) {
        return this.origin.copy(this.at(e, nl)),
        this
    }
    closestPointToPoint(e, t) {
        t.subVectors(e, this.origin);
        let o = t.dot(this.direction);
        return o < 0 ? t.copy(this.origin) : t.copy(this.direction).multiplyScalar(o).add(this.origin)
    }
    distanceToPoint(e) {
        return Math.sqrt(this.distanceSqToPoint(e))
    }
    distanceSqToPoint(e) {
        let t = nl.subVectors(e, this.origin).dot(this.direction);
        return t < 0 ? this.origin.distanceToSquared(e) : (nl.copy(this.direction).multiplyScalar(t).add(this.origin),
        nl.distanceToSquared(e))
    }
    distanceSqToSegment(e, t, o, c) {
        $1.copy(e).add(t).multiplyScalar(.5),
        Hy.copy(t).sub(e).normalize(),
        hc.copy(this.origin).sub($1);
        let d = e.distanceTo(t) * .5, p = -this.direction.dot(Hy), i = hc.dot(this.direction), v = -hc.dot(Hy), x = hc.lengthSq(), E = Math.abs(1 - p * p), A, C, I, D;
        if (E > 0)
            if (A = p * v - i,
            C = p * i - v,
            D = d * E,
            A >= 0)
                if (C >= -D)
                    if (C <= D) {
                        let P = 1 / E;
                        A *= P,
                        C *= P,
                        I = A * (A + p * C + 2 * i) + C * (p * A + C + 2 * v) + x
                    } else
                        C = d,
                        A = Math.max(0, -(p * C + i)),
                        I = -A * A + C * (C + 2 * v) + x;
                else
                    C = -d,
                    A = Math.max(0, -(p * C + i)),
                    I = -A * A + C * (C + 2 * v) + x;
            else
                C <= -D ? (A = Math.max(0, -(-p * d + i)),
                C = A > 0 ? -d : Math.min(Math.max(-d, -v), d),
                I = -A * A + C * (C + 2 * v) + x) : C <= D ? (A = 0,
                C = Math.min(Math.max(-d, -v), d),
                I = C * (C + 2 * v) + x) : (A = Math.max(0, -(p * d + i)),
                C = A > 0 ? d : Math.min(Math.max(-d, -v), d),
                I = -A * A + C * (C + 2 * v) + x);
        else
            C = p > 0 ? -d : d,
            A = Math.max(0, -(p * C + i)),
            I = -A * A + C * (C + 2 * v) + x;
        return o && o.copy(this.direction).multiplyScalar(A).add(this.origin),
        c && c.copy(Hy).multiplyScalar(C).add($1),
        I
    }
    intersectSphere(e, t) {
        nl.subVectors(e.center, this.origin);
        let o = nl.dot(this.direction)
          , c = nl.dot(nl) - o * o
          , d = e.radius * e.radius;
        if (c > d)
            return null;
        let p = Math.sqrt(d - c)
          , i = o - p
          , v = o + p;
        return i < 0 && v < 0 ? null : i < 0 ? this.at(v, t) : this.at(i, t)
    }
    intersectsSphere(e) {
        return this.distanceSqToPoint(e.center) <= e.radius * e.radius
    }
    distanceToPlane(e) {
        let t = e.normal.dot(this.direction);
        if (t === 0)
            return e.distanceToPoint(this.origin) === 0 ? 0 : null;
        let o = -(this.origin.dot(e.normal) + e.constant) / t;
        return o >= 0 ? o : null
    }
    intersectPlane(e, t) {
        let o = this.distanceToPlane(e);
        return o === null ? null : this.at(o, t)
    }
    intersectsPlane(e) {
        let t = e.distanceToPoint(this.origin);
        return t === 0 || e.normal.dot(this.direction) * t < 0
    }
    intersectBox(e, t) {
        let o, c, d, p, i, v, x = 1 / this.direction.x, E = 1 / this.direction.y, A = 1 / this.direction.z, C = this.origin;
        return x >= 0 ? (o = (e.min.x - C.x) * x,
        c = (e.max.x - C.x) * x) : (o = (e.max.x - C.x) * x,
        c = (e.min.x - C.x) * x),
        E >= 0 ? (d = (e.min.y - C.y) * E,
        p = (e.max.y - C.y) * E) : (d = (e.max.y - C.y) * E,
        p = (e.min.y - C.y) * E),
        o > p || d > c || ((d > o || o !== o) && (o = d),
        (p < c || c !== c) && (c = p),
        A >= 0 ? (i = (e.min.z - C.z) * A,
        v = (e.max.z - C.z) * A) : (i = (e.max.z - C.z) * A,
        v = (e.min.z - C.z) * A),
        o > v || i > c) || ((i > o || o !== o) && (o = i),
        (v < c || c !== c) && (c = v),
        c < 0) ? null : this.at(o >= 0 ? o : c, t)
    }
    intersectsBox(e) {
        return this.intersectBox(e, nl) !== null
    }
    intersectTriangle(e, t, o, c, d) {
        Q1.subVectors(t, e),
        Wy.subVectors(o, e),
        eb.crossVectors(Q1, Wy);
        let p = this.direction.dot(eb), i;
        if (p > 0) {
            if (c)
                return null;
            i = 1
        } else if (p < 0)
            i = -1,
            p = -p;
        else
            return null;
        hc.subVectors(this.origin, e);
        let v = i * this.direction.dot(Wy.crossVectors(hc, Wy));
        if (v < 0)
            return null;
        let x = i * this.direction.dot(Q1.cross(hc));
        if (x < 0 || v + x > p)
            return null;
        let E = -i * hc.dot(eb);
        return E < 0 ? null : this.at(E / p, d)
    }
    applyMatrix4(e) {
        return this.origin.applyMatrix4(e),
        this.direction.transformDirection(e),
        this
    }
    equals(e) {
        return e.origin.equals(this.origin) && e.direction.equals(this.direction)
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
  , Fn = class {
    constructor() {
        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
    }
    set(e, t, o, c, d, p, i, v, x, E, A, C, I, D, P, k) {
        let U = this.elements;
        return U[0] = e,
        U[4] = t,
        U[8] = o,
        U[12] = c,
        U[1] = d,
        U[5] = p,
        U[9] = i,
        U[13] = v,
        U[2] = x,
        U[6] = E,
        U[10] = A,
        U[14] = C,
        U[3] = I,
        U[7] = D,
        U[11] = P,
        U[15] = k,
        this
    }
    identity() {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
        this
    }
    clone() {
        return new Fn().fromArray(this.elements)
    }
    copy(e) {
        let t = this.elements
          , o = e.elements;
        return t[0] = o[0],
        t[1] = o[1],
        t[2] = o[2],
        t[3] = o[3],
        t[4] = o[4],
        t[5] = o[5],
        t[6] = o[6],
        t[7] = o[7],
        t[8] = o[8],
        t[9] = o[9],
        t[10] = o[10],
        t[11] = o[11],
        t[12] = o[12],
        t[13] = o[13],
        t[14] = o[14],
        t[15] = o[15],
        this
    }
    copyPosition(e) {
        let t = this.elements
          , o = e.elements;
        return t[12] = o[12],
        t[13] = o[13],
        t[14] = o[14],
        this
    }
    setFromMatrix3(e) {
        let t = e.elements;
        return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1),
        this
    }
    extractBasis(e, t, o) {
        return e.setFromMatrixColumn(this, 0),
        t.setFromMatrixColumn(this, 1),
        o.setFromMatrixColumn(this, 2),
        this
    }
    makeBasis(e, t, o) {
        return this.set(e.x, t.x, o.x, 0, e.y, t.y, o.y, 0, e.z, t.z, o.z, 0, 0, 0, 0, 1),
        this
    }
    extractRotation(e) {
        let t = this.elements
          , o = e.elements
          , c = 1 / Od.setFromMatrixColumn(e, 0).length()
          , d = 1 / Od.setFromMatrixColumn(e, 1).length()
          , p = 1 / Od.setFromMatrixColumn(e, 2).length();
        return t[0] = o[0] * c,
        t[1] = o[1] * c,
        t[2] = o[2] * c,
        t[3] = 0,
        t[4] = o[4] * d,
        t[5] = o[5] * d,
        t[6] = o[6] * d,
        t[7] = 0,
        t[8] = o[8] * p,
        t[9] = o[9] * p,
        t[10] = o[10] * p,
        t[11] = 0,
        t[12] = 0,
        t[13] = 0,
        t[14] = 0,
        t[15] = 1,
        this
    }
    makeRotationFromEuler(e) {
        e && e.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
        let t = this.elements
          , o = e.x
          , c = e.y
          , d = e.z
          , p = Math.cos(o)
          , i = Math.sin(o)
          , v = Math.cos(c)
          , x = Math.sin(c)
          , E = Math.cos(d)
          , A = Math.sin(d);
        if (e.order === "XYZ") {
            let C = p * E
              , I = p * A
              , D = i * E
              , P = i * A;
            t[0] = v * E,
            t[4] = -v * A,
            t[8] = x,
            t[1] = I + D * x,
            t[5] = C - P * x,
            t[9] = -i * v,
            t[2] = P - C * x,
            t[6] = D + I * x,
            t[10] = p * v
        } else if (e.order === "YXZ") {
            let C = v * E
              , I = v * A
              , D = x * E
              , P = x * A;
            t[0] = C + P * i,
            t[4] = D * i - I,
            t[8] = p * x,
            t[1] = p * A,
            t[5] = p * E,
            t[9] = -i,
            t[2] = I * i - D,
            t[6] = P + C * i,
            t[10] = p * v
        } else if (e.order === "ZXY") {
            let C = v * E
              , I = v * A
              , D = x * E
              , P = x * A;
            t[0] = C - P * i,
            t[4] = -p * A,
            t[8] = D + I * i,
            t[1] = I + D * i,
            t[5] = p * E,
            t[9] = P - C * i,
            t[2] = -p * x,
            t[6] = i,
            t[10] = p * v
        } else if (e.order === "ZYX") {
            let C = p * E
              , I = p * A
              , D = i * E
              , P = i * A;
            t[0] = v * E,
            t[4] = D * x - I,
            t[8] = C * x + P,
            t[1] = v * A,
            t[5] = P * x + C,
            t[9] = I * x - D,
            t[2] = -x,
            t[6] = i * v,
            t[10] = p * v
        } else if (e.order === "YZX") {
            let C = p * v
              , I = p * x
              , D = i * v
              , P = i * x;
            t[0] = v * E,
            t[4] = P - C * A,
            t[8] = D * A + I,
            t[1] = A,
            t[5] = p * E,
            t[9] = -i * E,
            t[2] = -x * E,
            t[6] = I * A + D,
            t[10] = C - P * A
        } else if (e.order === "XZY") {
            let C = p * v
              , I = p * x
              , D = i * v
              , P = i * x;
            t[0] = v * E,
            t[4] = -A,
            t[8] = x * E,
            t[1] = C * A + P,
            t[5] = p * E,
            t[9] = I * A - D,
            t[2] = D * A - I,
            t[6] = i * E,
            t[10] = P * A + C
        }
        return t[3] = 0,
        t[7] = 0,
        t[11] = 0,
        t[12] = 0,
        t[13] = 0,
        t[14] = 0,
        t[15] = 1,
        this
    }
    makeRotationFromQuaternion(e) {
        return this.compose(kz, e, zz)
    }
    lookAt(e, t, o) {
        let c = this.elements;
        return ro.subVectors(e, t),
        ro.lengthSq() === 0 && (ro.z = 1),
        ro.normalize(),
        fc.crossVectors(o, ro),
        fc.lengthSq() === 0 && (Math.abs(o.z) === 1 ? ro.x += 1e-4 : ro.z += 1e-4,
        ro.normalize(),
        fc.crossVectors(o, ro)),
        fc.normalize(),
        jy.crossVectors(ro, fc),
        c[0] = fc.x,
        c[4] = jy.x,
        c[8] = ro.x,
        c[1] = fc.y,
        c[5] = jy.y,
        c[9] = ro.y,
        c[2] = fc.z,
        c[6] = jy.z,
        c[10] = ro.z,
        this
    }
    multiply(e, t) {
        return t !== void 0 ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),
        this.multiplyMatrices(e, t)) : this.multiplyMatrices(this, e)
    }
    premultiply(e) {
        return this.multiplyMatrices(e, this)
    }
    multiplyMatrices(e, t) {
        let o = e.elements
          , c = t.elements
          , d = this.elements
          , p = o[0]
          , i = o[4]
          , v = o[8]
          , x = o[12]
          , E = o[1]
          , A = o[5]
          , C = o[9]
          , I = o[13]
          , D = o[2]
          , P = o[6]
          , k = o[10]
          , U = o[14]
          , Z = o[3]
          , K = o[7]
          , X = o[11]
          , W = o[15]
          , fe = c[0]
          , ce = c[4]
          , _e = c[8]
          , oe = c[12]
          , ee = c[1]
          , j = c[5]
          , ne = c[9]
          , be = c[13]
          , te = c[2]
          , ae = c[6]
          , se = c[10]
          , ke = c[14]
          , Be = c[3]
          , tt = c[7]
          , Ke = c[11]
          , bt = c[15];
        return d[0] = p * fe + i * ee + v * te + x * Be,
        d[4] = p * ce + i * j + v * ae + x * tt,
        d[8] = p * _e + i * ne + v * se + x * Ke,
        d[12] = p * oe + i * be + v * ke + x * bt,
        d[1] = E * fe + A * ee + C * te + I * Be,
        d[5] = E * ce + A * j + C * ae + I * tt,
        d[9] = E * _e + A * ne + C * se + I * Ke,
        d[13] = E * oe + A * be + C * ke + I * bt,
        d[2] = D * fe + P * ee + k * te + U * Be,
        d[6] = D * ce + P * j + k * ae + U * tt,
        d[10] = D * _e + P * ne + k * se + U * Ke,
        d[14] = D * oe + P * be + k * ke + U * bt,
        d[3] = Z * fe + K * ee + X * te + W * Be,
        d[7] = Z * ce + K * j + X * ae + W * tt,
        d[11] = Z * _e + K * ne + X * se + W * Ke,
        d[15] = Z * oe + K * be + X * ke + W * bt,
        this
    }
    multiplyScalar(e) {
        let t = this.elements;
        return t[0] *= e,
        t[4] *= e,
        t[8] *= e,
        t[12] *= e,
        t[1] *= e,
        t[5] *= e,
        t[9] *= e,
        t[13] *= e,
        t[2] *= e,
        t[6] *= e,
        t[10] *= e,
        t[14] *= e,
        t[3] *= e,
        t[7] *= e,
        t[11] *= e,
        t[15] *= e,
        this
    }
    determinant() {
        let e = this.elements
          , t = e[0]
          , o = e[4]
          , c = e[8]
          , d = e[12]
          , p = e[1]
          , i = e[5]
          , v = e[9]
          , x = e[13]
          , E = e[2]
          , A = e[6]
          , C = e[10]
          , I = e[14]
          , D = e[3]
          , P = e[7]
          , k = e[11]
          , U = e[15];
        return D * (+d * v * A - c * x * A - d * i * C + o * x * C + c * i * I - o * v * I) + P * (+t * v * I - t * x * C + d * p * C - c * p * I + c * x * E - d * v * E) + k * (+t * x * A - t * i * I - d * p * A + o * p * I + d * i * E - o * x * E) + U * (-c * i * E - t * v * A + t * i * C + c * p * A - o * p * C + o * v * E)
    }
    transpose() {
        let e = this.elements, t;
        return t = e[1],
        e[1] = e[4],
        e[4] = t,
        t = e[2],
        e[2] = e[8],
        e[8] = t,
        t = e[6],
        e[6] = e[9],
        e[9] = t,
        t = e[3],
        e[3] = e[12],
        e[12] = t,
        t = e[7],
        e[7] = e[13],
        e[13] = t,
        t = e[11],
        e[11] = e[14],
        e[14] = t,
        this
    }
    setPosition(e, t, o) {
        let c = this.elements;
        return e.isVector3 ? (c[12] = e.x,
        c[13] = e.y,
        c[14] = e.z) : (c[12] = e,
        c[13] = t,
        c[14] = o),
        this
    }
    invert() {
        let e = this.elements
          , t = e[0]
          , o = e[1]
          , c = e[2]
          , d = e[3]
          , p = e[4]
          , i = e[5]
          , v = e[6]
          , x = e[7]
          , E = e[8]
          , A = e[9]
          , C = e[10]
          , I = e[11]
          , D = e[12]
          , P = e[13]
          , k = e[14]
          , U = e[15]
          , Z = A * k * x - P * C * x + P * v * I - i * k * I - A * v * U + i * C * U
          , K = D * C * x - E * k * x - D * v * I + p * k * I + E * v * U - p * C * U
          , X = E * P * x - D * A * x + D * i * I - p * P * I - E * i * U + p * A * U
          , W = D * A * v - E * P * v - D * i * C + p * P * C + E * i * k - p * A * k
          , fe = t * Z + o * K + c * X + d * W;
        if (fe === 0)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        let ce = 1 / fe;
        return e[0] = Z * ce,
        e[1] = (P * C * d - A * k * d - P * c * I + o * k * I + A * c * U - o * C * U) * ce,
        e[2] = (i * k * d - P * v * d + P * c * x - o * k * x - i * c * U + o * v * U) * ce,
        e[3] = (A * v * d - i * C * d - A * c * x + o * C * x + i * c * I - o * v * I) * ce,
        e[4] = K * ce,
        e[5] = (E * k * d - D * C * d + D * c * I - t * k * I - E * c * U + t * C * U) * ce,
        e[6] = (D * v * d - p * k * d - D * c * x + t * k * x + p * c * U - t * v * U) * ce,
        e[7] = (p * C * d - E * v * d + E * c * x - t * C * x - p * c * I + t * v * I) * ce,
        e[8] = X * ce,
        e[9] = (D * A * d - E * P * d - D * o * I + t * P * I + E * o * U - t * A * U) * ce,
        e[10] = (p * P * d - D * i * d + D * o * x - t * P * x - p * o * U + t * i * U) * ce,
        e[11] = (E * i * d - p * A * d - E * o * x + t * A * x + p * o * I - t * i * I) * ce,
        e[12] = W * ce,
        e[13] = (E * P * c - D * A * c + D * o * C - t * P * C - E * o * k + t * A * k) * ce,
        e[14] = (D * i * c - p * P * c - D * o * v + t * P * v + p * o * k - t * i * k) * ce,
        e[15] = (p * A * c - E * i * c + E * o * v - t * A * v - p * o * C + t * i * C) * ce,
        this
    }
    scale(e) {
        let t = this.elements
          , o = e.x
          , c = e.y
          , d = e.z;
        return t[0] *= o,
        t[4] *= c,
        t[8] *= d,
        t[1] *= o,
        t[5] *= c,
        t[9] *= d,
        t[2] *= o,
        t[6] *= c,
        t[10] *= d,
        t[3] *= o,
        t[7] *= c,
        t[11] *= d,
        this
    }
    getMaxScaleOnAxis() {
        let e = this.elements
          , t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2]
          , o = e[4] * e[4] + e[5] * e[5] + e[6] * e[6]
          , c = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
        return Math.sqrt(Math.max(t, o, c))
    }
    makeTranslation(e, t, o) {
        return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, o, 0, 0, 0, 1),
        this
    }
    makeRotationX(e) {
        let t = Math.cos(e)
          , o = Math.sin(e);
        return this.set(1, 0, 0, 0, 0, t, -o, 0, 0, o, t, 0, 0, 0, 0, 1),
        this
    }
    makeRotationY(e) {
        let t = Math.cos(e)
          , o = Math.sin(e);
        return this.set(t, 0, o, 0, 0, 1, 0, 0, -o, 0, t, 0, 0, 0, 0, 1),
        this
    }
    makeRotationZ(e) {
        let t = Math.cos(e)
          , o = Math.sin(e);
        return this.set(t, -o, 0, 0, o, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
        this
    }
    makeRotationAxis(e, t) {
        let o = Math.cos(t)
          , c = Math.sin(t)
          , d = 1 - o
          , p = e.x
          , i = e.y
          , v = e.z
          , x = d * p
          , E = d * i;
        return this.set(x * p + o, x * i - c * v, x * v + c * i, 0, x * i + c * v, E * i + o, E * v - c * p, 0, x * v - c * i, E * v + c * p, d * v * v + o, 0, 0, 0, 0, 1),
        this
    }
    makeScale(e, t, o) {
        return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, o, 0, 0, 0, 0, 1),
        this
    }
    makeShear(e, t, o, c, d, p) {
        return this.set(1, o, d, 0, e, 1, p, 0, t, c, 1, 0, 0, 0, 0, 1),
        this
    }
    compose(e, t, o) {
        let c = this.elements
          , d = t._x
          , p = t._y
          , i = t._z
          , v = t._w
          , x = d + d
          , E = p + p
          , A = i + i
          , C = d * x
          , I = d * E
          , D = d * A
          , P = p * E
          , k = p * A
          , U = i * A
          , Z = v * x
          , K = v * E
          , X = v * A
          , W = o.x
          , fe = o.y
          , ce = o.z;
        return c[0] = (1 - (P + U)) * W,
        c[1] = (I + X) * W,
        c[2] = (D - K) * W,
        c[3] = 0,
        c[4] = (I - X) * fe,
        c[5] = (1 - (C + U)) * fe,
        c[6] = (k + Z) * fe,
        c[7] = 0,
        c[8] = (D + K) * ce,
        c[9] = (k - Z) * ce,
        c[10] = (1 - (C + P)) * ce,
        c[11] = 0,
        c[12] = e.x,
        c[13] = e.y,
        c[14] = e.z,
        c[15] = 1,
        this
    }
    decompose(e, t, o) {
        let c = this.elements
          , d = Od.set(c[0], c[1], c[2]).length()
          , p = Od.set(c[4], c[5], c[6]).length()
          , i = Od.set(c[8], c[9], c[10]).length();
        this.determinant() < 0 && (d = -d),
        e.x = c[12],
        e.y = c[13],
        e.z = c[14],
        Go.copy(this);
        let x = 1 / d
          , E = 1 / p
          , A = 1 / i;
        return Go.elements[0] *= x,
        Go.elements[1] *= x,
        Go.elements[2] *= x,
        Go.elements[4] *= E,
        Go.elements[5] *= E,
        Go.elements[6] *= E,
        Go.elements[8] *= A,
        Go.elements[9] *= A,
        Go.elements[10] *= A,
        t.setFromRotationMatrix(Go),
        o.x = d,
        o.y = p,
        o.z = i,
        this
    }
    makePerspective(e, t, o, c, d, p) {
        p === void 0 && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
        let i = this.elements
          , v = 2 * d / (t - e)
          , x = 2 * d / (o - c)
          , E = (t + e) / (t - e)
          , A = (o + c) / (o - c)
          , C = -(p + d) / (p - d)
          , I = -2 * p * d / (p - d);
        return i[0] = v,
        i[4] = 0,
        i[8] = E,
        i[12] = 0,
        i[1] = 0,
        i[5] = x,
        i[9] = A,
        i[13] = 0,
        i[2] = 0,
        i[6] = 0,
        i[10] = C,
        i[14] = I,
        i[3] = 0,
        i[7] = 0,
        i[11] = -1,
        i[15] = 0,
        this
    }
    makeOrthographic(e, t, o, c, d, p) {
        let i = this.elements
          , v = 1 / (t - e)
          , x = 1 / (o - c)
          , E = 1 / (p - d)
          , A = (t + e) * v
          , C = (o + c) * x
          , I = (p + d) * E;
        return i[0] = 2 * v,
        i[4] = 0,
        i[8] = 0,
        i[12] = -A,
        i[1] = 0,
        i[5] = 2 * x,
        i[9] = 0,
        i[13] = -C,
        i[2] = 0,
        i[6] = 0,
        i[10] = -2 * E,
        i[14] = -I,
        i[3] = 0,
        i[7] = 0,
        i[11] = 0,
        i[15] = 1,
        this
    }
    equals(e) {
        let t = this.elements
          , o = e.elements;
        for (let c = 0; c < 16; c++)
            if (t[c] !== o[c])
                return !1;
        return !0
    }
    fromArray(e, t=0) {
        for (let o = 0; o < 16; o++)
            this.elements[o] = e[o + t];
        return this
    }
    toArray(e=[], t=0) {
        let o = this.elements;
        return e[t] = o[0],
        e[t + 1] = o[1],
        e[t + 2] = o[2],
        e[t + 3] = o[3],
        e[t + 4] = o[4],
        e[t + 5] = o[5],
        e[t + 6] = o[6],
        e[t + 7] = o[7],
        e[t + 8] = o[8],
        e[t + 9] = o[9],
        e[t + 10] = o[10],
        e[t + 11] = o[11],
        e[t + 12] = o[12],
        e[t + 13] = o[13],
        e[t + 14] = o[14],
        e[t + 15] = o[15],
        e
    }
}
;
Fn.prototype.isMatrix4 = !0;
var Od = new Oe
  , Go = new Fn
  , kz = new Oe(0,0,0)
  , zz = new Oe(1,1,1)
  , fc = new Oe
  , jy = new Oe
  , ro = new Oe
  , m2 = new Fn
  , g2 = new Ur
  , il = class {
    constructor(e=0, t=0, o=0, c=il.DefaultOrder) {
        this._x = e,
        this._y = t,
        this._z = o,
        this._order = c
    }
    get x() {
        return this._x
    }
    set x(e) {
        this._x = e,
        this._onChangeCallback()
    }
    get y() {
        return this._y
    }
    set y(e) {
        this._y = e,
        this._onChangeCallback()
    }
    get z() {
        return this._z
    }
    set z(e) {
        this._z = e,
        this._onChangeCallback()
    }
    get order() {
        return this._order
    }
    set order(e) {
        this._order = e,
        this._onChangeCallback()
    }
    set(e, t, o, c=this._order) {
        return this._x = e,
        this._y = t,
        this._z = o,
        this._order = c,
        this._onChangeCallback(),
        this
    }
    clone() {
        return new this.constructor(this._x,this._y,this._z,this._order)
    }
    copy(e) {
        return this._x = e._x,
        this._y = e._y,
        this._z = e._z,
        this._order = e._order,
        this._onChangeCallback(),
        this
    }
    setFromRotationMatrix(e, t=this._order, o=!0) {
        let c = e.elements
          , d = c[0]
          , p = c[4]
          , i = c[8]
          , v = c[1]
          , x = c[5]
          , E = c[9]
          , A = c[2]
          , C = c[6]
          , I = c[10];
        switch (t) {
        case "XYZ":
            this._y = Math.asin(rs(i, -1, 1)),
            Math.abs(i) < .9999999 ? (this._x = Math.atan2(-E, I),
            this._z = Math.atan2(-p, d)) : (this._x = Math.atan2(C, x),
            this._z = 0);
            break;
        case "YXZ":
            this._x = Math.asin(-rs(E, -1, 1)),
            Math.abs(E) < .9999999 ? (this._y = Math.atan2(i, I),
            this._z = Math.atan2(v, x)) : (this._y = Math.atan2(-A, d),
            this._z = 0);
            break;
        case "ZXY":
            this._x = Math.asin(rs(C, -1, 1)),
            Math.abs(C) < .9999999 ? (this._y = Math.atan2(-A, I),
            this._z = Math.atan2(-p, x)) : (this._y = 0,
            this._z = Math.atan2(v, d));
            break;
        case "ZYX":
            this._y = Math.asin(-rs(A, -1, 1)),
            Math.abs(A) < .9999999 ? (this._x = Math.atan2(C, I),
            this._z = Math.atan2(v, d)) : (this._x = 0,
            this._z = Math.atan2(-p, x));
            break;
        case "YZX":
            this._z = Math.asin(rs(v, -1, 1)),
            Math.abs(v) < .9999999 ? (this._x = Math.atan2(-E, x),
            this._y = Math.atan2(-A, d)) : (this._x = 0,
            this._y = Math.atan2(i, I));
            break;
        case "XZY":
            this._z = Math.asin(-rs(p, -1, 1)),
            Math.abs(p) < .9999999 ? (this._x = Math.atan2(C, x),
            this._y = Math.atan2(i, d)) : (this._x = Math.atan2(-E, I),
            this._y = 0);
            break;
        default:
            console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t)
        }
        return this._order = t,
        o === !0 && this._onChangeCallback(),
        this
    }
    setFromQuaternion(e, t, o) {
        return m2.makeRotationFromQuaternion(e),
        this.setFromRotationMatrix(m2, t, o)
    }
    setFromVector3(e, t=this._order) {
        return this.set(e.x, e.y, e.z, t)
    }
    reorder(e) {
        return g2.setFromEuler(this),
        this.setFromQuaternion(g2, e)
    }
    equals(e) {
        return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
    }
    fromArray(e) {
        return this._x = e[0],
        this._y = e[1],
        this._z = e[2],
        e[3] !== void 0 && (this._order = e[3]),
        this._onChangeCallback(),
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this._x,
        e[t + 1] = this._y,
        e[t + 2] = this._z,
        e[t + 3] = this._order,
        e
    }
    _onChange(e) {
        return this._onChangeCallback = e,
        this
    }
    _onChangeCallback() {}
}
;
il.prototype.isEuler = !0;
il.DefaultOrder = "XYZ";
il.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
var Xy = class {
    constructor() {
        this.mask = 1 | 0
    }
    set(e) {
        this.mask = (1 << e | 0) >>> 0
    }
    enable(e) {
        this.mask |= 1 << e | 0
    }
    enableAll() {
        this.mask = 4294967295 | 0
    }
    toggle(e) {
        this.mask ^= 1 << e | 0
    }
    disable(e) {
        this.mask &= ~(1 << e | 0)
    }
    disableAll() {
        this.mask = 0
    }
    test(e) {
        return (this.mask & e.mask) != 0
    }
    isEnabled(e) {
        return (this.mask & (1 << e | 0)) != 0
    }
}
  , Oz = 0
  , _2 = new Oe
  , Nd = new Ur
  , rl = new Fn
  , Zy = new Oe
  , bm = new Oe
  , Nz = new Oe
  , Fz = new Ur
  , y2 = new Oe(1,0,0)
  , x2 = new Oe(0,1,0)
  , v2 = new Oe(0,0,1)
  , Bz = {
    type: "added"
}
  , b2 = {
    type: "removed"
}
  , Ai = class extends Bo {
    constructor() {
        super();
        Object.defineProperty(this, "id", {
            value: Oz++
        }),
        this.uuid = Uo(),
        this.name = "",
        this.type = "Object3D",
        this.parent = null,
        this.children = [],
        this.up = Ai.DefaultUp.clone();
        let e = new Oe
          , t = new il
          , o = new Ur
          , c = new Oe(1,1,1);
        function d() {
            o.setFromEuler(t, !1)
        }
        function p() {
            t.setFromQuaternion(o, void 0, !1)
        }
        t._onChange(d),
        o._onChange(p),
        Object.defineProperties(this, {
            position: {
                configurable: !0,
                enumerable: !0,
                value: e
            },
            rotation: {
                configurable: !0,
                enumerable: !0,
                value: t
            },
            quaternion: {
                configurable: !0,
                enumerable: !0,
                value: o
            },
            scale: {
                configurable: !0,
                enumerable: !0,
                value: c
            },
            modelViewMatrix: {
                value: new Fn
            },
            normalMatrix: {
                value: new Fr
            }
        }),
        this.matrix = new Fn,
        this.matrixWorld = new Fn,
        this.matrixAutoUpdate = Ai.DefaultMatrixAutoUpdate,
        this.matrixWorldNeedsUpdate = !1,
        this.layers = new Xy,
        this.visible = !0,
        this.castShadow = !1,
        this.receiveShadow = !1,
        this.frustumCulled = !0,
        this.renderOrder = 0,
        this.animations = [],
        this.userData = {}
    }
    onBeforeRender() {}
    onAfterRender() {}
    applyMatrix4(e) {
        this.matrixAutoUpdate && this.updateMatrix(),
        this.matrix.premultiply(e),
        this.matrix.decompose(this.position, this.quaternion, this.scale)
    }
    applyQuaternion(e) {
        return this.quaternion.premultiply(e),
        this
    }
    setRotationFromAxisAngle(e, t) {
        this.quaternion.setFromAxisAngle(e, t)
    }
    setRotationFromEuler(e) {
        this.quaternion.setFromEuler(e, !0)
    }
    setRotationFromMatrix(e) {
        this.quaternion.setFromRotationMatrix(e)
    }
    setRotationFromQuaternion(e) {
        this.quaternion.copy(e)
    }
    rotateOnAxis(e, t) {
        return Nd.setFromAxisAngle(e, t),
        this.quaternion.multiply(Nd),
        this
    }
    rotateOnWorldAxis(e, t) {
        return Nd.setFromAxisAngle(e, t),
        this.quaternion.premultiply(Nd),
        this
    }
    rotateX(e) {
        return this.rotateOnAxis(y2, e)
    }
    rotateY(e) {
        return this.rotateOnAxis(x2, e)
    }
    rotateZ(e) {
        return this.rotateOnAxis(v2, e)
    }
    translateOnAxis(e, t) {
        return _2.copy(e).applyQuaternion(this.quaternion),
        this.position.add(_2.multiplyScalar(t)),
        this
    }
    translateX(e) {
        return this.translateOnAxis(y2, e)
    }
    translateY(e) {
        return this.translateOnAxis(x2, e)
    }
    translateZ(e) {
        return this.translateOnAxis(v2, e)
    }
    localToWorld(e) {
        return e.applyMatrix4(this.matrixWorld)
    }
    worldToLocal(e) {
        return e.applyMatrix4(rl.copy(this.matrixWorld).invert())
    }
    lookAt(e, t, o) {
        e.isVector3 ? Zy.copy(e) : Zy.set(e, t, o);
        let c = this.parent;
        this.updateWorldMatrix(!0, !1),
        bm.setFromMatrixPosition(this.matrixWorld),
        this.isCamera || this.isLight ? rl.lookAt(bm, Zy, this.up) : rl.lookAt(Zy, bm, this.up),
        this.quaternion.setFromRotationMatrix(rl),
        c && (rl.extractRotation(c.matrixWorld),
        Nd.setFromRotationMatrix(rl),
        this.quaternion.premultiply(Nd.invert()))
    }
    add(e) {
        if (arguments.length > 1) {
            for (let t = 0; t < arguments.length; t++)
                this.add(arguments[t]);
            return this
        }
        return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e),
        this) : (e && e.isObject3D ? (e.parent !== null && e.parent.remove(e),
        e.parent = this,
        this.children.push(e),
        e.dispatchEvent(Bz)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e),
        this)
    }
    remove(e) {
        if (arguments.length > 1) {
            for (let o = 0; o < arguments.length; o++)
                this.remove(arguments[o]);
            return this
        }
        let t = this.children.indexOf(e);
        return t !== -1 && (e.parent = null,
        this.children.splice(t, 1),
        e.dispatchEvent(b2)),
        this
    }
    removeFromParent() {
        let e = this.parent;
        return e !== null && e.remove(this),
        this
    }
    clear() {
        for (let e = 0; e < this.children.length; e++) {
            let t = this.children[e];
            t.parent = null,
            t.dispatchEvent(b2)
        }
        return this.children.length = 0,
        this
    }
    attach(e) {
        return this.updateWorldMatrix(!0, !1),
        rl.copy(this.matrixWorld).invert(),
        e.parent !== null && (e.parent.updateWorldMatrix(!0, !1),
        rl.multiply(e.parent.matrixWorld)),
        e.applyMatrix4(rl),
        this.add(e),
        e.updateWorldMatrix(!1, !0),
        this
    }
    getObjectById(e) {
        return this.getObjectByProperty("id", e)
    }
    getObjectByName(e) {
        return this.getObjectByProperty("name", e)
    }
    getObjectByProperty(e, t) {
        if (this[e] === t)
            return this;
        for (let o = 0, c = this.children.length; o < c; o++) {
            let p = this.children[o].getObjectByProperty(e, t);
            if (p !== void 0)
                return p
        }
    }
    getWorldPosition(e) {
        return this.updateWorldMatrix(!0, !1),
        e.setFromMatrixPosition(this.matrixWorld)
    }
    getWorldQuaternion(e) {
        return this.updateWorldMatrix(!0, !1),
        this.matrixWorld.decompose(bm, e, Nz),
        e
    }
    getWorldScale(e) {
        return this.updateWorldMatrix(!0, !1),
        this.matrixWorld.decompose(bm, Fz, e),
        e
    }
    getWorldDirection(e) {
        this.updateWorldMatrix(!0, !1);
        let t = this.matrixWorld.elements;
        return e.set(t[8], t[9], t[10]).normalize()
    }
    raycast() {}
    traverse(e) {
        e(this);
        let t = this.children;
        for (let o = 0, c = t.length; o < c; o++)
            t[o].traverse(e)
    }
    traverseVisible(e) {
        if (this.visible === !1)
            return;
        e(this);
        let t = this.children;
        for (let o = 0, c = t.length; o < c; o++)
            t[o].traverseVisible(e)
    }
    traverseAncestors(e) {
        let t = this.parent;
        t !== null && (e(t),
        t.traverseAncestors(e))
    }
    updateMatrix() {
        this.matrix.compose(this.position, this.quaternion, this.scale),
        this.matrixWorldNeedsUpdate = !0
    }
    updateMatrixWorld(e) {
        this.matrixAutoUpdate && this.updateMatrix(),
        (this.matrixWorldNeedsUpdate || e) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
        this.matrixWorldNeedsUpdate = !1,
        e = !0);
        let t = this.children;
        for (let o = 0, c = t.length; o < c; o++)
            t[o].updateMatrixWorld(e)
    }
    updateWorldMatrix(e, t) {
        let o = this.parent;
        if (e === !0 && o !== null && o.updateWorldMatrix(!0, !1),
        this.matrixAutoUpdate && this.updateMatrix(),
        this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
        t === !0) {
            let c = this.children;
            for (let d = 0, p = c.length; d < p; d++)
                c[d].updateWorldMatrix(!1, !0)
        }
    }
    toJSON(e) {
        let t = e === void 0 || typeof e == "string"
          , o = {};
        t && (e = {
            geometries: {},
            materials: {},
            textures: {},
            images: {},
            shapes: {},
            skeletons: {},
            animations: {},
            nodes: {}
        },
        o.metadata = {
            version: 4.5,
            type: "Object",
            generator: "Object3D.toJSON"
        });
        let c = {};
        c.uuid = this.uuid,
        c.type = this.type,
        this.name !== "" && (c.name = this.name),
        this.castShadow === !0 && (c.castShadow = !0),
        this.receiveShadow === !0 && (c.receiveShadow = !0),
        this.visible === !1 && (c.visible = !1),
        this.frustumCulled === !1 && (c.frustumCulled = !1),
        this.renderOrder !== 0 && (c.renderOrder = this.renderOrder),
        JSON.stringify(this.userData) !== "{}" && (c.userData = this.userData),
        c.layers = this.layers.mask,
        c.matrix = this.matrix.toArray(),
        this.matrixAutoUpdate === !1 && (c.matrixAutoUpdate = !1),
        this.isInstancedMesh && (c.type = "InstancedMesh",
        c.count = this.count,
        c.instanceMatrix = this.instanceMatrix.toJSON(),
        this.instanceColor !== null && (c.instanceColor = this.instanceColor.toJSON()));
        function d(i, v) {
            return i[v.uuid] === void 0 && (i[v.uuid] = v.toJSON(e)),
            v.uuid
        }
        if (this.isScene)
            this.background && (this.background.isColor ? c.background = this.background.toJSON() : this.background.isTexture && (c.background = this.background.toJSON(e).uuid)),
            this.environment && this.environment.isTexture && (c.environment = this.environment.toJSON(e).uuid);
        else if (this.isMesh || this.isLine || this.isPoints) {
            c.geometry = d(e.geometries, this.geometry);
            let i = this.geometry.parameters;
            if (i !== void 0 && i.shapes !== void 0) {
                let v = i.shapes;
                if (Array.isArray(v))
                    for (let x = 0, E = v.length; x < E; x++) {
                        let A = v[x];
                        d(e.shapes, A)
                    }
                else
                    d(e.shapes, v)
            }
        }
        if (this.isSkinnedMesh && (c.bindMode = this.bindMode,
        c.bindMatrix = this.bindMatrix.toArray(),
        this.skeleton !== void 0 && (d(e.skeletons, this.skeleton),
        c.skeleton = this.skeleton.uuid)),
        this.material !== void 0)
            if (Array.isArray(this.material)) {
                let i = [];
                for (let v = 0, x = this.material.length; v < x; v++)
                    i.push(d(e.materials, this.material[v]));
                c.material = i
            } else
                c.material = d(e.materials, this.material);
        if (this.children.length > 0) {
            c.children = [];
            for (let i = 0; i < this.children.length; i++)
                c.children.push(this.children[i].toJSON(e).object)
        }
        if (this.animations.length > 0) {
            c.animations = [];
            for (let i = 0; i < this.animations.length; i++) {
                let v = this.animations[i];
                c.animations.push(d(e.animations, v))
            }
        }
        if (t) {
            let i = p(e.geometries)
              , v = p(e.materials)
              , x = p(e.textures)
              , E = p(e.images)
              , A = p(e.shapes)
              , C = p(e.skeletons)
              , I = p(e.animations)
              , D = p(e.nodes);
            i.length > 0 && (o.geometries = i),
            v.length > 0 && (o.materials = v),
            x.length > 0 && (o.textures = x),
            E.length > 0 && (o.images = E),
            A.length > 0 && (o.shapes = A),
            C.length > 0 && (o.skeletons = C),
            I.length > 0 && (o.animations = I),
            D.length > 0 && (o.nodes = D)
        }
        return o.object = c,
        o;
        function p(i) {
            let v = [];
            for (let x in i) {
                let E = i[x];
                delete E.metadata,
                v.push(E)
            }
            return v
        }
    }
    clone(e) {
        return new this.constructor().copy(this, e)
    }
    copy(e, t=!0) {
        if (this.name = e.name,
        this.up.copy(e.up),
        this.position.copy(e.position),
        this.rotation.order = e.rotation.order,
        this.quaternion.copy(e.quaternion),
        this.scale.copy(e.scale),
        this.matrix.copy(e.matrix),
        this.matrixWorld.copy(e.matrixWorld),
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate,
        this.layers.mask = e.layers.mask,
        this.visible = e.visible,
        this.castShadow = e.castShadow,
        this.receiveShadow = e.receiveShadow,
        this.frustumCulled = e.frustumCulled,
        this.renderOrder = e.renderOrder,
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        t === !0)
            for (let o = 0; o < e.children.length; o++) {
                let c = e.children[o];
                this.add(c.clone())
            }
        return this
    }
}
;
Ai.DefaultUp = new Oe(0,1,0);
Ai.DefaultMatrixAutoUpdate = !0;
Ai.prototype.isObject3D = !0;
var Ho = new Oe
  , sl = new Oe
  , tb = new Oe
  , ol = new Oe
  , Fd = new Oe
  , Bd = new Oe
  , w2 = new Oe
  , nb = new Oe
  , ib = new Oe
  , rb = new Oe
  , yr = class {
    constructor(e=new Oe, t=new Oe, o=new Oe) {
        this.a = e,
        this.b = t,
        this.c = o
    }
    static getNormal(e, t, o, c) {
        c.subVectors(o, t),
        Ho.subVectors(e, t),
        c.cross(Ho);
        let d = c.lengthSq();
        return d > 0 ? c.multiplyScalar(1 / Math.sqrt(d)) : c.set(0, 0, 0)
    }
    static getBarycoord(e, t, o, c, d) {
        Ho.subVectors(c, t),
        sl.subVectors(o, t),
        tb.subVectors(e, t);
        let p = Ho.dot(Ho)
          , i = Ho.dot(sl)
          , v = Ho.dot(tb)
          , x = sl.dot(sl)
          , E = sl.dot(tb)
          , A = p * x - i * i;
        if (A === 0)
            return d.set(-2, -1, -1);
        let C = 1 / A
          , I = (x * v - i * E) * C
          , D = (p * E - i * v) * C;
        return d.set(1 - I - D, D, I)
    }
    static containsPoint(e, t, o, c) {
        return this.getBarycoord(e, t, o, c, ol),
        ol.x >= 0 && ol.y >= 0 && ol.x + ol.y <= 1
    }
    static getUV(e, t, o, c, d, p, i, v) {
        return this.getBarycoord(e, t, o, c, ol),
        v.set(0, 0),
        v.addScaledVector(d, ol.x),
        v.addScaledVector(p, ol.y),
        v.addScaledVector(i, ol.z),
        v
    }
    static isFrontFacing(e, t, o, c) {
        return Ho.subVectors(o, t),
        sl.subVectors(e, t),
        Ho.cross(sl).dot(c) < 0
    }
    set(e, t, o) {
        return this.a.copy(e),
        this.b.copy(t),
        this.c.copy(o),
        this
    }
    setFromPointsAndIndices(e, t, o, c) {
        return this.a.copy(e[t]),
        this.b.copy(e[o]),
        this.c.copy(e[c]),
        this
    }
    setFromAttributeAndIndices(e, t, o, c) {
        return this.a.fromBufferAttribute(e, t),
        this.b.fromBufferAttribute(e, o),
        this.c.fromBufferAttribute(e, c),
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.a.copy(e.a),
        this.b.copy(e.b),
        this.c.copy(e.c),
        this
    }
    getArea() {
        return Ho.subVectors(this.c, this.b),
        sl.subVectors(this.a, this.b),
        Ho.cross(sl).length() * .5
    }
    getMidpoint(e) {
        return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
    }
    getNormal(e) {
        return yr.getNormal(this.a, this.b, this.c, e)
    }
    getPlane(e) {
        return e.setFromCoplanarPoints(this.a, this.b, this.c)
    }
    getBarycoord(e, t) {
        return yr.getBarycoord(e, this.a, this.b, this.c, t)
    }
    getUV(e, t, o, c, d) {
        return yr.getUV(e, this.a, this.b, this.c, t, o, c, d)
    }
    containsPoint(e) {
        return yr.containsPoint(e, this.a, this.b, this.c)
    }
    isFrontFacing(e) {
        return yr.isFrontFacing(this.a, this.b, this.c, e)
    }
    intersectsBox(e) {
        return e.intersectsTriangle(this)
    }
    closestPointToPoint(e, t) {
        let o = this.a, c = this.b, d = this.c, p, i;
        Fd.subVectors(c, o),
        Bd.subVectors(d, o),
        nb.subVectors(e, o);
        let v = Fd.dot(nb)
          , x = Bd.dot(nb);
        if (v <= 0 && x <= 0)
            return t.copy(o);
        ib.subVectors(e, c);
        let E = Fd.dot(ib)
          , A = Bd.dot(ib);
        if (E >= 0 && A <= E)
            return t.copy(c);
        let C = v * A - E * x;
        if (C <= 0 && v >= 0 && E <= 0)
            return p = v / (v - E),
            t.copy(o).addScaledVector(Fd, p);
        rb.subVectors(e, d);
        let I = Fd.dot(rb)
          , D = Bd.dot(rb);
        if (D >= 0 && I <= D)
            return t.copy(d);
        let P = I * x - v * D;
        if (P <= 0 && x >= 0 && D <= 0)
            return i = x / (x - D),
            t.copy(o).addScaledVector(Bd, i);
        let k = E * D - I * A;
        if (k <= 0 && A - E >= 0 && I - D >= 0)
            return w2.subVectors(d, c),
            i = (A - E) / (A - E + (I - D)),
            t.copy(c).addScaledVector(w2, i);
        let U = 1 / (k + P + C);
        return p = P * U,
        i = C * U,
        t.copy(o).addScaledVector(Fd, p).addScaledVector(Bd, i)
    }
    equals(e) {
        return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
    }
}
  , Uz = 0
  , wr = class extends Bo {
    constructor() {
        super();
        Object.defineProperty(this, "id", {
            value: Uz++
        }),
        this.uuid = Uo(),
        this.name = "",
        this.type = "Material",
        this.fog = !0,
        this.blending = Nu,
        this.side = Md,
        this.vertexColors = !1,
        this.opacity = 1,
        this.transparent = !1,
        this.blendSrc = h1,
        this.blendDst = d1,
        this.blendEquation = Fu,
        this.blendSrcAlpha = null,
        this.blendDstAlpha = null,
        this.blendEquationAlpha = null,
        this.depthFunc = Ey,
        this.depthTest = !0,
        this.depthWrite = !0,
        this.stencilWriteMask = 255,
        this.stencilFunc = c2,
        this.stencilRef = 0,
        this.stencilFuncMask = 255,
        this.stencilFail = ky,
        this.stencilZFail = ky,
        this.stencilZPass = ky,
        this.stencilWrite = !1,
        this.clippingPlanes = null,
        this.clipIntersection = !1,
        this.clipShadows = !1,
        this.shadowSide = null,
        this.colorWrite = !0,
        this.precision = null,
        this.polygonOffset = !1,
        this.polygonOffsetFactor = 0,
        this.polygonOffsetUnits = 0,
        this.dithering = !1,
        this.alphaToCoverage = !1,
        this.premultipliedAlpha = !1,
        this.visible = !0,
        this.toneMapped = !0,
        this.userData = {},
        this.version = 0,
        this._alphaTest = 0
    }
    get alphaTest() {
        return this._alphaTest
    }
    set alphaTest(e) {
        this._alphaTest > 0 != e > 0 && this.version++,
        this._alphaTest = e
    }
    onBuild() {}
    onBeforeRender() {}
    onBeforeCompile() {}
    customProgramCacheKey() {
        return this.onBeforeCompile.toString()
    }
    setValues(e) {
        if (e !== void 0)
            for (let t in e) {
                let o = e[t];
                if (o === void 0) {
                    console.warn("THREE.Material: '" + t + "' parameter is undefined.");
                    continue
                }
                if (t === "shading") {
                    console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."),
                    this.flatShading = o === s1;
                    continue
                }
                let c = this[t];
                if (c === void 0) {
                    console.warn("THREE." + this.type + ": '" + t + "' is not a property of this material.");
                    continue
                }
                c && c.isColor ? c.set(o) : c && c.isVector3 && o && o.isVector3 ? c.copy(o) : this[t] = o
            }
    }
    toJSON(e) {
        let t = e === void 0 || typeof e == "string";
        t && (e = {
            textures: {},
            images: {}
        });
        let o = {
            metadata: {
                version: 4.5,
                type: "Material",
                generator: "Material.toJSON"
            }
        };
        o.uuid = this.uuid,
        o.type = this.type,
        this.name !== "" && (o.name = this.name),
        this.color && this.color.isColor && (o.color = this.color.getHex()),
        this.roughness !== void 0 && (o.roughness = this.roughness),
        this.metalness !== void 0 && (o.metalness = this.metalness),
        this.sheen !== void 0 && (o.sheen = this.sheen),
        this.sheenColor && this.sheenColor.isColor && (o.sheenColor = this.sheenColor.getHex()),
        this.sheenRoughness !== void 0 && (o.sheenRoughness = this.sheenRoughness),
        this.emissive && this.emissive.isColor && (o.emissive = this.emissive.getHex()),
        this.emissiveIntensity && this.emissiveIntensity !== 1 && (o.emissiveIntensity = this.emissiveIntensity),
        this.specular && this.specular.isColor && (o.specular = this.specular.getHex()),
        this.specularIntensity !== void 0 && (o.specularIntensity = this.specularIntensity),
        this.specularColor && this.specularColor.isColor && (o.specularColor = this.specularColor.getHex()),
        this.shininess !== void 0 && (o.shininess = this.shininess),
        this.clearcoat !== void 0 && (o.clearcoat = this.clearcoat),
        this.clearcoatRoughness !== void 0 && (o.clearcoatRoughness = this.clearcoatRoughness),
        this.clearcoatMap && this.clearcoatMap.isTexture && (o.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
        this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (o.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
        this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (o.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid,
        o.clearcoatNormalScale = this.clearcoatNormalScale.toArray()),
        this.map && this.map.isTexture && (o.map = this.map.toJSON(e).uuid),
        this.matcap && this.matcap.isTexture && (o.matcap = this.matcap.toJSON(e).uuid),
        this.alphaMap && this.alphaMap.isTexture && (o.alphaMap = this.alphaMap.toJSON(e).uuid),
        this.lightMap && this.lightMap.isTexture && (o.lightMap = this.lightMap.toJSON(e).uuid,
        o.lightMapIntensity = this.lightMapIntensity),
        this.aoMap && this.aoMap.isTexture && (o.aoMap = this.aoMap.toJSON(e).uuid,
        o.aoMapIntensity = this.aoMapIntensity),
        this.bumpMap && this.bumpMap.isTexture && (o.bumpMap = this.bumpMap.toJSON(e).uuid,
        o.bumpScale = this.bumpScale),
        this.normalMap && this.normalMap.isTexture && (o.normalMap = this.normalMap.toJSON(e).uuid,
        o.normalMapType = this.normalMapType,
        o.normalScale = this.normalScale.toArray()),
        this.displacementMap && this.displacementMap.isTexture && (o.displacementMap = this.displacementMap.toJSON(e).uuid,
        o.displacementScale = this.displacementScale,
        o.displacementBias = this.displacementBias),
        this.roughnessMap && this.roughnessMap.isTexture && (o.roughnessMap = this.roughnessMap.toJSON(e).uuid),
        this.metalnessMap && this.metalnessMap.isTexture && (o.metalnessMap = this.metalnessMap.toJSON(e).uuid),
        this.emissiveMap && this.emissiveMap.isTexture && (o.emissiveMap = this.emissiveMap.toJSON(e).uuid),
        this.specularMap && this.specularMap.isTexture && (o.specularMap = this.specularMap.toJSON(e).uuid),
        this.specularIntensityMap && this.specularIntensityMap.isTexture && (o.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
        this.specularColorMap && this.specularColorMap.isTexture && (o.specularColorMap = this.specularColorMap.toJSON(e).uuid),
        this.envMap && this.envMap.isTexture && (o.envMap = this.envMap.toJSON(e).uuid,
        this.combine !== void 0 && (o.combine = this.combine)),
        this.envMapIntensity !== void 0 && (o.envMapIntensity = this.envMapIntensity),
        this.reflectivity !== void 0 && (o.reflectivity = this.reflectivity),
        this.refractionRatio !== void 0 && (o.refractionRatio = this.refractionRatio),
        this.gradientMap && this.gradientMap.isTexture && (o.gradientMap = this.gradientMap.toJSON(e).uuid),
        this.transmission !== void 0 && (o.transmission = this.transmission),
        this.transmissionMap && this.transmissionMap.isTexture && (o.transmissionMap = this.transmissionMap.toJSON(e).uuid),
        this.thickness !== void 0 && (o.thickness = this.thickness),
        this.thicknessMap && this.thicknessMap.isTexture && (o.thicknessMap = this.thicknessMap.toJSON(e).uuid),
        this.attenuationDistance !== void 0 && (o.attenuationDistance = this.attenuationDistance),
        this.attenuationColor !== void 0 && (o.attenuationColor = this.attenuationColor.getHex()),
        this.size !== void 0 && (o.size = this.size),
        this.shadowSide !== null && (o.shadowSide = this.shadowSide),
        this.sizeAttenuation !== void 0 && (o.sizeAttenuation = this.sizeAttenuation),
        this.blending !== Nu && (o.blending = this.blending),
        this.side !== Md && (o.side = this.side),
        this.vertexColors && (o.vertexColors = !0),
        this.opacity < 1 && (o.opacity = this.opacity),
        this.transparent === !0 && (o.transparent = this.transparent),
        o.depthFunc = this.depthFunc,
        o.depthTest = this.depthTest,
        o.depthWrite = this.depthWrite,
        o.colorWrite = this.colorWrite,
        o.stencilWrite = this.stencilWrite,
        o.stencilWriteMask = this.stencilWriteMask,
        o.stencilFunc = this.stencilFunc,
        o.stencilRef = this.stencilRef,
        o.stencilFuncMask = this.stencilFuncMask,
        o.stencilFail = this.stencilFail,
        o.stencilZFail = this.stencilZFail,
        o.stencilZPass = this.stencilZPass,
        this.rotation !== void 0 && this.rotation !== 0 && (o.rotation = this.rotation),
        this.polygonOffset === !0 && (o.polygonOffset = !0),
        this.polygonOffsetFactor !== 0 && (o.polygonOffsetFactor = this.polygonOffsetFactor),
        this.polygonOffsetUnits !== 0 && (o.polygonOffsetUnits = this.polygonOffsetUnits),
        this.linewidth !== void 0 && this.linewidth !== 1 && (o.linewidth = this.linewidth),
        this.dashSize !== void 0 && (o.dashSize = this.dashSize),
        this.gapSize !== void 0 && (o.gapSize = this.gapSize),
        this.scale !== void 0 && (o.scale = this.scale),
        this.dithering === !0 && (o.dithering = !0),
        this.alphaTest > 0 && (o.alphaTest = this.alphaTest),
        this.alphaToCoverage === !0 && (o.alphaToCoverage = this.alphaToCoverage),
        this.premultipliedAlpha === !0 && (o.premultipliedAlpha = this.premultipliedAlpha),
        this.wireframe === !0 && (o.wireframe = this.wireframe),
        this.wireframeLinewidth > 1 && (o.wireframeLinewidth = this.wireframeLinewidth),
        this.wireframeLinecap !== "round" && (o.wireframeLinecap = this.wireframeLinecap),
        this.wireframeLinejoin !== "round" && (o.wireframeLinejoin = this.wireframeLinejoin),
        this.flatShading === !0 && (o.flatShading = this.flatShading),
        this.visible === !1 && (o.visible = !1),
        this.toneMapped === !1 && (o.toneMapped = !1),
        JSON.stringify(this.userData) !== "{}" && (o.userData = this.userData);
        function c(d) {
            let p = [];
            for (let i in d) {
                let v = d[i];
                delete v.metadata,
                p.push(v)
            }
            return p
        }
        if (t) {
            let d = c(e.textures)
              , p = c(e.images);
            d.length > 0 && (o.textures = d),
            p.length > 0 && (o.images = p)
        }
        return o
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.name = e.name,
        this.fog = e.fog,
        this.blending = e.blending,
        this.side = e.side,
        this.vertexColors = e.vertexColors,
        this.opacity = e.opacity,
        this.transparent = e.transparent,
        this.blendSrc = e.blendSrc,
        this.blendDst = e.blendDst,
        this.blendEquation = e.blendEquation,
        this.blendSrcAlpha = e.blendSrcAlpha,
        this.blendDstAlpha = e.blendDstAlpha,
        this.blendEquationAlpha = e.blendEquationAlpha,
        this.depthFunc = e.depthFunc,
        this.depthTest = e.depthTest,
        this.depthWrite = e.depthWrite,
        this.stencilWriteMask = e.stencilWriteMask,
        this.stencilFunc = e.stencilFunc,
        this.stencilRef = e.stencilRef,
        this.stencilFuncMask = e.stencilFuncMask,
        this.stencilFail = e.stencilFail,
        this.stencilZFail = e.stencilZFail,
        this.stencilZPass = e.stencilZPass,
        this.stencilWrite = e.stencilWrite;
        let t = e.clippingPlanes
          , o = null;
        if (t !== null) {
            let c = t.length;
            o = new Array(c);
            for (let d = 0; d !== c; ++d)
                o[d] = t[d].clone()
        }
        return this.clippingPlanes = o,
        this.clipIntersection = e.clipIntersection,
        this.clipShadows = e.clipShadows,
        this.shadowSide = e.shadowSide,
        this.colorWrite = e.colorWrite,
        this.precision = e.precision,
        this.polygonOffset = e.polygonOffset,
        this.polygonOffsetFactor = e.polygonOffsetFactor,
        this.polygonOffsetUnits = e.polygonOffsetUnits,
        this.dithering = e.dithering,
        this.alphaTest = e.alphaTest,
        this.alphaToCoverage = e.alphaToCoverage,
        this.premultipliedAlpha = e.premultipliedAlpha,
        this.visible = e.visible,
        this.toneMapped = e.toneMapped,
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
    set needsUpdate(e) {
        e === !0 && this.version++
    }
}
;
wr.prototype.isMaterial = !0;
wr.fromType = function() {
    return null
}
;
var pc = class extends wr {
    constructor(e) {
        super();
        this.type = "MeshBasicMaterial",
        this.color = new In(16777215),
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.combine = um,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.specularMap = e.specularMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.combine = e.combine,
        this.reflectivity = e.reflectivity,
        this.refractionRatio = e.refractionRatio,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this
    }
}
;
pc.prototype.isMeshBasicMaterial = !0;
var Mr = new Oe
  , qy = new zt
  , or = class {
    constructor(e, t, o) {
        if (Array.isArray(e))
            throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.name = "",
        this.array = e,
        this.itemSize = t,
        this.count = e !== void 0 ? e.length / t : 0,
        this.normalized = o === !0,
        this.usage = Cd,
        this.updateRange = {
            offset: 0,
            count: -1
        },
        this.version = 0
    }
    onUploadCallback() {}
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    setUsage(e) {
        return this.usage = e,
        this
    }
    copy(e) {
        return this.name = e.name,
        this.array = new e.array.constructor(e.array),
        this.itemSize = e.itemSize,
        this.count = e.count,
        this.normalized = e.normalized,
        this.usage = e.usage,
        this
    }
    copyAt(e, t, o) {
        e *= this.itemSize,
        o *= t.itemSize;
        for (let c = 0, d = this.itemSize; c < d; c++)
            this.array[e + c] = t.array[o + c];
        return this
    }
    copyArray(e) {
        return this.array.set(e),
        this
    }
    copyColorsArray(e) {
        let t = this.array
          , o = 0;
        for (let c = 0, d = e.length; c < d; c++) {
            let p = e[c];
            p === void 0 && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", c),
            p = new In),
            t[o++] = p.r,
            t[o++] = p.g,
            t[o++] = p.b
        }
        return this
    }
    copyVector2sArray(e) {
        let t = this.array
          , o = 0;
        for (let c = 0, d = e.length; c < d; c++) {
            let p = e[c];
            p === void 0 && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", c),
            p = new zt),
            t[o++] = p.x,
            t[o++] = p.y
        }
        return this
    }
    copyVector3sArray(e) {
        let t = this.array
          , o = 0;
        for (let c = 0, d = e.length; c < d; c++) {
            let p = e[c];
            p === void 0 && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", c),
            p = new Oe),
            t[o++] = p.x,
            t[o++] = p.y,
            t[o++] = p.z
        }
        return this
    }
    copyVector4sArray(e) {
        let t = this.array
          , o = 0;
        for (let c = 0, d = e.length; c < d; c++) {
            let p = e[c];
            p === void 0 && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", c),
            p = new Ui),
            t[o++] = p.x,
            t[o++] = p.y,
            t[o++] = p.z,
            t[o++] = p.w
        }
        return this
    }
    applyMatrix3(e) {
        if (this.itemSize === 2)
            for (let t = 0, o = this.count; t < o; t++)
                qy.fromBufferAttribute(this, t),
                qy.applyMatrix3(e),
                this.setXY(t, qy.x, qy.y);
        else if (this.itemSize === 3)
            for (let t = 0, o = this.count; t < o; t++)
                Mr.fromBufferAttribute(this, t),
                Mr.applyMatrix3(e),
                this.setXYZ(t, Mr.x, Mr.y, Mr.z);
        return this
    }
    applyMatrix4(e) {
        for (let t = 0, o = this.count; t < o; t++)
            Mr.fromBufferAttribute(this, t),
            Mr.applyMatrix4(e),
            this.setXYZ(t, Mr.x, Mr.y, Mr.z);
        return this
    }
    applyNormalMatrix(e) {
        for (let t = 0, o = this.count; t < o; t++)
            Mr.fromBufferAttribute(this, t),
            Mr.applyNormalMatrix(e),
            this.setXYZ(t, Mr.x, Mr.y, Mr.z);
        return this
    }
    transformDirection(e) {
        for (let t = 0, o = this.count; t < o; t++)
            Mr.fromBufferAttribute(this, t),
            Mr.transformDirection(e),
            this.setXYZ(t, Mr.x, Mr.y, Mr.z);
        return this
    }
    set(e, t=0) {
        return this.array.set(e, t),
        this
    }
    getX(e) {
        return this.array[e * this.itemSize]
    }
    setX(e, t) {
        return this.array[e * this.itemSize] = t,
        this
    }
    getY(e) {
        return this.array[e * this.itemSize + 1]
    }
    setY(e, t) {
        return this.array[e * this.itemSize + 1] = t,
        this
    }
    getZ(e) {
        return this.array[e * this.itemSize + 2]
    }
    setZ(e, t) {
        return this.array[e * this.itemSize + 2] = t,
        this
    }
    getW(e) {
        return this.array[e * this.itemSize + 3]
    }
    setW(e, t) {
        return this.array[e * this.itemSize + 3] = t,
        this
    }
    setXY(e, t, o) {
        return e *= this.itemSize,
        this.array[e + 0] = t,
        this.array[e + 1] = o,
        this
    }
    setXYZ(e, t, o, c) {
        return e *= this.itemSize,
        this.array[e + 0] = t,
        this.array[e + 1] = o,
        this.array[e + 2] = c,
        this
    }
    setXYZW(e, t, o, c, d) {
        return e *= this.itemSize,
        this.array[e + 0] = t,
        this.array[e + 1] = o,
        this.array[e + 2] = c,
        this.array[e + 3] = d,
        this
    }
    onUpload(e) {
        return this.onUploadCallback = e,
        this
    }
    clone() {
        return new this.constructor(this.array,this.itemSize).copy(this)
    }
    toJSON() {
        let e = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.prototype.slice.call(this.array),
            normalized: this.normalized
        };
        return this.name !== "" && (e.name = this.name),
        this.usage !== Cd && (e.usage = this.usage),
        (this.updateRange.offset !== 0 || this.updateRange.count !== -1) && (e.updateRange = this.updateRange),
        e
    }
}
;
or.prototype.isBufferAttribute = !0;
var Ky = class extends or {
    constructor(e, t, o) {
        super(new Uint16Array(e), t, o)
    }
}
;
var Yy = class extends or {
    constructor(e, t, o) {
        super(new Uint32Array(e), t, o)
    }
}
  , sb = class extends or {
    constructor(e, t, o) {
        super(new Uint16Array(e), t, o)
    }
}
;
sb.prototype.isFloat16BufferAttribute = !0;
var xr = class extends or {
    constructor(e, t, o) {
        super(new Float32Array(e), t, o)
    }
}
;
var Vz = 0
  , wo = new Fn
  , ob = new Ai
  , Ud = new Oe
  , so = new io
  , wm = new io
  , ss = new Oe
  , Vi = class extends Bo {
    constructor() {
        super();
        Object.defineProperty(this, "id", {
            value: Vz++
        }),
        this.uuid = Uo(),
        this.name = "",
        this.type = "BufferGeometry",
        this.index = null,
        this.attributes = {},
        this.morphAttributes = {},
        this.morphTargetsRelative = !1,
        this.groups = [],
        this.boundingBox = null,
        this.boundingSphere = null,
        this.drawRange = {
            start: 0,
            count: Infinity
        },
        this.userData = {}
    }
    getIndex() {
        return this.index
    }
    setIndex(e) {
        return Array.isArray(e) ? this.index = new (h2(e) ? Yy : Ky)(e,1) : this.index = e,
        this
    }
    getAttribute(e) {
        return this.attributes[e]
    }
    setAttribute(e, t) {
        return this.attributes[e] = t,
        this
    }
    deleteAttribute(e) {
        return delete this.attributes[e],
        this
    }
    hasAttribute(e) {
        return this.attributes[e] !== void 0
    }
    addGroup(e, t, o=0) {
        this.groups.push({
            start: e,
            count: t,
            materialIndex: o
        })
    }
    clearGroups() {
        this.groups = []
    }
    setDrawRange(e, t) {
        this.drawRange.start = e,
        this.drawRange.count = t
    }
    applyMatrix4(e) {
        let t = this.attributes.position;
        t !== void 0 && (t.applyMatrix4(e),
        t.needsUpdate = !0);
        let o = this.attributes.normal;
        if (o !== void 0) {
            let d = new Fr().getNormalMatrix(e);
            o.applyNormalMatrix(d),
            o.needsUpdate = !0
        }
        let c = this.attributes.tangent;
        return c !== void 0 && (c.transformDirection(e),
        c.needsUpdate = !0),
        this.boundingBox !== null && this.computeBoundingBox(),
        this.boundingSphere !== null && this.computeBoundingSphere(),
        this
    }
    applyQuaternion(e) {
        return wo.makeRotationFromQuaternion(e),
        this.applyMatrix4(wo),
        this
    }
    rotateX(e) {
        return wo.makeRotationX(e),
        this.applyMatrix4(wo),
        this
    }
    rotateY(e) {
        return wo.makeRotationY(e),
        this.applyMatrix4(wo),
        this
    }
    rotateZ(e) {
        return wo.makeRotationZ(e),
        this.applyMatrix4(wo),
        this
    }
    translate(e, t, o) {
        return wo.makeTranslation(e, t, o),
        this.applyMatrix4(wo),
        this
    }
    scale(e, t, o) {
        return wo.makeScale(e, t, o),
        this.applyMatrix4(wo),
        this
    }
    lookAt(e) {
        return ob.lookAt(e),
        ob.updateMatrix(),
        this.applyMatrix4(ob.matrix),
        this
    }
    center() {
        return this.computeBoundingBox(),
        this.boundingBox.getCenter(Ud).negate(),
        this.translate(Ud.x, Ud.y, Ud.z),
        this
    }
    setFromPoints(e) {
        let t = [];
        for (let o = 0, c = e.length; o < c; o++) {
            let d = e[o];
            t.push(d.x, d.y, d.z || 0)
        }
        return this.setAttribute("position", new xr(t,3)),
        this
    }
    computeBoundingBox() {
        this.boundingBox === null && (this.boundingBox = new io);
        let e = this.attributes.position
          , t = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute) {
            console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this),
            this.boundingBox.set(new Oe(-Infinity,-Infinity,-Infinity), new Oe(Infinity,Infinity,Infinity));
            return
        }
        if (e !== void 0) {
            if (this.boundingBox.setFromBufferAttribute(e),
            t)
                for (let o = 0, c = t.length; o < c; o++) {
                    let d = t[o];
                    so.setFromBufferAttribute(d),
                    this.morphTargetsRelative ? (ss.addVectors(this.boundingBox.min, so.min),
                    this.boundingBox.expandByPoint(ss),
                    ss.addVectors(this.boundingBox.max, so.max),
                    this.boundingBox.expandByPoint(ss)) : (this.boundingBox.expandByPoint(so.min),
                    this.boundingBox.expandByPoint(so.max))
                }
        } else
            this.boundingBox.makeEmpty();
        (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
    }
    computeBoundingSphere() {
        this.boundingSphere === null && (this.boundingSphere = new uc);
        let e = this.attributes.position
          , t = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute) {
            console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this),
            this.boundingSphere.set(new Oe, Infinity);
            return
        }
        if (e) {
            let o = this.boundingSphere.center;
            if (so.setFromBufferAttribute(e),
            t)
                for (let d = 0, p = t.length; d < p; d++) {
                    let i = t[d];
                    wm.setFromBufferAttribute(i),
                    this.morphTargetsRelative ? (ss.addVectors(so.min, wm.min),
                    so.expandByPoint(ss),
                    ss.addVectors(so.max, wm.max),
                    so.expandByPoint(ss)) : (so.expandByPoint(wm.min),
                    so.expandByPoint(wm.max))
                }
            so.getCenter(o);
            let c = 0;
            for (let d = 0, p = e.count; d < p; d++)
                ss.fromBufferAttribute(e, d),
                c = Math.max(c, o.distanceToSquared(ss));
            if (t)
                for (let d = 0, p = t.length; d < p; d++) {
                    let i = t[d]
                      , v = this.morphTargetsRelative;
                    for (let x = 0, E = i.count; x < E; x++)
                        ss.fromBufferAttribute(i, x),
                        v && (Ud.fromBufferAttribute(e, x),
                        ss.add(Ud)),
                        c = Math.max(c, o.distanceToSquared(ss))
                }
            this.boundingSphere.radius = Math.sqrt(c),
            isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
        }
    }
    computeTangents() {
        let e = this.index
          , t = this.attributes;
        if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
            console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
            return
        }
        let o = e.array
          , c = t.position.array
          , d = t.normal.array
          , p = t.uv.array
          , i = c.length / 3;
        this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new or(new Float32Array(4 * i),4));
        let v = this.getAttribute("tangent").array
          , x = []
          , E = [];
        for (let ee = 0; ee < i; ee++)
            x[ee] = new Oe,
            E[ee] = new Oe;
        let A = new Oe
          , C = new Oe
          , I = new Oe
          , D = new zt
          , P = new zt
          , k = new zt
          , U = new Oe
          , Z = new Oe;
        function K(ee, j, ne) {
            A.fromArray(c, ee * 3),
            C.fromArray(c, j * 3),
            I.fromArray(c, ne * 3),
            D.fromArray(p, ee * 2),
            P.fromArray(p, j * 2),
            k.fromArray(p, ne * 2),
            C.sub(A),
            I.sub(A),
            P.sub(D),
            k.sub(D);
            let be = 1 / (P.x * k.y - k.x * P.y);
            !isFinite(be) || (U.copy(C).multiplyScalar(k.y).addScaledVector(I, -P.y).multiplyScalar(be),
            Z.copy(I).multiplyScalar(P.x).addScaledVector(C, -k.x).multiplyScalar(be),
            x[ee].add(U),
            x[j].add(U),
            x[ne].add(U),
            E[ee].add(Z),
            E[j].add(Z),
            E[ne].add(Z))
        }
        let X = this.groups;
        X.length === 0 && (X = [{
            start: 0,
            count: o.length
        }]);
        for (let ee = 0, j = X.length; ee < j; ++ee) {
            let ne = X[ee]
              , be = ne.start
              , te = ne.count;
            for (let ae = be, se = be + te; ae < se; ae += 3)
                K(o[ae + 0], o[ae + 1], o[ae + 2])
        }
        let W = new Oe
          , fe = new Oe
          , ce = new Oe
          , _e = new Oe;
        function oe(ee) {
            ce.fromArray(d, ee * 3),
            _e.copy(ce);
            let j = x[ee];
            W.copy(j),
            W.sub(ce.multiplyScalar(ce.dot(j))).normalize(),
            fe.crossVectors(_e, j);
            let be = fe.dot(E[ee]) < 0 ? -1 : 1;
            v[ee * 4] = W.x,
            v[ee * 4 + 1] = W.y,
            v[ee * 4 + 2] = W.z,
            v[ee * 4 + 3] = be
        }
        for (let ee = 0, j = X.length; ee < j; ++ee) {
            let ne = X[ee]
              , be = ne.start
              , te = ne.count;
            for (let ae = be, se = be + te; ae < se; ae += 3)
                oe(o[ae + 0]),
                oe(o[ae + 1]),
                oe(o[ae + 2])
        }
    }
    computeVertexNormals() {
        let e = this.index
          , t = this.getAttribute("position");
        if (t !== void 0) {
            let o = this.getAttribute("normal");
            if (o === void 0)
                o = new or(new Float32Array(t.count * 3),3),
                this.setAttribute("normal", o);
            else
                for (let C = 0, I = o.count; C < I; C++)
                    o.setXYZ(C, 0, 0, 0);
            let c = new Oe
              , d = new Oe
              , p = new Oe
              , i = new Oe
              , v = new Oe
              , x = new Oe
              , E = new Oe
              , A = new Oe;
            if (e)
                for (let C = 0, I = e.count; C < I; C += 3) {
                    let D = e.getX(C + 0)
                      , P = e.getX(C + 1)
                      , k = e.getX(C + 2);
                    c.fromBufferAttribute(t, D),
                    d.fromBufferAttribute(t, P),
                    p.fromBufferAttribute(t, k),
                    E.subVectors(p, d),
                    A.subVectors(c, d),
                    E.cross(A),
                    i.fromBufferAttribute(o, D),
                    v.fromBufferAttribute(o, P),
                    x.fromBufferAttribute(o, k),
                    i.add(E),
                    v.add(E),
                    x.add(E),
                    o.setXYZ(D, i.x, i.y, i.z),
                    o.setXYZ(P, v.x, v.y, v.z),
                    o.setXYZ(k, x.x, x.y, x.z)
                }
            else
                for (let C = 0, I = t.count; C < I; C += 3)
                    c.fromBufferAttribute(t, C + 0),
                    d.fromBufferAttribute(t, C + 1),
                    p.fromBufferAttribute(t, C + 2),
                    E.subVectors(p, d),
                    A.subVectors(c, d),
                    E.cross(A),
                    o.setXYZ(C + 0, E.x, E.y, E.z),
                    o.setXYZ(C + 1, E.x, E.y, E.z),
                    o.setXYZ(C + 2, E.x, E.y, E.z);
            this.normalizeNormals(),
            o.needsUpdate = !0
        }
    }
    merge(e, t) {
        if (!(e && e.isBufferGeometry)) {
            console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", e);
            return
        }
        t === void 0 && (t = 0,
        console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
        let o = this.attributes;
        for (let c in o) {
            if (e.attributes[c] === void 0)
                continue;
            let p = o[c].array
              , i = e.attributes[c]
              , v = i.array
              , x = i.itemSize * t
              , E = Math.min(v.length, p.length - x);
            for (let A = 0, C = x; A < E; A++,
            C++)
                p[C] = v[A]
        }
        return this
    }
    normalizeNormals() {
        let e = this.attributes.normal;
        for (let t = 0, o = e.count; t < o; t++)
            ss.fromBufferAttribute(e, t),
            ss.normalize(),
            e.setXYZ(t, ss.x, ss.y, ss.z)
    }
    toNonIndexed() {
        function e(i, v) {
            let x = i.array
              , E = i.itemSize
              , A = i.normalized
              , C = new x.constructor(v.length * E)
              , I = 0
              , D = 0;
            for (let P = 0, k = v.length; P < k; P++) {
                i.isInterleavedBufferAttribute ? I = v[P] * i.data.stride + i.offset : I = v[P] * E;
                for (let U = 0; U < E; U++)
                    C[D++] = x[I++]
            }
            return new or(C,E,A)
        }
        if (this.index === null)
            return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),
            this;
        let t = new Vi
          , o = this.index.array
          , c = this.attributes;
        for (let i in c) {
            let v = c[i]
              , x = e(v, o);
            t.setAttribute(i, x)
        }
        let d = this.morphAttributes;
        for (let i in d) {
            let v = []
              , x = d[i];
            for (let E = 0, A = x.length; E < A; E++) {
                let C = x[E]
                  , I = e(C, o);
                v.push(I)
            }
            t.morphAttributes[i] = v
        }
        t.morphTargetsRelative = this.morphTargetsRelative;
        let p = this.groups;
        for (let i = 0, v = p.length; i < v; i++) {
            let x = p[i];
            t.addGroup(x.start, x.count, x.materialIndex)
        }
        return t
    }
    toJSON() {
        let e = {
            metadata: {
                version: 4.5,
                type: "BufferGeometry",
                generator: "BufferGeometry.toJSON"
            }
        };
        if (e.uuid = this.uuid,
        e.type = this.type,
        this.name !== "" && (e.name = this.name),
        Object.keys(this.userData).length > 0 && (e.userData = this.userData),
        this.parameters !== void 0) {
            let v = this.parameters;
            for (let x in v)
                v[x] !== void 0 && (e[x] = v[x]);
            return e
        }
        e.data = {
            attributes: {}
        };
        let t = this.index;
        t !== null && (e.data.index = {
            type: t.array.constructor.name,
            array: Array.prototype.slice.call(t.array)
        });
        let o = this.attributes;
        for (let v in o) {
            let x = o[v];
            e.data.attributes[v] = x.toJSON(e.data)
        }
        let c = {}
          , d = !1;
        for (let v in this.morphAttributes) {
            let x = this.morphAttributes[v]
              , E = [];
            for (let A = 0, C = x.length; A < C; A++) {
                let I = x[A];
                E.push(I.toJSON(e.data))
            }
            E.length > 0 && (c[v] = E,
            d = !0)
        }
        d && (e.data.morphAttributes = c,
        e.data.morphTargetsRelative = this.morphTargetsRelative);
        let p = this.groups;
        p.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(p)));
        let i = this.boundingSphere;
        return i !== null && (e.data.boundingSphere = {
            center: i.center.toArray(),
            radius: i.radius
        }),
        e
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.index = null,
        this.attributes = {},
        this.morphAttributes = {},
        this.groups = [],
        this.boundingBox = null,
        this.boundingSphere = null;
        let t = {};
        this.name = e.name;
        let o = e.index;
        o !== null && this.setIndex(o.clone(t));
        let c = e.attributes;
        for (let x in c) {
            let E = c[x];
            this.setAttribute(x, E.clone(t))
        }
        let d = e.morphAttributes;
        for (let x in d) {
            let E = []
              , A = d[x];
            for (let C = 0, I = A.length; C < I; C++)
                E.push(A[C].clone(t));
            this.morphAttributes[x] = E
        }
        this.morphTargetsRelative = e.morphTargetsRelative;
        let p = e.groups;
        for (let x = 0, E = p.length; x < E; x++) {
            let A = p[x];
            this.addGroup(A.start, A.count, A.materialIndex)
        }
        let i = e.boundingBox;
        i !== null && (this.boundingBox = i.clone());
        let v = e.boundingSphere;
        return v !== null && (this.boundingSphere = v.clone()),
        this.drawRange.start = e.drawRange.start,
        this.drawRange.count = e.drawRange.count,
        this.userData = e.userData,
        e.parameters !== void 0 && (this.parameters = Object.assign({}, e.parameters)),
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
;
Vi.prototype.isBufferGeometry = !0;
var T2 = new Fn
  , Vd = new dc
  , ab = new uc
  , mc = new Oe
  , gc = new Oe
  , _c = new Oe
  , lb = new Oe
  , cb = new Oe
  , ub = new Oe
  , Jy = new Oe
  , $y = new Oe
  , Qy = new Oe
  , e0 = new zt
  , t0 = new zt
  , n0 = new zt
  , hb = new Oe
  , i0 = new Oe
  , Ir = class extends Ai {
    constructor(e=new Vi, t=new pc) {
        super();
        this.type = "Mesh",
        this.geometry = e,
        this.material = t,
        this.updateMorphTargets()
    }
    copy(e) {
        return super.copy(e),
        e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
        e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)),
        this.material = e.material,
        this.geometry = e.geometry,
        this
    }
    updateMorphTargets() {
        let e = this.geometry;
        if (e.isBufferGeometry) {
            let t = e.morphAttributes
              , o = Object.keys(t);
            if (o.length > 0) {
                let c = t[o[0]];
                if (c !== void 0) {
                    this.morphTargetInfluences = [],
                    this.morphTargetDictionary = {};
                    for (let d = 0, p = c.length; d < p; d++) {
                        let i = c[d].name || String(d);
                        this.morphTargetInfluences.push(0),
                        this.morphTargetDictionary[i] = d
                    }
                }
            }
        } else {
            let t = e.morphTargets;
            t !== void 0 && t.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
        }
    }
    raycast(e, t) {
        let o = this.geometry
          , c = this.material
          , d = this.matrixWorld;
        if (c === void 0 || (o.boundingSphere === null && o.computeBoundingSphere(),
        ab.copy(o.boundingSphere),
        ab.applyMatrix4(d),
        e.ray.intersectsSphere(ab) === !1) || (T2.copy(d).invert(),
        Vd.copy(e.ray).applyMatrix4(T2),
        o.boundingBox !== null && Vd.intersectsBox(o.boundingBox) === !1))
            return;
        let p;
        if (o.isBufferGeometry) {
            let i = o.index
              , v = o.attributes.position
              , x = o.morphAttributes.position
              , E = o.morphTargetsRelative
              , A = o.attributes.uv
              , C = o.attributes.uv2
              , I = o.groups
              , D = o.drawRange;
            if (i !== null)
                if (Array.isArray(c))
                    for (let P = 0, k = I.length; P < k; P++) {
                        let U = I[P]
                          , Z = c[U.materialIndex]
                          , K = Math.max(U.start, D.start)
                          , X = Math.min(i.count, Math.min(U.start + U.count, D.start + D.count));
                        for (let W = K, fe = X; W < fe; W += 3) {
                            let ce = i.getX(W)
                              , _e = i.getX(W + 1)
                              , oe = i.getX(W + 2);
                            p = r0(this, Z, e, Vd, v, x, E, A, C, ce, _e, oe),
                            p && (p.faceIndex = Math.floor(W / 3),
                            p.face.materialIndex = U.materialIndex,
                            t.push(p))
                        }
                    }
                else {
                    let P = Math.max(0, D.start)
                      , k = Math.min(i.count, D.start + D.count);
                    for (let U = P, Z = k; U < Z; U += 3) {
                        let K = i.getX(U)
                          , X = i.getX(U + 1)
                          , W = i.getX(U + 2);
                        p = r0(this, c, e, Vd, v, x, E, A, C, K, X, W),
                        p && (p.faceIndex = Math.floor(U / 3),
                        t.push(p))
                    }
                }
            else if (v !== void 0)
                if (Array.isArray(c))
                    for (let P = 0, k = I.length; P < k; P++) {
                        let U = I[P]
                          , Z = c[U.materialIndex]
                          , K = Math.max(U.start, D.start)
                          , X = Math.min(v.count, Math.min(U.start + U.count, D.start + D.count));
                        for (let W = K, fe = X; W < fe; W += 3) {
                            let ce = W
                              , _e = W + 1
                              , oe = W + 2;
                            p = r0(this, Z, e, Vd, v, x, E, A, C, ce, _e, oe),
                            p && (p.faceIndex = Math.floor(W / 3),
                            p.face.materialIndex = U.materialIndex,
                            t.push(p))
                        }
                    }
                else {
                    let P = Math.max(0, D.start)
                      , k = Math.min(v.count, D.start + D.count);
                    for (let U = P, Z = k; U < Z; U += 3) {
                        let K = U
                          , X = U + 1
                          , W = U + 2;
                        p = r0(this, c, e, Vd, v, x, E, A, C, K, X, W),
                        p && (p.faceIndex = Math.floor(U / 3),
                        t.push(p))
                    }
                }
        } else
            o.isGeometry && console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
    }
}
;
Ir.prototype.isMesh = !0;
function Gz(r, e, t, o, c, d, p, i) {
    let v;
    if (e.side === Zs ? v = o.intersectTriangle(p, d, c, !0, i) : v = o.intersectTriangle(c, d, p, e.side !== $a, i),
    v === null)
        return null;
    i0.copy(i),
    i0.applyMatrix4(r.matrixWorld);
    let x = t.ray.origin.distanceTo(i0);
    return x < t.near || x > t.far ? null : {
        distance: x,
        point: i0.clone(),
        object: r
    }
}
function r0(r, e, t, o, c, d, p, i, v, x, E, A) {
    mc.fromBufferAttribute(c, x),
    gc.fromBufferAttribute(c, E),
    _c.fromBufferAttribute(c, A);
    let C = r.morphTargetInfluences;
    if (d && C) {
        Jy.set(0, 0, 0),
        $y.set(0, 0, 0),
        Qy.set(0, 0, 0);
        for (let D = 0, P = d.length; D < P; D++) {
            let k = C[D]
              , U = d[D];
            k !== 0 && (lb.fromBufferAttribute(U, x),
            cb.fromBufferAttribute(U, E),
            ub.fromBufferAttribute(U, A),
            p ? (Jy.addScaledVector(lb, k),
            $y.addScaledVector(cb, k),
            Qy.addScaledVector(ub, k)) : (Jy.addScaledVector(lb.sub(mc), k),
            $y.addScaledVector(cb.sub(gc), k),
            Qy.addScaledVector(ub.sub(_c), k)))
        }
        mc.add(Jy),
        gc.add($y),
        _c.add(Qy)
    }
    r.isSkinnedMesh && (r.boneTransform(x, mc),
    r.boneTransform(E, gc),
    r.boneTransform(A, _c));
    let I = Gz(r, e, t, o, mc, gc, _c, hb);
    if (I) {
        i && (e0.fromBufferAttribute(i, x),
        t0.fromBufferAttribute(i, E),
        n0.fromBufferAttribute(i, A),
        I.uv = yr.getUV(hb, mc, gc, _c, e0, t0, n0, new zt)),
        v && (e0.fromBufferAttribute(v, x),
        t0.fromBufferAttribute(v, E),
        n0.fromBufferAttribute(v, A),
        I.uv2 = yr.getUV(hb, mc, gc, _c, e0, t0, n0, new zt));
        let D = {
            a: x,
            b: E,
            c: A,
            normal: new Oe,
            materialIndex: 0
        };
        yr.getNormal(mc, gc, _c, D.normal),
        I.face = D
    }
    return I
}
var va = class extends Vi {
    constructor(e=1, t=1, o=1, c=1, d=1, p=1) {
        super();
        this.type = "BoxGeometry",
        this.parameters = {
            width: e,
            height: t,
            depth: o,
            widthSegments: c,
            heightSegments: d,
            depthSegments: p
        };
        let i = this;
        c = Math.floor(c),
        d = Math.floor(d),
        p = Math.floor(p);
        let v = []
          , x = []
          , E = []
          , A = []
          , C = 0
          , I = 0;
        D("z", "y", "x", -1, -1, o, t, e, p, d, 0),
        D("z", "y", "x", 1, -1, o, t, -e, p, d, 1),
        D("x", "z", "y", 1, 1, e, o, t, c, p, 2),
        D("x", "z", "y", 1, -1, e, o, -t, c, p, 3),
        D("x", "y", "z", 1, -1, e, t, o, c, d, 4),
        D("x", "y", "z", -1, -1, e, t, -o, c, d, 5),
        this.setIndex(v),
        this.setAttribute("position", new xr(x,3)),
        this.setAttribute("normal", new xr(E,3)),
        this.setAttribute("uv", new xr(A,2));
        function D(P, k, U, Z, K, X, W, fe, ce, _e, oe) {
            let ee = X / ce
              , j = W / _e
              , ne = X / 2
              , be = W / 2
              , te = fe / 2
              , ae = ce + 1
              , se = _e + 1
              , ke = 0
              , Be = 0
              , tt = new Oe;
            for (let Ke = 0; Ke < se; Ke++) {
                let bt = Ke * j - be;
                for (let Et = 0; Et < ae; Et++) {
                    let Gt = Et * ee - ne;
                    tt[P] = Gt * Z,
                    tt[k] = bt * K,
                    tt[U] = te,
                    x.push(tt.x, tt.y, tt.z),
                    tt[P] = 0,
                    tt[k] = 0,
                    tt[U] = fe > 0 ? 1 : -1,
                    E.push(tt.x, tt.y, tt.z),
                    A.push(Et / ce),
                    A.push(1 - Ke / _e),
                    ke += 1
                }
            }
            for (let Ke = 0; Ke < _e; Ke++)
                for (let bt = 0; bt < ce; bt++) {
                    let Et = C + bt + ae * Ke
                      , Gt = C + bt + ae * (Ke + 1)
                      , Ye = C + (bt + 1) + ae * (Ke + 1)
                      , gn = C + (bt + 1) + ae * Ke;
                    v.push(Et, Gt, gn),
                    v.push(Gt, Ye, gn),
                    Be += 6
                }
            i.addGroup(I, Be, oe),
            I += Be,
            C += ke
        }
    }
    static fromJSON(e) {
        return new va(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)
    }
}
;
function Gd(r) {
    let e = {};
    for (let t in r) {
        e[t] = {};
        for (let o in r[t]) {
            let c = r[t][o];
            c && (c.isColor || c.isMatrix3 || c.isMatrix4 || c.isVector2 || c.isVector3 || c.isVector4 || c.isTexture || c.isQuaternion) ? e[t][o] = c.clone() : Array.isArray(c) ? e[t][o] = c.slice() : e[t][o] = c
        }
    }
    return e
}
function Ts(r) {
    let e = {};
    for (let t = 0; t < r.length; t++) {
        let o = Gd(r[t]);
        for (let c in o)
            e[c] = o[c]
    }
    return e
}
var E2 = {
    clone: Gd,
    merge: Ts
}
  , Hz = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`
  , Wz = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`
  , oo = class extends wr {
    constructor(e) {
        super();
        this.type = "ShaderMaterial",
        this.defines = {},
        this.uniforms = {},
        this.vertexShader = Hz,
        this.fragmentShader = Wz,
        this.linewidth = 1,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.fog = !1,
        this.lights = !1,
        this.clipping = !1,
        this.extensions = {
            derivatives: !1,
            fragDepth: !1,
            drawBuffers: !1,
            shaderTextureLOD: !1
        },
        this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv2: [0, 0]
        },
        this.index0AttributeName = void 0,
        this.uniformsNeedUpdate = !1,
        this.glslVersion = null,
        e !== void 0 && (e.attributes !== void 0 && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),
        this.setValues(e))
    }
    copy(e) {
        return super.copy(e),
        this.fragmentShader = e.fragmentShader,
        this.vertexShader = e.vertexShader,
        this.uniforms = Gd(e.uniforms),
        this.defines = Object.assign({}, e.defines),
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.lights = e.lights,
        this.clipping = e.clipping,
        this.extensions = Object.assign({}, e.extensions),
        this.glslVersion = e.glslVersion,
        this
    }
    toJSON(e) {
        let t = super.toJSON(e);
        t.glslVersion = this.glslVersion,
        t.uniforms = {};
        for (let c in this.uniforms) {
            let p = this.uniforms[c].value;
            p && p.isTexture ? t.uniforms[c] = {
                type: "t",
                value: p.toJSON(e).uuid
            } : p && p.isColor ? t.uniforms[c] = {
                type: "c",
                value: p.getHex()
            } : p && p.isVector2 ? t.uniforms[c] = {
                type: "v2",
                value: p.toArray()
            } : p && p.isVector3 ? t.uniforms[c] = {
                type: "v3",
                value: p.toArray()
            } : p && p.isVector4 ? t.uniforms[c] = {
                type: "v4",
                value: p.toArray()
            } : p && p.isMatrix3 ? t.uniforms[c] = {
                type: "m3",
                value: p.toArray()
            } : p && p.isMatrix4 ? t.uniforms[c] = {
                type: "m4",
                value: p.toArray()
            } : t.uniforms[c] = {
                value: p
            }
        }
        Object.keys(this.defines).length > 0 && (t.defines = this.defines),
        t.vertexShader = this.vertexShader,
        t.fragmentShader = this.fragmentShader;
        let o = {};
        for (let c in this.extensions)
            this.extensions[c] === !0 && (o[c] = !0);
        return Object.keys(o).length > 0 && (t.extensions = o),
        t
    }
}
;
oo.prototype.isShaderMaterial = !0;
var Tm = class extends Ai {
    constructor() {
        super();
        this.type = "Camera",
        this.matrixWorldInverse = new Fn,
        this.projectionMatrix = new Fn,
        this.projectionMatrixInverse = new Fn
    }
    copy(e, t) {
        return super.copy(e, t),
        this.matrixWorldInverse.copy(e.matrixWorldInverse),
        this.projectionMatrix.copy(e.projectionMatrix),
        this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
        this
    }
    getWorldDirection(e) {
        this.updateWorldMatrix(!0, !1);
        let t = this.matrixWorld.elements;
        return e.set(-t[8], -t[9], -t[10]).normalize()
    }
    updateMatrixWorld(e) {
        super.updateMatrixWorld(e),
        this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }
    updateWorldMatrix(e, t) {
        super.updateWorldMatrix(e, t),
        this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
;
Tm.prototype.isCamera = !0;
var os = class extends Tm {
    constructor(e=50, t=1, o=.1, c=2e3) {
        super();
        this.type = "PerspectiveCamera",
        this.fov = e,
        this.zoom = 1,
        this.near = o,
        this.far = c,
        this.focus = 10,
        this.aspect = t,
        this.view = null,
        this.filmGauge = 35,
        this.filmOffset = 0,
        this.updateProjectionMatrix()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.fov = e.fov,
        this.zoom = e.zoom,
        this.near = e.near,
        this.far = e.far,
        this.focus = e.focus,
        this.aspect = e.aspect,
        this.view = e.view === null ? null : Object.assign({}, e.view),
        this.filmGauge = e.filmGauge,
        this.filmOffset = e.filmOffset,
        this
    }
    setFocalLength(e) {
        let t = .5 * this.getFilmHeight() / e;
        this.fov = B1 * 2 * Math.atan(t),
        this.updateProjectionMatrix()
    }
    getFocalLength() {
        let e = Math.tan(F1 * .5 * this.fov);
        return .5 * this.getFilmHeight() / e
    }
    getEffectiveFOV() {
        return B1 * 2 * Math.atan(Math.tan(F1 * .5 * this.fov) / this.zoom)
    }
    getFilmWidth() {
        return this.filmGauge * Math.min(this.aspect, 1)
    }
    getFilmHeight() {
        return this.filmGauge / Math.max(this.aspect, 1)
    }
    setViewOffset(e, t, o, c, d, p) {
        this.aspect = e / t,
        this.view === null && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }),
        this.view.enabled = !0,
        this.view.fullWidth = e,
        this.view.fullHeight = t,
        this.view.offsetX = o,
        this.view.offsetY = c,
        this.view.width = d,
        this.view.height = p,
        this.updateProjectionMatrix()
    }
    clearViewOffset() {
        this.view !== null && (this.view.enabled = !1),
        this.updateProjectionMatrix()
    }
    updateProjectionMatrix() {
        let e = this.near
          , t = e * Math.tan(F1 * .5 * this.fov) / this.zoom
          , o = 2 * t
          , c = this.aspect * o
          , d = -.5 * c
          , p = this.view;
        if (this.view !== null && this.view.enabled) {
            let v = p.fullWidth
              , x = p.fullHeight;
            d += p.offsetX * c / v,
            t -= p.offsetY * o / x,
            c *= p.width / v,
            o *= p.height / x
        }
        let i = this.filmOffset;
        i !== 0 && (d += e * i / this.getFilmWidth()),
        this.projectionMatrix.makePerspective(d, d + c, t, t - o, e, this.far),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }
    toJSON(e) {
        let t = super.toJSON(e);
        return t.object.fov = this.fov,
        t.object.zoom = this.zoom,
        t.object.near = this.near,
        t.object.far = this.far,
        t.object.focus = this.focus,
        t.object.aspect = this.aspect,
        this.view !== null && (t.object.view = Object.assign({}, this.view)),
        t.object.filmGauge = this.filmGauge,
        t.object.filmOffset = this.filmOffset,
        t
    }
}
;
os.prototype.isPerspectiveCamera = !0;
var Hd = 90
  , Wd = 1
  , Em = class extends Ai {
    constructor(e, t, o) {
        super();
        if (this.type = "CubeCamera",
        o.isWebGLCubeRenderTarget !== !0) {
            console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
            return
        }
        this.renderTarget = o;
        let c = new os(Hd,Wd,e,t);
        c.layers = this.layers,
        c.up.set(0, -1, 0),
        c.lookAt(new Oe(1,0,0)),
        this.add(c);
        let d = new os(Hd,Wd,e,t);
        d.layers = this.layers,
        d.up.set(0, -1, 0),
        d.lookAt(new Oe(-1,0,0)),
        this.add(d);
        let p = new os(Hd,Wd,e,t);
        p.layers = this.layers,
        p.up.set(0, 0, 1),
        p.lookAt(new Oe(0,1,0)),
        this.add(p);
        let i = new os(Hd,Wd,e,t);
        i.layers = this.layers,
        i.up.set(0, 0, -1),
        i.lookAt(new Oe(0,-1,0)),
        this.add(i);
        let v = new os(Hd,Wd,e,t);
        v.layers = this.layers,
        v.up.set(0, -1, 0),
        v.lookAt(new Oe(0,0,1)),
        this.add(v);
        let x = new os(Hd,Wd,e,t);
        x.layers = this.layers,
        x.up.set(0, -1, 0),
        x.lookAt(new Oe(0,0,-1)),
        this.add(x)
    }
    update(e, t) {
        this.parent === null && this.updateMatrixWorld();
        let o = this.renderTarget
          , [c,d,p,i,v,x] = this.children
          , E = e.getRenderTarget()
          , A = e.outputEncoding
          , C = e.toneMapping
          , I = e.xr.enabled;
        e.outputEncoding = ya,
        e.toneMapping = _a,
        e.xr.enabled = !1;
        let D = o.texture.generateMipmaps;
        o.texture.generateMipmaps = !1,
        e.setRenderTarget(o, 0),
        e.render(t, c),
        e.setRenderTarget(o, 1),
        e.render(t, d),
        e.setRenderTarget(o, 2),
        e.render(t, p),
        e.setRenderTarget(o, 3),
        e.render(t, i),
        e.setRenderTarget(o, 4),
        e.render(t, v),
        o.texture.generateMipmaps = D,
        e.setRenderTarget(o, 5),
        e.render(t, x),
        e.setRenderTarget(E),
        e.outputEncoding = A,
        e.toneMapping = C,
        e.xr.enabled = I,
        o.texture.needsPMREMUpdate = !0
    }
}
  , jd = class extends Ar {
    constructor(e, t, o, c, d, p, i, v, x, E) {
        e = e !== void 0 ? e : [],
        t = t !== void 0 ? t : Bu,
        super(e, t, o, c, d, p, i, v, x, E),
        this.flipY = !1
    }
    get images() {
        return this.image
    }
    set images(e) {
        this.image = e
    }
}
;
jd.prototype.isCubeTexture = !0;
var s0 = class extends Cs {
    constructor(e, t={}) {
        super(e, e, t);
        let o = {
            width: e,
            height: e,
            depth: 1
        }
          , c = [o, o, o, o, o, o];
        this.texture = new jd(c,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.encoding),
        this.texture.isRenderTargetTexture = !0,
        this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : !1,
        this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : ns
    }
    fromEquirectangularTexture(e, t) {
        this.texture.type = t.type,
        this.texture.encoding = t.encoding,
        this.texture.generateMipmaps = t.generateMipmaps,
        this.texture.minFilter = t.minFilter,
        this.texture.magFilter = t.magFilter;
        let o = {
            uniforms: {
                tEquirect: {
                    value: null
                }
            },
            vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
            fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
        }
          , c = new va(5,5,5)
          , d = new oo({
            name: "CubemapFromEquirect",
            uniforms: Gd(o.uniforms),
            vertexShader: o.vertexShader,
            fragmentShader: o.fragmentShader,
            side: Zs,
            blending: Qa
        });
        d.uniforms.tEquirect.value = t;
        let p = new Ir(c,d)
          , i = t.minFilter;
        return t.minFilter === dm && (t.minFilter = ns),
        new Em(1,10,this).update(e, p),
        t.minFilter = i,
        p.geometry.dispose(),
        p.material.dispose(),
        this
    }
    clear(e, t, o, c) {
        let d = e.getRenderTarget();
        for (let p = 0; p < 6; p++)
            e.setRenderTarget(this, p),
            e.clear(t, o, c);
        e.setRenderTarget(d)
    }
}
;
s0.prototype.isWebGLCubeRenderTarget = !0;
var db = new Oe
  , jz = new Oe
  , Xz = new Fr
  , Wo = class {
    constructor(e=new Oe(1,0,0), t=0) {
        this.normal = e,
        this.constant = t
    }
    set(e, t) {
        return this.normal.copy(e),
        this.constant = t,
        this
    }
    setComponents(e, t, o, c) {
        return this.normal.set(e, t, o),
        this.constant = c,
        this
    }
    setFromNormalAndCoplanarPoint(e, t) {
        return this.normal.copy(e),
        this.constant = -t.dot(this.normal),
        this
    }
    setFromCoplanarPoints(e, t, o) {
        let c = db.subVectors(o, t).cross(jz.subVectors(e, t)).normalize();
        return this.setFromNormalAndCoplanarPoint(c, e),
        this
    }
    copy(e) {
        return this.normal.copy(e.normal),
        this.constant = e.constant,
        this
    }
    normalize() {
        let e = 1 / this.normal.length();
        return this.normal.multiplyScalar(e),
        this.constant *= e,
        this
    }
    negate() {
        return this.constant *= -1,
        this.normal.negate(),
        this
    }
    distanceToPoint(e) {
        return this.normal.dot(e) + this.constant
    }
    distanceToSphere(e) {
        return this.distanceToPoint(e.center) - e.radius
    }
    projectPoint(e, t) {
        return t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)
    }
    intersectLine(e, t) {
        let o = e.delta(db)
          , c = this.normal.dot(o);
        if (c === 0)
            return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
        let d = -(e.start.dot(this.normal) + this.constant) / c;
        return d < 0 || d > 1 ? null : t.copy(o).multiplyScalar(d).add(e.start)
    }
    intersectsLine(e) {
        let t = this.distanceToPoint(e.start)
          , o = this.distanceToPoint(e.end);
        return t < 0 && o > 0 || o < 0 && t > 0
    }
    intersectsBox(e) {
        return e.intersectsPlane(this)
    }
    intersectsSphere(e) {
        return e.intersectsPlane(this)
    }
    coplanarPoint(e) {
        return e.copy(this.normal).multiplyScalar(-this.constant)
    }
    applyMatrix4(e, t) {
        let o = t || Xz.getNormalMatrix(e)
          , c = this.coplanarPoint(db).applyMatrix4(e)
          , d = this.normal.applyMatrix3(o).normalize();
        return this.constant = -c.dot(d),
        this
    }
    translate(e) {
        return this.constant -= e.dot(this.normal),
        this
    }
    equals(e) {
        return e.normal.equals(this.normal) && e.constant === this.constant
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
;
Wo.prototype.isPlane = !0;
var Xd = new uc
  , o0 = new Oe
  , Zd = class {
    constructor(e=new Wo, t=new Wo, o=new Wo, c=new Wo, d=new Wo, p=new Wo) {
        this.planes = [e, t, o, c, d, p]
    }
    set(e, t, o, c, d, p) {
        let i = this.planes;
        return i[0].copy(e),
        i[1].copy(t),
        i[2].copy(o),
        i[3].copy(c),
        i[4].copy(d),
        i[5].copy(p),
        this
    }
    copy(e) {
        let t = this.planes;
        for (let o = 0; o < 6; o++)
            t[o].copy(e.planes[o]);
        return this
    }
    setFromProjectionMatrix(e) {
        let t = this.planes
          , o = e.elements
          , c = o[0]
          , d = o[1]
          , p = o[2]
          , i = o[3]
          , v = o[4]
          , x = o[5]
          , E = o[6]
          , A = o[7]
          , C = o[8]
          , I = o[9]
          , D = o[10]
          , P = o[11]
          , k = o[12]
          , U = o[13]
          , Z = o[14]
          , K = o[15];
        return t[0].setComponents(i - c, A - v, P - C, K - k).normalize(),
        t[1].setComponents(i + c, A + v, P + C, K + k).normalize(),
        t[2].setComponents(i + d, A + x, P + I, K + U).normalize(),
        t[3].setComponents(i - d, A - x, P - I, K - U).normalize(),
        t[4].setComponents(i - p, A - E, P - D, K - Z).normalize(),
        t[5].setComponents(i + p, A + E, P + D, K + Z).normalize(),
        this
    }
    intersectsObject(e) {
        let t = e.geometry;
        return t.boundingSphere === null && t.computeBoundingSphere(),
        Xd.copy(t.boundingSphere).applyMatrix4(e.matrixWorld),
        this.intersectsSphere(Xd)
    }
    intersectsSprite(e) {
        return Xd.center.set(0, 0, 0),
        Xd.radius = .7071067811865476,
        Xd.applyMatrix4(e.matrixWorld),
        this.intersectsSphere(Xd)
    }
    intersectsSphere(e) {
        let t = this.planes
          , o = e.center
          , c = -e.radius;
        for (let d = 0; d < 6; d++)
            if (t[d].distanceToPoint(o) < c)
                return !1;
        return !0
    }
    intersectsBox(e) {
        let t = this.planes;
        for (let o = 0; o < 6; o++) {
            let c = t[o];
            if (o0.x = c.normal.x > 0 ? e.max.x : e.min.x,
            o0.y = c.normal.y > 0 ? e.max.y : e.min.y,
            o0.z = c.normal.z > 0 ? e.max.z : e.min.z,
            c.distanceToPoint(o0) < 0)
                return !1
        }
        return !0
    }
    containsPoint(e) {
        let t = this.planes;
        for (let o = 0; o < 6; o++)
            if (t[o].distanceToPoint(e) < 0)
                return !1;
        return !0
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
;
function S2() {
    let r = null
      , e = !1
      , t = null
      , o = null;
    function c(d, p) {
        t(d, p),
        o = r.requestAnimationFrame(c)
    }
    return {
        start: function() {
            e !== !0 && t !== null && (o = r.requestAnimationFrame(c),
            e = !0)
        },
        stop: function() {
            r.cancelAnimationFrame(o),
            e = !1
        },
        setAnimationLoop: function(d) {
            t = d
        },
        setContext: function(d) {
            r = d
        }
    }
}
function Zz(r, e) {
    let t = e.isWebGL2
      , o = new WeakMap;
    function c(x, E) {
        let A = x.array
          , C = x.usage
          , I = r.createBuffer();
        r.bindBuffer(E, I),
        r.bufferData(E, A, C),
        x.onUploadCallback();
        let D;
        if (A instanceof Float32Array)
            D = 5126;
        else if (A instanceof Uint16Array)
            if (x.isFloat16BufferAttribute)
                if (t)
                    D = 5131;
                else
                    throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
            else
                D = 5123;
        else if (A instanceof Int16Array)
            D = 5122;
        else if (A instanceof Uint32Array)
            D = 5125;
        else if (A instanceof Int32Array)
            D = 5124;
        else if (A instanceof Int8Array)
            D = 5120;
        else if (A instanceof Uint8Array)
            D = 5121;
        else if (A instanceof Uint8ClampedArray)
            D = 5121;
        else
            throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + A);
        return {
            buffer: I,
            type: D,
            bytesPerElement: A.BYTES_PER_ELEMENT,
            version: x.version
        }
    }
    function d(x, E, A) {
        let C = E.array
          , I = E.updateRange;
        r.bindBuffer(A, x),
        I.count === -1 ? r.bufferSubData(A, 0, C) : (t ? r.bufferSubData(A, I.offset * C.BYTES_PER_ELEMENT, C, I.offset, I.count) : r.bufferSubData(A, I.offset * C.BYTES_PER_ELEMENT, C.subarray(I.offset, I.offset + I.count)),
        I.count = -1)
    }
    function p(x) {
        return x.isInterleavedBufferAttribute && (x = x.data),
        o.get(x)
    }
    function i(x) {
        x.isInterleavedBufferAttribute && (x = x.data);
        let E = o.get(x);
        E && (r.deleteBuffer(E.buffer),
        o.delete(x))
    }
    function v(x, E) {
        if (x.isGLBufferAttribute) {
            let C = o.get(x);
            (!C || C.version < x.version) && o.set(x, {
                buffer: x.buffer,
                type: x.type,
                bytesPerElement: x.elementSize,
                version: x.version
            });
            return
        }
        x.isInterleavedBufferAttribute && (x = x.data);
        let A = o.get(x);
        A === void 0 ? o.set(x, c(x, E)) : A.version < x.version && (d(A.buffer, x, E),
        A.version = x.version)
    }
    return {
        get: p,
        remove: i,
        update: v
    }
}
var qd = class extends Vi {
    constructor(e=1, t=1, o=1, c=1) {
        super();
        this.type = "PlaneGeometry",
        this.parameters = {
            width: e,
            height: t,
            widthSegments: o,
            heightSegments: c
        };
        let d = e / 2
          , p = t / 2
          , i = Math.floor(o)
          , v = Math.floor(c)
          , x = i + 1
          , E = v + 1
          , A = e / i
          , C = t / v
          , I = []
          , D = []
          , P = []
          , k = [];
        for (let U = 0; U < E; U++) {
            let Z = U * C - p;
            for (let K = 0; K < x; K++) {
                let X = K * A - d;
                D.push(X, -Z, 0),
                P.push(0, 0, 1),
                k.push(K / i),
                k.push(1 - U / v)
            }
        }
        for (let U = 0; U < v; U++)
            for (let Z = 0; Z < i; Z++) {
                let K = Z + x * U
                  , X = Z + x * (U + 1)
                  , W = Z + 1 + x * (U + 1)
                  , fe = Z + 1 + x * U;
                I.push(K, X, fe),
                I.push(X, W, fe)
            }
        this.setIndex(I),
        this.setAttribute("position", new xr(D,3)),
        this.setAttribute("normal", new xr(P,3)),
        this.setAttribute("uv", new xr(k,2))
    }
    static fromJSON(e) {
        return new qd(e.width,e.height,e.widthSegments,e.heightSegments)
    }
}
  , qz = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`
  , Kz = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`
  , Yz = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`
  , Jz = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`
  , $z = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`
  , Qz = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`
  , eO = "vec3 transformed = vec3( position );"
  , tO = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`
  , nO = `vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif`
  , iO = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`
  , rO = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`
  , sO = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`
  , oO = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`
  , aO = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`
  , lO = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`
  , cO = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`
  , uO = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`
  , hO = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`
  , dO = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float linearToRelativeLuminance( const in vec3 color ) {
	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );
	return dot( weights, color.rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`
  , fO = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 ) + 0.5;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define r0 1.0
	#define v0 0.339
	#define m0 - 2.0
	#define r1 0.8
	#define v1 0.276
	#define m1 - 1.0
	#define r4 0.4
	#define v4 0.046
	#define m4 2.0
	#define r5 0.305
	#define v5 0.016
	#define m5 3.0
	#define r6 0.21
	#define v6 0.0038
	#define m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= r1 ) {
			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;
		} else if ( roughness >= r4 ) {
			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;
		} else if ( roughness >= r5 ) {
			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;
		} else if ( roughness >= r6 ) {
			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`
  , pO = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`
  , mO = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`
  , gO = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`
  , _O = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`
  , yO = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`
  , xO = "gl_FragColor = linearToOutputTexel( gl_FragColor );"
  , vO = `vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`
  , bO = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`
  , wO = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`
  , TO = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`
  , EO = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`
  , SO = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`
  , AO = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`
  , MO = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`
  , IO = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`
  , CO = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`
  , DO = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );
	#endif
}`
  , LO = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vUv2 );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`
  , RO = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`
  , PO = `vec3 diffuse = vec3( 1.0 );
GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );
GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;
vLightFront = vec3( 0.0 );
vIndirectFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
	vIndirectBack = vec3( 0.0 );
#endif
IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;
vIndirectFront += getAmbientLightIrradiance( ambientLightColor );
vIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );
#ifdef DOUBLE_SIDED
	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );
	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );
#endif
#if NUM_POINT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		getPointLightInfo( pointLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_SPOT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		getSpotLightInfo( spotLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_DIR_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_HEMI_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		#ifdef DOUBLE_SIDED
			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );
		#endif
	}
	#pragma unroll_loop_end
#endif`
  , kO = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( PHYSICALLY_CORRECT_LIGHTS )
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#else
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`
  , zO = `#if defined( USE_ENVMAP )
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`
  , OO = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`
  , NO = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
#define Material_LightProbeLOD( material )	(0)`
  , FO = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`
  , BO = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD( material )	(0)`
  , UO = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	#ifdef SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULARINTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;
		#endif
		#ifdef USE_SPECULARCOLORMAP
			specularColorFactor *= texture2D( specularColorMap, vUv ).rgb;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEENCOLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEENROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;
	#endif
#endif`
  , VO = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	vec3 FssEss = specularColor * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`
  , GO = `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`
  , HO = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`
  , WO = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`
  , jO = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`
  , XO = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`
  , ZO = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`
  , qO = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`
  , KO = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`
  , YO = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`
  , JO = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`
  , $O = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`
  , QO = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`
  , eN = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`
  , tN = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`
  , nN = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`
  , iN = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`
  , rN = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`
  , sN = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`
  , oN = `#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`
  , aN = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`
  , lN = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`
  , cN = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`
  , uN = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`
  , hN = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`
  , dN = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`
  , fN = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`
  , pN = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`
  , mN = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`
  , gN = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`
  , _N = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`
  , yN = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`
  , xN = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`
  , vN = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`
  , bN = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`
  , wN = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`
  , TN = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`
  , EN = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`
  , SN = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`
  , AN = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`
  , MN = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	#ifdef BONE_TEXTURE
		uniform highp sampler2D boneTexture;
		uniform int boneTextureSize;
		mat4 getBoneMatrix( const in float i ) {
			float j = i * 4.0;
			float x = mod( j, float( boneTextureSize ) );
			float y = floor( j / float( boneTextureSize ) );
			float dx = 1.0 / float( boneTextureSize );
			float dy = 1.0 / float( boneTextureSize );
			y = dy * ( y + 0.5 );
			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
			mat4 bone = mat4( v1, v2, v3, v4 );
			return bone;
		}
	#else
		uniform mat4 boneMatrices[ MAX_BONES ];
		mat4 getBoneMatrix( const in float i ) {
			mat4 bone = boneMatrices[ int(i) ];
			return bone;
		}
	#endif
#endif`
  , IN = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`
  , CN = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`
  , DN = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`
  , LN = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`
  , RN = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`
  , PN = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`
  , kN = `#ifdef USE_TRANSMISSION
	float transmissionAlpha = 1.0;
	float transmissionFactor = transmission;
	float thicknessFactor = thickness;
	#ifdef USE_TRANSMISSIONMAP
		transmissionFactor *= texture2D( transmissionMap, vUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		thicknessFactor *= texture2D( thicknessMap, vUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,
		attenuationColor, attenuationDistance );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );
	transmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );
#endif`
  , zN = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		#ifdef texture2DLodEXT
			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#else
			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#endif
	}
	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( attenuationDistance == 0.0 ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`
  , ON = `#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`
  , NN = `#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`
  , FN = `#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`
  , BN = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`
  , UN = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`
  , VN = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`
  , GN = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`
  , HN = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`
  , WN = `uniform sampler2D t2D;
varying vec2 vUv;
void main() {
	gl_FragColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		gl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );
	#endif
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`
  , jN = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`
  , XN = `#include <envmap_common_pars_fragment>
uniform float opacity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>
	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`
  , ZN = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`
  , qN = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`
  , KN = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`
  , YN = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`
  , JN = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`
  , $N = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`
  , QN = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`
  , eF = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`
  , tF = `#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`
  , nF = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , iF = `#define LAMBERT
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , rF = `uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>
	#ifdef DOUBLE_SIDED
		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;
	#else
		reflectedLight.indirectDiffuse += vIndirectFront;
	#endif
	#include <lightmap_fragment>
	reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );
	#ifdef DOUBLE_SIDED
		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;
	#else
		reflectedLight.directDiffuse = vLightFront;
	#endif
	reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , sF = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`
  , oF = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , aF = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`
  , lF = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`
  , cF = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , uF = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , hF = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`
  , dF = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULARINTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
	#ifdef USE_SPECULARCOLORMAP
		uniform sampler2D specularColorMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEENCOLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEENROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , fF = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , pF = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , mF = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`
  , gF = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`
  , _F = `#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , yF = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`
  , xF = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`
  , vF = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`
  , hi = {
    alphamap_fragment: qz,
    alphamap_pars_fragment: Kz,
    alphatest_fragment: Yz,
    alphatest_pars_fragment: Jz,
    aomap_fragment: $z,
    aomap_pars_fragment: Qz,
    begin_vertex: eO,
    beginnormal_vertex: tO,
    bsdfs: nO,
    bumpmap_pars_fragment: iO,
    clipping_planes_fragment: rO,
    clipping_planes_pars_fragment: sO,
    clipping_planes_pars_vertex: oO,
    clipping_planes_vertex: aO,
    color_fragment: lO,
    color_pars_fragment: cO,
    color_pars_vertex: uO,
    color_vertex: hO,
    common: dO,
    cube_uv_reflection_fragment: fO,
    defaultnormal_vertex: pO,
    displacementmap_pars_vertex: mO,
    displacementmap_vertex: gO,
    emissivemap_fragment: _O,
    emissivemap_pars_fragment: yO,
    encodings_fragment: xO,
    encodings_pars_fragment: vO,
    envmap_fragment: bO,
    envmap_common_pars_fragment: wO,
    envmap_pars_fragment: TO,
    envmap_pars_vertex: EO,
    envmap_physical_pars_fragment: zO,
    envmap_vertex: SO,
    fog_vertex: AO,
    fog_pars_vertex: MO,
    fog_fragment: IO,
    fog_pars_fragment: CO,
    gradientmap_pars_fragment: DO,
    lightmap_fragment: LO,
    lightmap_pars_fragment: RO,
    lights_lambert_vertex: PO,
    lights_pars_begin: kO,
    lights_toon_fragment: OO,
    lights_toon_pars_fragment: NO,
    lights_phong_fragment: FO,
    lights_phong_pars_fragment: BO,
    lights_physical_fragment: UO,
    lights_physical_pars_fragment: VO,
    lights_fragment_begin: GO,
    lights_fragment_maps: HO,
    lights_fragment_end: WO,
    logdepthbuf_fragment: jO,
    logdepthbuf_pars_fragment: XO,
    logdepthbuf_pars_vertex: ZO,
    logdepthbuf_vertex: qO,
    map_fragment: KO,
    map_pars_fragment: YO,
    map_particle_fragment: JO,
    map_particle_pars_fragment: $O,
    metalnessmap_fragment: QO,
    metalnessmap_pars_fragment: eN,
    morphcolor_vertex: tN,
    morphnormal_vertex: nN,
    morphtarget_pars_vertex: iN,
    morphtarget_vertex: rN,
    normal_fragment_begin: sN,
    normal_fragment_maps: oN,
    normal_pars_fragment: aN,
    normal_pars_vertex: lN,
    normal_vertex: cN,
    normalmap_pars_fragment: uN,
    clearcoat_normal_fragment_begin: hN,
    clearcoat_normal_fragment_maps: dN,
    clearcoat_pars_fragment: fN,
    output_fragment: pN,
    packing: mN,
    premultiplied_alpha_fragment: gN,
    project_vertex: _N,
    dithering_fragment: yN,
    dithering_pars_fragment: xN,
    roughnessmap_fragment: vN,
    roughnessmap_pars_fragment: bN,
    shadowmap_pars_fragment: wN,
    shadowmap_pars_vertex: TN,
    shadowmap_vertex: EN,
    shadowmask_pars_fragment: SN,
    skinbase_vertex: AN,
    skinning_pars_vertex: MN,
    skinning_vertex: IN,
    skinnormal_vertex: CN,
    specularmap_fragment: DN,
    specularmap_pars_fragment: LN,
    tonemapping_fragment: RN,
    tonemapping_pars_fragment: PN,
    transmission_fragment: kN,
    transmission_pars_fragment: zN,
    uv_pars_fragment: ON,
    uv_pars_vertex: NN,
    uv_vertex: FN,
    uv2_pars_fragment: BN,
    uv2_pars_vertex: UN,
    uv2_vertex: VN,
    worldpos_vertex: GN,
    background_vert: HN,
    background_frag: WN,
    cube_vert: jN,
    cube_frag: XN,
    depth_vert: ZN,
    depth_frag: qN,
    distanceRGBA_vert: KN,
    distanceRGBA_frag: YN,
    equirect_vert: JN,
    equirect_frag: $N,
    linedashed_vert: QN,
    linedashed_frag: eF,
    meshbasic_vert: tF,
    meshbasic_frag: nF,
    meshlambert_vert: iF,
    meshlambert_frag: rF,
    meshmatcap_vert: sF,
    meshmatcap_frag: oF,
    meshnormal_vert: aF,
    meshnormal_frag: lF,
    meshphong_vert: cF,
    meshphong_frag: uF,
    meshphysical_vert: hF,
    meshphysical_frag: dF,
    meshtoon_vert: fF,
    meshtoon_frag: pF,
    points_vert: mF,
    points_frag: gF,
    shadow_vert: _F,
    shadow_frag: yF,
    sprite_vert: xF,
    sprite_frag: vF
}
  , dn = {
    common: {
        diffuse: {
            value: new In(16777215)
        },
        opacity: {
            value: 1
        },
        map: {
            value: null
        },
        uvTransform: {
            value: new Fr
        },
        uv2Transform: {
            value: new Fr
        },
        alphaMap: {
            value: null
        },
        alphaTest: {
            value: 0
        }
    },
    specularmap: {
        specularMap: {
            value: null
        }
    },
    envmap: {
        envMap: {
            value: null
        },
        flipEnvMap: {
            value: -1
        },
        reflectivity: {
            value: 1
        },
        ior: {
            value: 1.5
        },
        refractionRatio: {
            value: .98
        }
    },
    aomap: {
        aoMap: {
            value: null
        },
        aoMapIntensity: {
            value: 1
        }
    },
    lightmap: {
        lightMap: {
            value: null
        },
        lightMapIntensity: {
            value: 1
        }
    },
    emissivemap: {
        emissiveMap: {
            value: null
        }
    },
    bumpmap: {
        bumpMap: {
            value: null
        },
        bumpScale: {
            value: 1
        }
    },
    normalmap: {
        normalMap: {
            value: null
        },
        normalScale: {
            value: new zt(1,1)
        }
    },
    displacementmap: {
        displacementMap: {
            value: null
        },
        displacementScale: {
            value: 1
        },
        displacementBias: {
            value: 0
        }
    },
    roughnessmap: {
        roughnessMap: {
            value: null
        }
    },
    metalnessmap: {
        metalnessMap: {
            value: null
        }
    },
    gradientmap: {
        gradientMap: {
            value: null
        }
    },
    fog: {
        fogDensity: {
            value: 25e-5
        },
        fogNear: {
            value: 1
        },
        fogFar: {
            value: 2e3
        },
        fogColor: {
            value: new In(16777215)
        }
    },
    lights: {
        ambientLightColor: {
            value: []
        },
        lightProbe: {
            value: []
        },
        directionalLights: {
            value: [],
            properties: {
                direction: {},
                color: {}
            }
        },
        directionalLightShadows: {
            value: [],
            properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            }
        },
        directionalShadowMap: {
            value: []
        },
        directionalShadowMatrix: {
            value: []
        },
        spotLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                direction: {},
                distance: {},
                coneCos: {},
                penumbraCos: {},
                decay: {}
            }
        },
        spotLightShadows: {
            value: [],
            properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            }
        },
        spotShadowMap: {
            value: []
        },
        spotShadowMatrix: {
            value: []
        },
        pointLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                decay: {},
                distance: {}
            }
        },
        pointLightShadows: {
            value: [],
            properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
                shadowCameraNear: {},
                shadowCameraFar: {}
            }
        },
        pointShadowMap: {
            value: []
        },
        pointShadowMatrix: {
            value: []
        },
        hemisphereLights: {
            value: [],
            properties: {
                direction: {},
                skyColor: {},
                groundColor: {}
            }
        },
        rectAreaLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                width: {},
                height: {}
            }
        },
        ltc_1: {
            value: null
        },
        ltc_2: {
            value: null
        }
    },
    points: {
        diffuse: {
            value: new In(16777215)
        },
        opacity: {
            value: 1
        },
        size: {
            value: 1
        },
        scale: {
            value: 1
        },
        map: {
            value: null
        },
        alphaMap: {
            value: null
        },
        alphaTest: {
            value: 0
        },
        uvTransform: {
            value: new Fr
        }
    },
    sprite: {
        diffuse: {
            value: new In(16777215)
        },
        opacity: {
            value: 1
        },
        center: {
            value: new zt(.5,.5)
        },
        rotation: {
            value: 0
        },
        map: {
            value: null
        },
        alphaMap: {
            value: null
        },
        alphaTest: {
            value: 0
        },
        uvTransform: {
            value: new Fr
        }
    }
}
  , jo = {
    basic: {
        uniforms: Ts([dn.common, dn.specularmap, dn.envmap, dn.aomap, dn.lightmap, dn.fog]),
        vertexShader: hi.meshbasic_vert,
        fragmentShader: hi.meshbasic_frag
    },
    lambert: {
        uniforms: Ts([dn.common, dn.specularmap, dn.envmap, dn.aomap, dn.lightmap, dn.emissivemap, dn.fog, dn.lights, {
            emissive: {
                value: new In(0)
            }
        }]),
        vertexShader: hi.meshlambert_vert,
        fragmentShader: hi.meshlambert_frag
    },
    phong: {
        uniforms: Ts([dn.common, dn.specularmap, dn.envmap, dn.aomap, dn.lightmap, dn.emissivemap, dn.bumpmap, dn.normalmap, dn.displacementmap, dn.fog, dn.lights, {
            emissive: {
                value: new In(0)
            },
            specular: {
                value: new In(1118481)
            },
            shininess: {
                value: 30
            }
        }]),
        vertexShader: hi.meshphong_vert,
        fragmentShader: hi.meshphong_frag
    },
    standard: {
        uniforms: Ts([dn.common, dn.envmap, dn.aomap, dn.lightmap, dn.emissivemap, dn.bumpmap, dn.normalmap, dn.displacementmap, dn.roughnessmap, dn.metalnessmap, dn.fog, dn.lights, {
            emissive: {
                value: new In(0)
            },
            roughness: {
                value: 1
            },
            metalness: {
                value: 0
            },
            envMapIntensity: {
                value: 1
            }
        }]),
        vertexShader: hi.meshphysical_vert,
        fragmentShader: hi.meshphysical_frag
    },
    toon: {
        uniforms: Ts([dn.common, dn.aomap, dn.lightmap, dn.emissivemap, dn.bumpmap, dn.normalmap, dn.displacementmap, dn.gradientmap, dn.fog, dn.lights, {
            emissive: {
                value: new In(0)
            }
        }]),
        vertexShader: hi.meshtoon_vert,
        fragmentShader: hi.meshtoon_frag
    },
    matcap: {
        uniforms: Ts([dn.common, dn.bumpmap, dn.normalmap, dn.displacementmap, dn.fog, {
            matcap: {
                value: null
            }
        }]),
        vertexShader: hi.meshmatcap_vert,
        fragmentShader: hi.meshmatcap_frag
    },
    points: {
        uniforms: Ts([dn.points, dn.fog]),
        vertexShader: hi.points_vert,
        fragmentShader: hi.points_frag
    },
    dashed: {
        uniforms: Ts([dn.common, dn.fog, {
            scale: {
                value: 1
            },
            dashSize: {
                value: 1
            },
            totalSize: {
                value: 2
            }
        }]),
        vertexShader: hi.linedashed_vert,
        fragmentShader: hi.linedashed_frag
    },
    depth: {
        uniforms: Ts([dn.common, dn.displacementmap]),
        vertexShader: hi.depth_vert,
        fragmentShader: hi.depth_frag
    },
    normal: {
        uniforms: Ts([dn.common, dn.bumpmap, dn.normalmap, dn.displacementmap, {
            opacity: {
                value: 1
            }
        }]),
        vertexShader: hi.meshnormal_vert,
        fragmentShader: hi.meshnormal_frag
    },
    sprite: {
        uniforms: Ts([dn.sprite, dn.fog]),
        vertexShader: hi.sprite_vert,
        fragmentShader: hi.sprite_frag
    },
    background: {
        uniforms: {
            uvTransform: {
                value: new Fr
            },
            t2D: {
                value: null
            }
        },
        vertexShader: hi.background_vert,
        fragmentShader: hi.background_frag
    },
    cube: {
        uniforms: Ts([dn.envmap, {
            opacity: {
                value: 1
            }
        }]),
        vertexShader: hi.cube_vert,
        fragmentShader: hi.cube_frag
    },
    equirect: {
        uniforms: {
            tEquirect: {
                value: null
            }
        },
        vertexShader: hi.equirect_vert,
        fragmentShader: hi.equirect_frag
    },
    distanceRGBA: {
        uniforms: Ts([dn.common, dn.displacementmap, {
            referencePosition: {
                value: new Oe
            },
            nearDistance: {
                value: 1
            },
            farDistance: {
                value: 1e3
            }
        }]),
        vertexShader: hi.distanceRGBA_vert,
        fragmentShader: hi.distanceRGBA_frag
    },
    shadow: {
        uniforms: Ts([dn.lights, dn.fog, {
            color: {
                value: new In(0)
            },
            opacity: {
                value: 1
            }
        }]),
        vertexShader: hi.shadow_vert,
        fragmentShader: hi.shadow_frag
    }
};
jo.physical = {
    uniforms: Ts([jo.standard.uniforms, {
        clearcoat: {
            value: 0
        },
        clearcoatMap: {
            value: null
        },
        clearcoatRoughness: {
            value: 0
        },
        clearcoatRoughnessMap: {
            value: null
        },
        clearcoatNormalScale: {
            value: new zt(1,1)
        },
        clearcoatNormalMap: {
            value: null
        },
        sheen: {
            value: 0
        },
        sheenColor: {
            value: new In(0)
        },
        sheenColorMap: {
            value: null
        },
        sheenRoughness: {
            value: 1
        },
        sheenRoughnessMap: {
            value: null
        },
        transmission: {
            value: 0
        },
        transmissionMap: {
            value: null
        },
        transmissionSamplerSize: {
            value: new zt
        },
        transmissionSamplerMap: {
            value: null
        },
        thickness: {
            value: 0
        },
        thicknessMap: {
            value: null
        },
        attenuationDistance: {
            value: 0
        },
        attenuationColor: {
            value: new In(0)
        },
        specularIntensity: {
            value: 1
        },
        specularIntensityMap: {
            value: null
        },
        specularColor: {
            value: new In(1,1,1)
        },
        specularColorMap: {
            value: null
        }
    }]),
    vertexShader: hi.meshphysical_vert,
    fragmentShader: hi.meshphysical_frag
};
function bF(r, e, t, o, c, d) {
    let p = new In(0), i = c === !0 ? 0 : 1, v, x, E = null, A = 0, C = null;
    function I(P, k) {
        let U = !1
          , Z = k.isScene === !0 ? k.background : null;
        Z && Z.isTexture && (Z = e.get(Z));
        let K = r.xr
          , X = K.getSession && K.getSession();
        X && X.environmentBlendMode === "additive" && (Z = null),
        Z === null ? D(p, i) : Z && Z.isColor && (D(Z, 1),
        U = !0),
        (r.autoClear || U) && r.clear(r.autoClearColor, r.autoClearDepth, r.autoClearStencil),
        Z && (Z.isCubeTexture || Z.mapping === hm) ? (x === void 0 && (x = new Ir(new va(1,1,1),new oo({
            name: "BackgroundCubeMaterial",
            uniforms: Gd(jo.cube.uniforms),
            vertexShader: jo.cube.vertexShader,
            fragmentShader: jo.cube.fragmentShader,
            side: Zs,
            depthTest: !1,
            depthWrite: !1,
            fog: !1
        })),
        x.geometry.deleteAttribute("normal"),
        x.geometry.deleteAttribute("uv"),
        x.onBeforeRender = function(W, fe, ce) {
            this.matrixWorld.copyPosition(ce.matrixWorld)
        }
        ,
        Object.defineProperty(x.material, "envMap", {
            get: function() {
                return this.uniforms.envMap.value
            }
        }),
        o.update(x)),
        x.material.uniforms.envMap.value = Z,
        x.material.uniforms.flipEnvMap.value = Z.isCubeTexture && Z.isRenderTargetTexture === !1 ? -1 : 1,
        (E !== Z || A !== Z.version || C !== r.toneMapping) && (x.material.needsUpdate = !0,
        E = Z,
        A = Z.version,
        C = r.toneMapping),
        P.unshift(x, x.geometry, x.material, 0, 0, null)) : Z && Z.isTexture && (v === void 0 && (v = new Ir(new qd(2,2),new oo({
            name: "BackgroundMaterial",
            uniforms: Gd(jo.background.uniforms),
            vertexShader: jo.background.vertexShader,
            fragmentShader: jo.background.fragmentShader,
            side: Md,
            depthTest: !1,
            depthWrite: !1,
            fog: !1
        })),
        v.geometry.deleteAttribute("normal"),
        Object.defineProperty(v.material, "map", {
            get: function() {
                return this.uniforms.t2D.value
            }
        }),
        o.update(v)),
        v.material.uniforms.t2D.value = Z,
        Z.matrixAutoUpdate === !0 && Z.updateMatrix(),
        v.material.uniforms.uvTransform.value.copy(Z.matrix),
        (E !== Z || A !== Z.version || C !== r.toneMapping) && (v.material.needsUpdate = !0,
        E = Z,
        A = Z.version,
        C = r.toneMapping),
        P.unshift(v, v.geometry, v.material, 0, 0, null))
    }
    function D(P, k) {
        t.buffers.color.setClear(P.r, P.g, P.b, k, d)
    }
    return {
        getClearColor: function() {
            return p
        },
        setClearColor: function(P, k=1) {
            p.set(P),
            i = k,
            D(p, i)
        },
        getClearAlpha: function() {
            return i
        },
        setClearAlpha: function(P) {
            i = P,
            D(p, i)
        },
        render: I
    }
}
function wF(r, e, t, o) {
    let c = r.getParameter(34921)
      , d = o.isWebGL2 ? null : e.get("OES_vertex_array_object")
      , p = o.isWebGL2 || d !== null
      , i = {}
      , v = k(null)
      , x = v
      , E = !1;
    function A(te, ae, se, ke, Be) {
        let tt = !1;
        if (p) {
            let Ke = P(ke, se, ae);
            x !== Ke && (x = Ke,
            I(x.object)),
            tt = U(ke, Be),
            tt && Z(ke, Be)
        } else {
            let Ke = ae.wireframe === !0;
            (x.geometry !== ke.id || x.program !== se.id || x.wireframe !== Ke) && (x.geometry = ke.id,
            x.program = se.id,
            x.wireframe = Ke,
            tt = !0)
        }
        te.isInstancedMesh === !0 && (tt = !0),
        Be !== null && t.update(Be, 34963),
        (tt || E) && (E = !1,
        _e(te, ae, se, ke),
        Be !== null && r.bindBuffer(34963, t.get(Be).buffer))
    }
    function C() {
        return o.isWebGL2 ? r.createVertexArray() : d.createVertexArrayOES()
    }
    function I(te) {
        return o.isWebGL2 ? r.bindVertexArray(te) : d.bindVertexArrayOES(te)
    }
    function D(te) {
        return o.isWebGL2 ? r.deleteVertexArray(te) : d.deleteVertexArrayOES(te)
    }
    function P(te, ae, se) {
        let ke = se.wireframe === !0
          , Be = i[te.id];
        Be === void 0 && (Be = {},
        i[te.id] = Be);
        let tt = Be[ae.id];
        tt === void 0 && (tt = {},
        Be[ae.id] = tt);
        let Ke = tt[ke];
        return Ke === void 0 && (Ke = k(C()),
        tt[ke] = Ke),
        Ke
    }
    function k(te) {
        let ae = []
          , se = []
          , ke = [];
        for (let Be = 0; Be < c; Be++)
            ae[Be] = 0,
            se[Be] = 0,
            ke[Be] = 0;
        return {
            geometry: null,
            program: null,
            wireframe: !1,
            newAttributes: ae,
            enabledAttributes: se,
            attributeDivisors: ke,
            object: te,
            attributes: {},
            index: null
        }
    }
    function U(te, ae) {
        let se = x.attributes
          , ke = te.attributes
          , Be = 0;
        for (let tt in ke) {
            let Ke = se[tt]
              , bt = ke[tt];
            if (Ke === void 0 || Ke.attribute !== bt || Ke.data !== bt.data)
                return !0;
            Be++
        }
        return x.attributesNum !== Be || x.index !== ae
    }
    function Z(te, ae) {
        let se = {}
          , ke = te.attributes
          , Be = 0;
        for (let tt in ke) {
            let Ke = ke[tt]
              , bt = {};
            bt.attribute = Ke,
            Ke.data && (bt.data = Ke.data),
            se[tt] = bt,
            Be++
        }
        x.attributes = se,
        x.attributesNum = Be,
        x.index = ae
    }
    function K() {
        let te = x.newAttributes;
        for (let ae = 0, se = te.length; ae < se; ae++)
            te[ae] = 0
    }
    function X(te) {
        W(te, 0)
    }
    function W(te, ae) {
        let se = x.newAttributes
          , ke = x.enabledAttributes
          , Be = x.attributeDivisors;
        se[te] = 1,
        ke[te] === 0 && (r.enableVertexAttribArray(te),
        ke[te] = 1),
        Be[te] !== ae && ((o.isWebGL2 ? r : e.get("ANGLE_instanced_arrays"))[o.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](te, ae),
        Be[te] = ae)
    }
    function fe() {
        let te = x.newAttributes
          , ae = x.enabledAttributes;
        for (let se = 0, ke = ae.length; se < ke; se++)
            ae[se] !== te[se] && (r.disableVertexAttribArray(se),
            ae[se] = 0)
    }
    function ce(te, ae, se, ke, Be, tt) {
        o.isWebGL2 === !0 && (se === 5124 || se === 5125) ? r.vertexAttribIPointer(te, ae, se, Be, tt) : r.vertexAttribPointer(te, ae, se, ke, Be, tt)
    }
    function _e(te, ae, se, ke) {
        if (o.isWebGL2 === !1 && (te.isInstancedMesh || ke.isInstancedBufferGeometry) && e.get("ANGLE_instanced_arrays") === null)
            return;
        K();
        let Be = ke.attributes
          , tt = se.getAttributes()
          , Ke = ae.defaultAttributeValues;
        for (let bt in tt) {
            let Et = tt[bt];
            if (Et.location >= 0) {
                let Gt = Be[bt];
                if (Gt === void 0 && (bt === "instanceMatrix" && te.instanceMatrix && (Gt = te.instanceMatrix),
                bt === "instanceColor" && te.instanceColor && (Gt = te.instanceColor)),
                Gt !== void 0) {
                    let Ye = Gt.normalized
                      , gn = Gt.itemSize
                      , gt = t.get(Gt);
                    if (gt === void 0)
                        continue;
                    let Tn = gt.buffer
                      , xn = gt.type
                      , Dn = gt.bytesPerElement;
                    if (Gt.isInterleavedBufferAttribute) {
                        let Bt = Gt.data
                          , An = Bt.stride
                          , ut = Gt.offset;
                        if (Bt.isInstancedInterleavedBuffer) {
                            for (let ot = 0; ot < Et.locationSize; ot++)
                                W(Et.location + ot, Bt.meshPerAttribute);
                            te.isInstancedMesh !== !0 && ke._maxInstanceCount === void 0 && (ke._maxInstanceCount = Bt.meshPerAttribute * Bt.count)
                        } else
                            for (let ot = 0; ot < Et.locationSize; ot++)
                                X(Et.location + ot);
                        r.bindBuffer(34962, Tn);
                        for (let ot = 0; ot < Et.locationSize; ot++)
                            ce(Et.location + ot, gn / Et.locationSize, xn, Ye, An * Dn, (ut + gn / Et.locationSize * ot) * Dn)
                    } else {
                        if (Gt.isInstancedBufferAttribute) {
                            for (let Bt = 0; Bt < Et.locationSize; Bt++)
                                W(Et.location + Bt, Gt.meshPerAttribute);
                            te.isInstancedMesh !== !0 && ke._maxInstanceCount === void 0 && (ke._maxInstanceCount = Gt.meshPerAttribute * Gt.count)
                        } else
                            for (let Bt = 0; Bt < Et.locationSize; Bt++)
                                X(Et.location + Bt);
                        r.bindBuffer(34962, Tn);
                        for (let Bt = 0; Bt < Et.locationSize; Bt++)
                            ce(Et.location + Bt, gn / Et.locationSize, xn, Ye, gn * Dn, gn / Et.locationSize * Bt * Dn)
                    }
                } else if (Ke !== void 0) {
                    let Ye = Ke[bt];
                    if (Ye !== void 0)
                        switch (Ye.length) {
                        case 2:
                            r.vertexAttrib2fv(Et.location, Ye);
                            break;
                        case 3:
                            r.vertexAttrib3fv(Et.location, Ye);
                            break;
                        case 4:
                            r.vertexAttrib4fv(Et.location, Ye);
                            break;
                        default:
                            r.vertexAttrib1fv(Et.location, Ye)
                        }
                }
            }
        }
        fe()
    }
    function oe() {
        ne();
        for (let te in i) {
            let ae = i[te];
            for (let se in ae) {
                let ke = ae[se];
                for (let Be in ke)
                    D(ke[Be].object),
                    delete ke[Be];
                delete ae[se]
            }
            delete i[te]
        }
    }
    function ee(te) {
        if (i[te.id] === void 0)
            return;
        let ae = i[te.id];
        for (let se in ae) {
            let ke = ae[se];
            for (let Be in ke)
                D(ke[Be].object),
                delete ke[Be];
            delete ae[se]
        }
        delete i[te.id]
    }
    function j(te) {
        for (let ae in i) {
            let se = i[ae];
            if (se[te.id] === void 0)
                continue;
            let ke = se[te.id];
            for (let Be in ke)
                D(ke[Be].object),
                delete ke[Be];
            delete se[te.id]
        }
    }
    function ne() {
        be(),
        E = !0,
        x !== v && (x = v,
        I(x.object))
    }
    function be() {
        v.geometry = null,
        v.program = null,
        v.wireframe = !1
    }
    return {
        setup: A,
        reset: ne,
        resetDefaultState: be,
        dispose: oe,
        releaseStatesOfGeometry: ee,
        releaseStatesOfProgram: j,
        initAttributes: K,
        enableAttribute: X,
        disableUnusedAttributes: fe
    }
}
function TF(r, e, t, o) {
    let c = o.isWebGL2, d;
    function p(x) {
        d = x
    }
    function i(x, E) {
        r.drawArrays(d, x, E),
        t.update(E, d, 1)
    }
    function v(x, E, A) {
        if (A === 0)
            return;
        let C, I;
        if (c)
            C = r,
            I = "drawArraysInstanced";
        else if (C = e.get("ANGLE_instanced_arrays"),
        I = "drawArraysInstancedANGLE",
        C === null) {
            console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            return
        }
        C[I](d, x, E, A),
        t.update(E, d, A)
    }
    this.setMode = p,
    this.render = i,
    this.renderInstances = v
}
function EF(r, e, t) {
    let o;
    function c() {
        if (o !== void 0)
            return o;
        if (e.has("EXT_texture_filter_anisotropic") === !0) {
            let ce = e.get("EXT_texture_filter_anisotropic");
            o = r.getParameter(ce.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
        } else
            o = 0;
        return o
    }
    function d(ce) {
        if (ce === "highp") {
            if (r.getShaderPrecisionFormat(35633, 36338).precision > 0 && r.getShaderPrecisionFormat(35632, 36338).precision > 0)
                return "highp";
            ce = "mediump"
        }
        return ce === "mediump" && r.getShaderPrecisionFormat(35633, 36337).precision > 0 && r.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp"
    }
    let p = typeof WebGL2RenderingContext != "undefined" && r instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext != "undefined" && r instanceof WebGL2ComputeRenderingContext
      , i = t.precision !== void 0 ? t.precision : "highp"
      , v = d(i);
    v !== i && (console.warn("THREE.WebGLRenderer:", i, "not supported, using", v, "instead."),
    i = v);
    let x = p || e.has("WEBGL_draw_buffers")
      , E = t.logarithmicDepthBuffer === !0
      , A = r.getParameter(34930)
      , C = r.getParameter(35660)
      , I = r.getParameter(3379)
      , D = r.getParameter(34076)
      , P = r.getParameter(34921)
      , k = r.getParameter(36347)
      , U = r.getParameter(36348)
      , Z = r.getParameter(36349)
      , K = C > 0
      , X = p || e.has("OES_texture_float")
      , W = K && X
      , fe = p ? r.getParameter(36183) : 0;
    return {
        isWebGL2: p,
        drawBuffers: x,
        getMaxAnisotropy: c,
        getMaxPrecision: d,
        precision: i,
        logarithmicDepthBuffer: E,
        maxTextures: A,
        maxVertexTextures: C,
        maxTextureSize: I,
        maxCubemapSize: D,
        maxAttributes: P,
        maxVertexUniforms: k,
        maxVaryings: U,
        maxFragmentUniforms: Z,
        vertexTextures: K,
        floatFragmentTextures: X,
        floatVertexTextures: W,
        maxSamples: fe
    }
}
function SF(r) {
    let e = this
      , t = null
      , o = 0
      , c = !1
      , d = !1
      , p = new Wo
      , i = new Fr
      , v = {
        value: null,
        needsUpdate: !1
    };
    this.uniform = v,
    this.numPlanes = 0,
    this.numIntersection = 0,
    this.init = function(A, C, I) {
        let D = A.length !== 0 || C || o !== 0 || c;
        return c = C,
        t = E(A, I, 0),
        o = A.length,
        D
    }
    ,
    this.beginShadows = function() {
        d = !0,
        E(null)
    }
    ,
    this.endShadows = function() {
        d = !1,
        x()
    }
    ,
    this.setState = function(A, C, I) {
        let D = A.clippingPlanes
          , P = A.clipIntersection
          , k = A.clipShadows
          , U = r.get(A);
        if (!c || D === null || D.length === 0 || d && !k)
            d ? E(null) : x();
        else {
            let Z = d ? 0 : o
              , K = Z * 4
              , X = U.clippingState || null;
            v.value = X,
            X = E(D, C, K, I);
            for (let W = 0; W !== K; ++W)
                X[W] = t[W];
            U.clippingState = X,
            this.numIntersection = P ? this.numPlanes : 0,
            this.numPlanes += Z
        }
    }
    ;
    function x() {
        v.value !== t && (v.value = t,
        v.needsUpdate = o > 0),
        e.numPlanes = o,
        e.numIntersection = 0
    }
    function E(A, C, I, D) {
        let P = A !== null ? A.length : 0
          , k = null;
        if (P !== 0) {
            if (k = v.value,
            D !== !0 || k === null) {
                let U = I + P * 4
                  , Z = C.matrixWorldInverse;
                i.getNormalMatrix(Z),
                (k === null || k.length < U) && (k = new Float32Array(U));
                for (let K = 0, X = I; K !== P; ++K,
                X += 4)
                    p.copy(A[K]).applyMatrix4(Z, i),
                    p.normal.toArray(k, X),
                    k[X + 3] = p.constant
            }
            v.value = k,
            v.needsUpdate = !0
        }
        return e.numPlanes = P,
        e.numIntersection = 0,
        k
    }
}
function AF(r) {
    let e = new WeakMap;
    function t(p, i) {
        return i === Sy ? p.mapping = Bu : i === Ay && (p.mapping = Uu),
        p
    }
    function o(p) {
        if (p && p.isTexture && p.isRenderTargetTexture === !1) {
            let i = p.mapping;
            if (i === Sy || i === Ay)
                if (e.has(p)) {
                    let v = e.get(p).texture;
                    return t(v, p.mapping)
                } else {
                    let v = p.image;
                    if (v && v.height > 0) {
                        let x = new s0(v.height / 2);
                        return x.fromEquirectangularTexture(r, p),
                        e.set(p, x),
                        p.addEventListener("dispose", c),
                        t(x.texture, p.mapping)
                    } else
                        return null
                }
        }
        return p
    }
    function c(p) {
        let i = p.target;
        i.removeEventListener("dispose", c);
        let v = e.get(i);
        v !== void 0 && (e.delete(i),
        v.dispose())
    }
    function d() {
        e = new WeakMap
    }
    return {
        get: o,
        dispose: d
    }
}
var Sm = class extends Tm {
    constructor(e=-1, t=1, o=1, c=-1, d=.1, p=2e3) {
        super();
        this.type = "OrthographicCamera",
        this.zoom = 1,
        this.view = null,
        this.left = e,
        this.right = t,
        this.top = o,
        this.bottom = c,
        this.near = d,
        this.far = p,
        this.updateProjectionMatrix()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.left = e.left,
        this.right = e.right,
        this.top = e.top,
        this.bottom = e.bottom,
        this.near = e.near,
        this.far = e.far,
        this.zoom = e.zoom,
        this.view = e.view === null ? null : Object.assign({}, e.view),
        this
    }
    setViewOffset(e, t, o, c, d, p) {
        this.view === null && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }),
        this.view.enabled = !0,
        this.view.fullWidth = e,
        this.view.fullHeight = t,
        this.view.offsetX = o,
        this.view.offsetY = c,
        this.view.width = d,
        this.view.height = p,
        this.updateProjectionMatrix()
    }
    clearViewOffset() {
        this.view !== null && (this.view.enabled = !1),
        this.updateProjectionMatrix()
    }
    updateProjectionMatrix() {
        let e = (this.right - this.left) / (2 * this.zoom)
          , t = (this.top - this.bottom) / (2 * this.zoom)
          , o = (this.right + this.left) / 2
          , c = (this.top + this.bottom) / 2
          , d = o - e
          , p = o + e
          , i = c + t
          , v = c - t;
        if (this.view !== null && this.view.enabled) {
            let x = (this.right - this.left) / this.view.fullWidth / this.zoom
              , E = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            d += x * this.view.offsetX,
            p = d + x * this.view.width,
            i -= E * this.view.offsetY,
            v = i - E * this.view.height
        }
        this.projectionMatrix.makeOrthographic(d, p, i, v, this.near, this.far),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }
    toJSON(e) {
        let t = super.toJSON(e);
        return t.object.zoom = this.zoom,
        t.object.left = this.left,
        t.object.right = this.right,
        t.object.top = this.top,
        t.object.bottom = this.bottom,
        t.object.near = this.near,
        t.object.far = this.far,
        this.view !== null && (t.object.view = Object.assign({}, this.view)),
        t
    }
}
;
Sm.prototype.isOrthographicCamera = !0;
var Kd = 4
  , A2 = [.125, .215, .35, .446, .526, .582]
  , $u = 20
  , fb = new Sm
  , M2 = new In
  , pb = null
  , Qu = (1 + Math.sqrt(5)) / 2
  , Yd = 1 / Qu
  , I2 = [new Oe(1,1,1), new Oe(-1,1,1), new Oe(1,1,-1), new Oe(-1,1,-1), new Oe(0,Qu,Yd), new Oe(0,Qu,-Yd), new Oe(Yd,0,Qu), new Oe(-Yd,0,Qu), new Oe(Qu,Yd,0), new Oe(-Qu,Yd,0)]
  , a0 = class {
    constructor(e) {
        this._renderer = e,
        this._pingPongRenderTarget = null,
        this._lodMax = 0,
        this._cubeSize = 0,
        this._lodPlanes = [],
        this._sizeLods = [],
        this._sigmas = [],
        this._blurMaterial = null,
        this._cubemapMaterial = null,
        this._equirectMaterial = null,
        this._compileMaterial(this._blurMaterial)
    }
    fromScene(e, t=0, o=.1, c=100) {
        pb = this._renderer.getRenderTarget(),
        this._setSize(256);
        let d = this._allocateTargets();
        return d.depthBuffer = !0,
        this._sceneToCubeUV(e, o, c, d),
        t > 0 && this._blur(d, 0, 0, t),
        this._applyPMREM(d),
        this._cleanup(d),
        d
    }
    fromEquirectangular(e, t=null) {
        return this._fromTexture(e, t)
    }
    fromCubemap(e, t=null) {
        return this._fromTexture(e, t)
    }
    compileCubemapShader() {
        this._cubemapMaterial === null && (this._cubemapMaterial = L2(),
        this._compileMaterial(this._cubemapMaterial))
    }
    compileEquirectangularShader() {
        this._equirectMaterial === null && (this._equirectMaterial = D2(),
        this._compileMaterial(this._equirectMaterial))
    }
    dispose() {
        this._dispose(),
        this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
        this._equirectMaterial !== null && this._equirectMaterial.dispose()
    }
    _setSize(e) {
        this._lodMax = Math.floor(Math.log2(e)),
        this._cubeSize = Math.pow(2, this._lodMax)
    }
    _dispose() {
        this._blurMaterial !== null && this._blurMaterial.dispose(),
        this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
        for (let e = 0; e < this._lodPlanes.length; e++)
            this._lodPlanes[e].dispose()
    }
    _cleanup(e) {
        this._renderer.setRenderTarget(pb),
        e.scissorTest = !1,
        l0(e, 0, 0, e.width, e.height)
    }
    _fromTexture(e, t) {
        e.mapping === Bu || e.mapping === Uu ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4),
        pb = this._renderer.getRenderTarget();
        let o = t || this._allocateTargets();
        return this._textureToCubeUV(e, o),
        this._applyPMREM(o),
        this._cleanup(o),
        o
    }
    _allocateTargets() {
        let e = 3 * Math.max(this._cubeSize, 16 * 7)
          , t = 4 * this._cubeSize - 32
          , o = {
            magFilter: ns,
            minFilter: ns,
            generateMipmaps: !1,
            type: Gu,
            format: is,
            encoding: ya,
            depthBuffer: !1
        }
          , c = C2(e, t, o);
        if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e) {
            this._pingPongRenderTarget !== null && this._dispose(),
            this._pingPongRenderTarget = C2(e, t, o);
            let {_lodMax: d} = this;
            ({sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas} = MF(d)),
            this._blurMaterial = IF(d, e, t)
        }
        return c
    }
    _compileMaterial(e) {
        let t = new Ir(this._lodPlanes[0],e);
        this._renderer.compile(t, fb)
    }
    _sceneToCubeUV(e, t, o, c) {
        let d = 90
          , p = 1
          , i = new os(d,p,t,o)
          , v = [1, -1, 1, 1, 1, 1]
          , x = [1, 1, 1, -1, -1, -1]
          , E = this._renderer
          , A = E.autoClear
          , C = E.toneMapping;
        E.getClearColor(M2),
        E.toneMapping = _a,
        E.autoClear = !1;
        let I = new pc({
            name: "PMREM.Background",
            side: Zs,
            depthWrite: !1,
            depthTest: !1
        })
          , D = new Ir(new va,I)
          , P = !1
          , k = e.background;
        k ? k.isColor && (I.color.copy(k),
        e.background = null,
        P = !0) : (I.color.copy(M2),
        P = !0);
        for (let U = 0; U < 6; U++) {
            let Z = U % 3;
            Z === 0 ? (i.up.set(0, v[U], 0),
            i.lookAt(x[U], 0, 0)) : Z === 1 ? (i.up.set(0, 0, v[U]),
            i.lookAt(0, x[U], 0)) : (i.up.set(0, v[U], 0),
            i.lookAt(0, 0, x[U]));
            let K = this._cubeSize;
            l0(c, Z * K, U > 2 ? K : 0, K, K),
            E.setRenderTarget(c),
            P && E.render(D, i),
            E.render(e, i)
        }
        D.geometry.dispose(),
        D.material.dispose(),
        E.toneMapping = C,
        E.autoClear = A,
        e.background = k
    }
    _textureToCubeUV(e, t) {
        let o = this._renderer
          , c = e.mapping === Bu || e.mapping === Uu;
        c ? (this._cubemapMaterial === null && (this._cubemapMaterial = L2()),
        this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = D2());
        let d = c ? this._cubemapMaterial : this._equirectMaterial
          , p = new Ir(this._lodPlanes[0],d)
          , i = d.uniforms;
        i.envMap.value = e;
        let v = this._cubeSize;
        l0(t, 0, 0, 3 * v, 2 * v),
        o.setRenderTarget(t),
        o.render(p, fb)
    }
    _applyPMREM(e) {
        let t = this._renderer
          , o = t.autoClear;
        t.autoClear = !1;
        for (let c = 1; c < this._lodPlanes.length; c++) {
            let d = Math.sqrt(this._sigmas[c] * this._sigmas[c] - this._sigmas[c - 1] * this._sigmas[c - 1])
              , p = I2[(c - 1) % I2.length];
            this._blur(e, c - 1, c, d, p)
        }
        t.autoClear = o
    }
    _blur(e, t, o, c, d) {
        let p = this._pingPongRenderTarget;
        this._halfBlur(e, p, t, o, c, "latitudinal", d),
        this._halfBlur(p, e, o, o, c, "longitudinal", d)
    }
    _halfBlur(e, t, o, c, d, p, i) {
        let v = this._renderer
          , x = this._blurMaterial;
        p !== "latitudinal" && p !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
        let E = 3
          , A = new Ir(this._lodPlanes[c],x)
          , C = x.uniforms
          , I = this._sizeLods[o] - 1
          , D = isFinite(d) ? Math.PI / (2 * I) : 2 * Math.PI / (2 * $u - 1)
          , P = d / D
          , k = isFinite(d) ? 1 + Math.floor(E * P) : $u;
        k > $u && console.warn(`sigmaRadians, ${d}, is too large and will clip, as it requested ${k} samples when the maximum is set to ${$u}`);
        let U = []
          , Z = 0;
        for (let ce = 0; ce < $u; ++ce) {
            let _e = ce / P
              , oe = Math.exp(-_e * _e / 2);
            U.push(oe),
            ce === 0 ? Z += oe : ce < k && (Z += 2 * oe)
        }
        for (let ce = 0; ce < U.length; ce++)
            U[ce] = U[ce] / Z;
        C.envMap.value = e.texture,
        C.samples.value = k,
        C.weights.value = U,
        C.latitudinal.value = p === "latitudinal",
        i && (C.poleAxis.value = i);
        let {_lodMax: K} = this;
        C.dTheta.value = D,
        C.mipInt.value = K - o;
        let X = this._sizeLods[c]
          , W = 3 * X * (c > K - Kd ? c - K + Kd : 0)
          , fe = 4 * (this._cubeSize - X);
        l0(t, W, fe, 3 * X, 2 * X),
        v.setRenderTarget(t),
        v.render(A, fb)
    }
}
;
function MF(r) {
    let e = []
      , t = []
      , o = []
      , c = r
      , d = r - Kd + 1 + A2.length;
    for (let p = 0; p < d; p++) {
        let i = Math.pow(2, c);
        t.push(i);
        let v = 1 / i;
        p > r - Kd ? v = A2[p - r + Kd - 1] : p === 0 && (v = 0),
        o.push(v);
        let x = 1 / (i - 1)
          , E = -x / 2
          , A = 1 + x / 2
          , C = [E, E, A, E, A, A, E, E, A, A, E, A]
          , I = 6
          , D = 6
          , P = 3
          , k = 2
          , U = 1
          , Z = new Float32Array(P * D * I)
          , K = new Float32Array(k * D * I)
          , X = new Float32Array(U * D * I);
        for (let fe = 0; fe < I; fe++) {
            let ce = fe % 3 * 2 / 3 - 1
              , _e = fe > 2 ? 0 : -1
              , oe = [ce, _e, 0, ce + 2 / 3, _e, 0, ce + 2 / 3, _e + 1, 0, ce, _e, 0, ce + 2 / 3, _e + 1, 0, ce, _e + 1, 0];
            Z.set(oe, P * D * fe),
            K.set(C, k * D * fe);
            let ee = [fe, fe, fe, fe, fe, fe];
            X.set(ee, U * D * fe)
        }
        let W = new Vi;
        W.setAttribute("position", new or(Z,P)),
        W.setAttribute("uv", new or(K,k)),
        W.setAttribute("faceIndex", new or(X,U)),
        e.push(W),
        c > Kd && c--
    }
    return {
        lodPlanes: e,
        sizeLods: t,
        sigmas: o
    }
}
function C2(r, e, t) {
    let o = new Cs(r,e,t);
    return o.texture.mapping = hm,
    o.texture.name = "PMREM.cubeUv",
    o.scissorTest = !0,
    o
}
function l0(r, e, t, o, c) {
    r.viewport.set(e, t, o, c),
    r.scissor.set(e, t, o, c)
}
function IF(r, e, t) {
    let o = new Float32Array($u)
      , c = new Oe(0,1,0);
    return new oo({
        name: "SphericalGaussianBlur",
        defines: {
            n: $u,
            CUBEUV_TEXEL_WIDTH: 1 / e,
            CUBEUV_TEXEL_HEIGHT: 1 / t,
            CUBEUV_MAX_MIP: `${r}.0`
        },
        uniforms: {
            envMap: {
                value: null
            },
            samples: {
                value: 1
            },
            weights: {
                value: o
            },
            latitudinal: {
                value: !1
            },
            dTheta: {
                value: 0
            },
            mipInt: {
                value: 0
            },
            poleAxis: {
                value: c
            }
        },
        vertexShader: mb(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
        blending: Qa,
        depthTest: !1,
        depthWrite: !1
    })
}
function D2() {
    return new oo({
        name: "EquirectangularToCubeUV",
        uniforms: {
            envMap: {
                value: null
            }
        },
        vertexShader: mb(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
        blending: Qa,
        depthTest: !1,
        depthWrite: !1
    })
}
function L2() {
    return new oo({
        name: "CubemapToCubeUV",
        uniforms: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            }
        },
        vertexShader: mb(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
        blending: Qa,
        depthTest: !1,
        depthWrite: !1
    })
}
function mb() {
    return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
}
function CF(r) {
    let e = new WeakMap
      , t = null;
    function o(i) {
        if (i && i.isTexture) {
            let v = i.mapping
              , x = v === Sy || v === Ay
              , E = v === Bu || v === Uu;
            if (x || E)
                if (i.isRenderTargetTexture && i.needsPMREMUpdate === !0) {
                    i.needsPMREMUpdate = !1;
                    let A = e.get(i);
                    return t === null && (t = new a0(r)),
                    A = x ? t.fromEquirectangular(i, A) : t.fromCubemap(i, A),
                    e.set(i, A),
                    A.texture
                } else {
                    if (e.has(i))
                        return e.get(i).texture;
                    {
                        let A = i.image;
                        if (x && A && A.height > 0 || E && A && c(A)) {
                            t === null && (t = new a0(r));
                            let C = x ? t.fromEquirectangular(i) : t.fromCubemap(i);
                            return e.set(i, C),
                            i.addEventListener("dispose", d),
                            C.texture
                        } else
                            return null
                    }
                }
        }
        return i
    }
    function c(i) {
        let v = 0
          , x = 6;
        for (let E = 0; E < x; E++)
            i[E] !== void 0 && v++;
        return v === x
    }
    function d(i) {
        let v = i.target;
        v.removeEventListener("dispose", d);
        let x = e.get(v);
        x !== void 0 && (e.delete(v),
        x.dispose())
    }
    function p() {
        e = new WeakMap,
        t !== null && (t.dispose(),
        t = null)
    }
    return {
        get: o,
        dispose: p
    }
}
function DF(r) {
    let e = {};
    function t(o) {
        if (e[o] !== void 0)
            return e[o];
        let c;
        switch (o) {
        case "WEBGL_depth_texture":
            c = r.getExtension("WEBGL_depth_texture") || r.getExtension("MOZ_WEBGL_depth_texture") || r.getExtension("WEBKIT_WEBGL_depth_texture");
            break;
        case "EXT_texture_filter_anisotropic":
            c = r.getExtension("EXT_texture_filter_anisotropic") || r.getExtension("MOZ_EXT_texture_filter_anisotropic") || r.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
            break;
        case "WEBGL_compressed_texture_s3tc":
            c = r.getExtension("WEBGL_compressed_texture_s3tc") || r.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || r.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
            break;
        case "WEBGL_compressed_texture_pvrtc":
            c = r.getExtension("WEBGL_compressed_texture_pvrtc") || r.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
            break;
        default:
            c = r.getExtension(o)
        }
        return e[o] = c,
        c
    }
    return {
        has: function(o) {
            return t(o) !== null
        },
        init: function(o) {
            o.isWebGL2 ? t("EXT_color_buffer_float") : (t("WEBGL_depth_texture"),
            t("OES_texture_float"),
            t("OES_texture_half_float"),
            t("OES_texture_half_float_linear"),
            t("OES_standard_derivatives"),
            t("OES_element_index_uint"),
            t("OES_vertex_array_object"),
            t("ANGLE_instanced_arrays")),
            t("OES_texture_float_linear"),
            t("EXT_color_buffer_half_float"),
            t("WEBGL_multisampled_render_to_texture")
        },
        get: function(o) {
            let c = t(o);
            return c === null && console.warn("THREE.WebGLRenderer: " + o + " extension not supported."),
            c
        }
    }
}
function LF(r, e, t, o) {
    let c = {}
      , d = new WeakMap;
    function p(A) {
        let C = A.target;
        C.index !== null && e.remove(C.index);
        for (let D in C.attributes)
            e.remove(C.attributes[D]);
        C.removeEventListener("dispose", p),
        delete c[C.id];
        let I = d.get(C);
        I && (e.remove(I),
        d.delete(C)),
        o.releaseStatesOfGeometry(C),
        C.isInstancedBufferGeometry === !0 && delete C._maxInstanceCount,
        t.memory.geometries--
    }
    function i(A, C) {
        return c[C.id] === !0 || (C.addEventListener("dispose", p),
        c[C.id] = !0,
        t.memory.geometries++),
        C
    }
    function v(A) {
        let C = A.attributes;
        for (let D in C)
            e.update(C[D], 34962);
        let I = A.morphAttributes;
        for (let D in I) {
            let P = I[D];
            for (let k = 0, U = P.length; k < U; k++)
                e.update(P[k], 34962)
        }
    }
    function x(A) {
        let C = []
          , I = A.index
          , D = A.attributes.position
          , P = 0;
        if (I !== null) {
            let Z = I.array;
            P = I.version;
            for (let K = 0, X = Z.length; K < X; K += 3) {
                let W = Z[K + 0]
                  , fe = Z[K + 1]
                  , ce = Z[K + 2];
                C.push(W, fe, fe, ce, ce, W)
            }
        } else {
            let Z = D.array;
            P = D.version;
            for (let K = 0, X = Z.length / 3 - 1; K < X; K += 3) {
                let W = K + 0
                  , fe = K + 1
                  , ce = K + 2;
                C.push(W, fe, fe, ce, ce, W)
            }
        }
        let k = new (h2(C) ? Yy : Ky)(C,1);
        k.version = P;
        let U = d.get(A);
        U && e.remove(U),
        d.set(A, k)
    }
    function E(A) {
        let C = d.get(A);
        if (C) {
            let I = A.index;
            I !== null && C.version < I.version && x(A)
        } else
            x(A);
        return d.get(A)
    }
    return {
        get: i,
        update: v,
        getWireframeAttribute: E
    }
}
function RF(r, e, t, o) {
    let c = o.isWebGL2, d;
    function p(C) {
        d = C
    }
    let i, v;
    function x(C) {
        i = C.type,
        v = C.bytesPerElement
    }
    function E(C, I) {
        r.drawElements(d, I, i, C * v),
        t.update(I, d, 1)
    }
    function A(C, I, D) {
        if (D === 0)
            return;
        let P, k;
        if (c)
            P = r,
            k = "drawElementsInstanced";
        else if (P = e.get("ANGLE_instanced_arrays"),
        k = "drawElementsInstancedANGLE",
        P === null) {
            console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            return
        }
        P[k](d, I, i, C * v, D),
        t.update(I, d, D)
    }
    this.setMode = p,
    this.setIndex = x,
    this.render = E,
    this.renderInstances = A
}
function PF(r) {
    let e = {
        geometries: 0,
        textures: 0
    }
      , t = {
        frame: 0,
        calls: 0,
        triangles: 0,
        points: 0,
        lines: 0
    };
    function o(d, p, i) {
        switch (t.calls++,
        p) {
        case 4:
            t.triangles += i * (d / 3);
            break;
        case 1:
            t.lines += i * (d / 2);
            break;
        case 3:
            t.lines += i * (d - 1);
            break;
        case 2:
            t.lines += i * d;
            break;
        case 0:
            t.points += i * d;
            break;
        default:
            console.error("THREE.WebGLInfo: Unknown draw mode:", p);
            break
        }
    }
    function c() {
        t.frame++,
        t.calls = 0,
        t.triangles = 0,
        t.points = 0,
        t.lines = 0
    }
    return {
        memory: e,
        render: t,
        programs: null,
        autoReset: !0,
        reset: c,
        update: o
    }
}
function kF(r, e) {
    return r[0] - e[0]
}
function zF(r, e) {
    return Math.abs(e[1]) - Math.abs(r[1])
}
function gb(r, e) {
    let t = 1
      , o = e.isInterleavedBufferAttribute ? e.data.array : e.array;
    o instanceof Int8Array ? t = 127 : o instanceof Int16Array ? t = 32767 : o instanceof Int32Array ? t = 2147483647 : console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ", o),
    r.divideScalar(t)
}
function OF(r, e, t) {
    let o = {}
      , c = new Float32Array(8)
      , d = new WeakMap
      , p = new Ui
      , i = [];
    for (let x = 0; x < 8; x++)
        i[x] = [x, 0];
    function v(x, E, A, C) {
        let I = x.morphTargetInfluences;
        if (e.isWebGL2 === !0) {
            let D = E.morphAttributes.position || E.morphAttributes.normal || E.morphAttributes.color
              , P = D !== void 0 ? D.length : 0
              , k = d.get(E);
            if (k === void 0 || k.count !== P) {
                let ae = function() {
                    be.dispose(),
                    d.delete(E),
                    E.removeEventListener("dispose", ae)
                };
                k !== void 0 && k.texture.dispose();
                let K = E.morphAttributes.position !== void 0
                  , X = E.morphAttributes.normal !== void 0
                  , W = E.morphAttributes.color !== void 0
                  , fe = E.morphAttributes.position || []
                  , ce = E.morphAttributes.normal || []
                  , _e = E.morphAttributes.color || []
                  , oe = 0;
                K === !0 && (oe = 1),
                X === !0 && (oe = 2),
                W === !0 && (oe = 3);
                let ee = E.attributes.position.count * oe
                  , j = 1;
                ee > e.maxTextureSize && (j = Math.ceil(ee / e.maxTextureSize),
                ee = e.maxTextureSize);
                let ne = new Float32Array(ee * j * 4 * P)
                  , be = new Rd(ne,ee,j,P);
                be.type = rc,
                be.needsUpdate = !0;
                let te = oe * 4;
                for (let se = 0; se < P; se++) {
                    let ke = fe[se]
                      , Be = ce[se]
                      , tt = _e[se]
                      , Ke = ee * j * 4 * se;
                    for (let bt = 0; bt < ke.count; bt++) {
                        let Et = bt * te;
                        K === !0 && (p.fromBufferAttribute(ke, bt),
                        ke.normalized === !0 && gb(p, ke),
                        ne[Ke + Et + 0] = p.x,
                        ne[Ke + Et + 1] = p.y,
                        ne[Ke + Et + 2] = p.z,
                        ne[Ke + Et + 3] = 0),
                        X === !0 && (p.fromBufferAttribute(Be, bt),
                        Be.normalized === !0 && gb(p, Be),
                        ne[Ke + Et + 4] = p.x,
                        ne[Ke + Et + 5] = p.y,
                        ne[Ke + Et + 6] = p.z,
                        ne[Ke + Et + 7] = 0),
                        W === !0 && (p.fromBufferAttribute(tt, bt),
                        tt.normalized === !0 && gb(p, tt),
                        ne[Ke + Et + 8] = p.x,
                        ne[Ke + Et + 9] = p.y,
                        ne[Ke + Et + 10] = p.z,
                        ne[Ke + Et + 11] = tt.itemSize === 4 ? p.w : 1)
                    }
                }
                k = {
                    count: P,
                    texture: be,
                    size: new zt(ee,j)
                },
                d.set(E, k),
                E.addEventListener("dispose", ae)
            }
            let U = 0;
            for (let K = 0; K < I.length; K++)
                U += I[K];
            let Z = E.morphTargetsRelative ? 1 : 1 - U;
            C.getUniforms().setValue(r, "morphTargetBaseInfluence", Z),
            C.getUniforms().setValue(r, "morphTargetInfluences", I),
            C.getUniforms().setValue(r, "morphTargetsTexture", k.texture, t),
            C.getUniforms().setValue(r, "morphTargetsTextureSize", k.size)
        } else {
            let D = I === void 0 ? 0 : I.length
              , P = o[E.id];
            if (P === void 0 || P.length !== D) {
                P = [];
                for (let X = 0; X < D; X++)
                    P[X] = [X, 0];
                o[E.id] = P
            }
            for (let X = 0; X < D; X++) {
                let W = P[X];
                W[0] = X,
                W[1] = I[X]
            }
            P.sort(zF);
            for (let X = 0; X < 8; X++)
                X < D && P[X][1] ? (i[X][0] = P[X][0],
                i[X][1] = P[X][1]) : (i[X][0] = Number.MAX_SAFE_INTEGER,
                i[X][1] = 0);
            i.sort(kF);
            let k = E.morphAttributes.position
              , U = E.morphAttributes.normal
              , Z = 0;
            for (let X = 0; X < 8; X++) {
                let W = i[X]
                  , fe = W[0]
                  , ce = W[1];
                fe !== Number.MAX_SAFE_INTEGER && ce ? (k && E.getAttribute("morphTarget" + X) !== k[fe] && E.setAttribute("morphTarget" + X, k[fe]),
                U && E.getAttribute("morphNormal" + X) !== U[fe] && E.setAttribute("morphNormal" + X, U[fe]),
                c[X] = ce,
                Z += ce) : (k && E.hasAttribute("morphTarget" + X) === !0 && E.deleteAttribute("morphTarget" + X),
                U && E.hasAttribute("morphNormal" + X) === !0 && E.deleteAttribute("morphNormal" + X),
                c[X] = 0)
            }
            let K = E.morphTargetsRelative ? 1 : 1 - Z;
            C.getUniforms().setValue(r, "morphTargetBaseInfluence", K),
            C.getUniforms().setValue(r, "morphTargetInfluences", c)
        }
    }
    return {
        update: v
    }
}
function NF(r, e, t, o) {
    let c = new WeakMap;
    function d(v) {
        let x = o.render.frame
          , E = v.geometry
          , A = e.get(v, E);
        return c.get(A) !== x && (e.update(A),
        c.set(A, x)),
        v.isInstancedMesh && (v.hasEventListener("dispose", i) === !1 && v.addEventListener("dispose", i),
        t.update(v.instanceMatrix, 34962),
        v.instanceColor !== null && t.update(v.instanceColor, 34962)),
        A
    }
    function p() {
        c = new WeakMap
    }
    function i(v) {
        let x = v.target;
        x.removeEventListener("dispose", i),
        t.remove(x.instanceMatrix),
        x.instanceColor !== null && t.remove(x.instanceColor)
    }
    return {
        update: d,
        dispose: p
    }
}
var R2 = new Ar
  , P2 = new Rd
  , k2 = new ac
  , z2 = new jd
  , O2 = []
  , N2 = []
  , F2 = new Float32Array(16)
  , B2 = new Float32Array(9)
  , U2 = new Float32Array(4);
function Jd(r, e, t) {
    let o = r[0];
    if (o <= 0 || o > 0)
        return r;
    let c = e * t
      , d = O2[c];
    if (d === void 0 && (d = new Float32Array(c),
    O2[c] = d),
    e !== 0) {
        o.toArray(d, 0);
        for (let p = 1, i = 0; p !== e; ++p)
            i += t,
            r[p].toArray(d, i)
    }
    return d
}
function Ds(r, e) {
    if (r.length !== e.length)
        return !1;
    for (let t = 0, o = r.length; t < o; t++)
        if (r[t] !== e[t])
            return !1;
    return !0
}
function Es(r, e) {
    for (let t = 0, o = e.length; t < o; t++)
        r[t] = e[t]
}
function c0(r, e) {
    let t = N2[e];
    t === void 0 && (t = new Int32Array(e),
    N2[e] = t);
    for (let o = 0; o !== e; ++o)
        t[o] = r.allocateTextureUnit();
    return t
}
function FF(r, e) {
    let t = this.cache;
    t[0] !== e && (r.uniform1f(this.addr, e),
    t[0] = e)
}
function BF(r, e) {
    let t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y) && (r.uniform2f(this.addr, e.x, e.y),
        t[0] = e.x,
        t[1] = e.y);
    else {
        if (Ds(t, e))
            return;
        r.uniform2fv(this.addr, e),
        Es(t, e)
    }
}
function UF(r, e) {
    let t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (r.uniform3f(this.addr, e.x, e.y, e.z),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z);
    else if (e.r !== void 0)
        (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (r.uniform3f(this.addr, e.r, e.g, e.b),
        t[0] = e.r,
        t[1] = e.g,
        t[2] = e.b);
    else {
        if (Ds(t, e))
            return;
        r.uniform3fv(this.addr, e),
        Es(t, e)
    }
}
function VF(r, e) {
    let t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (r.uniform4f(this.addr, e.x, e.y, e.z, e.w),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z,
        t[3] = e.w);
    else {
        if (Ds(t, e))
            return;
        r.uniform4fv(this.addr, e),
        Es(t, e)
    }
}
function GF(r, e) {
    let t = this.cache
      , o = e.elements;
    if (o === void 0) {
        if (Ds(t, e))
            return;
        r.uniformMatrix2fv(this.addr, !1, e),
        Es(t, e)
    } else {
        if (Ds(t, o))
            return;
        U2.set(o),
        r.uniformMatrix2fv(this.addr, !1, U2),
        Es(t, o)
    }
}
function HF(r, e) {
    let t = this.cache
      , o = e.elements;
    if (o === void 0) {
        if (Ds(t, e))
            return;
        r.uniformMatrix3fv(this.addr, !1, e),
        Es(t, e)
    } else {
        if (Ds(t, o))
            return;
        B2.set(o),
        r.uniformMatrix3fv(this.addr, !1, B2),
        Es(t, o)
    }
}
function WF(r, e) {
    let t = this.cache
      , o = e.elements;
    if (o === void 0) {
        if (Ds(t, e))
            return;
        r.uniformMatrix4fv(this.addr, !1, e),
        Es(t, e)
    } else {
        if (Ds(t, o))
            return;
        F2.set(o),
        r.uniformMatrix4fv(this.addr, !1, F2),
        Es(t, o)
    }
}
function jF(r, e) {
    let t = this.cache;
    t[0] !== e && (r.uniform1i(this.addr, e),
    t[0] = e)
}
function XF(r, e) {
    let t = this.cache;
    Ds(t, e) || (r.uniform2iv(this.addr, e),
    Es(t, e))
}
function ZF(r, e) {
    let t = this.cache;
    Ds(t, e) || (r.uniform3iv(this.addr, e),
    Es(t, e))
}
function qF(r, e) {
    let t = this.cache;
    Ds(t, e) || (r.uniform4iv(this.addr, e),
    Es(t, e))
}
function KF(r, e) {
    let t = this.cache;
    t[0] !== e && (r.uniform1ui(this.addr, e),
    t[0] = e)
}
function YF(r, e) {
    let t = this.cache;
    Ds(t, e) || (r.uniform2uiv(this.addr, e),
    Es(t, e))
}
function JF(r, e) {
    let t = this.cache;
    Ds(t, e) || (r.uniform3uiv(this.addr, e),
    Es(t, e))
}
function $F(r, e) {
    let t = this.cache;
    Ds(t, e) || (r.uniform4uiv(this.addr, e),
    Es(t, e))
}
function QF(r, e, t) {
    let o = this.cache
      , c = t.allocateTextureUnit();
    o[0] !== c && (r.uniform1i(this.addr, c),
    o[0] = c),
    t.setTexture2D(e || R2, c)
}
function eB(r, e, t) {
    let o = this.cache
      , c = t.allocateTextureUnit();
    o[0] !== c && (r.uniform1i(this.addr, c),
    o[0] = c),
    t.setTexture3D(e || k2, c)
}
function tB(r, e, t) {
    let o = this.cache
      , c = t.allocateTextureUnit();
    o[0] !== c && (r.uniform1i(this.addr, c),
    o[0] = c),
    t.setTextureCube(e || z2, c)
}
function nB(r, e, t) {
    let o = this.cache
      , c = t.allocateTextureUnit();
    o[0] !== c && (r.uniform1i(this.addr, c),
    o[0] = c),
    t.setTexture2DArray(e || P2, c)
}
function iB(r) {
    switch (r) {
    case 5126:
        return FF;
    case 35664:
        return BF;
    case 35665:
        return UF;
    case 35666:
        return VF;
    case 35674:
        return GF;
    case 35675:
        return HF;
    case 35676:
        return WF;
    case 5124:
    case 35670:
        return jF;
    case 35667:
    case 35671:
        return XF;
    case 35668:
    case 35672:
        return ZF;
    case 35669:
    case 35673:
        return qF;
    case 5125:
        return KF;
    case 36294:
        return YF;
    case 36295:
        return JF;
    case 36296:
        return $F;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
        return QF;
    case 35679:
    case 36299:
    case 36307:
        return eB;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
        return tB;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
        return nB
    }
}
function rB(r, e) {
    r.uniform1fv(this.addr, e)
}
function sB(r, e) {
    let t = Jd(e, this.size, 2);
    r.uniform2fv(this.addr, t)
}
function oB(r, e) {
    let t = Jd(e, this.size, 3);
    r.uniform3fv(this.addr, t)
}
function aB(r, e) {
    let t = Jd(e, this.size, 4);
    r.uniform4fv(this.addr, t)
}
function lB(r, e) {
    let t = Jd(e, this.size, 4);
    r.uniformMatrix2fv(this.addr, !1, t)
}
function cB(r, e) {
    let t = Jd(e, this.size, 9);
    r.uniformMatrix3fv(this.addr, !1, t)
}
function uB(r, e) {
    let t = Jd(e, this.size, 16);
    r.uniformMatrix4fv(this.addr, !1, t)
}
function hB(r, e) {
    r.uniform1iv(this.addr, e)
}
function dB(r, e) {
    r.uniform2iv(this.addr, e)
}
function fB(r, e) {
    r.uniform3iv(this.addr, e)
}
function pB(r, e) {
    r.uniform4iv(this.addr, e)
}
function mB(r, e) {
    r.uniform1uiv(this.addr, e)
}
function gB(r, e) {
    r.uniform2uiv(this.addr, e)
}
function _B(r, e) {
    r.uniform3uiv(this.addr, e)
}
function yB(r, e) {
    r.uniform4uiv(this.addr, e)
}
function xB(r, e, t) {
    let o = e.length
      , c = c0(t, o);
    r.uniform1iv(this.addr, c);
    for (let d = 0; d !== o; ++d)
        t.setTexture2D(e[d] || R2, c[d])
}
function vB(r, e, t) {
    let o = e.length
      , c = c0(t, o);
    r.uniform1iv(this.addr, c);
    for (let d = 0; d !== o; ++d)
        t.setTexture3D(e[d] || k2, c[d])
}
function bB(r, e, t) {
    let o = e.length
      , c = c0(t, o);
    r.uniform1iv(this.addr, c);
    for (let d = 0; d !== o; ++d)
        t.setTextureCube(e[d] || z2, c[d])
}
function wB(r, e, t) {
    let o = e.length
      , c = c0(t, o);
    r.uniform1iv(this.addr, c);
    for (let d = 0; d !== o; ++d)
        t.setTexture2DArray(e[d] || P2, c[d])
}
function TB(r) {
    switch (r) {
    case 5126:
        return rB;
    case 35664:
        return sB;
    case 35665:
        return oB;
    case 35666:
        return aB;
    case 35674:
        return lB;
    case 35675:
        return cB;
    case 35676:
        return uB;
    case 5124:
    case 35670:
        return hB;
    case 35667:
    case 35671:
        return dB;
    case 35668:
    case 35672:
        return fB;
    case 35669:
    case 35673:
        return pB;
    case 5125:
        return mB;
    case 36294:
        return gB;
    case 36295:
        return _B;
    case 36296:
        return yB;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
        return xB;
    case 35679:
    case 36299:
    case 36307:
        return vB;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
        return bB;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
        return wB
    }
}
function EB(r, e, t) {
    this.id = r,
    this.addr = t,
    this.cache = [],
    this.setValue = iB(e.type)
}
function V2(r, e, t) {
    this.id = r,
    this.addr = t,
    this.cache = [],
    this.size = e.size,
    this.setValue = TB(e.type)
}
V2.prototype.updateCache = function(r) {
    let e = this.cache;
    r instanceof Float32Array && e.length !== r.length && (this.cache = new Float32Array(r.length)),
    Es(e, r)
}
;
function G2(r) {
    this.id = r,
    this.seq = [],
    this.map = {}
}
G2.prototype.setValue = function(r, e, t) {
    let o = this.seq;
    for (let c = 0, d = o.length; c !== d; ++c) {
        let p = o[c];
        p.setValue(r, e[p.id], t)
    }
}
;
var _b = /(\w+)(\])?(\[|\.)?/g;
function H2(r, e) {
    r.seq.push(e),
    r.map[e.id] = e
}
function SB(r, e, t) {
    let o = r.name
      , c = o.length;
    for (_b.lastIndex = 0; ; ) {
        let d = _b.exec(o)
          , p = _b.lastIndex
          , i = d[1]
          , v = d[2] === "]"
          , x = d[3];
        if (v && (i = i | 0),
        x === void 0 || x === "[" && p + 2 === c) {
            H2(t, x === void 0 ? new EB(i,r,e) : new V2(i,r,e));
            break
        } else {
            let A = t.map[i];
            A === void 0 && (A = new G2(i),
            H2(t, A)),
            t = A
        }
    }
}
function yc(r, e) {
    this.seq = [],
    this.map = {};
    let t = r.getProgramParameter(e, 35718);
    for (let o = 0; o < t; ++o) {
        let c = r.getActiveUniform(e, o)
          , d = r.getUniformLocation(e, c.name);
        SB(c, d, this)
    }
}
yc.prototype.setValue = function(r, e, t, o) {
    let c = this.map[e];
    c !== void 0 && c.setValue(r, t, o)
}
;
yc.prototype.setOptional = function(r, e, t) {
    let o = e[t];
    o !== void 0 && this.setValue(r, t, o)
}
;
yc.upload = function(r, e, t, o) {
    for (let c = 0, d = e.length; c !== d; ++c) {
        let p = e[c]
          , i = t[p.id];
        i.needsUpdate !== !1 && p.setValue(r, i.value, o)
    }
}
;
yc.seqWithValue = function(r, e) {
    let t = [];
    for (let o = 0, c = r.length; o !== c; ++o) {
        let d = r[o];
        d.id in e && t.push(d)
    }
    return t
}
;
function W2(r, e, t) {
    let o = r.createShader(e);
    return r.shaderSource(o, t),
    r.compileShader(o),
    o
}
var AB = 0;
function MB(r, e) {
    let t = r.split(`
`)
      , o = []
      , c = Math.max(e - 6, 0)
      , d = Math.min(e + 6, t.length);
    for (let p = c; p < d; p++)
        o.push(p + 1 + ": " + t[p]);
    return o.join(`
`)
}
function IB(r) {
    switch (r) {
    case ya:
        return ["Linear", "( value )"];
    case er:
        return ["sRGB", "( value )"];
    default:
        return console.warn("THREE.WebGLProgram: Unsupported encoding:", r),
        ["Linear", "( value )"]
    }
}
function j2(r, e, t) {
    let o = r.getShaderParameter(e, 35713)
      , c = r.getShaderInfoLog(e).trim();
    if (o && c === "")
        return "";
    let d = parseInt(/ERROR: 0:(\d+)/.exec(c)[1]);
    return t.toUpperCase() + `

` + c + `

` + MB(r.getShaderSource(e), d)
}
function CB(r, e) {
    let t = IB(e);
    return "vec4 " + r + "( vec4 value ) { return LinearTo" + t[0] + t[1] + "; }"
}
function DB(r, e) {
    let t;
    switch (e) {
    case OM:
        t = "Linear";
        break;
    case NM:
        t = "Reinhard";
        break;
    case FM:
        t = "OptimizedCineon";
        break;
    case BM:
        t = "ACESFilmic";
        break;
    case UM:
        t = "Custom";
        break;
    default:
        console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
        t = "Linear"
    }
    return "vec3 " + r + "( vec3 color ) { return " + t + "ToneMapping( color ); }"
}
function LB(r) {
    return [r.extensionDerivatives || !!r.envMapCubeUVHeight || r.bumpMap || r.tangentSpaceNormalMap || r.clearcoatNormalMap || r.flatShading || r.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "", (r.extensionFragDepth || r.logarithmicDepthBuffer) && r.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", r.extensionDrawBuffers && r.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (r.extensionShaderTextureLOD || r.envMap || r.transmission) && r.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Am).join(`
`)
}
function RB(r) {
    let e = [];
    for (let t in r) {
        let o = r[t];
        o !== !1 && e.push("#define " + t + " " + o)
    }
    return e.join(`
`)
}
function PB(r, e) {
    let t = {}
      , o = r.getProgramParameter(e, 35721);
    for (let c = 0; c < o; c++) {
        let d = r.getActiveAttrib(e, c)
          , p = d.name
          , i = 1;
        d.type === 35674 && (i = 2),
        d.type === 35675 && (i = 3),
        d.type === 35676 && (i = 4),
        t[p] = {
            type: d.type,
            location: r.getAttribLocation(e, p),
            locationSize: i
        }
    }
    return t
}
function Am(r) {
    return r !== ""
}
function X2(r, e) {
    return r.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
}
function Z2(r, e) {
    return r.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
}
var kB = /^[ \t]*#include +<([\w\d./]+)>/gm;
function yb(r) {
    return r.replace(kB, zB)
}
function zB(r, e) {
    let t = hi[e];
    if (t === void 0)
        throw new Error("Can not resolve #include <" + e + ">");
    return yb(t)
}
var OB = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g
  , NB = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function K2(r) {
    return r.replace(NB, q2).replace(OB, FB)
}
function FB(r, e, t, o) {
    return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),
    q2(r, e, t, o)
}
function q2(r, e, t, o) {
    let c = "";
    for (let d = parseInt(e); d < parseInt(t); d++)
        c += o.replace(/\[\s*i\s*\]/g, "[ " + d + " ]").replace(/UNROLLED_LOOP_INDEX/g, d);
    return c
}
function Y2(r) {
    let e = "precision " + r.precision + ` float;
precision ` + r.precision + " int;";
    return r.precision === "highp" ? e += `
#define HIGH_PRECISION` : r.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : r.precision === "lowp" && (e += `
#define LOW_PRECISION`),
    e
}
function BB(r) {
    let e = "SHADOWMAP_TYPE_BASIC";
    return r.shadowMapType === r1 ? e = "SHADOWMAP_TYPE_PCF" : r.shadowMapType === pM ? e = "SHADOWMAP_TYPE_PCF_SOFT" : r.shadowMapType === Ad && (e = "SHADOWMAP_TYPE_VSM"),
    e
}
function UB(r) {
    let e = "ENVMAP_TYPE_CUBE";
    if (r.envMap)
        switch (r.envMapMode) {
        case Bu:
        case Uu:
            e = "ENVMAP_TYPE_CUBE";
            break;
        case hm:
            e = "ENVMAP_TYPE_CUBE_UV";
            break
        }
    return e
}
function VB(r) {
    let e = "ENVMAP_MODE_REFLECTION";
    if (r.envMap)
        switch (r.envMapMode) {
        case Uu:
            e = "ENVMAP_MODE_REFRACTION";
            break
        }
    return e
}
function GB(r) {
    let e = "ENVMAP_BLENDING_NONE";
    if (r.envMap)
        switch (r.combine) {
        case um:
            e = "ENVMAP_BLENDING_MULTIPLY";
            break;
        case kM:
            e = "ENVMAP_BLENDING_MIX";
            break;
        case zM:
            e = "ENVMAP_BLENDING_ADD";
            break
        }
    return e
}
function HB(r) {
    let e = r.envMapCubeUVHeight;
    if (e === null)
        return null;
    let t = Math.log2(e / 32 + 1) + 3
      , o = 1 / e;
    return {
        texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)),
        texelHeight: o,
        maxMip: t
    }
}
function WB(r, e, t, o) {
    let c = r.getContext(), d = t.defines, p = t.vertexShader, i = t.fragmentShader, v = BB(t), x = UB(t), E = VB(t), A = GB(t), C = HB(t), I = t.isWebGL2 ? "" : LB(t), D = RB(d), P = c.createProgram(), k, U, Z = t.glslVersion ? "#version " + t.glslVersion + `
` : "";
    t.isRawShaderMaterial ? (k = [D].filter(Am).join(`
`),
    k.length > 0 && (k += `
`),
    U = [I, D].filter(Am).join(`
`),
    U.length > 0 && (U += `
`)) : (k = [Y2(t), "#define SHADER_NAME " + t.shaderName, D, t.instancing ? "#define USE_INSTANCING" : "", t.instancingColor ? "#define USE_INSTANCING_COLOR" : "", t.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define MAX_BONES " + t.maxBones, t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.map ? "#define USE_MAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + E : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMap && t.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", t.normalMap && t.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.displacementMap && t.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", t.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", t.vertexTangents ? "#define USE_TANGENT" : "", t.vertexColors ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUvs ? "#define USE_UV" : "", t.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.skinning ? "#define USE_SKINNING" : "", t.useVertexTexture ? "#define BONE_TEXTURE" : "", t.morphTargets ? "#define USE_MORPHTARGETS" : "", t.morphNormals && t.flatShading === !1 ? "#define USE_MORPHNORMALS" : "", t.morphColors && t.isWebGL2 ? "#define USE_MORPHCOLORS" : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + v : "", t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "	attribute vec3 morphTarget0;", "	attribute vec3 morphTarget1;", "	attribute vec3 morphTarget2;", "	attribute vec3 morphTarget3;", "	#ifdef USE_MORPHNORMALS", "		attribute vec3 morphNormal0;", "		attribute vec3 morphNormal1;", "		attribute vec3 morphNormal2;", "		attribute vec3 morphNormal3;", "	#else", "		attribute vec3 morphTarget4;", "		attribute vec3 morphTarget5;", "		attribute vec3 morphTarget6;", "		attribute vec3 morphTarget7;", "	#endif", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", `
`].filter(Am).join(`
`),
    U = [I, Y2(t), "#define SHADER_NAME " + t.shaderName, D, t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.map ? "#define USE_MAP" : "", t.matcap ? "#define USE_MATCAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + x : "", t.envMap ? "#define " + E : "", t.envMap ? "#define " + A : "", C ? "#define CUBEUV_TEXEL_WIDTH " + C.texelWidth : "", C ? "#define CUBEUV_TEXEL_HEIGHT " + C.texelHeight : "", C ? "#define CUBEUV_MAX_MIP " + C.maxMip + ".0" : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMap && t.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", t.normalMap && t.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", t.clearcoat ? "#define USE_CLEARCOAT" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", t.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.alphaTest ? "#define USE_ALPHATEST" : "", t.sheen ? "#define USE_SHEEN" : "", t.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", t.vertexTangents ? "#define USE_TANGENT" : "", t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUvs ? "#define USE_UV" : "", t.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", t.gradientMap ? "#define USE_GRADIENTMAP" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + v : "", t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", t.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", t.toneMapping !== _a ? "#define TONE_MAPPING" : "", t.toneMapping !== _a ? hi.tonemapping_pars_fragment : "", t.toneMapping !== _a ? DB("toneMapping", t.toneMapping) : "", t.dithering ? "#define DITHERING" : "", t.opaque ? "#define OPAQUE" : "", hi.encodings_pars_fragment, CB("linearToOutputTexel", t.outputEncoding), t.depthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "", `
`].filter(Am).join(`
`)),
    p = yb(p),
    p = X2(p, t),
    p = Z2(p, t),
    i = yb(i),
    i = X2(i, t),
    i = Z2(i, t),
    p = K2(p),
    i = K2(i),
    t.isWebGL2 && t.isRawShaderMaterial !== !0 && (Z = `#version 300 es
`,
    k = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join(`
`) + `
` + k,
    U = ["#define varying in", t.glslVersion === Dd ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", t.glslVersion === Dd ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join(`
`) + `
` + U);
    let K = Z + k + p
      , X = Z + U + i
      , W = W2(c, 35633, K)
      , fe = W2(c, 35632, X);
    if (c.attachShader(P, W),
    c.attachShader(P, fe),
    t.index0AttributeName !== void 0 ? c.bindAttribLocation(P, 0, t.index0AttributeName) : t.morphTargets === !0 && c.bindAttribLocation(P, 0, "position"),
    c.linkProgram(P),
    r.debug.checkShaderErrors) {
        let oe = c.getProgramInfoLog(P).trim()
          , ee = c.getShaderInfoLog(W).trim()
          , j = c.getShaderInfoLog(fe).trim()
          , ne = !0
          , be = !0;
        if (c.getProgramParameter(P, 35714) === !1) {
            ne = !1;
            let te = j2(c, W, "vertex")
              , ae = j2(c, fe, "fragment");
            console.error("THREE.WebGLProgram: Shader Error " + c.getError() + " - VALIDATE_STATUS " + c.getProgramParameter(P, 35715) + `

Program Info Log: ` + oe + `
` + te + `
` + ae)
        } else
            oe !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", oe) : (ee === "" || j === "") && (be = !1);
        be && (this.diagnostics = {
            runnable: ne,
            programLog: oe,
            vertexShader: {
                log: ee,
                prefix: k
            },
            fragmentShader: {
                log: j,
                prefix: U
            }
        })
    }
    c.deleteShader(W),
    c.deleteShader(fe);
    let ce;
    this.getUniforms = function() {
        return ce === void 0 && (ce = new yc(c,P)),
        ce
    }
    ;
    let _e;
    return this.getAttributes = function() {
        return _e === void 0 && (_e = PB(c, P)),
        _e
    }
    ,
    this.destroy = function() {
        o.releaseStatesOfProgram(this),
        c.deleteProgram(P),
        this.program = void 0
    }
    ,
    this.name = t.shaderName,
    this.id = AB++,
    this.cacheKey = e,
    this.usedTimes = 1,
    this.program = P,
    this.vertexShader = W,
    this.fragmentShader = fe,
    this
}
var jB = 0
  , J2 = class {
    constructor() {
        this.shaderCache = new Map,
        this.materialCache = new Map
    }
    update(e) {
        let t = e.vertexShader
          , o = e.fragmentShader
          , c = this._getShaderStage(t)
          , d = this._getShaderStage(o)
          , p = this._getShaderCacheForMaterial(e);
        return p.has(c) === !1 && (p.add(c),
        c.usedTimes++),
        p.has(d) === !1 && (p.add(d),
        d.usedTimes++),
        this
    }
    remove(e) {
        let t = this.materialCache.get(e);
        for (let o of t)
            o.usedTimes--,
            o.usedTimes === 0 && this.shaderCache.delete(o.code);
        return this.materialCache.delete(e),
        this
    }
    getVertexShaderID(e) {
        return this._getShaderStage(e.vertexShader).id
    }
    getFragmentShaderID(e) {
        return this._getShaderStage(e.fragmentShader).id
    }
    dispose() {
        this.shaderCache.clear(),
        this.materialCache.clear()
    }
    _getShaderCacheForMaterial(e) {
        let t = this.materialCache;
        return t.has(e) === !1 && t.set(e, new Set),
        t.get(e)
    }
    _getShaderStage(e) {
        let t = this.shaderCache;
        if (t.has(e) === !1) {
            let o = new $2(e);
            t.set(e, o)
        }
        return t.get(e)
    }
}
  , $2 = class {
    constructor(e) {
        this.id = jB++,
        this.code = e,
        this.usedTimes = 0
    }
}
;
function XB(r, e, t, o, c, d, p) {
    let i = new Xy
      , v = new J2
      , x = []
      , E = c.isWebGL2
      , A = c.logarithmicDepthBuffer
      , C = c.floatVertexTextures
      , I = c.maxVertexUniforms
      , D = c.vertexTextures
      , P = c.precision
      , k = {
        MeshDepthMaterial: "depth",
        MeshDistanceMaterial: "distanceRGBA",
        MeshNormalMaterial: "normal",
        MeshBasicMaterial: "basic",
        MeshLambertMaterial: "lambert",
        MeshPhongMaterial: "phong",
        MeshToonMaterial: "toon",
        MeshStandardMaterial: "physical",
        MeshPhysicalMaterial: "physical",
        MeshMatcapMaterial: "matcap",
        LineBasicMaterial: "basic",
        LineDashedMaterial: "dashed",
        PointsMaterial: "points",
        ShadowMaterial: "shadow",
        SpriteMaterial: "sprite"
    };
    function U(j) {
        let be = j.skeleton.bones;
        if (C)
            return 1024;
        {
            let ae = Math.floor((I - 20) / 4)
              , se = Math.min(ae, be.length);
            return se < be.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + be.length + " bones. This GPU supports " + se + "."),
            0) : se
        }
    }
    function Z(j, ne, be, te, ae) {
        let se = te.fog
          , ke = ae.geometry
          , Be = j.isMeshStandardMaterial ? te.environment : null
          , tt = (j.isMeshStandardMaterial ? t : e).get(j.envMap || Be)
          , Ke = !!tt && tt.mapping === hm ? tt.image.height : null
          , bt = k[j.type]
          , Et = ae.isSkinnedMesh ? U(ae) : 0;
        j.precision !== null && (P = c.getMaxPrecision(j.precision),
        P !== j.precision && console.warn("THREE.WebGLProgram.getParameters:", j.precision, "not supported, using", P, "instead."));
        let Gt = ke.morphAttributes.position || ke.morphAttributes.normal || ke.morphAttributes.color
          , Ye = Gt !== void 0 ? Gt.length : 0
          , gn = 0;
        ke.morphAttributes.position !== void 0 && (gn = 1),
        ke.morphAttributes.normal !== void 0 && (gn = 2),
        ke.morphAttributes.color !== void 0 && (gn = 3);
        let gt, Tn, xn, Dn;
        if (bt) {
            let xt = jo[bt];
            gt = xt.vertexShader,
            Tn = xt.fragmentShader
        } else
            gt = j.vertexShader,
            Tn = j.fragmentShader,
            v.update(j),
            xn = v.getVertexShaderID(j),
            Dn = v.getFragmentShaderID(j);
        let Bt = r.getRenderTarget()
          , An = j.alphaTest > 0
          , ut = j.clearcoat > 0;
        return {
            isWebGL2: E,
            shaderID: bt,
            shaderName: j.type,
            vertexShader: gt,
            fragmentShader: Tn,
            defines: j.defines,
            customVertexShaderID: xn,
            customFragmentShaderID: Dn,
            isRawShaderMaterial: j.isRawShaderMaterial === !0,
            glslVersion: j.glslVersion,
            precision: P,
            instancing: ae.isInstancedMesh === !0,
            instancingColor: ae.isInstancedMesh === !0 && ae.instanceColor !== null,
            supportsVertexTextures: D,
            outputEncoding: Bt === null ? r.outputEncoding : Bt.isXRRenderTarget === !0 ? Bt.texture.encoding : ya,
            map: !!j.map,
            matcap: !!j.matcap,
            envMap: !!tt,
            envMapMode: tt && tt.mapping,
            envMapCubeUVHeight: Ke,
            lightMap: !!j.lightMap,
            aoMap: !!j.aoMap,
            emissiveMap: !!j.emissiveMap,
            bumpMap: !!j.bumpMap,
            normalMap: !!j.normalMap,
            objectSpaceNormalMap: j.normalMapType === l2,
            tangentSpaceNormalMap: j.normalMapType === Zu,
            decodeVideoTexture: !!j.map && j.map.isVideoTexture === !0 && j.map.encoding === er,
            clearcoat: ut,
            clearcoatMap: ut && !!j.clearcoatMap,
            clearcoatRoughnessMap: ut && !!j.clearcoatRoughnessMap,
            clearcoatNormalMap: ut && !!j.clearcoatNormalMap,
            displacementMap: !!j.displacementMap,
            roughnessMap: !!j.roughnessMap,
            metalnessMap: !!j.metalnessMap,
            specularMap: !!j.specularMap,
            specularIntensityMap: !!j.specularIntensityMap,
            specularColorMap: !!j.specularColorMap,
            opaque: j.transparent === !1 && j.blending === Nu,
            alphaMap: !!j.alphaMap,
            alphaTest: An,
            gradientMap: !!j.gradientMap,
            sheen: j.sheen > 0,
            sheenColorMap: !!j.sheenColorMap,
            sheenRoughnessMap: !!j.sheenRoughnessMap,
            transmission: j.transmission > 0,
            transmissionMap: !!j.transmissionMap,
            thicknessMap: !!j.thicknessMap,
            combine: j.combine,
            vertexTangents: !!j.normalMap && !!ke.attributes.tangent,
            vertexColors: j.vertexColors,
            vertexAlphas: j.vertexColors === !0 && !!ke.attributes.color && ke.attributes.color.itemSize === 4,
            vertexUvs: !!j.map || !!j.bumpMap || !!j.normalMap || !!j.specularMap || !!j.alphaMap || !!j.emissiveMap || !!j.roughnessMap || !!j.metalnessMap || !!j.clearcoatMap || !!j.clearcoatRoughnessMap || !!j.clearcoatNormalMap || !!j.displacementMap || !!j.transmissionMap || !!j.thicknessMap || !!j.specularIntensityMap || !!j.specularColorMap || !!j.sheenColorMap || !!j.sheenRoughnessMap,
            uvsVertexOnly: !(!!j.map || !!j.bumpMap || !!j.normalMap || !!j.specularMap || !!j.alphaMap || !!j.emissiveMap || !!j.roughnessMap || !!j.metalnessMap || !!j.clearcoatNormalMap || j.transmission > 0 || !!j.transmissionMap || !!j.thicknessMap || !!j.specularIntensityMap || !!j.specularColorMap || j.sheen > 0 || !!j.sheenColorMap || !!j.sheenRoughnessMap) && !!j.displacementMap,
            fog: !!se,
            useFog: j.fog,
            fogExp2: se && se.isFogExp2,
            flatShading: !!j.flatShading,
            sizeAttenuation: j.sizeAttenuation,
            logarithmicDepthBuffer: A,
            skinning: ae.isSkinnedMesh === !0 && Et > 0,
            maxBones: Et,
            useVertexTexture: C,
            morphTargets: ke.morphAttributes.position !== void 0,
            morphNormals: ke.morphAttributes.normal !== void 0,
            morphColors: ke.morphAttributes.color !== void 0,
            morphTargetsCount: Ye,
            morphTextureStride: gn,
            numDirLights: ne.directional.length,
            numPointLights: ne.point.length,
            numSpotLights: ne.spot.length,
            numRectAreaLights: ne.rectArea.length,
            numHemiLights: ne.hemi.length,
            numDirLightShadows: ne.directionalShadowMap.length,
            numPointLightShadows: ne.pointShadowMap.length,
            numSpotLightShadows: ne.spotShadowMap.length,
            numClippingPlanes: p.numPlanes,
            numClipIntersection: p.numIntersection,
            dithering: j.dithering,
            shadowMapEnabled: r.shadowMap.enabled && be.length > 0,
            shadowMapType: r.shadowMap.type,
            toneMapping: j.toneMapped ? r.toneMapping : _a,
            physicallyCorrectLights: r.physicallyCorrectLights,
            premultipliedAlpha: j.premultipliedAlpha,
            doubleSided: j.side === $a,
            flipSided: j.side === Zs,
            depthPacking: j.depthPacking !== void 0 ? j.depthPacking : !1,
            index0AttributeName: j.index0AttributeName,
            extensionDerivatives: j.extensions && j.extensions.derivatives,
            extensionFragDepth: j.extensions && j.extensions.fragDepth,
            extensionDrawBuffers: j.extensions && j.extensions.drawBuffers,
            extensionShaderTextureLOD: j.extensions && j.extensions.shaderTextureLOD,
            rendererExtensionFragDepth: E || o.has("EXT_frag_depth"),
            rendererExtensionDrawBuffers: E || o.has("WEBGL_draw_buffers"),
            rendererExtensionShaderTextureLod: E || o.has("EXT_shader_texture_lod"),
            customProgramCacheKey: j.customProgramCacheKey()
        }
    }
    function K(j) {
        let ne = [];
        if (j.shaderID ? ne.push(j.shaderID) : (ne.push(j.customVertexShaderID),
        ne.push(j.customFragmentShaderID)),
        j.defines !== void 0)
            for (let be in j.defines)
                ne.push(be),
                ne.push(j.defines[be]);
        return j.isRawShaderMaterial === !1 && (X(ne, j),
        W(ne, j),
        ne.push(r.outputEncoding)),
        ne.push(j.customProgramCacheKey),
        ne.join()
    }
    function X(j, ne) {
        j.push(ne.precision),
        j.push(ne.outputEncoding),
        j.push(ne.envMapMode),
        j.push(ne.envMapCubeUVHeight),
        j.push(ne.combine),
        j.push(ne.vertexUvs),
        j.push(ne.fogExp2),
        j.push(ne.sizeAttenuation),
        j.push(ne.maxBones),
        j.push(ne.morphTargetsCount),
        j.push(ne.morphAttributeCount),
        j.push(ne.numDirLights),
        j.push(ne.numPointLights),
        j.push(ne.numSpotLights),
        j.push(ne.numHemiLights),
        j.push(ne.numRectAreaLights),
        j.push(ne.numDirLightShadows),
        j.push(ne.numPointLightShadows),
        j.push(ne.numSpotLightShadows),
        j.push(ne.shadowMapType),
        j.push(ne.toneMapping),
        j.push(ne.numClippingPlanes),
        j.push(ne.numClipIntersection)
    }
    function W(j, ne) {
        i.disableAll(),
        ne.isWebGL2 && i.enable(0),
        ne.supportsVertexTextures && i.enable(1),
        ne.instancing && i.enable(2),
        ne.instancingColor && i.enable(3),
        ne.map && i.enable(4),
        ne.matcap && i.enable(5),
        ne.envMap && i.enable(6),
        ne.lightMap && i.enable(7),
        ne.aoMap && i.enable(8),
        ne.emissiveMap && i.enable(9),
        ne.bumpMap && i.enable(10),
        ne.normalMap && i.enable(11),
        ne.objectSpaceNormalMap && i.enable(12),
        ne.tangentSpaceNormalMap && i.enable(13),
        ne.clearcoat && i.enable(14),
        ne.clearcoatMap && i.enable(15),
        ne.clearcoatRoughnessMap && i.enable(16),
        ne.clearcoatNormalMap && i.enable(17),
        ne.displacementMap && i.enable(18),
        ne.specularMap && i.enable(19),
        ne.roughnessMap && i.enable(20),
        ne.metalnessMap && i.enable(21),
        ne.gradientMap && i.enable(22),
        ne.alphaMap && i.enable(23),
        ne.alphaTest && i.enable(24),
        ne.vertexColors && i.enable(25),
        ne.vertexAlphas && i.enable(26),
        ne.vertexUvs && i.enable(27),
        ne.vertexTangents && i.enable(28),
        ne.uvsVertexOnly && i.enable(29),
        ne.fog && i.enable(30),
        j.push(i.mask),
        i.disableAll(),
        ne.useFog && i.enable(0),
        ne.flatShading && i.enable(1),
        ne.logarithmicDepthBuffer && i.enable(2),
        ne.skinning && i.enable(3),
        ne.useVertexTexture && i.enable(4),
        ne.morphTargets && i.enable(5),
        ne.morphNormals && i.enable(6),
        ne.morphColors && i.enable(7),
        ne.premultipliedAlpha && i.enable(8),
        ne.shadowMapEnabled && i.enable(9),
        ne.physicallyCorrectLights && i.enable(10),
        ne.doubleSided && i.enable(11),
        ne.flipSided && i.enable(12),
        ne.depthPacking && i.enable(13),
        ne.dithering && i.enable(14),
        ne.specularIntensityMap && i.enable(15),
        ne.specularColorMap && i.enable(16),
        ne.transmission && i.enable(17),
        ne.transmissionMap && i.enable(18),
        ne.thicknessMap && i.enable(19),
        ne.sheen && i.enable(20),
        ne.sheenColorMap && i.enable(21),
        ne.sheenRoughnessMap && i.enable(22),
        ne.decodeVideoTexture && i.enable(23),
        ne.opaque && i.enable(24),
        j.push(i.mask)
    }
    function fe(j) {
        let ne = k[j.type], be;
        if (ne) {
            let te = jo[ne];
            be = E2.clone(te.uniforms)
        } else
            be = j.uniforms;
        return be
    }
    function ce(j, ne) {
        let be;
        for (let te = 0, ae = x.length; te < ae; te++) {
            let se = x[te];
            if (se.cacheKey === ne) {
                be = se,
                ++be.usedTimes;
                break
            }
        }
        return be === void 0 && (be = new WB(r,ne,j,d),
        x.push(be)),
        be
    }
    function _e(j) {
        if (--j.usedTimes == 0) {
            let ne = x.indexOf(j);
            x[ne] = x[x.length - 1],
            x.pop(),
            j.destroy()
        }
    }
    function oe(j) {
        v.remove(j)
    }
    function ee() {
        v.dispose()
    }
    return {
        getParameters: Z,
        getProgramCacheKey: K,
        getUniforms: fe,
        acquireProgram: ce,
        releaseProgram: _e,
        releaseShaderCache: oe,
        programs: x,
        dispose: ee
    }
}
function ZB() {
    let r = new WeakMap;
    function e(d) {
        let p = r.get(d);
        return p === void 0 && (p = {},
        r.set(d, p)),
        p
    }
    function t(d) {
        r.delete(d)
    }
    function o(d, p, i) {
        r.get(d)[p] = i
    }
    function c() {
        r = new WeakMap
    }
    return {
        get: e,
        remove: t,
        update: o,
        dispose: c
    }
}
function qB(r, e) {
    return r.groupOrder !== e.groupOrder ? r.groupOrder - e.groupOrder : r.renderOrder !== e.renderOrder ? r.renderOrder - e.renderOrder : r.material.id !== e.material.id ? r.material.id - e.material.id : r.z !== e.z ? r.z - e.z : r.id - e.id
}
function Q2(r, e) {
    return r.groupOrder !== e.groupOrder ? r.groupOrder - e.groupOrder : r.renderOrder !== e.renderOrder ? r.renderOrder - e.renderOrder : r.z !== e.z ? e.z - r.z : r.id - e.id
}
function eI() {
    let r = []
      , e = 0
      , t = []
      , o = []
      , c = [];
    function d() {
        e = 0,
        t.length = 0,
        o.length = 0,
        c.length = 0
    }
    function p(A, C, I, D, P, k) {
        let U = r[e];
        return U === void 0 ? (U = {
            id: A.id,
            object: A,
            geometry: C,
            material: I,
            groupOrder: D,
            renderOrder: A.renderOrder,
            z: P,
            group: k
        },
        r[e] = U) : (U.id = A.id,
        U.object = A,
        U.geometry = C,
        U.material = I,
        U.groupOrder = D,
        U.renderOrder = A.renderOrder,
        U.z = P,
        U.group = k),
        e++,
        U
    }
    function i(A, C, I, D, P, k) {
        let U = p(A, C, I, D, P, k);
        I.transmission > 0 ? o.push(U) : I.transparent === !0 ? c.push(U) : t.push(U)
    }
    function v(A, C, I, D, P, k) {
        let U = p(A, C, I, D, P, k);
        I.transmission > 0 ? o.unshift(U) : I.transparent === !0 ? c.unshift(U) : t.unshift(U)
    }
    function x(A, C) {
        t.length > 1 && t.sort(A || qB),
        o.length > 1 && o.sort(C || Q2),
        c.length > 1 && c.sort(C || Q2)
    }
    function E() {
        for (let A = e, C = r.length; A < C; A++) {
            let I = r[A];
            if (I.id === null)
                break;
            I.id = null,
            I.object = null,
            I.geometry = null,
            I.material = null,
            I.group = null
        }
    }
    return {
        opaque: t,
        transmissive: o,
        transparent: c,
        init: d,
        push: i,
        unshift: v,
        finish: E,
        sort: x
    }
}
function KB() {
    let r = new WeakMap;
    function e(o, c) {
        let d;
        return r.has(o) === !1 ? (d = new eI,
        r.set(o, [d])) : c >= r.get(o).length ? (d = new eI,
        r.get(o).push(d)) : d = r.get(o)[c],
        d
    }
    function t() {
        r = new WeakMap
    }
    return {
        get: e,
        dispose: t
    }
}
function YB() {
    let r = {};
    return {
        get: function(e) {
            if (r[e.id] !== void 0)
                return r[e.id];
            let t;
            switch (e.type) {
            case "DirectionalLight":
                t = {
                    direction: new Oe,
                    color: new In
                };
                break;
            case "SpotLight":
                t = {
                    position: new Oe,
                    direction: new Oe,
                    color: new In,
                    distance: 0,
                    coneCos: 0,
                    penumbraCos: 0,
                    decay: 0
                };
                break;
            case "PointLight":
                t = {
                    position: new Oe,
                    color: new In,
                    distance: 0,
                    decay: 0
                };
                break;
            case "HemisphereLight":
                t = {
                    direction: new Oe,
                    skyColor: new In,
                    groundColor: new In
                };
                break;
            case "RectAreaLight":
                t = {
                    color: new In,
                    position: new Oe,
                    halfWidth: new Oe,
                    halfHeight: new Oe
                };
                break
            }
            return r[e.id] = t,
            t
        }
    }
}
function JB() {
    let r = {};
    return {
        get: function(e) {
            if (r[e.id] !== void 0)
                return r[e.id];
            let t;
            switch (e.type) {
            case "DirectionalLight":
                t = {
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new zt
                };
                break;
            case "SpotLight":
                t = {
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new zt
                };
                break;
            case "PointLight":
                t = {
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new zt,
                    shadowCameraNear: 1,
                    shadowCameraFar: 1e3
                };
                break
            }
            return r[e.id] = t,
            t
        }
    }
}
var $B = 0;
function QB(r, e) {
    return (e.castShadow ? 1 : 0) - (r.castShadow ? 1 : 0)
}
function e5(r, e) {
    let t = new YB
      , o = JB()
      , c = {
        version: 0,
        hash: {
            directionalLength: -1,
            pointLength: -1,
            spotLength: -1,
            rectAreaLength: -1,
            hemiLength: -1,
            numDirectionalShadows: -1,
            numPointShadows: -1,
            numSpotShadows: -1
        },
        ambient: [0, 0, 0],
        probe: [],
        directional: [],
        directionalShadow: [],
        directionalShadowMap: [],
        directionalShadowMatrix: [],
        spot: [],
        spotShadow: [],
        spotShadowMap: [],
        spotShadowMatrix: [],
        rectArea: [],
        rectAreaLTC1: null,
        rectAreaLTC2: null,
        point: [],
        pointShadow: [],
        pointShadowMap: [],
        pointShadowMatrix: [],
        hemi: []
    };
    for (let E = 0; E < 9; E++)
        c.probe.push(new Oe);
    let d = new Oe
      , p = new Fn
      , i = new Fn;
    function v(E, A) {
        let C = 0
          , I = 0
          , D = 0;
        for (let oe = 0; oe < 9; oe++)
            c.probe[oe].set(0, 0, 0);
        let P = 0
          , k = 0
          , U = 0
          , Z = 0
          , K = 0
          , X = 0
          , W = 0
          , fe = 0;
        E.sort(QB);
        let ce = A !== !0 ? Math.PI : 1;
        for (let oe = 0, ee = E.length; oe < ee; oe++) {
            let j = E[oe]
              , ne = j.color
              , be = j.intensity
              , te = j.distance
              , ae = j.shadow && j.shadow.map ? j.shadow.map.texture : null;
            if (j.isAmbientLight)
                C += ne.r * be * ce,
                I += ne.g * be * ce,
                D += ne.b * be * ce;
            else if (j.isLightProbe)
                for (let se = 0; se < 9; se++)
                    c.probe[se].addScaledVector(j.sh.coefficients[se], be);
            else if (j.isDirectionalLight) {
                let se = t.get(j);
                if (se.color.copy(j.color).multiplyScalar(j.intensity * ce),
                j.castShadow) {
                    let ke = j.shadow
                      , Be = o.get(j);
                    Be.shadowBias = ke.bias,
                    Be.shadowNormalBias = ke.normalBias,
                    Be.shadowRadius = ke.radius,
                    Be.shadowMapSize = ke.mapSize,
                    c.directionalShadow[P] = Be,
                    c.directionalShadowMap[P] = ae,
                    c.directionalShadowMatrix[P] = j.shadow.matrix,
                    X++
                }
                c.directional[P] = se,
                P++
            } else if (j.isSpotLight) {
                let se = t.get(j);
                if (se.position.setFromMatrixPosition(j.matrixWorld),
                se.color.copy(ne).multiplyScalar(be * ce),
                se.distance = te,
                se.coneCos = Math.cos(j.angle),
                se.penumbraCos = Math.cos(j.angle * (1 - j.penumbra)),
                se.decay = j.decay,
                j.castShadow) {
                    let ke = j.shadow
                      , Be = o.get(j);
                    Be.shadowBias = ke.bias,
                    Be.shadowNormalBias = ke.normalBias,
                    Be.shadowRadius = ke.radius,
                    Be.shadowMapSize = ke.mapSize,
                    c.spotShadow[U] = Be,
                    c.spotShadowMap[U] = ae,
                    c.spotShadowMatrix[U] = j.shadow.matrix,
                    fe++
                }
                c.spot[U] = se,
                U++
            } else if (j.isRectAreaLight) {
                let se = t.get(j);
                se.color.copy(ne).multiplyScalar(be),
                se.halfWidth.set(j.width * .5, 0, 0),
                se.halfHeight.set(0, j.height * .5, 0),
                c.rectArea[Z] = se,
                Z++
            } else if (j.isPointLight) {
                let se = t.get(j);
                if (se.color.copy(j.color).multiplyScalar(j.intensity * ce),
                se.distance = j.distance,
                se.decay = j.decay,
                j.castShadow) {
                    let ke = j.shadow
                      , Be = o.get(j);
                    Be.shadowBias = ke.bias,
                    Be.shadowNormalBias = ke.normalBias,
                    Be.shadowRadius = ke.radius,
                    Be.shadowMapSize = ke.mapSize,
                    Be.shadowCameraNear = ke.camera.near,
                    Be.shadowCameraFar = ke.camera.far,
                    c.pointShadow[k] = Be,
                    c.pointShadowMap[k] = ae,
                    c.pointShadowMatrix[k] = j.shadow.matrix,
                    W++
                }
                c.point[k] = se,
                k++
            } else if (j.isHemisphereLight) {
                let se = t.get(j);
                se.skyColor.copy(j.color).multiplyScalar(be * ce),
                se.groundColor.copy(j.groundColor).multiplyScalar(be * ce),
                c.hemi[K] = se,
                K++
            }
        }
        Z > 0 && (e.isWebGL2 || r.has("OES_texture_float_linear") === !0 ? (c.rectAreaLTC1 = dn.LTC_FLOAT_1,
        c.rectAreaLTC2 = dn.LTC_FLOAT_2) : r.has("OES_texture_half_float_linear") === !0 ? (c.rectAreaLTC1 = dn.LTC_HALF_1,
        c.rectAreaLTC2 = dn.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),
        c.ambient[0] = C,
        c.ambient[1] = I,
        c.ambient[2] = D;
        let _e = c.hash;
        (_e.directionalLength !== P || _e.pointLength !== k || _e.spotLength !== U || _e.rectAreaLength !== Z || _e.hemiLength !== K || _e.numDirectionalShadows !== X || _e.numPointShadows !== W || _e.numSpotShadows !== fe) && (c.directional.length = P,
        c.spot.length = U,
        c.rectArea.length = Z,
        c.point.length = k,
        c.hemi.length = K,
        c.directionalShadow.length = X,
        c.directionalShadowMap.length = X,
        c.pointShadow.length = W,
        c.pointShadowMap.length = W,
        c.spotShadow.length = fe,
        c.spotShadowMap.length = fe,
        c.directionalShadowMatrix.length = X,
        c.pointShadowMatrix.length = W,
        c.spotShadowMatrix.length = fe,
        _e.directionalLength = P,
        _e.pointLength = k,
        _e.spotLength = U,
        _e.rectAreaLength = Z,
        _e.hemiLength = K,
        _e.numDirectionalShadows = X,
        _e.numPointShadows = W,
        _e.numSpotShadows = fe,
        c.version = $B++)
    }
    function x(E, A) {
        let C = 0
          , I = 0
          , D = 0
          , P = 0
          , k = 0
          , U = A.matrixWorldInverse;
        for (let Z = 0, K = E.length; Z < K; Z++) {
            let X = E[Z];
            if (X.isDirectionalLight) {
                let W = c.directional[C];
                W.direction.setFromMatrixPosition(X.matrixWorld),
                d.setFromMatrixPosition(X.target.matrixWorld),
                W.direction.sub(d),
                W.direction.transformDirection(U),
                C++
            } else if (X.isSpotLight) {
                let W = c.spot[D];
                W.position.setFromMatrixPosition(X.matrixWorld),
                W.position.applyMatrix4(U),
                W.direction.setFromMatrixPosition(X.matrixWorld),
                d.setFromMatrixPosition(X.target.matrixWorld),
                W.direction.sub(d),
                W.direction.transformDirection(U),
                D++
            } else if (X.isRectAreaLight) {
                let W = c.rectArea[P];
                W.position.setFromMatrixPosition(X.matrixWorld),
                W.position.applyMatrix4(U),
                i.identity(),
                p.copy(X.matrixWorld),
                p.premultiply(U),
                i.extractRotation(p),
                W.halfWidth.set(X.width * .5, 0, 0),
                W.halfHeight.set(0, X.height * .5, 0),
                W.halfWidth.applyMatrix4(i),
                W.halfHeight.applyMatrix4(i),
                P++
            } else if (X.isPointLight) {
                let W = c.point[I];
                W.position.setFromMatrixPosition(X.matrixWorld),
                W.position.applyMatrix4(U),
                I++
            } else if (X.isHemisphereLight) {
                let W = c.hemi[k];
                W.direction.setFromMatrixPosition(X.matrixWorld),
                W.direction.transformDirection(U),
                W.direction.normalize(),
                k++
            }
        }
    }
    return {
        setup: v,
        setupView: x,
        state: c
    }
}
function tI(r, e) {
    let t = new e5(r,e)
      , o = []
      , c = [];
    function d() {
        o.length = 0,
        c.length = 0
    }
    function p(A) {
        o.push(A)
    }
    function i(A) {
        c.push(A)
    }
    function v(A) {
        t.setup(o, A)
    }
    function x(A) {
        t.setupView(o, A)
    }
    return {
        init: d,
        state: {
            lightsArray: o,
            shadowsArray: c,
            lights: t
        },
        setupLights: v,
        setupLightsView: x,
        pushLight: p,
        pushShadow: i
    }
}
function t5(r, e) {
    let t = new WeakMap;
    function o(d, p=0) {
        let i;
        return t.has(d) === !1 ? (i = new tI(r,e),
        t.set(d, [i])) : p >= t.get(d).length ? (i = new tI(r,e),
        t.get(d).push(i)) : i = t.get(d)[p],
        i
    }
    function c() {
        t = new WeakMap
    }
    return {
        get: o,
        dispose: c
    }
}
var Mm = class extends wr {
    constructor(e) {
        super();
        this.type = "MeshDepthMaterial",
        this.depthPacking = o2,
        this.map = null,
        this.alphaMap = null,
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.fog = !1,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.depthPacking = e.depthPacking,
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this
    }
}
;
Mm.prototype.isMeshDepthMaterial = !0;
var Im = class extends wr {
    constructor(e) {
        super();
        this.type = "MeshDistanceMaterial",
        this.referencePosition = new Oe,
        this.nearDistance = 1,
        this.farDistance = 1e3,
        this.map = null,
        this.alphaMap = null,
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.fog = !1,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.referencePosition.copy(e.referencePosition),
        this.nearDistance = e.nearDistance,
        this.farDistance = e.farDistance,
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this
    }
}
;
Im.prototype.isMeshDistanceMaterial = !0;
var n5 = `void main() {
	gl_Position = vec4( position, 1.0 );
}`
  , i5 = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function nI(r, e, t) {
    let o = new Zd
      , c = new zt
      , d = new zt
      , p = new Ui
      , i = new Mm({
        depthPacking: a2
    })
      , v = new Im
      , x = {}
      , E = t.maxTextureSize
      , A = {
        0: Zs,
        1: Md,
        2: $a
    }
      , C = new oo({
        defines: {
            VSM_SAMPLES: 8
        },
        uniforms: {
            shadow_pass: {
                value: null
            },
            resolution: {
                value: new zt
            },
            radius: {
                value: 4
            }
        },
        vertexShader: n5,
        fragmentShader: i5
    })
      , I = C.clone();
    I.defines.HORIZONTAL_PASS = 1;
    let D = new Vi;
    D.setAttribute("position", new or(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]),3));
    let P = new Ir(D,C)
      , k = this;
    this.enabled = !1,
    this.autoUpdate = !0,
    this.needsUpdate = !1,
    this.type = r1,
    this.render = function(X, W, fe) {
        if (k.enabled === !1 || k.autoUpdate === !1 && k.needsUpdate === !1 || X.length === 0)
            return;
        let ce = r.getRenderTarget()
          , _e = r.getActiveCubeFace()
          , oe = r.getActiveMipmapLevel()
          , ee = r.state;
        ee.setBlending(Qa),
        ee.buffers.color.setClear(1, 1, 1, 1),
        ee.buffers.depth.setTest(!0),
        ee.setScissorTest(!1);
        for (let j = 0, ne = X.length; j < ne; j++) {
            let be = X[j]
              , te = be.shadow;
            if (te === void 0) {
                console.warn("THREE.WebGLShadowMap:", be, "has no shadow.");
                continue
            }
            if (te.autoUpdate === !1 && te.needsUpdate === !1)
                continue;
            c.copy(te.mapSize);
            let ae = te.getFrameExtents();
            if (c.multiply(ae),
            d.copy(te.mapSize),
            (c.x > E || c.y > E) && (c.x > E && (d.x = Math.floor(E / ae.x),
            c.x = d.x * ae.x,
            te.mapSize.x = d.x),
            c.y > E && (d.y = Math.floor(E / ae.y),
            c.y = d.y * ae.y,
            te.mapSize.y = d.y)),
            te.map === null && !te.isPointLightShadow && this.type === Ad && (te.map = new Cs(c.x,c.y),
            te.map.texture.name = be.name + ".shadowMap",
            te.mapPass = new Cs(c.x,c.y),
            te.camera.updateProjectionMatrix()),
            te.map === null) {
                let ke = {
                    minFilter: Di,
                    magFilter: Di,
                    format: is
                };
                te.map = new Cs(c.x,c.y,ke),
                te.map.texture.name = be.name + ".shadowMap",
                te.camera.updateProjectionMatrix()
            }
            r.setRenderTarget(te.map),
            r.clear();
            let se = te.getViewportCount();
            for (let ke = 0; ke < se; ke++) {
                let Be = te.getViewport(ke);
                p.set(d.x * Be.x, d.y * Be.y, d.x * Be.z, d.y * Be.w),
                ee.viewport(p),
                te.updateMatrices(be, ke),
                o = te.getFrustum(),
                K(W, fe, te.camera, be, this.type)
            }
            !te.isPointLightShadow && this.type === Ad && U(te, fe),
            te.needsUpdate = !1
        }
        k.needsUpdate = !1,
        r.setRenderTarget(ce, _e, oe)
    }
    ;
    function U(X, W) {
        let fe = e.update(P);
        C.defines.VSM_SAMPLES !== X.blurSamples && (C.defines.VSM_SAMPLES = X.blurSamples,
        I.defines.VSM_SAMPLES = X.blurSamples,
        C.needsUpdate = !0,
        I.needsUpdate = !0),
        C.uniforms.shadow_pass.value = X.map.texture,
        C.uniforms.resolution.value = X.mapSize,
        C.uniforms.radius.value = X.radius,
        r.setRenderTarget(X.mapPass),
        r.clear(),
        r.renderBufferDirect(W, null, fe, C, P, null),
        I.uniforms.shadow_pass.value = X.mapPass.texture,
        I.uniforms.resolution.value = X.mapSize,
        I.uniforms.radius.value = X.radius,
        r.setRenderTarget(X.map),
        r.clear(),
        r.renderBufferDirect(W, null, fe, I, P, null)
    }
    function Z(X, W, fe, ce, _e, oe) {
        let ee = null
          , j = fe.isPointLight === !0 ? X.customDistanceMaterial : X.customDepthMaterial;
        if (j !== void 0 ? ee = j : ee = fe.isPointLight === !0 ? v : i,
        r.localClippingEnabled && W.clipShadows === !0 && W.clippingPlanes.length !== 0 || W.displacementMap && W.displacementScale !== 0 || W.alphaMap && W.alphaTest > 0) {
            let ne = ee.uuid
              , be = W.uuid
              , te = x[ne];
            te === void 0 && (te = {},
            x[ne] = te);
            let ae = te[be];
            ae === void 0 && (ae = ee.clone(),
            te[be] = ae),
            ee = ae
        }
        return ee.visible = W.visible,
        ee.wireframe = W.wireframe,
        oe === Ad ? ee.side = W.shadowSide !== null ? W.shadowSide : W.side : ee.side = W.shadowSide !== null ? W.shadowSide : A[W.side],
        ee.alphaMap = W.alphaMap,
        ee.alphaTest = W.alphaTest,
        ee.clipShadows = W.clipShadows,
        ee.clippingPlanes = W.clippingPlanes,
        ee.clipIntersection = W.clipIntersection,
        ee.displacementMap = W.displacementMap,
        ee.displacementScale = W.displacementScale,
        ee.displacementBias = W.displacementBias,
        ee.wireframeLinewidth = W.wireframeLinewidth,
        ee.linewidth = W.linewidth,
        fe.isPointLight === !0 && ee.isMeshDistanceMaterial === !0 && (ee.referencePosition.setFromMatrixPosition(fe.matrixWorld),
        ee.nearDistance = ce,
        ee.farDistance = _e),
        ee
    }
    function K(X, W, fe, ce, _e) {
        if (X.visible === !1)
            return;
        if (X.layers.test(W.layers) && (X.isMesh || X.isLine || X.isPoints) && (X.castShadow || X.receiveShadow && _e === Ad) && (!X.frustumCulled || o.intersectsObject(X))) {
            X.modelViewMatrix.multiplyMatrices(fe.matrixWorldInverse, X.matrixWorld);
            let j = e.update(X)
              , ne = X.material;
            if (Array.isArray(ne)) {
                let be = j.groups;
                for (let te = 0, ae = be.length; te < ae; te++) {
                    let se = be[te]
                      , ke = ne[se.materialIndex];
                    if (ke && ke.visible) {
                        let Be = Z(X, ke, ce, fe.near, fe.far, _e);
                        r.renderBufferDirect(fe, null, j, Be, X, se)
                    }
                }
            } else if (ne.visible) {
                let be = Z(X, ne, ce, fe.near, fe.far, _e);
                r.renderBufferDirect(fe, null, j, be, X, null)
            }
        }
        let ee = X.children;
        for (let j = 0, ne = ee.length; j < ne; j++)
            K(ee[j], W, fe, ce, _e)
    }
}
function r5(r, e, t) {
    let o = t.isWebGL2;
    function c() {
        let Ge = !1
          , Wt = new Ui
          , Ut = null
          , _n = new Ui(0,0,0,0);
        return {
            setMask: function(Ft) {
                Ut !== Ft && !Ge && (r.colorMask(Ft, Ft, Ft, Ft),
                Ut = Ft)
            },
            setLocked: function(Ft) {
                Ge = Ft
            },
            setClear: function(Ft, nn, Jt, Ln, Zn) {
                Zn === !0 && (Ft *= Ln,
                nn *= Ln,
                Jt *= Ln),
                Wt.set(Ft, nn, Jt, Ln),
                _n.equals(Wt) === !1 && (r.clearColor(Ft, nn, Jt, Ln),
                _n.copy(Wt))
            },
            reset: function() {
                Ge = !1,
                Ut = null,
                _n.set(-1, 0, 0, 0)
            }
        }
    }
    function d() {
        let Ge = !1
          , Wt = null
          , Ut = null
          , _n = null;
        return {
            setTest: function(Ft) {
                Ft ? gn(2929) : gt(2929)
            },
            setMask: function(Ft) {
                Wt !== Ft && !Ge && (r.depthMask(Ft),
                Wt = Ft)
            },
            setFunc: function(Ft) {
                if (Ut !== Ft) {
                    if (Ft)
                        switch (Ft) {
                        case MM:
                            r.depthFunc(512);
                            break;
                        case IM:
                            r.depthFunc(519);
                            break;
                        case CM:
                            r.depthFunc(513);
                            break;
                        case Ey:
                            r.depthFunc(515);
                            break;
                        case DM:
                            r.depthFunc(514);
                            break;
                        case LM:
                            r.depthFunc(518);
                            break;
                        case RM:
                            r.depthFunc(516);
                            break;
                        case PM:
                            r.depthFunc(517);
                            break;
                        default:
                            r.depthFunc(515)
                        }
                    else
                        r.depthFunc(515);
                    Ut = Ft
                }
            },
            setLocked: function(Ft) {
                Ge = Ft
            },
            setClear: function(Ft) {
                _n !== Ft && (r.clearDepth(Ft),
                _n = Ft)
            },
            reset: function() {
                Ge = !1,
                Wt = null,
                Ut = null,
                _n = null
            }
        }
    }
    function p() {
        let Ge = !1
          , Wt = null
          , Ut = null
          , _n = null
          , Ft = null
          , nn = null
          , Jt = null
          , Ln = null
          , Zn = null;
        return {
            setTest: function(Vn) {
                Ge || (Vn ? gn(2960) : gt(2960))
            },
            setMask: function(Vn) {
                Wt !== Vn && !Ge && (r.stencilMask(Vn),
                Wt = Vn)
            },
            setFunc: function(Vn, Tr, fr) {
                (Ut !== Vn || _n !== Tr || Ft !== fr) && (r.stencilFunc(Vn, Tr, fr),
                Ut = Vn,
                _n = Tr,
                Ft = fr)
            },
            setOp: function(Vn, Tr, fr) {
                (nn !== Vn || Jt !== Tr || Ln !== fr) && (r.stencilOp(Vn, Tr, fr),
                nn = Vn,
                Jt = Tr,
                Ln = fr)
            },
            setLocked: function(Vn) {
                Ge = Vn
            },
            setClear: function(Vn) {
                Zn !== Vn && (r.clearStencil(Vn),
                Zn = Vn)
            },
            reset: function() {
                Ge = !1,
                Wt = null,
                Ut = null,
                _n = null,
                Ft = null,
                nn = null,
                Jt = null,
                Ln = null,
                Zn = null
            }
        }
    }
    let i = new c
      , v = new d
      , x = new p
      , E = {}
      , A = {}
      , C = new WeakMap
      , I = []
      , D = null
      , P = !1
      , k = null
      , U = null
      , Z = null
      , K = null
      , X = null
      , W = null
      , fe = null
      , ce = !1
      , _e = null
      , oe = null
      , ee = null
      , j = null
      , ne = null
      , be = r.getParameter(35661)
      , te = !1
      , ae = 0
      , se = r.getParameter(7938);
    se.indexOf("WebGL") !== -1 ? (ae = parseFloat(/^WebGL (\d)/.exec(se)[1]),
    te = ae >= 1) : se.indexOf("OpenGL ES") !== -1 && (ae = parseFloat(/^OpenGL ES (\d)/.exec(se)[1]),
    te = ae >= 2);
    let ke = null
      , Be = {}
      , tt = r.getParameter(3088)
      , Ke = r.getParameter(2978)
      , bt = new Ui().fromArray(tt)
      , Et = new Ui().fromArray(Ke);
    function Gt(Ge, Wt, Ut) {
        let _n = new Uint8Array(4)
          , Ft = r.createTexture();
        r.bindTexture(Ge, Ft),
        r.texParameteri(Ge, 10241, 9728),
        r.texParameteri(Ge, 10240, 9728);
        for (let nn = 0; nn < Ut; nn++)
            r.texImage2D(Wt + nn, 0, 6408, 1, 1, 0, 6408, 5121, _n);
        return Ft
    }
    let Ye = {};
    Ye[3553] = Gt(3553, 3553, 1),
    Ye[34067] = Gt(34067, 34069, 6),
    i.setClear(0, 0, 0, 1),
    v.setClear(1),
    x.setClear(0),
    gn(2929),
    v.setFunc(Ey),
    xt(!1),
    on(i1),
    gn(2884),
    ut(Qa);
    function gn(Ge) {
        E[Ge] !== !0 && (r.enable(Ge),
        E[Ge] = !0)
    }
    function gt(Ge) {
        E[Ge] !== !1 && (r.disable(Ge),
        E[Ge] = !1)
    }
    function Tn(Ge, Wt) {
        return A[Ge] !== Wt ? (r.bindFramebuffer(Ge, Wt),
        A[Ge] = Wt,
        o && (Ge === 36009 && (A[36160] = Wt),
        Ge === 36160 && (A[36009] = Wt)),
        !0) : !1
    }
    function xn(Ge, Wt) {
        let Ut = I
          , _n = !1;
        if (Ge)
            if (Ut = C.get(Wt),
            Ut === void 0 && (Ut = [],
            C.set(Wt, Ut)),
            Ge.isWebGLMultipleRenderTargets) {
                let Ft = Ge.texture;
                if (Ut.length !== Ft.length || Ut[0] !== 36064) {
                    for (let nn = 0, Jt = Ft.length; nn < Jt; nn++)
                        Ut[nn] = 36064 + nn;
                    Ut.length = Ft.length,
                    _n = !0
                }
            } else
                Ut[0] !== 36064 && (Ut[0] = 36064,
                _n = !0);
        else
            Ut[0] !== 1029 && (Ut[0] = 1029,
            _n = !0);
        _n && (t.isWebGL2 ? r.drawBuffers(Ut) : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(Ut))
    }
    function Dn(Ge) {
        return D !== Ge ? (r.useProgram(Ge),
        D = Ge,
        !0) : !1
    }
    let Bt = {
        [Fu]: 32774,
        [gM]: 32778,
        [_M]: 32779
    };
    if (o)
        Bt[c1] = 32775,
        Bt[u1] = 32776;
    else {
        let Ge = e.get("EXT_blend_minmax");
        Ge !== null && (Bt[c1] = Ge.MIN_EXT,
        Bt[u1] = Ge.MAX_EXT)
    }
    let An = {
        [yM]: 0,
        [xM]: 1,
        [vM]: 768,
        [h1]: 770,
        [AM]: 776,
        [EM]: 774,
        [wM]: 772,
        [bM]: 769,
        [d1]: 771,
        [SM]: 775,
        [TM]: 773
    };
    function ut(Ge, Wt, Ut, _n, Ft, nn, Jt, Ln) {
        if (Ge === Qa) {
            P === !0 && (gt(3042),
            P = !1);
            return
        }
        if (P === !1 && (gn(3042),
        P = !0),
        Ge !== mM) {
            if (Ge !== k || Ln !== ce) {
                if ((U !== Fu || X !== Fu) && (r.blendEquation(32774),
                U = Fu,
                X = Fu),
                Ln)
                    switch (Ge) {
                    case Nu:
                        r.blendFuncSeparate(1, 771, 1, 771);
                        break;
                    case o1:
                        r.blendFunc(1, 1);
                        break;
                    case a1:
                        r.blendFuncSeparate(0, 769, 0, 1);
                        break;
                    case l1:
                        r.blendFuncSeparate(0, 768, 0, 770);
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", Ge);
                        break
                    }
                else
                    switch (Ge) {
                    case Nu:
                        r.blendFuncSeparate(770, 771, 1, 771);
                        break;
                    case o1:
                        r.blendFunc(770, 1);
                        break;
                    case a1:
                        r.blendFuncSeparate(0, 769, 0, 1);
                        break;
                    case l1:
                        r.blendFunc(0, 768);
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", Ge);
                        break
                    }
                Z = null,
                K = null,
                W = null,
                fe = null,
                k = Ge,
                ce = Ln
            }
            return
        }
        Ft = Ft || Wt,
        nn = nn || Ut,
        Jt = Jt || _n,
        (Wt !== U || Ft !== X) && (r.blendEquationSeparate(Bt[Wt], Bt[Ft]),
        U = Wt,
        X = Ft),
        (Ut !== Z || _n !== K || nn !== W || Jt !== fe) && (r.blendFuncSeparate(An[Ut], An[_n], An[nn], An[Jt]),
        Z = Ut,
        K = _n,
        W = nn,
        fe = Jt),
        k = Ge,
        ce = null
    }
    function ot(Ge, Wt) {
        Ge.side === $a ? gt(2884) : gn(2884);
        let Ut = Ge.side === Zs;
        Wt && (Ut = !Ut),
        xt(Ut),
        Ge.blending === Nu && Ge.transparent === !1 ? ut(Qa) : ut(Ge.blending, Ge.blendEquation, Ge.blendSrc, Ge.blendDst, Ge.blendEquationAlpha, Ge.blendSrcAlpha, Ge.blendDstAlpha, Ge.premultipliedAlpha),
        v.setFunc(Ge.depthFunc),
        v.setTest(Ge.depthTest),
        v.setMask(Ge.depthWrite),
        i.setMask(Ge.colorWrite);
        let _n = Ge.stencilWrite;
        x.setTest(_n),
        _n && (x.setMask(Ge.stencilWriteMask),
        x.setFunc(Ge.stencilFunc, Ge.stencilRef, Ge.stencilFuncMask),
        x.setOp(Ge.stencilFail, Ge.stencilZFail, Ge.stencilZPass)),
        Pn(Ge.polygonOffset, Ge.polygonOffsetFactor, Ge.polygonOffsetUnits),
        Ge.alphaToCoverage === !0 ? gn(32926) : gt(32926)
    }
    function xt(Ge) {
        _e !== Ge && (Ge ? r.frontFace(2304) : r.frontFace(2305),
        _e = Ge)
    }
    function on(Ge) {
        Ge !== dM ? (gn(2884),
        Ge !== oe && (Ge === i1 ? r.cullFace(1029) : Ge === fM ? r.cullFace(1028) : r.cullFace(1032))) : gt(2884),
        oe = Ge
    }
    function $t(Ge) {
        Ge !== ee && (te && r.lineWidth(Ge),
        ee = Ge)
    }
    function Pn(Ge, Wt, Ut) {
        Ge ? (gn(32823),
        (j !== Wt || ne !== Ut) && (r.polygonOffset(Wt, Ut),
        j = Wt,
        ne = Ut)) : gt(32823)
    }
    function kt(Ge) {
        Ge ? gn(3089) : gt(3089)
    }
    function Zt(Ge) {
        Ge === void 0 && (Ge = 33984 + be - 1),
        ke !== Ge && (r.activeTexture(Ge),
        ke = Ge)
    }
    function zn(Ge, Wt) {
        ke === null && Zt();
        let Ut = Be[ke];
        Ut === void 0 && (Ut = {
            type: void 0,
            texture: void 0
        },
        Be[ke] = Ut),
        (Ut.type !== Ge || Ut.texture !== Wt) && (r.bindTexture(Ge, Wt || Ye[Ge]),
        Ut.type = Ge,
        Ut.texture = Wt)
    }
    function Qt() {
        let Ge = Be[ke];
        Ge !== void 0 && Ge.type !== void 0 && (r.bindTexture(Ge.type, null),
        Ge.type = void 0,
        Ge.texture = void 0)
    }
    function xe() {
        try {
            r.compressedTexImage2D.apply(r, arguments)
        } catch (Ge) {
            console.error("THREE.WebGLState:", Ge)
        }
    }
    function he() {
        try {
            r.texSubImage2D.apply(r, arguments)
        } catch (Ge) {
            console.error("THREE.WebGLState:", Ge)
        }
    }
    function Qe() {
        try {
            r.texSubImage3D.apply(r, arguments)
        } catch (Ge) {
            console.error("THREE.WebGLState:", Ge)
        }
    }
    function ft() {
        try {
            r.compressedTexSubImage2D.apply(r, arguments)
        } catch (Ge) {
            console.error("THREE.WebGLState:", Ge)
        }
    }
    function St() {
        try {
            r.texStorage2D.apply(r, arguments)
        } catch (Ge) {
            console.error("THREE.WebGLState:", Ge)
        }
    }
    function Mt() {
        try {
            r.texStorage3D.apply(r, arguments)
        } catch (Ge) {
            console.error("THREE.WebGLState:", Ge)
        }
    }
    function an() {
        try {
            r.texImage2D.apply(r, arguments)
        } catch (Ge) {
            console.error("THREE.WebGLState:", Ge)
        }
    }
    function Ie() {
        try {
            r.texImage3D.apply(r, arguments)
        } catch (Ge) {
            console.error("THREE.WebGLState:", Ge)
        }
    }
    function Ct(Ge) {
        bt.equals(Ge) === !1 && (r.scissor(Ge.x, Ge.y, Ge.z, Ge.w),
        bt.copy(Ge))
    }
    function ln(Ge) {
        Et.equals(Ge) === !1 && (r.viewport(Ge.x, Ge.y, Ge.z, Ge.w),
        Et.copy(Ge))
    }
    function Kt() {
        r.disable(3042),
        r.disable(2884),
        r.disable(2929),
        r.disable(32823),
        r.disable(3089),
        r.disable(2960),
        r.disable(32926),
        r.blendEquation(32774),
        r.blendFunc(1, 0),
        r.blendFuncSeparate(1, 0, 1, 0),
        r.colorMask(!0, !0, !0, !0),
        r.clearColor(0, 0, 0, 0),
        r.depthMask(!0),
        r.depthFunc(513),
        r.clearDepth(1),
        r.stencilMask(4294967295),
        r.stencilFunc(519, 0, 4294967295),
        r.stencilOp(7680, 7680, 7680),
        r.clearStencil(0),
        r.cullFace(1029),
        r.frontFace(2305),
        r.polygonOffset(0, 0),
        r.activeTexture(33984),
        r.bindFramebuffer(36160, null),
        o === !0 && (r.bindFramebuffer(36009, null),
        r.bindFramebuffer(36008, null)),
        r.useProgram(null),
        r.lineWidth(1),
        r.scissor(0, 0, r.canvas.width, r.canvas.height),
        r.viewport(0, 0, r.canvas.width, r.canvas.height),
        E = {},
        ke = null,
        Be = {},
        A = {},
        C = new WeakMap,
        I = [],
        D = null,
        P = !1,
        k = null,
        U = null,
        Z = null,
        K = null,
        X = null,
        W = null,
        fe = null,
        ce = !1,
        _e = null,
        oe = null,
        ee = null,
        j = null,
        ne = null,
        bt.set(0, 0, r.canvas.width, r.canvas.height),
        Et.set(0, 0, r.canvas.width, r.canvas.height),
        i.reset(),
        v.reset(),
        x.reset()
    }
    return {
        buffers: {
            color: i,
            depth: v,
            stencil: x
        },
        enable: gn,
        disable: gt,
        bindFramebuffer: Tn,
        drawBuffers: xn,
        useProgram: Dn,
        setBlending: ut,
        setMaterial: ot,
        setFlipSided: xt,
        setCullFace: on,
        setLineWidth: $t,
        setPolygonOffset: Pn,
        setScissorTest: kt,
        activeTexture: Zt,
        bindTexture: zn,
        unbindTexture: Qt,
        compressedTexImage2D: xe,
        texImage2D: an,
        texImage3D: Ie,
        texStorage2D: St,
        texStorage3D: Mt,
        texSubImage2D: he,
        texSubImage3D: Qe,
        compressedTexSubImage2D: ft,
        scissor: Ct,
        viewport: ln,
        reset: Kt
    }
}
function s5(r, e, t, o, c, d, p) {
    let i = c.isWebGL2, v = c.maxTextures, x = c.maxCubemapSize, E = c.maxTextureSize, A = c.maxSamples, C = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null, I = /OculusBrowser/g.test(navigator.userAgent), D = new WeakMap, P, k = new WeakMap, U = !1;
    try {
        U = typeof OffscreenCanvas != "undefined" && new OffscreenCanvas(1,1).getContext("2d") !== null
    } catch (xe) {}
    function Z(xe, he) {
        return U ? new OffscreenCanvas(xe,he) : xm("canvas")
    }
    function K(xe, he, Qe, ft) {
        let St = 1;
        if ((xe.width > ft || xe.height > ft) && (St = ft / Math.max(xe.width, xe.height)),
        St < 1 || he === !0)
            if (typeof HTMLImageElement != "undefined" && xe instanceof HTMLImageElement || typeof HTMLCanvasElement != "undefined" && xe instanceof HTMLCanvasElement || typeof ImageBitmap != "undefined" && xe instanceof ImageBitmap) {
                let Mt = he ? V1 : Math.floor
                  , an = Mt(St * xe.width)
                  , Ie = Mt(St * xe.height);
                P === void 0 && (P = Z(an, Ie));
                let Ct = Qe ? Z(an, Ie) : P;
                return Ct.width = an,
                Ct.height = Ie,
                Ct.getContext("2d").drawImage(xe, 0, 0, an, Ie),
                console.warn("THREE.WebGLRenderer: Texture has been resized from (" + xe.width + "x" + xe.height + ") to (" + an + "x" + Ie + ")."),
                Ct
            } else
                return "data"in xe && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + xe.width + "x" + xe.height + ")."),
                xe;
        return xe
    }
    function X(xe) {
        return u2(xe.width) && u2(xe.height)
    }
    function W(xe) {
        return i ? !1 : xe.wrapS !== vo || xe.wrapT !== vo || xe.minFilter !== Di && xe.minFilter !== ns
    }
    function fe(xe, he) {
        return xe.generateMipmaps && he && xe.minFilter !== Di && xe.minFilter !== ns
    }
    function ce(xe) {
        r.generateMipmap(xe)
    }
    function _e(xe, he, Qe, ft, St=!1) {
        if (i === !1)
            return he;
        if (xe !== null) {
            if (r[xe] !== void 0)
                return r[xe];
            console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + xe + "'")
        }
        let Mt = he;
        return he === 6403 && (Qe === 5126 && (Mt = 33326),
        Qe === 5131 && (Mt = 33325),
        Qe === 5121 && (Mt = 33321)),
        he === 33319 && (Qe === 5126 && (Mt = 33328),
        Qe === 5131 && (Mt = 33327),
        Qe === 5121 && (Mt = 33323)),
        he === 6408 && (Qe === 5126 && (Mt = 34836),
        Qe === 5131 && (Mt = 34842),
        Qe === 5121 && (Mt = ft === er && St === !1 ? 35907 : 32856),
        Qe === 32819 && (Mt = 32854),
        Qe === 32820 && (Mt = 32855)),
        (Mt === 33325 || Mt === 33326 || Mt === 33327 || Mt === 33328 || Mt === 34842 || Mt === 34836) && e.get("EXT_color_buffer_float"),
        Mt
    }
    function oe(xe, he, Qe) {
        return fe(xe, Qe) === !0 || xe.isFramebufferTexture && xe.minFilter !== Di && xe.minFilter !== ns ? Math.log2(Math.max(he.width, he.height)) + 1 : xe.mipmaps !== void 0 && xe.mipmaps.length > 0 ? xe.mipmaps.length : xe.isCompressedTexture && Array.isArray(xe.image) ? he.mipmaps.length : 1
    }
    function ee(xe) {
        return xe === Di || xe === p1 || xe === m1 ? 9728 : 9729
    }
    function j(xe) {
        let he = xe.target;
        he.removeEventListener("dispose", j),
        be(he),
        he.isVideoTexture && D.delete(he)
    }
    function ne(xe) {
        let he = xe.target;
        he.removeEventListener("dispose", ne),
        ae(he)
    }
    function be(xe) {
        let he = o.get(xe);
        if (he.__webglInit === void 0)
            return;
        let Qe = xe.source
          , ft = k.get(Qe);
        if (ft) {
            let St = ft[he.__cacheKey];
            St.usedTimes--,
            St.usedTimes === 0 && te(xe),
            Object.keys(ft).length === 0 && k.delete(Qe)
        }
        o.remove(xe)
    }
    function te(xe) {
        let he = o.get(xe);
        r.deleteTexture(he.__webglTexture);
        let Qe = xe.source
          , ft = k.get(Qe);
        delete ft[he.__cacheKey],
        p.memory.textures--
    }
    function ae(xe) {
        let he = xe.texture
          , Qe = o.get(xe)
          , ft = o.get(he);
        if (ft.__webglTexture !== void 0 && (r.deleteTexture(ft.__webglTexture),
        p.memory.textures--),
        xe.depthTexture && xe.depthTexture.dispose(),
        xe.isWebGLCubeRenderTarget)
            for (let St = 0; St < 6; St++)
                r.deleteFramebuffer(Qe.__webglFramebuffer[St]),
                Qe.__webglDepthbuffer && r.deleteRenderbuffer(Qe.__webglDepthbuffer[St]);
        else
            r.deleteFramebuffer(Qe.__webglFramebuffer),
            Qe.__webglDepthbuffer && r.deleteRenderbuffer(Qe.__webglDepthbuffer),
            Qe.__webglMultisampledFramebuffer && r.deleteFramebuffer(Qe.__webglMultisampledFramebuffer),
            Qe.__webglColorRenderbuffer && r.deleteRenderbuffer(Qe.__webglColorRenderbuffer),
            Qe.__webglDepthRenderbuffer && r.deleteRenderbuffer(Qe.__webglDepthRenderbuffer);
        if (xe.isWebGLMultipleRenderTargets)
            for (let St = 0, Mt = he.length; St < Mt; St++) {
                let an = o.get(he[St]);
                an.__webglTexture && (r.deleteTexture(an.__webglTexture),
                p.memory.textures--),
                o.remove(he[St])
            }
        o.remove(he),
        o.remove(xe)
    }
    let se = 0;
    function ke() {
        se = 0
    }
    function Be() {
        let xe = se;
        return xe >= v && console.warn("THREE.WebGLTextures: Trying to use " + xe + " texture units while this GPU supports only " + v),
        se += 1,
        xe
    }
    function tt(xe) {
        let he = [];
        return he.push(xe.wrapS),
        he.push(xe.wrapT),
        he.push(xe.magFilter),
        he.push(xe.minFilter),
        he.push(xe.anisotropy),
        he.push(xe.internalFormat),
        he.push(xe.format),
        he.push(xe.type),
        he.push(xe.generateMipmaps),
        he.push(xe.premultiplyAlpha),
        he.push(xe.flipY),
        he.push(xe.unpackAlignment),
        he.push(xe.encoding),
        he.join()
    }
    function Ke(xe, he) {
        let Qe = o.get(xe);
        if (xe.isVideoTexture && zn(xe),
        xe.isRenderTargetTexture === !1 && xe.version > 0 && Qe.__version !== xe.version) {
            let ft = xe.image;
            if (ft === null)
                console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
            else if (ft.complete === !1)
                console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
            else {
                xn(Qe, xe, he);
                return
            }
        }
        t.activeTexture(33984 + he),
        t.bindTexture(3553, Qe.__webglTexture)
    }
    function bt(xe, he) {
        let Qe = o.get(xe);
        if (xe.version > 0 && Qe.__version !== xe.version) {
            xn(Qe, xe, he);
            return
        }
        t.activeTexture(33984 + he),
        t.bindTexture(35866, Qe.__webglTexture)
    }
    function Et(xe, he) {
        let Qe = o.get(xe);
        if (xe.version > 0 && Qe.__version !== xe.version) {
            xn(Qe, xe, he);
            return
        }
        t.activeTexture(33984 + he),
        t.bindTexture(32879, Qe.__webglTexture)
    }
    function Gt(xe, he) {
        let Qe = o.get(xe);
        if (xe.version > 0 && Qe.__version !== xe.version) {
            Dn(Qe, xe, he);
            return
        }
        t.activeTexture(33984 + he),
        t.bindTexture(34067, Qe.__webglTexture)
    }
    let Ye = {
        [Vu]: 10497,
        [vo]: 33071,
        [My]: 33648
    }
      , gn = {
        [Di]: 9728,
        [p1]: 9984,
        [m1]: 9986,
        [ns]: 9729,
        [VM]: 9985,
        [dm]: 9987
    };
    function gt(xe, he, Qe) {
        if (Qe ? (r.texParameteri(xe, 10242, Ye[he.wrapS]),
        r.texParameteri(xe, 10243, Ye[he.wrapT]),
        (xe === 32879 || xe === 35866) && r.texParameteri(xe, 32882, Ye[he.wrapR]),
        r.texParameteri(xe, 10240, gn[he.magFilter]),
        r.texParameteri(xe, 10241, gn[he.minFilter])) : (r.texParameteri(xe, 10242, 33071),
        r.texParameteri(xe, 10243, 33071),
        (xe === 32879 || xe === 35866) && r.texParameteri(xe, 32882, 33071),
        (he.wrapS !== vo || he.wrapT !== vo) && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),
        r.texParameteri(xe, 10240, ee(he.magFilter)),
        r.texParameteri(xe, 10241, ee(he.minFilter)),
        he.minFilter !== Di && he.minFilter !== ns && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),
        e.has("EXT_texture_filter_anisotropic") === !0) {
            let ft = e.get("EXT_texture_filter_anisotropic");
            if (he.type === rc && e.has("OES_texture_float_linear") === !1 || i === !1 && he.type === Gu && e.has("OES_texture_half_float_linear") === !1)
                return;
            (he.anisotropy > 1 || o.get(he).__currentAnisotropy) && (r.texParameterf(xe, ft.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(he.anisotropy, c.getMaxAnisotropy())),
            o.get(he).__currentAnisotropy = he.anisotropy)
        }
    }
    function Tn(xe, he) {
        let Qe = !1;
        xe.__webglInit === void 0 && (xe.__webglInit = !0,
        he.addEventListener("dispose", j));
        let ft = he.source
          , St = k.get(ft);
        St === void 0 && (St = {},
        k.set(ft, St));
        let Mt = tt(he);
        if (Mt !== xe.__cacheKey) {
            St[Mt] === void 0 && (St[Mt] = {
                texture: r.createTexture(),
                usedTimes: 0
            },
            p.memory.textures++,
            Qe = !0),
            St[Mt].usedTimes++;
            let an = St[xe.__cacheKey];
            an !== void 0 && (St[xe.__cacheKey].usedTimes--,
            an.usedTimes === 0 && te(he)),
            xe.__cacheKey = Mt,
            xe.__webglTexture = St[Mt].texture
        }
        return Qe
    }
    function xn(xe, he, Qe) {
        let ft = 3553;
        he.isDataArrayTexture && (ft = 35866),
        he.isData3DTexture && (ft = 32879);
        let St = Tn(xe, he)
          , Mt = he.source;
        if (t.activeTexture(33984 + Qe),
        t.bindTexture(ft, xe.__webglTexture),
        Mt.version !== Mt.__currentVersion || St === !0) {
            r.pixelStorei(37440, he.flipY),
            r.pixelStorei(37441, he.premultiplyAlpha),
            r.pixelStorei(3317, he.unpackAlignment),
            r.pixelStorei(37443, 0);
            let an = W(he) && X(he.image) === !1
              , Ie = K(he.image, an, !1, E);
            Ie = Qt(he, Ie);
            let Ct = X(Ie) || i
              , ln = d.convert(he.format, he.encoding)
              , Kt = d.convert(he.type)
              , Ge = _e(he.internalFormat, ln, Kt, he.encoding, he.isVideoTexture);
            gt(ft, he, Ct);
            let Wt, Ut = he.mipmaps, _n = i && he.isVideoTexture !== !0, Ft = xe.__version === void 0, nn = oe(he, Ie, Ct);
            if (he.isDepthTexture)
                Ge = 6402,
                i ? he.type === rc ? Ge = 36012 : he.type === fm ? Ge = 33190 : he.type === Hu ? Ge = 35056 : Ge = 33189 : he.type === rc && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),
                he.format === sc && Ge === 6402 && he.type !== Id && he.type !== fm && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),
                he.type = Id,
                Kt = d.convert(he.type)),
                he.format === Wu && Ge === 6402 && (Ge = 34041,
                he.type !== Hu && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),
                he.type = Hu,
                Kt = d.convert(he.type))),
                _n && Ft ? t.texStorage2D(3553, 1, Ge, Ie.width, Ie.height) : t.texImage2D(3553, 0, Ge, Ie.width, Ie.height, 0, ln, Kt, null);
            else if (he.isDataTexture)
                if (Ut.length > 0 && Ct) {
                    _n && Ft && t.texStorage2D(3553, nn, Ge, Ut[0].width, Ut[0].height);
                    for (let Jt = 0, Ln = Ut.length; Jt < Ln; Jt++)
                        Wt = Ut[Jt],
                        _n ? t.texSubImage2D(3553, Jt, 0, 0, Wt.width, Wt.height, ln, Kt, Wt.data) : t.texImage2D(3553, Jt, Ge, Wt.width, Wt.height, 0, ln, Kt, Wt.data);
                    he.generateMipmaps = !1
                } else
                    _n ? (Ft && t.texStorage2D(3553, nn, Ge, Ie.width, Ie.height),
                    t.texSubImage2D(3553, 0, 0, 0, Ie.width, Ie.height, ln, Kt, Ie.data)) : t.texImage2D(3553, 0, Ge, Ie.width, Ie.height, 0, ln, Kt, Ie.data);
            else if (he.isCompressedTexture) {
                _n && Ft && t.texStorage2D(3553, nn, Ge, Ut[0].width, Ut[0].height);
                for (let Jt = 0, Ln = Ut.length; Jt < Ln; Jt++)
                    Wt = Ut[Jt],
                    he.format !== is ? ln !== null ? _n ? t.compressedTexSubImage2D(3553, Jt, 0, 0, Wt.width, Wt.height, ln, Wt.data) : t.compressedTexImage2D(3553, Jt, Ge, Wt.width, Wt.height, 0, Wt.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : _n ? t.texSubImage2D(3553, Jt, 0, 0, Wt.width, Wt.height, ln, Kt, Wt.data) : t.texImage2D(3553, Jt, Ge, Wt.width, Wt.height, 0, ln, Kt, Wt.data)
            } else if (he.isDataArrayTexture)
                _n ? (Ft && t.texStorage3D(35866, nn, Ge, Ie.width, Ie.height, Ie.depth),
                t.texSubImage3D(35866, 0, 0, 0, 0, Ie.width, Ie.height, Ie.depth, ln, Kt, Ie.data)) : t.texImage3D(35866, 0, Ge, Ie.width, Ie.height, Ie.depth, 0, ln, Kt, Ie.data);
            else if (he.isData3DTexture)
                _n ? (Ft && t.texStorage3D(32879, nn, Ge, Ie.width, Ie.height, Ie.depth),
                t.texSubImage3D(32879, 0, 0, 0, 0, Ie.width, Ie.height, Ie.depth, ln, Kt, Ie.data)) : t.texImage3D(32879, 0, Ge, Ie.width, Ie.height, Ie.depth, 0, ln, Kt, Ie.data);
            else if (he.isFramebufferTexture)
                _n && Ft ? t.texStorage2D(3553, nn, Ge, Ie.width, Ie.height) : t.texImage2D(3553, 0, Ge, Ie.width, Ie.height, 0, ln, Kt, null);
            else if (Ut.length > 0 && Ct) {
                _n && Ft && t.texStorage2D(3553, nn, Ge, Ut[0].width, Ut[0].height);
                for (let Jt = 0, Ln = Ut.length; Jt < Ln; Jt++)
                    Wt = Ut[Jt],
                    _n ? t.texSubImage2D(3553, Jt, 0, 0, ln, Kt, Wt) : t.texImage2D(3553, Jt, Ge, ln, Kt, Wt);
                he.generateMipmaps = !1
            } else
                _n ? (Ft && t.texStorage2D(3553, nn, Ge, Ie.width, Ie.height),
                t.texSubImage2D(3553, 0, 0, 0, ln, Kt, Ie)) : t.texImage2D(3553, 0, Ge, ln, Kt, Ie);
            fe(he, Ct) && ce(ft),
            Mt.__currentVersion = Mt.version,
            he.onUpdate && he.onUpdate(he)
        }
        xe.__version = he.version
    }
    function Dn(xe, he, Qe) {
        if (he.image.length !== 6)
            return;
        let ft = Tn(xe, he)
          , St = he.source;
        if (t.activeTexture(33984 + Qe),
        t.bindTexture(34067, xe.__webglTexture),
        St.version !== St.__currentVersion || ft === !0) {
            r.pixelStorei(37440, he.flipY),
            r.pixelStorei(37441, he.premultiplyAlpha),
            r.pixelStorei(3317, he.unpackAlignment),
            r.pixelStorei(37443, 0);
            let Mt = he.isCompressedTexture || he.image[0].isCompressedTexture
              , an = he.image[0] && he.image[0].isDataTexture
              , Ie = [];
            for (let Jt = 0; Jt < 6; Jt++)
                !Mt && !an ? Ie[Jt] = K(he.image[Jt], !1, !0, x) : Ie[Jt] = an ? he.image[Jt].image : he.image[Jt],
                Ie[Jt] = Qt(he, Ie[Jt]);
            let Ct = Ie[0]
              , ln = X(Ct) || i
              , Kt = d.convert(he.format, he.encoding)
              , Ge = d.convert(he.type)
              , Wt = _e(he.internalFormat, Kt, Ge, he.encoding)
              , Ut = i && he.isVideoTexture !== !0
              , _n = xe.__version === void 0
              , Ft = oe(he, Ct, ln);
            gt(34067, he, ln);
            let nn;
            if (Mt) {
                Ut && _n && t.texStorage2D(34067, Ft, Wt, Ct.width, Ct.height);
                for (let Jt = 0; Jt < 6; Jt++) {
                    nn = Ie[Jt].mipmaps;
                    for (let Ln = 0; Ln < nn.length; Ln++) {
                        let Zn = nn[Ln];
                        he.format !== is ? Kt !== null ? Ut ? t.compressedTexSubImage2D(34069 + Jt, Ln, 0, 0, Zn.width, Zn.height, Kt, Zn.data) : t.compressedTexImage2D(34069 + Jt, Ln, Wt, Zn.width, Zn.height, 0, Zn.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : Ut ? t.texSubImage2D(34069 + Jt, Ln, 0, 0, Zn.width, Zn.height, Kt, Ge, Zn.data) : t.texImage2D(34069 + Jt, Ln, Wt, Zn.width, Zn.height, 0, Kt, Ge, Zn.data)
                    }
                }
            } else {
                nn = he.mipmaps,
                Ut && _n && (nn.length > 0 && Ft++,
                t.texStorage2D(34067, Ft, Wt, Ie[0].width, Ie[0].height));
                for (let Jt = 0; Jt < 6; Jt++)
                    if (an) {
                        Ut ? t.texSubImage2D(34069 + Jt, 0, 0, 0, Ie[Jt].width, Ie[Jt].height, Kt, Ge, Ie[Jt].data) : t.texImage2D(34069 + Jt, 0, Wt, Ie[Jt].width, Ie[Jt].height, 0, Kt, Ge, Ie[Jt].data);
                        for (let Ln = 0; Ln < nn.length; Ln++) {
                            let Vn = nn[Ln].image[Jt].image;
                            Ut ? t.texSubImage2D(34069 + Jt, Ln + 1, 0, 0, Vn.width, Vn.height, Kt, Ge, Vn.data) : t.texImage2D(34069 + Jt, Ln + 1, Wt, Vn.width, Vn.height, 0, Kt, Ge, Vn.data)
                        }
                    } else {
                        Ut ? t.texSubImage2D(34069 + Jt, 0, 0, 0, Kt, Ge, Ie[Jt]) : t.texImage2D(34069 + Jt, 0, Wt, Kt, Ge, Ie[Jt]);
                        for (let Ln = 0; Ln < nn.length; Ln++) {
                            let Zn = nn[Ln];
                            Ut ? t.texSubImage2D(34069 + Jt, Ln + 1, 0, 0, Kt, Ge, Zn.image[Jt]) : t.texImage2D(34069 + Jt, Ln + 1, Wt, Kt, Ge, Zn.image[Jt])
                        }
                    }
            }
            fe(he, ln) && ce(34067),
            St.__currentVersion = St.version,
            he.onUpdate && he.onUpdate(he)
        }
        xe.__version = he.version
    }
    function Bt(xe, he, Qe, ft, St) {
        let Mt = d.convert(Qe.format, Qe.encoding)
          , an = d.convert(Qe.type)
          , Ie = _e(Qe.internalFormat, Mt, an, Qe.encoding);
        o.get(he).__hasExternalTextures || (St === 32879 || St === 35866 ? t.texImage3D(St, 0, Ie, he.width, he.height, he.depth, 0, Mt, an, null) : t.texImage2D(St, 0, Ie, he.width, he.height, 0, Mt, an, null)),
        t.bindFramebuffer(36160, xe),
        Zt(he) ? C.framebufferTexture2DMultisampleEXT(36160, ft, St, o.get(Qe).__webglTexture, 0, kt(he)) : r.framebufferTexture2D(36160, ft, St, o.get(Qe).__webglTexture, 0),
        t.bindFramebuffer(36160, null)
    }
    function An(xe, he, Qe) {
        if (r.bindRenderbuffer(36161, xe),
        he.depthBuffer && !he.stencilBuffer) {
            let ft = 33189;
            if (Qe || Zt(he)) {
                let St = he.depthTexture;
                St && St.isDepthTexture && (St.type === rc ? ft = 36012 : St.type === fm && (ft = 33190));
                let Mt = kt(he);
                Zt(he) ? C.renderbufferStorageMultisampleEXT(36161, Mt, ft, he.width, he.height) : r.renderbufferStorageMultisample(36161, Mt, ft, he.width, he.height)
            } else
                r.renderbufferStorage(36161, ft, he.width, he.height);
            r.framebufferRenderbuffer(36160, 36096, 36161, xe)
        } else if (he.depthBuffer && he.stencilBuffer) {
            let ft = kt(he);
            Qe && Zt(he) === !1 ? r.renderbufferStorageMultisample(36161, ft, 35056, he.width, he.height) : Zt(he) ? C.renderbufferStorageMultisampleEXT(36161, ft, 35056, he.width, he.height) : r.renderbufferStorage(36161, 34041, he.width, he.height),
            r.framebufferRenderbuffer(36160, 33306, 36161, xe)
        } else {
            let ft = he.isWebGLMultipleRenderTargets === !0 ? he.texture[0] : he.texture
              , St = d.convert(ft.format, ft.encoding)
              , Mt = d.convert(ft.type)
              , an = _e(ft.internalFormat, St, Mt, ft.encoding)
              , Ie = kt(he);
            Qe && Zt(he) === !1 ? r.renderbufferStorageMultisample(36161, Ie, an, he.width, he.height) : Zt(he) ? C.renderbufferStorageMultisampleEXT(36161, Ie, an, he.width, he.height) : r.renderbufferStorage(36161, an, he.width, he.height)
        }
        r.bindRenderbuffer(36161, null)
    }
    function ut(xe, he) {
        if (he && he.isWebGLCubeRenderTarget)
            throw new Error("Depth Texture with cube render targets is not supported");
        if (t.bindFramebuffer(36160, xe),
        !(he.depthTexture && he.depthTexture.isDepthTexture))
            throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
        (!o.get(he.depthTexture).__webglTexture || he.depthTexture.image.width !== he.width || he.depthTexture.image.height !== he.height) && (he.depthTexture.image.width = he.width,
        he.depthTexture.image.height = he.height,
        he.depthTexture.needsUpdate = !0),
        Ke(he.depthTexture, 0);
        let ft = o.get(he.depthTexture).__webglTexture
          , St = kt(he);
        if (he.depthTexture.format === sc)
            Zt(he) ? C.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, ft, 0, St) : r.framebufferTexture2D(36160, 36096, 3553, ft, 0);
        else if (he.depthTexture.format === Wu)
            Zt(he) ? C.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, ft, 0, St) : r.framebufferTexture2D(36160, 33306, 3553, ft, 0);
        else
            throw new Error("Unknown depthTexture format")
    }
    function ot(xe) {
        let he = o.get(xe)
          , Qe = xe.isWebGLCubeRenderTarget === !0;
        if (xe.depthTexture && !he.__autoAllocateDepthBuffer) {
            if (Qe)
                throw new Error("target.depthTexture not supported in Cube render targets");
            ut(he.__webglFramebuffer, xe)
        } else if (Qe) {
            he.__webglDepthbuffer = [];
            for (let ft = 0; ft < 6; ft++)
                t.bindFramebuffer(36160, he.__webglFramebuffer[ft]),
                he.__webglDepthbuffer[ft] = r.createRenderbuffer(),
                An(he.__webglDepthbuffer[ft], xe, !1)
        } else
            t.bindFramebuffer(36160, he.__webglFramebuffer),
            he.__webglDepthbuffer = r.createRenderbuffer(),
            An(he.__webglDepthbuffer, xe, !1);
        t.bindFramebuffer(36160, null)
    }
    function xt(xe, he, Qe) {
        let ft = o.get(xe);
        he !== void 0 && Bt(ft.__webglFramebuffer, xe, xe.texture, 36064, 3553),
        Qe !== void 0 && ot(xe)
    }
    function on(xe) {
        let he = xe.texture
          , Qe = o.get(xe)
          , ft = o.get(he);
        xe.addEventListener("dispose", ne),
        xe.isWebGLMultipleRenderTargets !== !0 && (ft.__webglTexture === void 0 && (ft.__webglTexture = r.createTexture()),
        ft.__version = he.version,
        p.memory.textures++);
        let St = xe.isWebGLCubeRenderTarget === !0
          , Mt = xe.isWebGLMultipleRenderTargets === !0
          , an = X(xe) || i;
        if (St) {
            Qe.__webglFramebuffer = [];
            for (let Ie = 0; Ie < 6; Ie++)
                Qe.__webglFramebuffer[Ie] = r.createFramebuffer()
        } else if (Qe.__webglFramebuffer = r.createFramebuffer(),
        Mt)
            if (c.drawBuffers) {
                let Ie = xe.texture;
                for (let Ct = 0, ln = Ie.length; Ct < ln; Ct++) {
                    let Kt = o.get(Ie[Ct]);
                    Kt.__webglTexture === void 0 && (Kt.__webglTexture = r.createTexture(),
                    p.memory.textures++)
                }
            } else
                console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
        else if (i && xe.samples > 0 && Zt(xe) === !1) {
            Qe.__webglMultisampledFramebuffer = r.createFramebuffer(),
            Qe.__webglColorRenderbuffer = r.createRenderbuffer(),
            r.bindRenderbuffer(36161, Qe.__webglColorRenderbuffer);
            let Ie = d.convert(he.format, he.encoding)
              , Ct = d.convert(he.type)
              , ln = _e(he.internalFormat, Ie, Ct, he.encoding)
              , Kt = kt(xe);
            r.renderbufferStorageMultisample(36161, Kt, ln, xe.width, xe.height),
            t.bindFramebuffer(36160, Qe.__webglMultisampledFramebuffer),
            r.framebufferRenderbuffer(36160, 36064, 36161, Qe.__webglColorRenderbuffer),
            r.bindRenderbuffer(36161, null),
            xe.depthBuffer && (Qe.__webglDepthRenderbuffer = r.createRenderbuffer(),
            An(Qe.__webglDepthRenderbuffer, xe, !0)),
            t.bindFramebuffer(36160, null)
        }
        if (St) {
            t.bindTexture(34067, ft.__webglTexture),
            gt(34067, he, an);
            for (let Ie = 0; Ie < 6; Ie++)
                Bt(Qe.__webglFramebuffer[Ie], xe, he, 36064, 34069 + Ie);
            fe(he, an) && ce(34067),
            t.unbindTexture()
        } else if (Mt) {
            let Ie = xe.texture;
            for (let Ct = 0, ln = Ie.length; Ct < ln; Ct++) {
                let Kt = Ie[Ct]
                  , Ge = o.get(Kt);
                t.bindTexture(3553, Ge.__webglTexture),
                gt(3553, Kt, an),
                Bt(Qe.__webglFramebuffer, xe, Kt, 36064 + Ct, 3553),
                fe(Kt, an) && ce(3553)
            }
            t.unbindTexture()
        } else {
            let Ie = 3553;
            (xe.isWebGL3DRenderTarget || xe.isWebGLArrayRenderTarget) && (i ? Ie = xe.isWebGL3DRenderTarget ? 32879 : 35866 : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")),
            t.bindTexture(Ie, ft.__webglTexture),
            gt(Ie, he, an),
            Bt(Qe.__webglFramebuffer, xe, he, 36064, Ie),
            fe(he, an) && ce(Ie),
            t.unbindTexture()
        }
        xe.depthBuffer && ot(xe)
    }
    function $t(xe) {
        let he = X(xe) || i
          , Qe = xe.isWebGLMultipleRenderTargets === !0 ? xe.texture : [xe.texture];
        for (let ft = 0, St = Qe.length; ft < St; ft++) {
            let Mt = Qe[ft];
            if (fe(Mt, he)) {
                let an = xe.isWebGLCubeRenderTarget ? 34067 : 3553
                  , Ie = o.get(Mt).__webglTexture;
                t.bindTexture(an, Ie),
                ce(an),
                t.unbindTexture()
            }
        }
    }
    function Pn(xe) {
        if (i && xe.samples > 0 && Zt(xe) === !1) {
            let he = xe.width
              , Qe = xe.height
              , ft = 16384
              , St = [36064]
              , Mt = xe.stencilBuffer ? 33306 : 36096;
            xe.depthBuffer && St.push(Mt);
            let an = o.get(xe)
              , Ie = an.__ignoreDepthValues !== void 0 ? an.__ignoreDepthValues : !1;
            Ie === !1 && (xe.depthBuffer && (ft |= 256),
            xe.stencilBuffer && (ft |= 1024)),
            t.bindFramebuffer(36008, an.__webglMultisampledFramebuffer),
            t.bindFramebuffer(36009, an.__webglFramebuffer),
            Ie === !0 && (r.invalidateFramebuffer(36008, [Mt]),
            r.invalidateFramebuffer(36009, [Mt])),
            r.blitFramebuffer(0, 0, he, Qe, 0, 0, he, Qe, ft, 9728),
            I && r.invalidateFramebuffer(36008, St),
            t.bindFramebuffer(36008, null),
            t.bindFramebuffer(36009, an.__webglMultisampledFramebuffer)
        }
    }
    function kt(xe) {
        return Math.min(A, xe.samples)
    }
    function Zt(xe) {
        let he = o.get(xe);
        return i && xe.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && he.__useRenderToTexture !== !1
    }
    function zn(xe) {
        let he = p.render.frame;
        D.get(xe) !== he && (D.set(xe, he),
        xe.update())
    }
    function Qt(xe, he) {
        let Qe = xe.encoding
          , ft = xe.format
          , St = xe.type;
        return xe.isCompressedTexture === !0 || xe.isVideoTexture === !0 || xe.format === zy || Qe !== ya && (Qe === er ? i === !1 ? e.has("EXT_sRGB") === !0 && ft === is ? (xe.format = zy,
        xe.minFilter = ns,
        xe.generateMipmaps = !1) : he = el.sRGBToLinear(he) : (ft !== is || St !== ic) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture encoding:", Qe)),
        he
    }
    this.allocateTextureUnit = Be,
    this.resetTextureUnits = ke,
    this.setTexture2D = Ke,
    this.setTexture2DArray = bt,
    this.setTexture3D = Et,
    this.setTextureCube = Gt,
    this.rebindTextures = xt,
    this.setupRenderTarget = on,
    this.updateRenderTargetMipmap = $t,
    this.updateMultisampleRenderTarget = Pn,
    this.setupDepthRenderbuffer = ot,
    this.setupFrameBufferTexture = Bt,
    this.useMultisampledRTT = Zt
}
function iI(r, e, t) {
    let o = t.isWebGL2;
    function c(d, p=null) {
        let i;
        if (d === ic)
            return 5121;
        if (d === jM)
            return 32819;
        if (d === XM)
            return 32820;
        if (d === GM)
            return 5120;
        if (d === HM)
            return 5122;
        if (d === Id)
            return 5123;
        if (d === WM)
            return 5124;
        if (d === fm)
            return 5125;
        if (d === rc)
            return 5126;
        if (d === Gu)
            return o ? 5131 : (i = e.get("OES_texture_half_float"),
            i !== null ? i.HALF_FLOAT_OES : null);
        if (d === ZM)
            return 6406;
        if (d === is)
            return 6408;
        if (d === KM)
            return 6409;
        if (d === YM)
            return 6410;
        if (d === sc)
            return 6402;
        if (d === Wu)
            return 34041;
        if (d === pm)
            return 6403;
        if (d === qM)
            return console.warn("THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"),
            6408;
        if (d === zy)
            return i = e.get("EXT_sRGB"),
            i !== null ? i.SRGB_ALPHA_EXT : null;
        if (d === JM)
            return 36244;
        if (d === $M)
            return 33319;
        if (d === QM)
            return 33320;
        if (d === e2)
            return 36249;
        if (d === Iy || d === Cy || d === Dy || d === Ly)
            if (p === er)
                if (i = e.get("WEBGL_compressed_texture_s3tc_srgb"),
                i !== null) {
                    if (d === Iy)
                        return i.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                    if (d === Cy)
                        return i.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                    if (d === Dy)
                        return i.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                    if (d === Ly)
                        return i.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                } else
                    return null;
            else if (i = e.get("WEBGL_compressed_texture_s3tc"),
            i !== null) {
                if (d === Iy)
                    return i.COMPRESSED_RGB_S3TC_DXT1_EXT;
                if (d === Cy)
                    return i.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                if (d === Dy)
                    return i.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                if (d === Ly)
                    return i.COMPRESSED_RGBA_S3TC_DXT5_EXT
            } else
                return null;
        if (d === g1 || d === _1 || d === y1 || d === x1)
            if (i = e.get("WEBGL_compressed_texture_pvrtc"),
            i !== null) {
                if (d === g1)
                    return i.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                if (d === _1)
                    return i.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                if (d === y1)
                    return i.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                if (d === x1)
                    return i.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
            } else
                return null;
        if (d === t2)
            return i = e.get("WEBGL_compressed_texture_etc1"),
            i !== null ? i.COMPRESSED_RGB_ETC1_WEBGL : null;
        if (d === v1 || d === b1)
            if (i = e.get("WEBGL_compressed_texture_etc"),
            i !== null) {
                if (d === v1)
                    return p === er ? i.COMPRESSED_SRGB8_ETC2 : i.COMPRESSED_RGB8_ETC2;
                if (d === b1)
                    return p === er ? i.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : i.COMPRESSED_RGBA8_ETC2_EAC
            } else
                return null;
        if (d === w1 || d === T1 || d === E1 || d === S1 || d === A1 || d === M1 || d === I1 || d === C1 || d === D1 || d === L1 || d === R1 || d === P1 || d === k1 || d === z1)
            if (i = e.get("WEBGL_compressed_texture_astc"),
            i !== null) {
                if (d === w1)
                    return p === er ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : i.COMPRESSED_RGBA_ASTC_4x4_KHR;
                if (d === T1)
                    return p === er ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : i.COMPRESSED_RGBA_ASTC_5x4_KHR;
                if (d === E1)
                    return p === er ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : i.COMPRESSED_RGBA_ASTC_5x5_KHR;
                if (d === S1)
                    return p === er ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : i.COMPRESSED_RGBA_ASTC_6x5_KHR;
                if (d === A1)
                    return p === er ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : i.COMPRESSED_RGBA_ASTC_6x6_KHR;
                if (d === M1)
                    return p === er ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : i.COMPRESSED_RGBA_ASTC_8x5_KHR;
                if (d === I1)
                    return p === er ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : i.COMPRESSED_RGBA_ASTC_8x6_KHR;
                if (d === C1)
                    return p === er ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : i.COMPRESSED_RGBA_ASTC_8x8_KHR;
                if (d === D1)
                    return p === er ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : i.COMPRESSED_RGBA_ASTC_10x5_KHR;
                if (d === L1)
                    return p === er ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : i.COMPRESSED_RGBA_ASTC_10x6_KHR;
                if (d === R1)
                    return p === er ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : i.COMPRESSED_RGBA_ASTC_10x8_KHR;
                if (d === P1)
                    return p === er ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : i.COMPRESSED_RGBA_ASTC_10x10_KHR;
                if (d === k1)
                    return p === er ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : i.COMPRESSED_RGBA_ASTC_12x10_KHR;
                if (d === z1)
                    return p === er ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : i.COMPRESSED_RGBA_ASTC_12x12_KHR
            } else
                return null;
        if (d === O1)
            if (i = e.get("EXT_texture_compression_bptc"),
            i !== null) {
                if (d === O1)
                    return p === er ? i.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : i.COMPRESSED_RGBA_BPTC_UNORM_EXT
            } else
                return null;
        if (d === Hu)
            return o ? 34042 : (i = e.get("WEBGL_depth_texture"),
            i !== null ? i.UNSIGNED_INT_24_8_WEBGL : null)
    }
    return {
        convert: c
    }
}
var u0 = class extends os {
    constructor(e=[]) {
        super();
        this.cameras = e
    }
}
;
u0.prototype.isArrayCamera = !0;
var eh = class extends Ai {
    constructor() {
        super();
        this.type = "Group"
    }
}
;
eh.prototype.isGroup = !0;
var o5 = {
    type: "move"
}
  , h0 = class {
    constructor() {
        this._targetRay = null,
        this._grip = null,
        this._hand = null
    }
    getHandSpace() {
        return this._hand === null && (this._hand = new eh,
        this._hand.matrixAutoUpdate = !1,
        this._hand.visible = !1,
        this._hand.joints = {},
        this._hand.inputState = {
            pinching: !1
        }),
        this._hand
    }
    getTargetRaySpace() {
        return this._targetRay === null && (this._targetRay = new eh,
        this._targetRay.matrixAutoUpdate = !1,
        this._targetRay.visible = !1,
        this._targetRay.hasLinearVelocity = !1,
        this._targetRay.linearVelocity = new Oe,
        this._targetRay.hasAngularVelocity = !1,
        this._targetRay.angularVelocity = new Oe),
        this._targetRay
    }
    getGripSpace() {
        return this._grip === null && (this._grip = new eh,
        this._grip.matrixAutoUpdate = !1,
        this._grip.visible = !1,
        this._grip.hasLinearVelocity = !1,
        this._grip.linearVelocity = new Oe,
        this._grip.hasAngularVelocity = !1,
        this._grip.angularVelocity = new Oe),
        this._grip
    }
    dispatchEvent(e) {
        return this._targetRay !== null && this._targetRay.dispatchEvent(e),
        this._grip !== null && this._grip.dispatchEvent(e),
        this._hand !== null && this._hand.dispatchEvent(e),
        this
    }
    disconnect(e) {
        return this.dispatchEvent({
            type: "disconnected",
            data: e
        }),
        this._targetRay !== null && (this._targetRay.visible = !1),
        this._grip !== null && (this._grip.visible = !1),
        this._hand !== null && (this._hand.visible = !1),
        this
    }
    update(e, t, o) {
        let c = null
          , d = null
          , p = null
          , i = this._targetRay
          , v = this._grip
          , x = this._hand;
        if (e && t.session.visibilityState !== "visible-blurred")
            if (i !== null && (c = t.getPose(e.targetRaySpace, o),
            c !== null && (i.matrix.fromArray(c.transform.matrix),
            i.matrix.decompose(i.position, i.rotation, i.scale),
            c.linearVelocity ? (i.hasLinearVelocity = !0,
            i.linearVelocity.copy(c.linearVelocity)) : i.hasLinearVelocity = !1,
            c.angularVelocity ? (i.hasAngularVelocity = !0,
            i.angularVelocity.copy(c.angularVelocity)) : i.hasAngularVelocity = !1,
            this.dispatchEvent(o5))),
            x && e.hand) {
                p = !0;
                for (let P of e.hand.values()) {
                    let k = t.getJointPose(P, o);
                    if (x.joints[P.jointName] === void 0) {
                        let Z = new eh;
                        Z.matrixAutoUpdate = !1,
                        Z.visible = !1,
                        x.joints[P.jointName] = Z,
                        x.add(Z)
                    }
                    let U = x.joints[P.jointName];
                    k !== null && (U.matrix.fromArray(k.transform.matrix),
                    U.matrix.decompose(U.position, U.rotation, U.scale),
                    U.jointRadius = k.radius),
                    U.visible = k !== null
                }
                let E = x.joints["index-finger-tip"]
                  , A = x.joints["thumb-tip"]
                  , C = E.position.distanceTo(A.position)
                  , I = .02
                  , D = .005;
                x.inputState.pinching && C > I + D ? (x.inputState.pinching = !1,
                this.dispatchEvent({
                    type: "pinchend",
                    handedness: e.handedness,
                    target: this
                })) : !x.inputState.pinching && C <= I - D && (x.inputState.pinching = !0,
                this.dispatchEvent({
                    type: "pinchstart",
                    handedness: e.handedness,
                    target: this
                }))
            } else
                v !== null && e.gripSpace && (d = t.getPose(e.gripSpace, o),
                d !== null && (v.matrix.fromArray(d.transform.matrix),
                v.matrix.decompose(v.position, v.rotation, v.scale),
                d.linearVelocity ? (v.hasLinearVelocity = !0,
                v.linearVelocity.copy(d.linearVelocity)) : v.hasLinearVelocity = !1,
                d.angularVelocity ? (v.hasAngularVelocity = !0,
                v.angularVelocity.copy(d.angularVelocity)) : v.hasAngularVelocity = !1));
        return i !== null && (i.visible = c !== null),
        v !== null && (v.visible = d !== null),
        x !== null && (x.visible = p !== null),
        this
    }
}
  , d0 = class extends Ar {
    constructor(e, t, o, c, d, p, i, v, x, E) {
        if (E = E !== void 0 ? E : sc,
        E !== sc && E !== Wu)
            throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        o === void 0 && E === sc && (o = Id),
        o === void 0 && E === Wu && (o = Hu),
        super(null, c, d, p, i, v, E, o, x),
        this.image = {
            width: e,
            height: t
        },
        this.magFilter = i !== void 0 ? i : Di,
        this.minFilter = v !== void 0 ? v : Di,
        this.flipY = !1,
        this.generateMipmaps = !1
    }
}
;
d0.prototype.isDepthTexture = !0;
var rI = class extends Bo {
    constructor(e, t) {
        super();
        let o = this
          , c = null
          , d = 1
          , p = null
          , i = "local-floor"
          , v = null
          , x = null
          , E = null
          , A = null
          , C = null
          , I = t.getContextAttributes()
          , D = null
          , P = null
          , k = []
          , U = new Map
          , Z = new os;
        Z.layers.enable(1),
        Z.viewport = new Ui;
        let K = new os;
        K.layers.enable(2),
        K.viewport = new Ui;
        let X = [Z, K]
          , W = new u0;
        W.layers.enable(1),
        W.layers.enable(2);
        let fe = null
          , ce = null;
        this.cameraAutoUpdate = !0,
        this.enabled = !1,
        this.isPresenting = !1,
        this.getController = function(Be) {
            let tt = k[Be];
            return tt === void 0 && (tt = new h0,
            k[Be] = tt),
            tt.getTargetRaySpace()
        }
        ,
        this.getControllerGrip = function(Be) {
            let tt = k[Be];
            return tt === void 0 && (tt = new h0,
            k[Be] = tt),
            tt.getGripSpace()
        }
        ,
        this.getHand = function(Be) {
            let tt = k[Be];
            return tt === void 0 && (tt = new h0,
            k[Be] = tt),
            tt.getHandSpace()
        }
        ;
        function _e(Be) {
            let tt = U.get(Be.inputSource);
            tt && tt.dispatchEvent({
                type: Be.type,
                data: Be.inputSource
            })
        }
        function oe() {
            U.forEach(function(Be, tt) {
                Be.disconnect(tt)
            }),
            U.clear(),
            fe = null,
            ce = null,
            e.setRenderTarget(D),
            A = null,
            E = null,
            x = null,
            c = null,
            P = null,
            ke.stop(),
            o.isPresenting = !1,
            o.dispatchEvent({
                type: "sessionend"
            })
        }
        this.setFramebufferScaleFactor = function(Be) {
            d = Be,
            o.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
        }
        ,
        this.setReferenceSpaceType = function(Be) {
            i = Be,
            o.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
        }
        ,
        this.getReferenceSpace = function() {
            return p
        }
        ,
        this.getBaseLayer = function() {
            return E !== null ? E : A
        }
        ,
        this.getBinding = function() {
            return x
        }
        ,
        this.getFrame = function() {
            return C
        }
        ,
        this.getSession = function() {
            return c
        }
        ,
        this.setSession = async function(Be) {
            if (c = Be,
            c !== null) {
                if (D = e.getRenderTarget(),
                c.addEventListener("select", _e),
                c.addEventListener("selectstart", _e),
                c.addEventListener("selectend", _e),
                c.addEventListener("squeeze", _e),
                c.addEventListener("squeezestart", _e),
                c.addEventListener("squeezeend", _e),
                c.addEventListener("end", oe),
                c.addEventListener("inputsourceschange", ee),
                I.xrCompatible !== !0 && await t.makeXRCompatible(),
                c.renderState.layers === void 0 || e.capabilities.isWebGL2 === !1) {
                    let tt = {
                        antialias: c.renderState.layers === void 0 ? I.antialias : !0,
                        alpha: I.alpha,
                        depth: I.depth,
                        stencil: I.stencil,
                        framebufferScaleFactor: d
                    };
                    A = new XRWebGLLayer(c,t,tt),
                    c.updateRenderState({
                        baseLayer: A
                    }),
                    P = new Cs(A.framebufferWidth,A.framebufferHeight,{
                        format: is,
                        type: ic,
                        encoding: e.outputEncoding
                    })
                } else {
                    let tt = null
                      , Ke = null
                      , bt = null;
                    I.depth && (bt = I.stencil ? 35056 : 33190,
                    tt = I.stencil ? Wu : sc,
                    Ke = I.stencil ? Hu : Id);
                    let Et = {
                        colorFormat: e.outputEncoding === er ? 35907 : 32856,
                        depthFormat: bt,
                        scaleFactor: d
                    };
                    x = new XRWebGLBinding(c,t),
                    E = x.createProjectionLayer(Et),
                    c.updateRenderState({
                        layers: [E]
                    }),
                    P = new Cs(E.textureWidth,E.textureHeight,{
                        format: is,
                        type: ic,
                        depthTexture: new d0(E.textureWidth,E.textureHeight,Ke,void 0,void 0,void 0,void 0,void 0,void 0,tt),
                        stencilBuffer: I.stencil,
                        encoding: e.outputEncoding,
                        samples: I.antialias ? 4 : 0
                    });
                    let Gt = e.properties.get(P);
                    Gt.__ignoreDepthValues = E.ignoreDepthValues
                }
                P.isXRRenderTarget = !0,
                this.setFoveation(1),
                p = await c.requestReferenceSpace(i),
                ke.setContext(c),
                ke.start(),
                o.isPresenting = !0,
                o.dispatchEvent({
                    type: "sessionstart"
                })
            }
        }
        ;
        function ee(Be) {
            let tt = c.inputSources;
            for (let Ke = 0; Ke < k.length; Ke++)
                U.set(tt[Ke], k[Ke]);
            for (let Ke = 0; Ke < Be.removed.length; Ke++) {
                let bt = Be.removed[Ke]
                  , Et = U.get(bt);
                Et && (Et.dispatchEvent({
                    type: "disconnected",
                    data: bt
                }),
                U.delete(bt))
            }
            for (let Ke = 0; Ke < Be.added.length; Ke++) {
                let bt = Be.added[Ke]
                  , Et = U.get(bt);
                Et && Et.dispatchEvent({
                    type: "connected",
                    data: bt
                })
            }
        }
        let j = new Oe
          , ne = new Oe;
        function be(Be, tt, Ke) {
            j.setFromMatrixPosition(tt.matrixWorld),
            ne.setFromMatrixPosition(Ke.matrixWorld);
            let bt = j.distanceTo(ne)
              , Et = tt.projectionMatrix.elements
              , Gt = Ke.projectionMatrix.elements
              , Ye = Et[14] / (Et[10] - 1)
              , gn = Et[14] / (Et[10] + 1)
              , gt = (Et[9] + 1) / Et[5]
              , Tn = (Et[9] - 1) / Et[5]
              , xn = (Et[8] - 1) / Et[0]
              , Dn = (Gt[8] + 1) / Gt[0]
              , Bt = Ye * xn
              , An = Ye * Dn
              , ut = bt / (-xn + Dn)
              , ot = ut * -xn;
            tt.matrixWorld.decompose(Be.position, Be.quaternion, Be.scale),
            Be.translateX(ot),
            Be.translateZ(ut),
            Be.matrixWorld.compose(Be.position, Be.quaternion, Be.scale),
            Be.matrixWorldInverse.copy(Be.matrixWorld).invert();
            let xt = Ye + ut
              , on = gn + ut
              , $t = Bt - ot
              , Pn = An + (bt - ot)
              , kt = gt * gn / on * xt
              , Zt = Tn * gn / on * xt;
            Be.projectionMatrix.makePerspective($t, Pn, kt, Zt, xt, on)
        }
        function te(Be, tt) {
            tt === null ? Be.matrixWorld.copy(Be.matrix) : Be.matrixWorld.multiplyMatrices(tt.matrixWorld, Be.matrix),
            Be.matrixWorldInverse.copy(Be.matrixWorld).invert()
        }
        this.updateCamera = function(Be) {
            if (c === null)
                return;
            W.near = K.near = Z.near = Be.near,
            W.far = K.far = Z.far = Be.far,
            (fe !== W.near || ce !== W.far) && (c.updateRenderState({
                depthNear: W.near,
                depthFar: W.far
            }),
            fe = W.near,
            ce = W.far);
            let tt = Be.parent
              , Ke = W.cameras;
            te(W, tt);
            for (let Et = 0; Et < Ke.length; Et++)
                te(Ke[Et], tt);
            W.matrixWorld.decompose(W.position, W.quaternion, W.scale),
            Be.position.copy(W.position),
            Be.quaternion.copy(W.quaternion),
            Be.scale.copy(W.scale),
            Be.matrix.copy(W.matrix),
            Be.matrixWorld.copy(W.matrixWorld);
            let bt = Be.children;
            for (let Et = 0, Gt = bt.length; Et < Gt; Et++)
                bt[Et].updateMatrixWorld(!0);
            Ke.length === 2 ? be(W, Z, K) : W.projectionMatrix.copy(Z.projectionMatrix)
        }
        ,
        this.getCamera = function() {
            return W
        }
        ,
        this.getFoveation = function() {
            if (E !== null)
                return E.fixedFoveation;
            if (A !== null)
                return A.fixedFoveation
        }
        ,
        this.setFoveation = function(Be) {
            E !== null && (E.fixedFoveation = Be),
            A !== null && A.fixedFoveation !== void 0 && (A.fixedFoveation = Be)
        }
        ;
        let ae = null;
        function se(Be, tt) {
            if (v = tt.getViewerPose(p),
            C = tt,
            v !== null) {
                let bt = v.views;
                A !== null && (e.setRenderTargetFramebuffer(P, A.framebuffer),
                e.setRenderTarget(P));
                let Et = !1;
                bt.length !== W.cameras.length && (W.cameras.length = 0,
                Et = !0);
                for (let Gt = 0; Gt < bt.length; Gt++) {
                    let Ye = bt[Gt]
                      , gn = null;
                    if (A !== null)
                        gn = A.getViewport(Ye);
                    else {
                        let Tn = x.getViewSubImage(E, Ye);
                        gn = Tn.viewport,
                        Gt === 0 && (e.setRenderTargetTextures(P, Tn.colorTexture, E.ignoreDepthValues ? void 0 : Tn.depthStencilTexture),
                        e.setRenderTarget(P))
                    }
                    let gt = X[Gt];
                    gt.matrix.fromArray(Ye.transform.matrix),
                    gt.projectionMatrix.fromArray(Ye.projectionMatrix),
                    gt.viewport.set(gn.x, gn.y, gn.width, gn.height),
                    Gt === 0 && W.matrix.copy(gt.matrix),
                    Et === !0 && W.cameras.push(gt)
                }
            }
            let Ke = c.inputSources;
            for (let bt = 0; bt < k.length; bt++) {
                let Et = k[bt]
                  , Gt = Ke[bt];
                Et.update(Gt, tt, p)
            }
            ae && ae(Be, tt),
            C = null
        }
        let ke = new S2;
        ke.setAnimationLoop(se),
        this.setAnimationLoop = function(Be) {
            ae = Be
        }
        ,
        this.dispose = function() {}
    }
}
;
function a5(r, e) {
    function t(P, k) {
        P.fogColor.value.copy(k.color),
        k.isFog ? (P.fogNear.value = k.near,
        P.fogFar.value = k.far) : k.isFogExp2 && (P.fogDensity.value = k.density)
    }
    function o(P, k, U, Z, K) {
        k.isMeshBasicMaterial || k.isMeshLambertMaterial ? c(P, k) : k.isMeshToonMaterial ? (c(P, k),
        E(P, k)) : k.isMeshPhongMaterial ? (c(P, k),
        x(P, k)) : k.isMeshStandardMaterial ? (c(P, k),
        A(P, k),
        k.isMeshPhysicalMaterial && C(P, k, K)) : k.isMeshMatcapMaterial ? (c(P, k),
        I(P, k)) : k.isMeshDepthMaterial ? c(P, k) : k.isMeshDistanceMaterial ? (c(P, k),
        D(P, k)) : k.isMeshNormalMaterial ? c(P, k) : k.isLineBasicMaterial ? (d(P, k),
        k.isLineDashedMaterial && p(P, k)) : k.isPointsMaterial ? i(P, k, U, Z) : k.isSpriteMaterial ? v(P, k) : k.isShadowMaterial ? (P.color.value.copy(k.color),
        P.opacity.value = k.opacity) : k.isShaderMaterial && (k.uniformsNeedUpdate = !1)
    }
    function c(P, k) {
        P.opacity.value = k.opacity,
        k.color && P.diffuse.value.copy(k.color),
        k.emissive && P.emissive.value.copy(k.emissive).multiplyScalar(k.emissiveIntensity),
        k.map && (P.map.value = k.map),
        k.alphaMap && (P.alphaMap.value = k.alphaMap),
        k.bumpMap && (P.bumpMap.value = k.bumpMap,
        P.bumpScale.value = k.bumpScale,
        k.side === Zs && (P.bumpScale.value *= -1)),
        k.displacementMap && (P.displacementMap.value = k.displacementMap,
        P.displacementScale.value = k.displacementScale,
        P.displacementBias.value = k.displacementBias),
        k.emissiveMap && (P.emissiveMap.value = k.emissiveMap),
        k.normalMap && (P.normalMap.value = k.normalMap,
        P.normalScale.value.copy(k.normalScale),
        k.side === Zs && P.normalScale.value.negate()),
        k.specularMap && (P.specularMap.value = k.specularMap),
        k.alphaTest > 0 && (P.alphaTest.value = k.alphaTest);
        let U = e.get(k).envMap;
        if (U && (P.envMap.value = U,
        P.flipEnvMap.value = U.isCubeTexture && U.isRenderTargetTexture === !1 ? -1 : 1,
        P.reflectivity.value = k.reflectivity,
        P.ior.value = k.ior,
        P.refractionRatio.value = k.refractionRatio),
        k.lightMap) {
            P.lightMap.value = k.lightMap;
            let X = r.physicallyCorrectLights !== !0 ? Math.PI : 1;
            P.lightMapIntensity.value = k.lightMapIntensity * X
        }
        k.aoMap && (P.aoMap.value = k.aoMap,
        P.aoMapIntensity.value = k.aoMapIntensity);
        let Z;
        k.map ? Z = k.map : k.specularMap ? Z = k.specularMap : k.displacementMap ? Z = k.displacementMap : k.normalMap ? Z = k.normalMap : k.bumpMap ? Z = k.bumpMap : k.roughnessMap ? Z = k.roughnessMap : k.metalnessMap ? Z = k.metalnessMap : k.alphaMap ? Z = k.alphaMap : k.emissiveMap ? Z = k.emissiveMap : k.clearcoatMap ? Z = k.clearcoatMap : k.clearcoatNormalMap ? Z = k.clearcoatNormalMap : k.clearcoatRoughnessMap ? Z = k.clearcoatRoughnessMap : k.specularIntensityMap ? Z = k.specularIntensityMap : k.specularColorMap ? Z = k.specularColorMap : k.transmissionMap ? Z = k.transmissionMap : k.thicknessMap ? Z = k.thicknessMap : k.sheenColorMap ? Z = k.sheenColorMap : k.sheenRoughnessMap && (Z = k.sheenRoughnessMap),
        Z !== void 0 && (Z.isWebGLRenderTarget && (Z = Z.texture),
        Z.matrixAutoUpdate === !0 && Z.updateMatrix(),
        P.uvTransform.value.copy(Z.matrix));
        let K;
        k.aoMap ? K = k.aoMap : k.lightMap && (K = k.lightMap),
        K !== void 0 && (K.isWebGLRenderTarget && (K = K.texture),
        K.matrixAutoUpdate === !0 && K.updateMatrix(),
        P.uv2Transform.value.copy(K.matrix))
    }
    function d(P, k) {
        P.diffuse.value.copy(k.color),
        P.opacity.value = k.opacity
    }
    function p(P, k) {
        P.dashSize.value = k.dashSize,
        P.totalSize.value = k.dashSize + k.gapSize,
        P.scale.value = k.scale
    }
    function i(P, k, U, Z) {
        P.diffuse.value.copy(k.color),
        P.opacity.value = k.opacity,
        P.size.value = k.size * U,
        P.scale.value = Z * .5,
        k.map && (P.map.value = k.map),
        k.alphaMap && (P.alphaMap.value = k.alphaMap),
        k.alphaTest > 0 && (P.alphaTest.value = k.alphaTest);
        let K;
        k.map ? K = k.map : k.alphaMap && (K = k.alphaMap),
        K !== void 0 && (K.matrixAutoUpdate === !0 && K.updateMatrix(),
        P.uvTransform.value.copy(K.matrix))
    }
    function v(P, k) {
        P.diffuse.value.copy(k.color),
        P.opacity.value = k.opacity,
        P.rotation.value = k.rotation,
        k.map && (P.map.value = k.map),
        k.alphaMap && (P.alphaMap.value = k.alphaMap),
        k.alphaTest > 0 && (P.alphaTest.value = k.alphaTest);
        let U;
        k.map ? U = k.map : k.alphaMap && (U = k.alphaMap),
        U !== void 0 && (U.matrixAutoUpdate === !0 && U.updateMatrix(),
        P.uvTransform.value.copy(U.matrix))
    }
    function x(P, k) {
        P.specular.value.copy(k.specular),
        P.shininess.value = Math.max(k.shininess, 1e-4)
    }
    function E(P, k) {
        k.gradientMap && (P.gradientMap.value = k.gradientMap)
    }
    function A(P, k) {
        P.roughness.value = k.roughness,
        P.metalness.value = k.metalness,
        k.roughnessMap && (P.roughnessMap.value = k.roughnessMap),
        k.metalnessMap && (P.metalnessMap.value = k.metalnessMap),
        e.get(k).envMap && (P.envMapIntensity.value = k.envMapIntensity)
    }
    function C(P, k, U) {
        P.ior.value = k.ior,
        k.sheen > 0 && (P.sheenColor.value.copy(k.sheenColor).multiplyScalar(k.sheen),
        P.sheenRoughness.value = k.sheenRoughness,
        k.sheenColorMap && (P.sheenColorMap.value = k.sheenColorMap),
        k.sheenRoughnessMap && (P.sheenRoughnessMap.value = k.sheenRoughnessMap)),
        k.clearcoat > 0 && (P.clearcoat.value = k.clearcoat,
        P.clearcoatRoughness.value = k.clearcoatRoughness,
        k.clearcoatMap && (P.clearcoatMap.value = k.clearcoatMap),
        k.clearcoatRoughnessMap && (P.clearcoatRoughnessMap.value = k.clearcoatRoughnessMap),
        k.clearcoatNormalMap && (P.clearcoatNormalScale.value.copy(k.clearcoatNormalScale),
        P.clearcoatNormalMap.value = k.clearcoatNormalMap,
        k.side === Zs && P.clearcoatNormalScale.value.negate())),
        k.transmission > 0 && (P.transmission.value = k.transmission,
        P.transmissionSamplerMap.value = U.texture,
        P.transmissionSamplerSize.value.set(U.width, U.height),
        k.transmissionMap && (P.transmissionMap.value = k.transmissionMap),
        P.thickness.value = k.thickness,
        k.thicknessMap && (P.thicknessMap.value = k.thicknessMap),
        P.attenuationDistance.value = k.attenuationDistance,
        P.attenuationColor.value.copy(k.attenuationColor)),
        P.specularIntensity.value = k.specularIntensity,
        P.specularColor.value.copy(k.specularColor),
        k.specularIntensityMap && (P.specularIntensityMap.value = k.specularIntensityMap),
        k.specularColorMap && (P.specularColorMap.value = k.specularColorMap)
    }
    function I(P, k) {
        k.matcap && (P.matcap.value = k.matcap)
    }
    function D(P, k) {
        P.referencePosition.value.copy(k.referencePosition),
        P.nearDistance.value = k.nearDistance,
        P.farDistance.value = k.farDistance
    }
    return {
        refreshFogUniforms: t,
        refreshMaterialUniforms: o
    }
}
function l5() {
    let r = xm("canvas");
    return r.style.display = "block",
    r
}
function zi(r={}) {
    let e = r.canvas !== void 0 ? r.canvas : l5(), t = r.context !== void 0 ? r.context : null, o = r.depth !== void 0 ? r.depth : !0, c = r.stencil !== void 0 ? r.stencil : !0, d = r.antialias !== void 0 ? r.antialias : !1, p = r.premultipliedAlpha !== void 0 ? r.premultipliedAlpha : !0, i = r.preserveDrawingBuffer !== void 0 ? r.preserveDrawingBuffer : !1, v = r.powerPreference !== void 0 ? r.powerPreference : "default", x = r.failIfMajorPerformanceCaveat !== void 0 ? r.failIfMajorPerformanceCaveat : !1, E;
    r.context !== void 0 ? E = t.getContextAttributes().alpha : E = r.alpha !== void 0 ? r.alpha : !1;
    let A = null
      , C = null
      , I = []
      , D = [];
    this.domElement = e,
    this.debug = {
        checkShaderErrors: !0
    },
    this.autoClear = !0,
    this.autoClearColor = !0,
    this.autoClearDepth = !0,
    this.autoClearStencil = !0,
    this.sortObjects = !0,
    this.clippingPlanes = [],
    this.localClippingEnabled = !1,
    this.outputEncoding = ya,
    this.physicallyCorrectLights = !1,
    this.toneMapping = _a,
    this.toneMappingExposure = 1;
    let P = this
      , k = !1
      , U = 0
      , Z = 0
      , K = null
      , X = -1
      , W = null
      , fe = new Ui
      , ce = new Ui
      , _e = null
      , oe = e.width
      , ee = e.height
      , j = 1
      , ne = null
      , be = null
      , te = new Ui(0,0,oe,ee)
      , ae = new Ui(0,0,oe,ee)
      , se = !1
      , ke = new Zd
      , Be = !1
      , tt = !1
      , Ke = null
      , bt = new Fn
      , Et = new zt
      , Gt = new Oe
      , Ye = {
        background: null,
        fog: null,
        environment: null,
        overrideMaterial: null,
        isScene: !0
    };
    function gn() {
        return K === null ? j : 1
    }
    let gt = t;
    function Tn(F, $) {
        for (let ie = 0; ie < F.length; ie++) {
            let ue = F[ie]
              , Ee = e.getContext(ue, $);
            if (Ee !== null)
                return Ee
        }
        return null
    }
    try {
        let F = {
            alpha: !0,
            depth: o,
            stencil: c,
            antialias: d,
            premultipliedAlpha: p,
            preserveDrawingBuffer: i,
            powerPreference: v,
            failIfMajorPerformanceCaveat: x
        };
        if ("setAttribute"in e && e.setAttribute("data-engine", `three.js r ${Ty}`),
        e.addEventListener("webglcontextlost", Ge, !1),
        e.addEventListener("webglcontextrestored", Wt, !1),
        gt === null) {
            let $ = ["webgl2", "webgl", "experimental-webgl"];
            if (P.isWebGL1Renderer === !0 && $.shift(),
            gt = Tn($, F),
            gt === null)
                throw Tn($) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
        }
        gt.getShaderPrecisionFormat === void 0 && (gt.getShaderPrecisionFormat = function() {
            return {
                rangeMin: 1,
                rangeMax: 1,
                precision: 1
            }
        }
        )
    } catch (F) {
        throw console.error("THREE.WebGLRenderer: " + F.message),
        F
    }
    let xn, Dn, Bt, An, ut, ot, xt, on, $t, Pn, kt, Zt, zn, Qt, xe, he, Qe, ft, St, Mt, an, Ie, Ct;
    function ln() {
        xn = new DF(gt),
        Dn = new EF(gt,xn,r),
        xn.init(Dn),
        Ie = new iI(gt,xn,Dn),
        Bt = new r5(gt,xn,Dn),
        An = new PF(gt),
        ut = new ZB,
        ot = new s5(gt,xn,Bt,ut,Dn,Ie,An),
        xt = new AF(P),
        on = new CF(P),
        $t = new Zz(gt,Dn),
        Ct = new wF(gt,xn,$t,Dn),
        Pn = new LF(gt,$t,An,Ct),
        kt = new NF(gt,Pn,$t,An),
        St = new OF(gt,Dn,ot),
        he = new SF(ut),
        Zt = new XB(P,xt,on,xn,Dn,Ct,he),
        zn = new a5(P,ut),
        Qt = new KB,
        xe = new t5(xn,Dn),
        ft = new bF(P,xt,Bt,kt,E,p),
        Qe = new nI(P,kt,Dn),
        Mt = new TF(gt,xn,An,Dn),
        an = new RF(gt,xn,An,Dn),
        An.programs = Zt.programs,
        P.capabilities = Dn,
        P.extensions = xn,
        P.properties = ut,
        P.renderLists = Qt,
        P.shadowMap = Qe,
        P.state = Bt,
        P.info = An
    }
    ln();
    let Kt = new rI(P,gt);
    this.xr = Kt,
    this.getContext = function() {
        return gt
    }
    ,
    this.getContextAttributes = function() {
        return gt.getContextAttributes()
    }
    ,
    this.forceContextLoss = function() {
        let F = xn.get("WEBGL_lose_context");
        F && F.loseContext()
    }
    ,
    this.forceContextRestore = function() {
        let F = xn.get("WEBGL_lose_context");
        F && F.restoreContext()
    }
    ,
    this.getPixelRatio = function() {
        return j
    }
    ,
    this.setPixelRatio = function(F) {
        F !== void 0 && (j = F,
        this.setSize(oe, ee, !1))
    }
    ,
    this.getSize = function(F) {
        return F.set(oe, ee)
    }
    ,
    this.setSize = function(F, $, ie) {
        if (Kt.isPresenting) {
            console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
            return
        }
        oe = F,
        ee = $,
        e.width = Math.floor(F * j),
        e.height = Math.floor($ * j),
        ie !== !1 && (e.style.width = F + "px",
        e.style.height = $ + "px"),
        this.setViewport(0, 0, F, $)
    }
    ,
    this.getDrawingBufferSize = function(F) {
        return F.set(oe * j, ee * j).floor()
    }
    ,
    this.setDrawingBufferSize = function(F, $, ie) {
        oe = F,
        ee = $,
        j = ie,
        e.width = Math.floor(F * ie),
        e.height = Math.floor($ * ie),
        this.setViewport(0, 0, F, $)
    }
    ,
    this.getCurrentViewport = function(F) {
        return F.copy(fe)
    }
    ,
    this.getViewport = function(F) {
        return F.copy(te)
    }
    ,
    this.setViewport = function(F, $, ie, ue) {
        F.isVector4 ? te.set(F.x, F.y, F.z, F.w) : te.set(F, $, ie, ue),
        Bt.viewport(fe.copy(te).multiplyScalar(j).floor())
    }
    ,
    this.getScissor = function(F) {
        return F.copy(ae)
    }
    ,
    this.setScissor = function(F, $, ie, ue) {
        F.isVector4 ? ae.set(F.x, F.y, F.z, F.w) : ae.set(F, $, ie, ue),
        Bt.scissor(ce.copy(ae).multiplyScalar(j).floor())
    }
    ,
    this.getScissorTest = function() {
        return se
    }
    ,
    this.setScissorTest = function(F) {
        Bt.setScissorTest(se = F)
    }
    ,
    this.setOpaqueSort = function(F) {
        ne = F
    }
    ,
    this.setTransparentSort = function(F) {
        be = F
    }
    ,
    this.getClearColor = function(F) {
        return F.copy(ft.getClearColor())
    }
    ,
    this.setClearColor = function() {
        ft.setClearColor.apply(ft, arguments)
    }
    ,
    this.getClearAlpha = function() {
        return ft.getClearAlpha()
    }
    ,
    this.setClearAlpha = function() {
        ft.setClearAlpha.apply(ft, arguments)
    }
    ,
    this.clear = function(F=!0, $=!0, ie=!0) {
        let ue = 0;
        F && (ue |= 16384),
        $ && (ue |= 256),
        ie && (ue |= 1024),
        gt.clear(ue)
    }
    ,
    this.clearColor = function() {
        this.clear(!0, !1, !1)
    }
    ,
    this.clearDepth = function() {
        this.clear(!1, !0, !1)
    }
    ,
    this.clearStencil = function() {
        this.clear(!1, !1, !0)
    }
    ,
    this.dispose = function() {
        e.removeEventListener("webglcontextlost", Ge, !1),
        e.removeEventListener("webglcontextrestored", Wt, !1),
        Qt.dispose(),
        xe.dispose(),
        ut.dispose(),
        xt.dispose(),
        on.dispose(),
        kt.dispose(),
        Ct.dispose(),
        Zt.dispose(),
        Kt.dispose(),
        Kt.removeEventListener("sessionstart", Ln),
        Kt.removeEventListener("sessionend", Zn),
        Ke && (Ke.dispose(),
        Ke = null),
        Vn.stop()
    }
    ;
    function Ge(F) {
        F.preventDefault(),
        console.log("THREE.WebGLRenderer: Context Lost."),
        k = !0
    }
    function Wt() {
        console.log("THREE.WebGLRenderer: Context Restored."),
        k = !1;
        let F = An.autoReset
          , $ = Qe.enabled
          , ie = Qe.autoUpdate
          , ue = Qe.needsUpdate
          , Ee = Qe.type;
        ln(),
        An.autoReset = F,
        Qe.enabled = $,
        Qe.autoUpdate = ie,
        Qe.needsUpdate = ue,
        Qe.type = Ee
    }
    function Ut(F) {
        let $ = F.target;
        $.removeEventListener("dispose", Ut),
        _n($)
    }
    function _n(F) {
        Ft(F),
        ut.remove(F)
    }
    function Ft(F) {
        let $ = ut.get(F).programs;
        $ !== void 0 && ($.forEach(function(ie) {
            Zt.releaseProgram(ie)
        }),
        F.isShaderMaterial && Zt.releaseShaderCache(F))
    }
    this.renderBufferDirect = function(F, $, ie, ue, Ee, He) {
        $ === null && ($ = Ye);
        let Re = Ee.isMesh && Ee.matrixWorld.determinant() < 0
          , Ze = ds(F, $, ie, ue, Ee);
        Bt.setMaterial(ue, Re);
        let ye = ie.index
          , et = ie.attributes.position;
        if (ye === null) {
            if (et === void 0 || et.count === 0)
                return
        } else if (ye.count === 0)
            return;
        let We = 1;
        ue.wireframe === !0 && (ye = Pn.getWireframeAttribute(ie),
        We = 2),
        Ct.setup(Ee, ue, Ze, ie, ye);
        let ze, Rt = Mt;
        ye !== null && (ze = $t.get(ye),
        Rt = an,
        Rt.setIndex(ze));
        let wt = ye !== null ? ye.count : et.count
          , fn = ie.drawRange.start * We
          , Mn = ie.drawRange.count * We
          , Nn = He !== null ? He.start * We : 0
          , jt = He !== null ? He.count * We : Infinity
          , qn = Math.max(fn, Nn)
          , On = Math.min(wt, fn + Mn, Nn + jt) - 1
          , ar = Math.max(0, On - qn + 1);
        if (ar !== 0) {
            if (Ee.isMesh)
                ue.wireframe === !0 ? (Bt.setLineWidth(ue.wireframeLinewidth * gn()),
                Rt.setMode(1)) : Rt.setMode(4);
            else if (Ee.isLine) {
                let pr = ue.linewidth;
                pr === void 0 && (pr = 1),
                Bt.setLineWidth(pr * gn()),
                Ee.isLineSegments ? Rt.setMode(1) : Ee.isLineLoop ? Rt.setMode(2) : Rt.setMode(3)
            } else
                Ee.isPoints ? Rt.setMode(0) : Ee.isSprite && Rt.setMode(4);
            if (Ee.isInstancedMesh)
                Rt.renderInstances(qn, ar, Ee.count);
            else if (ie.isInstancedBufferGeometry) {
                let pr = Math.min(ie.instanceCount, ie._maxInstanceCount);
                Rt.renderInstances(qn, ar, pr)
            } else
                Rt.render(qn, ar)
        }
    }
    ,
    this.compile = function(F, $) {
        C = xe.get(F),
        C.init(),
        D.push(C),
        F.traverseVisible(function(ie) {
            ie.isLight && ie.layers.test($.layers) && (C.pushLight(ie),
            ie.castShadow && C.pushShadow(ie))
        }),
        C.setupLights(P.physicallyCorrectLights),
        F.traverse(function(ie) {
            let ue = ie.material;
            if (ue)
                if (Array.isArray(ue))
                    for (let Ee = 0; Ee < ue.length; Ee++) {
                        let He = ue[Ee];
                        Gr(He, F, ie)
                    }
                else
                    Gr(ue, F, ie)
        }),
        D.pop(),
        C = null
    }
    ;
    let nn = null;
    function Jt(F) {
        nn && nn(F)
    }
    function Ln() {
        Vn.stop()
    }
    function Zn() {
        Vn.start()
    }
    let Vn = new S2;
    Vn.setAnimationLoop(Jt),
    typeof self != "undefined" && Vn.setContext(self),
    this.setAnimationLoop = function(F) {
        nn = F,
        Kt.setAnimationLoop(F),
        F === null ? Vn.stop() : Vn.start()
    }
    ,
    Kt.addEventListener("sessionstart", Ln),
    Kt.addEventListener("sessionend", Zn),
    this.render = function(F, $) {
        if ($ !== void 0 && $.isCamera !== !0) {
            console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
            return
        }
        if (k === !0)
            return;
        F.autoUpdate === !0 && F.updateMatrixWorld(),
        $.parent === null && $.updateMatrixWorld(),
        Kt.enabled === !0 && Kt.isPresenting === !0 && (Kt.cameraAutoUpdate === !0 && Kt.updateCamera($),
        $ = Kt.getCamera()),
        F.isScene === !0 && F.onBeforeRender(P, F, $, K),
        C = xe.get(F, D.length),
        C.init(),
        D.push(C),
        bt.multiplyMatrices($.projectionMatrix, $.matrixWorldInverse),
        ke.setFromProjectionMatrix(bt),
        tt = this.localClippingEnabled,
        Be = he.init(this.clippingPlanes, tt, $),
        A = Qt.get(F, I.length),
        A.init(),
        I.push(A),
        Tr(F, $, 0, P.sortObjects),
        A.finish(),
        P.sortObjects === !0 && A.sort(ne, be),
        Be === !0 && he.beginShadows();
        let ie = C.state.shadowsArray;
        if (Qe.render(ie, F, $),
        Be === !0 && he.endShadows(),
        this.info.autoReset === !0 && this.info.reset(),
        ft.render(A, F),
        C.setupLights(P.physicallyCorrectLights),
        $.isArrayCamera) {
            let ue = $.cameras;
            for (let Ee = 0, He = ue.length; Ee < He; Ee++) {
                let Re = ue[Ee];
                fr(A, F, Re, Re.viewport)
            }
        } else
            fr(A, F, $);
        K !== null && (ot.updateMultisampleRenderTarget(K),
        ot.updateRenderTargetMipmap(K)),
        F.isScene === !0 && F.onAfterRender(P, F, $),
        Ct.resetDefaultState(),
        X = -1,
        W = null,
        D.pop(),
        D.length > 0 ? C = D[D.length - 1] : C = null,
        I.pop(),
        I.length > 0 ? A = I[I.length - 1] : A = null
    }
    ;
    function Tr(F, $, ie, ue) {
        if (F.visible === !1)
            return;
        if (F.layers.test($.layers)) {
            if (F.isGroup)
                ie = F.renderOrder;
            else if (F.isLOD)
                F.autoUpdate === !0 && F.update($);
            else if (F.isLight)
                C.pushLight(F),
                F.castShadow && C.pushShadow(F);
            else if (F.isSprite) {
                if (!F.frustumCulled || ke.intersectsSprite(F)) {
                    ue && Gt.setFromMatrixPosition(F.matrixWorld).applyMatrix4(bt);
                    let Re = kt.update(F)
                      , Ze = F.material;
                    Ze.visible && A.push(F, Re, Ze, ie, Gt.z, null)
                }
            } else if ((F.isMesh || F.isLine || F.isPoints) && (F.isSkinnedMesh && F.skeleton.frame !== An.render.frame && (F.skeleton.update(),
            F.skeleton.frame = An.render.frame),
            !F.frustumCulled || ke.intersectsObject(F))) {
                ue && Gt.setFromMatrixPosition(F.matrixWorld).applyMatrix4(bt);
                let Re = kt.update(F)
                  , Ze = F.material;
                if (Array.isArray(Ze)) {
                    let ye = Re.groups;
                    for (let et = 0, We = ye.length; et < We; et++) {
                        let ze = ye[et]
                          , Rt = Ze[ze.materialIndex];
                        Rt && Rt.visible && A.push(F, Re, Rt, ie, Gt.z, ze)
                    }
                } else
                    Ze.visible && A.push(F, Re, Ze, ie, Gt.z, null)
            }
        }
        let He = F.children;
        for (let Re = 0, Ze = He.length; Re < Ze; Re++)
            Tr(He[Re], $, ie, ue)
    }
    function fr(F, $, ie, ue) {
        let Ee = F.opaque
          , He = F.transmissive
          , Re = F.transparent;
        C.setupLightsView(ie),
        He.length > 0 && Rs(Ee, $, ie),
        ue && Bt.viewport(fe.copy(ue)),
        Ee.length > 0 && Cr(Ee, $, ie),
        He.length > 0 && Cr(He, $, ie),
        Re.length > 0 && Cr(Re, $, ie),
        Bt.buffers.depth.setTest(!0),
        Bt.buffers.depth.setMask(!0),
        Bt.buffers.color.setMask(!0),
        Bt.setPolygonOffset(!1)
    }
    function Rs(F, $, ie) {
        let ue = Dn.isWebGL2;
        Ke === null && (Ke = new Cs(1,1,{
            generateMipmaps: !0,
            type: Ie.convert(Gu) !== null ? Gu : ic,
            minFilter: dm,
            samples: ue && d === !0 ? 4 : 0
        })),
        P.getDrawingBufferSize(Et),
        ue ? Ke.setSize(Et.x, Et.y) : Ke.setSize(V1(Et.x), V1(Et.y));
        let Ee = P.getRenderTarget();
        P.setRenderTarget(Ke),
        P.clear();
        let He = P.toneMapping;
        P.toneMapping = _a,
        Cr(F, $, ie),
        P.toneMapping = He,
        ot.updateMultisampleRenderTarget(Ke),
        ot.updateRenderTargetMipmap(Ke),
        P.setRenderTarget(Ee)
    }
    function Cr(F, $, ie) {
        let ue = $.isScene === !0 ? $.overrideMaterial : null;
        for (let Ee = 0, He = F.length; Ee < He; Ee++) {
            let Re = F[Ee]
              , Ze = Re.object
              , ye = Re.geometry
              , et = ue === null ? Re.material : ue
              , We = Re.group;
            Ze.layers.test(ie.layers) && Vr(Ze, $, ie, ye, et, We)
        }
    }
    function Vr(F, $, ie, ue, Ee, He) {
        F.onBeforeRender(P, $, ie, ue, Ee, He),
        F.modelViewMatrix.multiplyMatrices(ie.matrixWorldInverse, F.matrixWorld),
        F.normalMatrix.getNormalMatrix(F.modelViewMatrix),
        Ee.onBeforeRender(P, $, ie, ue, F, He),
        Ee.transparent === !0 && Ee.side === $a ? (Ee.side = Zs,
        Ee.needsUpdate = !0,
        P.renderBufferDirect(ie, $, ue, Ee, F, He),
        Ee.side = Md,
        Ee.needsUpdate = !0,
        P.renderBufferDirect(ie, $, ue, Ee, F, He),
        Ee.side = $a) : P.renderBufferDirect(ie, $, ue, Ee, F, He),
        F.onAfterRender(P, $, ie, ue, Ee, He)
    }
    function Gr(F, $, ie) {
        $.isScene !== !0 && ($ = Ye);
        let ue = ut.get(F)
          , Ee = C.state.lights
          , He = C.state.shadowsArray
          , Re = Ee.state.version
          , Ze = Zt.getParameters(F, Ee.state, He, $, ie)
          , ye = Zt.getProgramCacheKey(Ze)
          , et = ue.programs;
        ue.environment = F.isMeshStandardMaterial ? $.environment : null,
        ue.fog = $.fog,
        ue.envMap = (F.isMeshStandardMaterial ? on : xt).get(F.envMap || ue.environment),
        et === void 0 && (F.addEventListener("dispose", Ut),
        et = new Map,
        ue.programs = et);
        let We = et.get(ye);
        if (We !== void 0) {
            if (ue.currentProgram === We && ue.lightsStateVersion === Re)
                return Ps(F, Ze),
                We
        } else
            Ze.uniforms = Zt.getUniforms(F),
            F.onBuild(ie, Ze, P),
            F.onBeforeCompile(Ze, P),
            We = Zt.acquireProgram(Ze, ye),
            et.set(ye, We),
            ue.uniforms = Ze.uniforms;
        let ze = ue.uniforms;
        (!F.isShaderMaterial && !F.isRawShaderMaterial || F.clipping === !0) && (ze.clippingPlanes = he.uniform),
        Ps(F, Ze),
        ue.needsLights = Y(F),
        ue.lightsStateVersion = Re,
        ue.needsLights && (ze.ambientLightColor.value = Ee.state.ambient,
        ze.lightProbe.value = Ee.state.probe,
        ze.directionalLights.value = Ee.state.directional,
        ze.directionalLightShadows.value = Ee.state.directionalShadow,
        ze.spotLights.value = Ee.state.spot,
        ze.spotLightShadows.value = Ee.state.spotShadow,
        ze.rectAreaLights.value = Ee.state.rectArea,
        ze.ltc_1.value = Ee.state.rectAreaLTC1,
        ze.ltc_2.value = Ee.state.rectAreaLTC2,
        ze.pointLights.value = Ee.state.point,
        ze.pointLightShadows.value = Ee.state.pointShadow,
        ze.hemisphereLights.value = Ee.state.hemi,
        ze.directionalShadowMap.value = Ee.state.directionalShadowMap,
        ze.directionalShadowMatrix.value = Ee.state.directionalShadowMatrix,
        ze.spotShadowMap.value = Ee.state.spotShadowMap,
        ze.spotShadowMatrix.value = Ee.state.spotShadowMatrix,
        ze.pointShadowMap.value = Ee.state.pointShadowMap,
        ze.pointShadowMatrix.value = Ee.state.pointShadowMatrix);
        let Rt = We.getUniforms()
          , wt = yc.seqWithValue(Rt.seq, ze);
        return ue.currentProgram = We,
        ue.uniformsList = wt,
        We
    }
    function Ps(F, $) {
        let ie = ut.get(F);
        ie.outputEncoding = $.outputEncoding,
        ie.instancing = $.instancing,
        ie.skinning = $.skinning,
        ie.morphTargets = $.morphTargets,
        ie.morphNormals = $.morphNormals,
        ie.morphColors = $.morphColors,
        ie.morphTargetsCount = $.morphTargetsCount,
        ie.numClippingPlanes = $.numClippingPlanes,
        ie.numIntersection = $.numClipIntersection,
        ie.vertexAlphas = $.vertexAlphas,
        ie.vertexTangents = $.vertexTangents,
        ie.toneMapping = $.toneMapping
    }
    function ds(F, $, ie, ue, Ee) {
        $.isScene !== !0 && ($ = Ye),
        ot.resetTextureUnits();
        let He = $.fog
          , Re = ue.isMeshStandardMaterial ? $.environment : null
          , Ze = K === null ? P.outputEncoding : K.isXRRenderTarget === !0 ? K.texture.encoding : ya
          , ye = (ue.isMeshStandardMaterial ? on : xt).get(ue.envMap || Re)
          , et = ue.vertexColors === !0 && !!ie.attributes.color && ie.attributes.color.itemSize === 4
          , We = !!ue.normalMap && !!ie.attributes.tangent
          , ze = !!ie.morphAttributes.position
          , Rt = !!ie.morphAttributes.normal
          , wt = !!ie.morphAttributes.color
          , fn = ue.toneMapped ? P.toneMapping : _a
          , Mn = ie.morphAttributes.position || ie.morphAttributes.normal || ie.morphAttributes.color
          , Nn = Mn !== void 0 ? Mn.length : 0
          , jt = ut.get(ue)
          , qn = C.state.lights;
        if (Be === !0 && (tt === !0 || F !== W)) {
            let Zi = F === W && ue.id === X;
            he.setState(ue, F, Zi)
        }
        let On = !1;
        ue.version === jt.__version ? (jt.needsLights && jt.lightsStateVersion !== qn.state.version || jt.outputEncoding !== Ze || Ee.isInstancedMesh && jt.instancing === !1 || !Ee.isInstancedMesh && jt.instancing === !0 || Ee.isSkinnedMesh && jt.skinning === !1 || !Ee.isSkinnedMesh && jt.skinning === !0 || jt.envMap !== ye || ue.fog && jt.fog !== He || jt.numClippingPlanes !== void 0 && (jt.numClippingPlanes !== he.numPlanes || jt.numIntersection !== he.numIntersection) || jt.vertexAlphas !== et || jt.vertexTangents !== We || jt.morphTargets !== ze || jt.morphNormals !== Rt || jt.morphColors !== wt || jt.toneMapping !== fn || Dn.isWebGL2 === !0 && jt.morphTargetsCount !== Nn) && (On = !0) : (On = !0,
        jt.__version = ue.version);
        let ar = jt.currentProgram;
        On === !0 && (ar = Gr(ue, $, Ee));
        let pr = !1
          , ht = !1
          , mr = !1
          , jn = ar.getUniforms()
          , vr = jt.uniforms;
        if (Bt.useProgram(ar.program) && (pr = !0,
        ht = !0,
        mr = !0),
        ue.id !== X && (X = ue.id,
        ht = !0),
        pr || W !== F) {
            if (jn.setValue(gt, "projectionMatrix", F.projectionMatrix),
            Dn.logarithmicDepthBuffer && jn.setValue(gt, "logDepthBufFC", 2 / (Math.log(F.far + 1) / Math.LN2)),
            W !== F && (W = F,
            ht = !0,
            mr = !0),
            ue.isShaderMaterial || ue.isMeshPhongMaterial || ue.isMeshToonMaterial || ue.isMeshStandardMaterial || ue.envMap) {
                let Zi = jn.map.cameraPosition;
                Zi !== void 0 && Zi.setValue(gt, Gt.setFromMatrixPosition(F.matrixWorld))
            }
            (ue.isMeshPhongMaterial || ue.isMeshToonMaterial || ue.isMeshLambertMaterial || ue.isMeshBasicMaterial || ue.isMeshStandardMaterial || ue.isShaderMaterial) && jn.setValue(gt, "isOrthographic", F.isOrthographicCamera === !0),
            (ue.isMeshPhongMaterial || ue.isMeshToonMaterial || ue.isMeshLambertMaterial || ue.isMeshBasicMaterial || ue.isMeshStandardMaterial || ue.isShaderMaterial || ue.isShadowMaterial || Ee.isSkinnedMesh) && jn.setValue(gt, "viewMatrix", F.matrixWorldInverse)
        }
        if (Ee.isSkinnedMesh) {
            jn.setOptional(gt, Ee, "bindMatrix"),
            jn.setOptional(gt, Ee, "bindMatrixInverse");
            let Zi = Ee.skeleton;
            Zi && (Dn.floatVertexTextures ? (Zi.boneTexture === null && Zi.computeBoneTexture(),
            jn.setValue(gt, "boneTexture", Zi.boneTexture, ot),
            jn.setValue(gt, "boneTextureSize", Zi.boneTextureSize)) : jn.setOptional(gt, Zi, "boneMatrices"))
        }
        let ao = ie.morphAttributes;
        return (ao.position !== void 0 || ao.normal !== void 0 || ao.color !== void 0 && Dn.isWebGL2 === !0) && St.update(Ee, ie, ue, ar),
        (ht || jt.receiveShadow !== Ee.receiveShadow) && (jt.receiveShadow = Ee.receiveShadow,
        jn.setValue(gt, "receiveShadow", Ee.receiveShadow)),
        ht && (jn.setValue(gt, "toneMappingExposure", P.toneMappingExposure),
        jt.needsLights && Te(vr, mr),
        He && ue.fog && zn.refreshFogUniforms(vr, He),
        zn.refreshMaterialUniforms(vr, ue, j, ee, Ke),
        yc.upload(gt, jt.uniformsList, vr, ot)),
        ue.isShaderMaterial && ue.uniformsNeedUpdate === !0 && (yc.upload(gt, jt.uniformsList, vr, ot),
        ue.uniformsNeedUpdate = !1),
        ue.isSpriteMaterial && jn.setValue(gt, "center", Ee.center),
        jn.setValue(gt, "modelViewMatrix", Ee.modelViewMatrix),
        jn.setValue(gt, "normalMatrix", Ee.normalMatrix),
        jn.setValue(gt, "modelMatrix", Ee.matrixWorld),
        ar
    }
    function Te(F, $) {
        F.ambientLightColor.needsUpdate = $,
        F.lightProbe.needsUpdate = $,
        F.directionalLights.needsUpdate = $,
        F.directionalLightShadows.needsUpdate = $,
        F.pointLights.needsUpdate = $,
        F.pointLightShadows.needsUpdate = $,
        F.spotLights.needsUpdate = $,
        F.spotLightShadows.needsUpdate = $,
        F.rectAreaLights.needsUpdate = $,
        F.hemisphereLights.needsUpdate = $
    }
    function Y(F) {
        return F.isMeshLambertMaterial || F.isMeshToonMaterial || F.isMeshPhongMaterial || F.isMeshStandardMaterial || F.isShadowMaterial || F.isShaderMaterial && F.lights === !0
    }
    this.getActiveCubeFace = function() {
        return U
    }
    ,
    this.getActiveMipmapLevel = function() {
        return Z
    }
    ,
    this.getRenderTarget = function() {
        return K
    }
    ,
    this.setRenderTargetTextures = function(F, $, ie) {
        ut.get(F.texture).__webglTexture = $,
        ut.get(F.depthTexture).__webglTexture = ie;
        let ue = ut.get(F);
        ue.__hasExternalTextures = !0,
        ue.__hasExternalTextures && (ue.__autoAllocateDepthBuffer = ie === void 0,
        ue.__autoAllocateDepthBuffer || xn.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),
        ue.__useRenderToTexture = !1))
    }
    ,
    this.setRenderTargetFramebuffer = function(F, $) {
        let ie = ut.get(F);
        ie.__webglFramebuffer = $,
        ie.__useDefaultFramebuffer = $ === void 0
    }
    ,
    this.setRenderTarget = function(F, $=0, ie=0) {
        K = F,
        U = $,
        Z = ie;
        let ue = !0;
        if (F) {
            let ye = ut.get(F);
            ye.__useDefaultFramebuffer !== void 0 ? (Bt.bindFramebuffer(36160, null),
            ue = !1) : ye.__webglFramebuffer === void 0 ? ot.setupRenderTarget(F) : ye.__hasExternalTextures && ot.rebindTextures(F, ut.get(F.texture).__webglTexture, ut.get(F.depthTexture).__webglTexture)
        }
        let Ee = null
          , He = !1
          , Re = !1;
        if (F) {
            let ye = F.texture;
            (ye.isData3DTexture || ye.isDataArrayTexture) && (Re = !0);
            let et = ut.get(F).__webglFramebuffer;
            F.isWebGLCubeRenderTarget ? (Ee = et[$],
            He = !0) : Dn.isWebGL2 && F.samples > 0 && ot.useMultisampledRTT(F) === !1 ? Ee = ut.get(F).__webglMultisampledFramebuffer : Ee = et,
            fe.copy(F.viewport),
            ce.copy(F.scissor),
            _e = F.scissorTest
        } else
            fe.copy(te).multiplyScalar(j).floor(),
            ce.copy(ae).multiplyScalar(j).floor(),
            _e = se;
        if (Bt.bindFramebuffer(36160, Ee) && Dn.drawBuffers && ue && Bt.drawBuffers(F, Ee),
        Bt.viewport(fe),
        Bt.scissor(ce),
        Bt.setScissorTest(_e),
        He) {
            let ye = ut.get(F.texture);
            gt.framebufferTexture2D(36160, 36064, 34069 + $, ye.__webglTexture, ie)
        } else if (Re) {
            let ye = ut.get(F.texture)
              , et = $ || 0;
            gt.framebufferTextureLayer(36160, 36064, ye.__webglTexture, ie || 0, et)
        }
        X = -1
    }
    ,
    this.readRenderTargetPixels = function(F, $, ie, ue, Ee, He, Re) {
        if (!(F && F.isWebGLRenderTarget)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
            return
        }
        let Ze = ut.get(F).__webglFramebuffer;
        if (F.isWebGLCubeRenderTarget && Re !== void 0 && (Ze = Ze[Re]),
        Ze) {
            Bt.bindFramebuffer(36160, Ze);
            try {
                let ye = F.texture
                  , et = ye.format
                  , We = ye.type;
                if (et !== is && Ie.convert(et) !== gt.getParameter(35739)) {
                    console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                    return
                }
                let ze = We === Gu && (xn.has("EXT_color_buffer_half_float") || Dn.isWebGL2 && xn.has("EXT_color_buffer_float"));
                if (We !== ic && Ie.convert(We) !== gt.getParameter(35738) && !(We === rc && (Dn.isWebGL2 || xn.has("OES_texture_float") || xn.has("WEBGL_color_buffer_float"))) && !ze) {
                    console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                    return
                }
                $ >= 0 && $ <= F.width - ue && ie >= 0 && ie <= F.height - Ee && gt.readPixels($, ie, ue, Ee, Ie.convert(et), Ie.convert(We), He)
            } finally {
                let ye = K !== null ? ut.get(K).__webglFramebuffer : null;
                Bt.bindFramebuffer(36160, ye)
            }
        }
    }
    ,
    this.copyFramebufferToTexture = function(F, $, ie=0) {
        if ($.isFramebufferTexture !== !0) {
            console.error("THREE.WebGLRenderer: copyFramebufferToTexture() can only be used with FramebufferTexture.");
            return
        }
        let ue = Math.pow(2, -ie)
          , Ee = Math.floor($.image.width * ue)
          , He = Math.floor($.image.height * ue);
        ot.setTexture2D($, 0),
        gt.copyTexSubImage2D(3553, ie, 0, 0, F.x, F.y, Ee, He),
        Bt.unbindTexture()
    }
    ,
    this.copyTextureToTexture = function(F, $, ie, ue=0) {
        let Ee = $.image.width
          , He = $.image.height
          , Re = Ie.convert(ie.format)
          , Ze = Ie.convert(ie.type);
        ot.setTexture2D(ie, 0),
        gt.pixelStorei(37440, ie.flipY),
        gt.pixelStorei(37441, ie.premultiplyAlpha),
        gt.pixelStorei(3317, ie.unpackAlignment),
        $.isDataTexture ? gt.texSubImage2D(3553, ue, F.x, F.y, Ee, He, Re, Ze, $.image.data) : $.isCompressedTexture ? gt.compressedTexSubImage2D(3553, ue, F.x, F.y, $.mipmaps[0].width, $.mipmaps[0].height, Re, $.mipmaps[0].data) : gt.texSubImage2D(3553, ue, F.x, F.y, Re, Ze, $.image),
        ue === 0 && ie.generateMipmaps && gt.generateMipmap(3553),
        Bt.unbindTexture()
    }
    ,
    this.copyTextureToTexture3D = function(F, $, ie, ue, Ee=0) {
        if (P.isWebGL1Renderer) {
            console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
            return
        }
        let He = F.max.x - F.min.x + 1, Re = F.max.y - F.min.y + 1, Ze = F.max.z - F.min.z + 1, ye = Ie.convert(ue.format), et = Ie.convert(ue.type), We;
        if (ue.isData3DTexture)
            ot.setTexture3D(ue, 0),
            We = 32879;
        else if (ue.isDataArrayTexture)
            ot.setTexture2DArray(ue, 0),
            We = 35866;
        else {
            console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
            return
        }
        gt.pixelStorei(37440, ue.flipY),
        gt.pixelStorei(37441, ue.premultiplyAlpha),
        gt.pixelStorei(3317, ue.unpackAlignment);
        let ze = gt.getParameter(3314)
          , Rt = gt.getParameter(32878)
          , wt = gt.getParameter(3316)
          , fn = gt.getParameter(3315)
          , Mn = gt.getParameter(32877)
          , Nn = ie.isCompressedTexture ? ie.mipmaps[0] : ie.image;
        gt.pixelStorei(3314, Nn.width),
        gt.pixelStorei(32878, Nn.height),
        gt.pixelStorei(3316, F.min.x),
        gt.pixelStorei(3315, F.min.y),
        gt.pixelStorei(32877, F.min.z),
        ie.isDataTexture || ie.isData3DTexture ? gt.texSubImage3D(We, Ee, $.x, $.y, $.z, He, Re, Ze, ye, et, Nn.data) : ie.isCompressedTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),
        gt.compressedTexSubImage3D(We, Ee, $.x, $.y, $.z, He, Re, Ze, ye, Nn.data)) : gt.texSubImage3D(We, Ee, $.x, $.y, $.z, He, Re, Ze, ye, et, Nn),
        gt.pixelStorei(3314, ze),
        gt.pixelStorei(32878, Rt),
        gt.pixelStorei(3316, wt),
        gt.pixelStorei(3315, fn),
        gt.pixelStorei(32877, Mn),
        Ee === 0 && ue.generateMipmaps && gt.generateMipmap(We),
        Bt.unbindTexture()
    }
    ,
    this.initTexture = function(F) {
        ot.setTexture2D(F, 0),
        Bt.unbindTexture()
    }
    ,
    this.resetState = function() {
        U = 0,
        Z = 0,
        K = null,
        Bt.reset(),
        Ct.reset()
    }
    ,
    typeof __THREE_DEVTOOLS__ != "undefined" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
        detail: this
    }))
}
zi.prototype.isWebGLRenderer = !0;
var xb = class extends zi {
}
;
xb.prototype.isWebGL1Renderer = !0;
var Cm = class {
    constructor(e, t=25e-5) {
        this.name = "",
        this.color = new In(e),
        this.density = t
    }
    clone() {
        return new Cm(this.color,this.density)
    }
    toJSON() {
        return {
            type: "FogExp2",
            color: this.color.getHex(),
            density: this.density
        }
    }
}
;
Cm.prototype.isFogExp2 = !0;
var Dm = class {
    constructor(e, t=1, o=1e3) {
        this.name = "",
        this.color = new In(e),
        this.near = t,
        this.far = o
    }
    clone() {
        return new Dm(this.color,this.near,this.far)
    }
    toJSON() {
        return {
            type: "Fog",
            color: this.color.getHex(),
            near: this.near,
            far: this.far
        }
    }
}
;
Dm.prototype.isFog = !0;
var $d = class extends Ai {
    constructor() {
        super();
        this.type = "Scene",
        this.background = null,
        this.environment = null,
        this.fog = null,
        this.overrideMaterial = null,
        this.autoUpdate = !0,
        typeof __THREE_DEVTOOLS__ != "undefined" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
            detail: this
        }))
    }
    copy(e, t) {
        return super.copy(e, t),
        e.background !== null && (this.background = e.background.clone()),
        e.environment !== null && (this.environment = e.environment.clone()),
        e.fog !== null && (this.fog = e.fog.clone()),
        e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()),
        this.autoUpdate = e.autoUpdate,
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this
    }
    toJSON(e) {
        let t = super.toJSON(e);
        return this.fog !== null && (t.object.fog = this.fog.toJSON()),
        t
    }
}
;
$d.prototype.isScene = !0;
var th = class {
    constructor(e, t) {
        this.array = e,
        this.stride = t,
        this.count = e !== void 0 ? e.length / t : 0,
        this.usage = Cd,
        this.updateRange = {
            offset: 0,
            count: -1
        },
        this.version = 0,
        this.uuid = Uo()
    }
    onUploadCallback() {}
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    setUsage(e) {
        return this.usage = e,
        this
    }
    copy(e) {
        return this.array = new e.array.constructor(e.array),
        this.count = e.count,
        this.stride = e.stride,
        this.usage = e.usage,
        this
    }
    copyAt(e, t, o) {
        e *= this.stride,
        o *= t.stride;
        for (let c = 0, d = this.stride; c < d; c++)
            this.array[e + c] = t.array[o + c];
        return this
    }
    set(e, t=0) {
        return this.array.set(e, t),
        this
    }
    clone(e) {
        e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
        this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Uo()),
        e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
        let t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid])
          , o = new this.constructor(t,this.stride);
        return o.setUsage(this.usage),
        o
    }
    onUpload(e) {
        return this.onUploadCallback = e,
        this
    }
    toJSON(e) {
        return e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
        this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Uo()),
        e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))),
        {
            uuid: this.uuid,
            buffer: this.array.buffer._uuid,
            type: this.array.constructor.name,
            stride: this.stride
        }
    }
}
;
th.prototype.isInterleavedBuffer = !0;
var Ls = new Oe
  , nh = class {
    constructor(e, t, o, c=!1) {
        this.name = "",
        this.data = e,
        this.itemSize = t,
        this.offset = o,
        this.normalized = c === !0
    }
    get count() {
        return this.data.count
    }
    get array() {
        return this.data.array
    }
    set needsUpdate(e) {
        this.data.needsUpdate = e
    }
    applyMatrix4(e) {
        for (let t = 0, o = this.data.count; t < o; t++)
            Ls.fromBufferAttribute(this, t),
            Ls.applyMatrix4(e),
            this.setXYZ(t, Ls.x, Ls.y, Ls.z);
        return this
    }
    applyNormalMatrix(e) {
        for (let t = 0, o = this.count; t < o; t++)
            Ls.fromBufferAttribute(this, t),
            Ls.applyNormalMatrix(e),
            this.setXYZ(t, Ls.x, Ls.y, Ls.z);
        return this
    }
    transformDirection(e) {
        for (let t = 0, o = this.count; t < o; t++)
            Ls.fromBufferAttribute(this, t),
            Ls.transformDirection(e),
            this.setXYZ(t, Ls.x, Ls.y, Ls.z);
        return this
    }
    setX(e, t) {
        return this.data.array[e * this.data.stride + this.offset] = t,
        this
    }
    setY(e, t) {
        return this.data.array[e * this.data.stride + this.offset + 1] = t,
        this
    }
    setZ(e, t) {
        return this.data.array[e * this.data.stride + this.offset + 2] = t,
        this
    }
    setW(e, t) {
        return this.data.array[e * this.data.stride + this.offset + 3] = t,
        this
    }
    getX(e) {
        return this.data.array[e * this.data.stride + this.offset]
    }
    getY(e) {
        return this.data.array[e * this.data.stride + this.offset + 1]
    }
    getZ(e) {
        return this.data.array[e * this.data.stride + this.offset + 2]
    }
    getW(e) {
        return this.data.array[e * this.data.stride + this.offset + 3]
    }
    setXY(e, t, o) {
        return e = e * this.data.stride + this.offset,
        this.data.array[e + 0] = t,
        this.data.array[e + 1] = o,
        this
    }
    setXYZ(e, t, o, c) {
        return e = e * this.data.stride + this.offset,
        this.data.array[e + 0] = t,
        this.data.array[e + 1] = o,
        this.data.array[e + 2] = c,
        this
    }
    setXYZW(e, t, o, c, d) {
        return e = e * this.data.stride + this.offset,
        this.data.array[e + 0] = t,
        this.data.array[e + 1] = o,
        this.data.array[e + 2] = c,
        this.data.array[e + 3] = d,
        this
    }
    clone(e) {
        if (e === void 0) {
            console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
            let t = [];
            for (let o = 0; o < this.count; o++) {
                let c = o * this.data.stride + this.offset;
                for (let d = 0; d < this.itemSize; d++)
                    t.push(this.data.array[c + d])
            }
            return new or(new this.array.constructor(t),this.itemSize,this.normalized)
        } else
            return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
            e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
            new nh(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)
    }
    toJSON(e) {
        if (e === void 0) {
            console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
            let t = [];
            for (let o = 0; o < this.count; o++) {
                let c = o * this.data.stride + this.offset;
                for (let d = 0; d < this.itemSize; d++)
                    t.push(this.data.array[c + d])
            }
            return {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: t,
                normalized: this.normalized
            }
        } else
            return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
            e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
            {
                isInterleavedBufferAttribute: !0,
                itemSize: this.itemSize,
                data: this.data.uuid,
                offset: this.offset,
                normalized: this.normalized
            }
    }
}
;
nh.prototype.isInterleavedBufferAttribute = !0;
var Lm = class extends wr {
    constructor(e) {
        super();
        this.type = "SpriteMaterial",
        this.color = new In(16777215),
        this.map = null,
        this.alphaMap = null,
        this.rotation = 0,
        this.sizeAttenuation = !0,
        this.transparent = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.rotation = e.rotation,
        this.sizeAttenuation = e.sizeAttenuation,
        this
    }
}
;
Lm.prototype.isSpriteMaterial = !0;
var Qd, Rm = new Oe, ef = new Oe, tf = new Oe, nf = new zt, Pm = new zt, sI = new Fn, f0 = new Oe, km = new Oe, p0 = new Oe, oI = new zt, vb = new zt, aI = new zt, bb = class extends Ai {
    constructor(e) {
        super();
        if (this.type = "Sprite",
        Qd === void 0) {
            Qd = new Vi;
            let t = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1])
              , o = new th(t,5);
            Qd.setIndex([0, 1, 2, 0, 2, 3]),
            Qd.setAttribute("position", new nh(o,3,0,!1)),
            Qd.setAttribute("uv", new nh(o,2,3,!1))
        }
        this.geometry = Qd,
        this.material = e !== void 0 ? e : new Lm,
        this.center = new zt(.5,.5)
    }
    raycast(e, t) {
        e.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),
        ef.setFromMatrixScale(this.matrixWorld),
        sI.copy(e.camera.matrixWorld),
        this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld),
        tf.setFromMatrixPosition(this.modelViewMatrix),
        e.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 && ef.multiplyScalar(-tf.z);
        let o = this.material.rotation, c, d;
        o !== 0 && (d = Math.cos(o),
        c = Math.sin(o));
        let p = this.center;
        m0(f0.set(-.5, -.5, 0), tf, p, ef, c, d),
        m0(km.set(.5, -.5, 0), tf, p, ef, c, d),
        m0(p0.set(.5, .5, 0), tf, p, ef, c, d),
        oI.set(0, 0),
        vb.set(1, 0),
        aI.set(1, 1);
        let i = e.ray.intersectTriangle(f0, km, p0, !1, Rm);
        if (i === null && (m0(km.set(-.5, .5, 0), tf, p, ef, c, d),
        vb.set(0, 1),
        i = e.ray.intersectTriangle(f0, p0, km, !1, Rm),
        i === null))
            return;
        let v = e.ray.origin.distanceTo(Rm);
        v < e.near || v > e.far || t.push({
            distance: v,
            point: Rm.clone(),
            uv: yr.getUV(Rm, f0, km, p0, oI, vb, aI, new zt),
            face: null,
            object: this
        })
    }
    copy(e) {
        return super.copy(e),
        e.center !== void 0 && this.center.copy(e.center),
        this.material = e.material,
        this
    }
}
;
bb.prototype.isSprite = !0;
function m0(r, e, t, o, c, d) {
    nf.subVectors(r, t).addScalar(.5).multiply(o),
    c !== void 0 ? (Pm.x = d * nf.x - c * nf.y,
    Pm.y = c * nf.x + d * nf.y) : Pm.copy(nf),
    r.copy(e),
    r.x += Pm.x,
    r.y += Pm.y,
    r.applyMatrix4(sI)
}
var lI = new Oe
  , cI = new Ui
  , uI = new Ui
  , c5 = new Oe
  , hI = new Fn
  , g0 = class extends Ir {
    constructor(e, t) {
        super(e, t);
        this.type = "SkinnedMesh",
        this.bindMode = "attached",
        this.bindMatrix = new Fn,
        this.bindMatrixInverse = new Fn
    }
    copy(e) {
        return super.copy(e),
        this.bindMode = e.bindMode,
        this.bindMatrix.copy(e.bindMatrix),
        this.bindMatrixInverse.copy(e.bindMatrixInverse),
        this.skeleton = e.skeleton,
        this
    }
    bind(e, t) {
        this.skeleton = e,
        t === void 0 && (this.updateMatrixWorld(!0),
        this.skeleton.calculateInverses(),
        t = this.matrixWorld),
        this.bindMatrix.copy(t),
        this.bindMatrixInverse.copy(t).invert()
    }
    pose() {
        this.skeleton.pose()
    }
    normalizeSkinWeights() {
        let e = new Ui
          , t = this.geometry.attributes.skinWeight;
        for (let o = 0, c = t.count; o < c; o++) {
            e.fromBufferAttribute(t, o);
            let d = 1 / e.manhattanLength();
            d !== Infinity ? e.multiplyScalar(d) : e.set(1, 0, 0, 0),
            t.setXYZW(o, e.x, e.y, e.z, e.w)
        }
    }
    updateMatrixWorld(e) {
        super.updateMatrixWorld(e),
        this.bindMode === "attached" ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === "detached" ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
    }
    boneTransform(e, t) {
        let o = this.skeleton
          , c = this.geometry;
        cI.fromBufferAttribute(c.attributes.skinIndex, e),
        uI.fromBufferAttribute(c.attributes.skinWeight, e),
        lI.copy(t).applyMatrix4(this.bindMatrix),
        t.set(0, 0, 0);
        for (let d = 0; d < 4; d++) {
            let p = uI.getComponent(d);
            if (p !== 0) {
                let i = cI.getComponent(d);
                hI.multiplyMatrices(o.bones[i].matrixWorld, o.boneInverses[i]),
                t.addScaledVector(c5.copy(lI).applyMatrix4(hI), p)
            }
        }
        return t.applyMatrix4(this.bindMatrixInverse)
    }
}
;
g0.prototype.isSkinnedMesh = !0;
var wb = class extends Ai {
    constructor() {
        super();
        this.type = "Bone"
    }
}
;
wb.prototype.isBone = !0;
var al = class extends Ar {
    constructor(e=null, t=1, o=1, c, d, p, i, v, x=Di, E=Di, A, C) {
        super(null, p, i, v, x, E, c, d, A, C);
        this.image = {
            data: e,
            width: t,
            height: o
        },
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1
    }
}
;
al.prototype.isDataTexture = !0;
var zm = class extends or {
    constructor(e, t, o, c=1) {
        typeof o == "number" && (c = o,
        o = !1,
        console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")),
        super(e, t, o),
        this.meshPerAttribute = c
    }
    copy(e) {
        return super.copy(e),
        this.meshPerAttribute = e.meshPerAttribute,
        this
    }
    toJSON() {
        let e = super.toJSON();
        return e.meshPerAttribute = this.meshPerAttribute,
        e.isInstancedBufferAttribute = !0,
        e
    }
}
;
zm.prototype.isInstancedBufferAttribute = !0;
var dI = new Fn
  , fI = new Fn
  , _0 = []
  , Om = new Ir
  , Tb = class extends Ir {
    constructor(e, t, o) {
        super(e, t);
        this.instanceMatrix = new zm(new Float32Array(o * 16),16),
        this.instanceColor = null,
        this.count = o,
        this.frustumCulled = !1
    }
    copy(e) {
        return super.copy(e),
        this.instanceMatrix.copy(e.instanceMatrix),
        e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()),
        this.count = e.count,
        this
    }
    getColorAt(e, t) {
        t.fromArray(this.instanceColor.array, e * 3)
    }
    getMatrixAt(e, t) {
        t.fromArray(this.instanceMatrix.array, e * 16)
    }
    raycast(e, t) {
        let o = this.matrixWorld
          , c = this.count;
        if (Om.geometry = this.geometry,
        Om.material = this.material,
        Om.material !== void 0)
            for (let d = 0; d < c; d++) {
                this.getMatrixAt(d, dI),
                fI.multiplyMatrices(o, dI),
                Om.matrixWorld = fI,
                Om.raycast(e, _0);
                for (let p = 0, i = _0.length; p < i; p++) {
                    let v = _0[p];
                    v.instanceId = d,
                    v.object = this,
                    t.push(v)
                }
                _0.length = 0
            }
    }
    setColorAt(e, t) {
        this.instanceColor === null && (this.instanceColor = new zm(new Float32Array(this.instanceMatrix.count * 3),3)),
        t.toArray(this.instanceColor.array, e * 3)
    }
    setMatrixAt(e, t) {
        t.toArray(this.instanceMatrix.array, e * 16)
    }
    updateMorphTargets() {}
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
;
Tb.prototype.isInstancedMesh = !0;
var ll = class extends wr {
    constructor(e) {
        super();
        this.type = "LineBasicMaterial",
        this.color = new In(16777215),
        this.linewidth = 1,
        this.linecap = "round",
        this.linejoin = "round",
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.linewidth = e.linewidth,
        this.linecap = e.linecap,
        this.linejoin = e.linejoin,
        this
    }
}
;
ll.prototype.isLineBasicMaterial = !0;
var pI = new Oe
  , mI = new Oe
  , gI = new Fn
  , Eb = new dc
  , y0 = new uc
  , Nm = class extends Ai {
    constructor(e=new Vi, t=new ll) {
        super();
        this.type = "Line",
        this.geometry = e,
        this.material = t,
        this.updateMorphTargets()
    }
    copy(e) {
        return super.copy(e),
        this.material = e.material,
        this.geometry = e.geometry,
        this
    }
    computeLineDistances() {
        let e = this.geometry;
        if (e.isBufferGeometry)
            if (e.index === null) {
                let t = e.attributes.position
                  , o = [0];
                for (let c = 1, d = t.count; c < d; c++)
                    pI.fromBufferAttribute(t, c - 1),
                    mI.fromBufferAttribute(t, c),
                    o[c] = o[c - 1],
                    o[c] += pI.distanceTo(mI);
                e.setAttribute("lineDistance", new xr(o,1))
            } else
                console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        else
            e.isGeometry && console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
        return this
    }
    raycast(e, t) {
        let o = this.geometry
          , c = this.matrixWorld
          , d = e.params.Line.threshold
          , p = o.drawRange;
        if (o.boundingSphere === null && o.computeBoundingSphere(),
        y0.copy(o.boundingSphere),
        y0.applyMatrix4(c),
        y0.radius += d,
        e.ray.intersectsSphere(y0) === !1)
            return;
        gI.copy(c).invert(),
        Eb.copy(e.ray).applyMatrix4(gI);
        let i = d / ((this.scale.x + this.scale.y + this.scale.z) / 3)
          , v = i * i
          , x = new Oe
          , E = new Oe
          , A = new Oe
          , C = new Oe
          , I = this.isLineSegments ? 2 : 1;
        if (o.isBufferGeometry) {
            let D = o.index
              , k = o.attributes.position;
            if (D !== null) {
                let U = Math.max(0, p.start)
                  , Z = Math.min(D.count, p.start + p.count);
                for (let K = U, X = Z - 1; K < X; K += I) {
                    let W = D.getX(K)
                      , fe = D.getX(K + 1);
                    if (x.fromBufferAttribute(k, W),
                    E.fromBufferAttribute(k, fe),
                    Eb.distanceSqToSegment(x, E, C, A) > v)
                        continue;
                    C.applyMatrix4(this.matrixWorld);
                    let _e = e.ray.origin.distanceTo(C);
                    _e < e.near || _e > e.far || t.push({
                        distance: _e,
                        point: A.clone().applyMatrix4(this.matrixWorld),
                        index: K,
                        face: null,
                        faceIndex: null,
                        object: this
                    })
                }
            } else {
                let U = Math.max(0, p.start)
                  , Z = Math.min(k.count, p.start + p.count);
                for (let K = U, X = Z - 1; K < X; K += I) {
                    if (x.fromBufferAttribute(k, K),
                    E.fromBufferAttribute(k, K + 1),
                    Eb.distanceSqToSegment(x, E, C, A) > v)
                        continue;
                    C.applyMatrix4(this.matrixWorld);
                    let fe = e.ray.origin.distanceTo(C);
                    fe < e.near || fe > e.far || t.push({
                        distance: fe,
                        point: A.clone().applyMatrix4(this.matrixWorld),
                        index: K,
                        face: null,
                        faceIndex: null,
                        object: this
                    })
                }
            }
        } else
            o.isGeometry && console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
    }
    updateMorphTargets() {
        let e = this.geometry;
        if (e.isBufferGeometry) {
            let t = e.morphAttributes
              , o = Object.keys(t);
            if (o.length > 0) {
                let c = t[o[0]];
                if (c !== void 0) {
                    this.morphTargetInfluences = [],
                    this.morphTargetDictionary = {};
                    for (let d = 0, p = c.length; d < p; d++) {
                        let i = c[d].name || String(d);
                        this.morphTargetInfluences.push(0),
                        this.morphTargetDictionary[i] = d
                    }
                }
            }
        } else {
            let t = e.morphTargets;
            t !== void 0 && t.length > 0 && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
        }
    }
}
;
Nm.prototype.isLine = !0;
var _I = new Oe
  , yI = new Oe
  , rf = class extends Nm {
    constructor(e, t) {
        super(e, t);
        this.type = "LineSegments"
    }
    computeLineDistances() {
        let e = this.geometry;
        if (e.isBufferGeometry)
            if (e.index === null) {
                let t = e.attributes.position
                  , o = [];
                for (let c = 0, d = t.count; c < d; c += 2)
                    _I.fromBufferAttribute(t, c),
                    yI.fromBufferAttribute(t, c + 1),
                    o[c] = c === 0 ? 0 : o[c - 1],
                    o[c + 1] = o[c] + _I.distanceTo(yI);
                e.setAttribute("lineDistance", new xr(o,1))
            } else
                console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        else
            e.isGeometry && console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
        return this
    }
}
;
rf.prototype.isLineSegments = !0;
var Sb = class extends Nm {
    constructor(e, t) {
        super(e, t);
        this.type = "LineLoop"
    }
}
;
Sb.prototype.isLineLoop = !0;
var Fm = class extends wr {
    constructor(e) {
        super();
        this.type = "PointsMaterial",
        this.color = new In(16777215),
        this.map = null,
        this.alphaMap = null,
        this.size = 1,
        this.sizeAttenuation = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.size = e.size,
        this.sizeAttenuation = e.sizeAttenuation,
        this
    }
}
;
Fm.prototype.isPointsMaterial = !0;
var xI = new Fn
  , Ab = new dc
  , x0 = new uc
  , v0 = new Oe
  , Mb = class extends Ai {
    constructor(e=new Vi, t=new Fm) {
        super();
        this.type = "Points",
        this.geometry = e,
        this.material = t,
        this.updateMorphTargets()
    }
    copy(e) {
        return super.copy(e),
        this.material = e.material,
        this.geometry = e.geometry,
        this
    }
    raycast(e, t) {
        let o = this.geometry
          , c = this.matrixWorld
          , d = e.params.Points.threshold
          , p = o.drawRange;
        if (o.boundingSphere === null && o.computeBoundingSphere(),
        x0.copy(o.boundingSphere),
        x0.applyMatrix4(c),
        x0.radius += d,
        e.ray.intersectsSphere(x0) === !1)
            return;
        xI.copy(c).invert(),
        Ab.copy(e.ray).applyMatrix4(xI);
        let i = d / ((this.scale.x + this.scale.y + this.scale.z) / 3)
          , v = i * i;
        if (o.isBufferGeometry) {
            let x = o.index
              , A = o.attributes.position;
            if (x !== null) {
                let C = Math.max(0, p.start)
                  , I = Math.min(x.count, p.start + p.count);
                for (let D = C, P = I; D < P; D++) {
                    let k = x.getX(D);
                    v0.fromBufferAttribute(A, k),
                    vI(v0, k, v, c, e, t, this)
                }
            } else {
                let C = Math.max(0, p.start)
                  , I = Math.min(A.count, p.start + p.count);
                for (let D = C, P = I; D < P; D++)
                    v0.fromBufferAttribute(A, D),
                    vI(v0, D, v, c, e, t, this)
            }
        } else
            console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
    }
    updateMorphTargets() {
        let e = this.geometry;
        if (e.isBufferGeometry) {
            let t = e.morphAttributes
              , o = Object.keys(t);
            if (o.length > 0) {
                let c = t[o[0]];
                if (c !== void 0) {
                    this.morphTargetInfluences = [],
                    this.morphTargetDictionary = {};
                    for (let d = 0, p = c.length; d < p; d++) {
                        let i = c[d].name || String(d);
                        this.morphTargetInfluences.push(0),
                        this.morphTargetDictionary[i] = d
                    }
                }
            }
        } else {
            let t = e.morphTargets;
            t !== void 0 && t.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
        }
    }
}
;
Mb.prototype.isPoints = !0;
function vI(r, e, t, o, c, d, p) {
    let i = Ab.distanceSqToPoint(r);
    if (i < t) {
        let v = new Oe;
        Ab.closestPointToPoint(r, v),
        v.applyMatrix4(o);
        let x = c.ray.origin.distanceTo(v);
        if (x < c.near || x > c.far)
            return;
        d.push({
            distance: x,
            distanceToRay: Math.sqrt(i),
            point: v,
            index: e,
            face: null,
            object: p
        })
    }
}
var Ib = class extends Ar {
    constructor(e, t, o, c, d, p, i, v, x) {
        super(e, t, o, c, d, p, i, v, x);
        this.minFilter = p !== void 0 ? p : ns,
        this.magFilter = d !== void 0 ? d : ns,
        this.generateMipmaps = !1;
        let E = this;
        function A() {
            E.needsUpdate = !0,
            e.requestVideoFrameCallback(A)
        }
        "requestVideoFrameCallback"in e && e.requestVideoFrameCallback(A)
    }
    clone() {
        return new this.constructor(this.image).copy(this)
    }
    update() {
        let e = this.image;
        "requestVideoFrameCallback"in e === !1 && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
    }
}
;
Ib.prototype.isVideoTexture = !0;
var Cb = class extends Ar {
    constructor(e, t, o) {
        super({
            width: e,
            height: t
        });
        this.format = o,
        this.magFilter = Di,
        this.minFilter = Di,
        this.generateMipmaps = !1,
        this.needsUpdate = !0
    }
}
;
Cb.prototype.isFramebufferTexture = !0;
var Db = class extends Ar {
    constructor(e, t, o, c, d, p, i, v, x, E, A, C) {
        super(null, p, i, v, x, E, c, d, A, C);
        this.image = {
            width: t,
            height: o
        },
        this.mipmaps = e,
        this.flipY = !1,
        this.generateMipmaps = !1
    }
}
;
Db.prototype.isCompressedTexture = !0;
var Lb = class extends Ar {
    constructor(e, t, o, c, d, p, i, v, x) {
        super(e, t, o, c, d, p, i, v, x);
        this.needsUpdate = !0
    }
}
;
Lb.prototype.isCanvasTexture = !0;
var qs = class {
    constructor() {
        this.type = "Curve",
        this.arcLengthDivisions = 200
    }
    getPoint() {
        return console.warn("THREE.Curve: .getPoint() not implemented."),
        null
    }
    getPointAt(e, t) {
        let o = this.getUtoTmapping(e);
        return this.getPoint(o, t)
    }
    getPoints(e=5) {
        let t = [];
        for (let o = 0; o <= e; o++)
            t.push(this.getPoint(o / e));
        return t
    }
    getSpacedPoints(e=5) {
        let t = [];
        for (let o = 0; o <= e; o++)
            t.push(this.getPointAt(o / e));
        return t
    }
    getLength() {
        let e = this.getLengths();
        return e[e.length - 1]
    }
    getLengths(e=this.arcLengthDivisions) {
        if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
            return this.cacheArcLengths;
        this.needsUpdate = !1;
        let t = [], o, c = this.getPoint(0), d = 0;
        t.push(0);
        for (let p = 1; p <= e; p++)
            o = this.getPoint(p / e),
            d += o.distanceTo(c),
            t.push(d),
            c = o;
        return this.cacheArcLengths = t,
        t
    }
    updateArcLengths() {
        this.needsUpdate = !0,
        this.getLengths()
    }
    getUtoTmapping(e, t) {
        let o = this.getLengths(), c = 0, d = o.length, p;
        t ? p = t : p = e * o[d - 1];
        let i = 0, v = d - 1, x;
        for (; i <= v; )
            if (c = Math.floor(i + (v - i) / 2),
            x = o[c] - p,
            x < 0)
                i = c + 1;
            else if (x > 0)
                v = c - 1;
            else {
                v = c;
                break
            }
        if (c = v,
        o[c] === p)
            return c / (d - 1);
        let E = o[c]
          , C = o[c + 1] - E
          , I = (p - E) / C;
        return (c + I) / (d - 1)
    }
    getTangent(e, t) {
        let o = 1e-4
          , c = e - o
          , d = e + o;
        c < 0 && (c = 0),
        d > 1 && (d = 1);
        let p = this.getPoint(c)
          , i = this.getPoint(d)
          , v = t || (p.isVector2 ? new zt : new Oe);
        return v.copy(i).sub(p).normalize(),
        v
    }
    getTangentAt(e, t) {
        let o = this.getUtoTmapping(e);
        return this.getTangent(o, t)
    }
    computeFrenetFrames(e, t) {
        let o = new Oe
          , c = []
          , d = []
          , p = []
          , i = new Oe
          , v = new Fn;
        for (let I = 0; I <= e; I++) {
            let D = I / e;
            c[I] = this.getTangentAt(D, new Oe)
        }
        d[0] = new Oe,
        p[0] = new Oe;
        let x = Number.MAX_VALUE
          , E = Math.abs(c[0].x)
          , A = Math.abs(c[0].y)
          , C = Math.abs(c[0].z);
        E <= x && (x = E,
        o.set(1, 0, 0)),
        A <= x && (x = A,
        o.set(0, 1, 0)),
        C <= x && o.set(0, 0, 1),
        i.crossVectors(c[0], o).normalize(),
        d[0].crossVectors(c[0], i),
        p[0].crossVectors(c[0], d[0]);
        for (let I = 1; I <= e; I++) {
            if (d[I] = d[I - 1].clone(),
            p[I] = p[I - 1].clone(),
            i.crossVectors(c[I - 1], c[I]),
            i.length() > Number.EPSILON) {
                i.normalize();
                let D = Math.acos(rs(c[I - 1].dot(c[I]), -1, 1));
                d[I].applyMatrix4(v.makeRotationAxis(i, D))
            }
            p[I].crossVectors(c[I], d[I])
        }
        if (t === !0) {
            let I = Math.acos(rs(d[0].dot(d[e]), -1, 1));
            I /= e,
            c[0].dot(i.crossVectors(d[0], d[e])) > 0 && (I = -I);
            for (let D = 1; D <= e; D++)
                d[D].applyMatrix4(v.makeRotationAxis(c[D], I * D)),
                p[D].crossVectors(c[D], d[D])
        }
        return {
            tangents: c,
            normals: d,
            binormals: p
        }
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.arcLengthDivisions = e.arcLengthDivisions,
        this
    }
    toJSON() {
        let e = {
            metadata: {
                version: 4.5,
                type: "Curve",
                generator: "Curve.toJSON"
            }
        };
        return e.arcLengthDivisions = this.arcLengthDivisions,
        e.type = this.type,
        e
    }
    fromJSON(e) {
        return this.arcLengthDivisions = e.arcLengthDivisions,
        this
    }
}
  , sf = class extends qs {
    constructor(e=0, t=0, o=1, c=1, d=0, p=Math.PI * 2, i=!1, v=0) {
        super();
        this.type = "EllipseCurve",
        this.aX = e,
        this.aY = t,
        this.xRadius = o,
        this.yRadius = c,
        this.aStartAngle = d,
        this.aEndAngle = p,
        this.aClockwise = i,
        this.aRotation = v
    }
    getPoint(e, t) {
        let o = t || new zt
          , c = Math.PI * 2
          , d = this.aEndAngle - this.aStartAngle
          , p = Math.abs(d) < Number.EPSILON;
        for (; d < 0; )
            d += c;
        for (; d > c; )
            d -= c;
        d < Number.EPSILON && (p ? d = 0 : d = c),
        this.aClockwise === !0 && !p && (d === c ? d = -c : d = d - c);
        let i = this.aStartAngle + e * d
          , v = this.aX + this.xRadius * Math.cos(i)
          , x = this.aY + this.yRadius * Math.sin(i);
        if (this.aRotation !== 0) {
            let E = Math.cos(this.aRotation)
              , A = Math.sin(this.aRotation)
              , C = v - this.aX
              , I = x - this.aY;
            v = C * E - I * A + this.aX,
            x = C * A + I * E + this.aY
        }
        return o.set(v, x)
    }
    copy(e) {
        return super.copy(e),
        this.aX = e.aX,
        this.aY = e.aY,
        this.xRadius = e.xRadius,
        this.yRadius = e.yRadius,
        this.aStartAngle = e.aStartAngle,
        this.aEndAngle = e.aEndAngle,
        this.aClockwise = e.aClockwise,
        this.aRotation = e.aRotation,
        this
    }
    toJSON() {
        let e = super.toJSON();
        return e.aX = this.aX,
        e.aY = this.aY,
        e.xRadius = this.xRadius,
        e.yRadius = this.yRadius,
        e.aStartAngle = this.aStartAngle,
        e.aEndAngle = this.aEndAngle,
        e.aClockwise = this.aClockwise,
        e.aRotation = this.aRotation,
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.aX = e.aX,
        this.aY = e.aY,
        this.xRadius = e.xRadius,
        this.yRadius = e.yRadius,
        this.aStartAngle = e.aStartAngle,
        this.aEndAngle = e.aEndAngle,
        this.aClockwise = e.aClockwise,
        this.aRotation = e.aRotation,
        this
    }
}
;
sf.prototype.isEllipseCurve = !0;
var b0 = class extends sf {
    constructor(e, t, o, c, d, p) {
        super(e, t, o, o, c, d, p);
        this.type = "ArcCurve"
    }
}
;
b0.prototype.isArcCurve = !0;
function Rb() {
    let r = 0
      , e = 0
      , t = 0
      , o = 0;
    function c(d, p, i, v) {
        r = d,
        e = i,
        t = -3 * d + 3 * p - 2 * i - v,
        o = 2 * d - 2 * p + i + v
    }
    return {
        initCatmullRom: function(d, p, i, v, x) {
            c(p, i, x * (i - d), x * (v - p))
        },
        initNonuniformCatmullRom: function(d, p, i, v, x, E, A) {
            let C = (p - d) / x - (i - d) / (x + E) + (i - p) / E
              , I = (i - p) / E - (v - p) / (E + A) + (v - i) / A;
            C *= E,
            I *= E,
            c(p, i, C, I)
        },
        calc: function(d) {
            let p = d * d
              , i = p * d;
            return r + e * d + t * p + o * i
        }
    }
}
var w0 = new Oe
  , Pb = new Rb
  , kb = new Rb
  , zb = new Rb
  , T0 = class extends qs {
    constructor(e=[], t=!1, o="centripetal", c=.5) {
        super();
        this.type = "CatmullRomCurve3",
        this.points = e,
        this.closed = t,
        this.curveType = o,
        this.tension = c
    }
    getPoint(e, t=new Oe) {
        let o = t
          , c = this.points
          , d = c.length
          , p = (d - (this.closed ? 0 : 1)) * e
          , i = Math.floor(p)
          , v = p - i;
        this.closed ? i += i > 0 ? 0 : (Math.floor(Math.abs(i) / d) + 1) * d : v === 0 && i === d - 1 && (i = d - 2,
        v = 1);
        let x, E;
        this.closed || i > 0 ? x = c[(i - 1) % d] : (w0.subVectors(c[0], c[1]).add(c[0]),
        x = w0);
        let A = c[i % d]
          , C = c[(i + 1) % d];
        if (this.closed || i + 2 < d ? E = c[(i + 2) % d] : (w0.subVectors(c[d - 1], c[d - 2]).add(c[d - 1]),
        E = w0),
        this.curveType === "centripetal" || this.curveType === "chordal") {
            let I = this.curveType === "chordal" ? .5 : .25
              , D = Math.pow(x.distanceToSquared(A), I)
              , P = Math.pow(A.distanceToSquared(C), I)
              , k = Math.pow(C.distanceToSquared(E), I);
            P < 1e-4 && (P = 1),
            D < 1e-4 && (D = P),
            k < 1e-4 && (k = P),
            Pb.initNonuniformCatmullRom(x.x, A.x, C.x, E.x, D, P, k),
            kb.initNonuniformCatmullRom(x.y, A.y, C.y, E.y, D, P, k),
            zb.initNonuniformCatmullRom(x.z, A.z, C.z, E.z, D, P, k)
        } else
            this.curveType === "catmullrom" && (Pb.initCatmullRom(x.x, A.x, C.x, E.x, this.tension),
            kb.initCatmullRom(x.y, A.y, C.y, E.y, this.tension),
            zb.initCatmullRom(x.z, A.z, C.z, E.z, this.tension));
        return o.set(Pb.calc(v), kb.calc(v), zb.calc(v)),
        o
    }
    copy(e) {
        super.copy(e),
        this.points = [];
        for (let t = 0, o = e.points.length; t < o; t++) {
            let c = e.points[t];
            this.points.push(c.clone())
        }
        return this.closed = e.closed,
        this.curveType = e.curveType,
        this.tension = e.tension,
        this
    }
    toJSON() {
        let e = super.toJSON();
        e.points = [];
        for (let t = 0, o = this.points.length; t < o; t++) {
            let c = this.points[t];
            e.points.push(c.toArray())
        }
        return e.closed = this.closed,
        e.curveType = this.curveType,
        e.tension = this.tension,
        e
    }
    fromJSON(e) {
        super.fromJSON(e),
        this.points = [];
        for (let t = 0, o = e.points.length; t < o; t++) {
            let c = e.points[t];
            this.points.push(new Oe().fromArray(c))
        }
        return this.closed = e.closed,
        this.curveType = e.curveType,
        this.tension = e.tension,
        this
    }
}
;
T0.prototype.isCatmullRomCurve3 = !0;
function bI(r, e, t, o, c) {
    let d = (o - e) * .5
      , p = (c - t) * .5
      , i = r * r
      , v = r * i;
    return (2 * t - 2 * o + d + p) * v + (-3 * t + 3 * o - 2 * d - p) * i + d * r + t
}
function u5(r, e) {
    let t = 1 - r;
    return t * t * e
}
function h5(r, e) {
    return 2 * (1 - r) * r * e
}
function d5(r, e) {
    return r * r * e
}
function Bm(r, e, t, o) {
    return u5(r, e) + h5(r, t) + d5(r, o)
}
function f5(r, e) {
    let t = 1 - r;
    return t * t * t * e
}
function p5(r, e) {
    let t = 1 - r;
    return 3 * t * t * r * e
}
function m5(r, e) {
    return 3 * (1 - r) * r * r * e
}
function g5(r, e) {
    return r * r * r * e
}
function Um(r, e, t, o, c) {
    return f5(r, e) + p5(r, t) + m5(r, o) + g5(r, c)
}
var Vm = class extends qs {
    constructor(e=new zt, t=new zt, o=new zt, c=new zt) {
        super();
        this.type = "CubicBezierCurve",
        this.v0 = e,
        this.v1 = t,
        this.v2 = o,
        this.v3 = c
    }
    getPoint(e, t=new zt) {
        let o = t
          , c = this.v0
          , d = this.v1
          , p = this.v2
          , i = this.v3;
        return o.set(Um(e, c.x, d.x, p.x, i.x), Um(e, c.y, d.y, p.y, i.y)),
        o
    }
    copy(e) {
        return super.copy(e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this.v3.copy(e.v3),
        this
    }
    toJSON() {
        let e = super.toJSON();
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e.v3 = this.v3.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this.v3.fromArray(e.v3),
        this
    }
}
;
Vm.prototype.isCubicBezierCurve = !0;
var E0 = class extends qs {
    constructor(e=new Oe, t=new Oe, o=new Oe, c=new Oe) {
        super();
        this.type = "CubicBezierCurve3",
        this.v0 = e,
        this.v1 = t,
        this.v2 = o,
        this.v3 = c
    }
    getPoint(e, t=new Oe) {
        let o = t
          , c = this.v0
          , d = this.v1
          , p = this.v2
          , i = this.v3;
        return o.set(Um(e, c.x, d.x, p.x, i.x), Um(e, c.y, d.y, p.y, i.y), Um(e, c.z, d.z, p.z, i.z)),
        o
    }
    copy(e) {
        return super.copy(e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this.v3.copy(e.v3),
        this
    }
    toJSON() {
        let e = super.toJSON();
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e.v3 = this.v3.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this.v3.fromArray(e.v3),
        this
    }
}
;
E0.prototype.isCubicBezierCurve3 = !0;
var of = class extends qs {
    constructor(e=new zt, t=new zt) {
        super();
        this.type = "LineCurve",
        this.v1 = e,
        this.v2 = t
    }
    getPoint(e, t=new zt) {
        let o = t;
        return e === 1 ? o.copy(this.v2) : (o.copy(this.v2).sub(this.v1),
        o.multiplyScalar(e).add(this.v1)),
        o
    }
    getPointAt(e, t) {
        return this.getPoint(e, t)
    }
    getTangent(e, t) {
        let o = t || new zt;
        return o.copy(this.v2).sub(this.v1).normalize(),
        o
    }
    copy(e) {
        return super.copy(e),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    toJSON() {
        let e = super.toJSON();
        return e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
}
;
of.prototype.isLineCurve = !0;
var Ob = class extends qs {
    constructor(e=new Oe, t=new Oe) {
        super();
        this.type = "LineCurve3",
        this.isLineCurve3 = !0,
        this.v1 = e,
        this.v2 = t
    }
    getPoint(e, t=new Oe) {
        let o = t;
        return e === 1 ? o.copy(this.v2) : (o.copy(this.v2).sub(this.v1),
        o.multiplyScalar(e).add(this.v1)),
        o
    }
    getPointAt(e, t) {
        return this.getPoint(e, t)
    }
    copy(e) {
        return super.copy(e),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    toJSON() {
        let e = super.toJSON();
        return e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
}
  , Gm = class extends qs {
    constructor(e=new zt, t=new zt, o=new zt) {
        super();
        this.type = "QuadraticBezierCurve",
        this.v0 = e,
        this.v1 = t,
        this.v2 = o
    }
    getPoint(e, t=new zt) {
        let o = t
          , c = this.v0
          , d = this.v1
          , p = this.v2;
        return o.set(Bm(e, c.x, d.x, p.x), Bm(e, c.y, d.y, p.y)),
        o
    }
    copy(e) {
        return super.copy(e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    toJSON() {
        let e = super.toJSON();
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
}
;
Gm.prototype.isQuadraticBezierCurve = !0;
var S0 = class extends qs {
    constructor(e=new Oe, t=new Oe, o=new Oe) {
        super();
        this.type = "QuadraticBezierCurve3",
        this.v0 = e,
        this.v1 = t,
        this.v2 = o
    }
    getPoint(e, t=new Oe) {
        let o = t
          , c = this.v0
          , d = this.v1
          , p = this.v2;
        return o.set(Bm(e, c.x, d.x, p.x), Bm(e, c.y, d.y, p.y), Bm(e, c.z, d.z, p.z)),
        o
    }
    copy(e) {
        return super.copy(e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    toJSON() {
        let e = super.toJSON();
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
}
;
S0.prototype.isQuadraticBezierCurve3 = !0;
var Hm = class extends qs {
    constructor(e=[]) {
        super();
        this.type = "SplineCurve",
        this.points = e
    }
    getPoint(e, t=new zt) {
        let o = t
          , c = this.points
          , d = (c.length - 1) * e
          , p = Math.floor(d)
          , i = d - p
          , v = c[p === 0 ? p : p - 1]
          , x = c[p]
          , E = c[p > c.length - 2 ? c.length - 1 : p + 1]
          , A = c[p > c.length - 3 ? c.length - 1 : p + 2];
        return o.set(bI(i, v.x, x.x, E.x, A.x), bI(i, v.y, x.y, E.y, A.y)),
        o
    }
    copy(e) {
        super.copy(e),
        this.points = [];
        for (let t = 0, o = e.points.length; t < o; t++) {
            let c = e.points[t];
            this.points.push(c.clone())
        }
        return this
    }
    toJSON() {
        let e = super.toJSON();
        e.points = [];
        for (let t = 0, o = this.points.length; t < o; t++) {
            let c = this.points[t];
            e.points.push(c.toArray())
        }
        return e
    }
    fromJSON(e) {
        super.fromJSON(e),
        this.points = [];
        for (let t = 0, o = e.points.length; t < o; t++) {
            let c = e.points[t];
            this.points.push(new zt().fromArray(c))
        }
        return this
    }
}
;
Hm.prototype.isSplineCurve = !0;
var wI = Object.freeze({
    __proto__: null,
    ArcCurve: b0,
    CatmullRomCurve3: T0,
    CubicBezierCurve: Vm,
    CubicBezierCurve3: E0,
    EllipseCurve: sf,
    LineCurve: of,
    LineCurve3: Ob,
    QuadraticBezierCurve: Gm,
    QuadraticBezierCurve3: S0,
    SplineCurve: Hm
})
  , Nb = class extends qs {
    constructor() {
        super();
        this.type = "CurvePath",
        this.curves = [],
        this.autoClose = !1
    }
    add(e) {
        this.curves.push(e)
    }
    closePath() {
        let e = this.curves[0].getPoint(0)
          , t = this.curves[this.curves.length - 1].getPoint(1);
        e.equals(t) || this.curves.push(new of(t,e))
    }
    getPoint(e, t) {
        let o = e * this.getLength()
          , c = this.getCurveLengths()
          , d = 0;
        for (; d < c.length; ) {
            if (c[d] >= o) {
                let p = c[d] - o
                  , i = this.curves[d]
                  , v = i.getLength()
                  , x = v === 0 ? 0 : 1 - p / v;
                return i.getPointAt(x, t)
            }
            d++
        }
        return null
    }
    getLength() {
        let e = this.getCurveLengths();
        return e[e.length - 1]
    }
    updateArcLengths() {
        this.needsUpdate = !0,
        this.cacheLengths = null,
        this.getCurveLengths()
    }
    getCurveLengths() {
        if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
            return this.cacheLengths;
        let e = []
          , t = 0;
        for (let o = 0, c = this.curves.length; o < c; o++)
            t += this.curves[o].getLength(),
            e.push(t);
        return this.cacheLengths = e,
        e
    }
    getSpacedPoints(e=40) {
        let t = [];
        for (let o = 0; o <= e; o++)
            t.push(this.getPoint(o / e));
        return this.autoClose && t.push(t[0]),
        t
    }
    getPoints(e=12) {
        let t = [], o;
        for (let c = 0, d = this.curves; c < d.length; c++) {
            let p = d[c]
              , i = p.isEllipseCurve ? e * 2 : p.isLineCurve || p.isLineCurve3 ? 1 : p.isSplineCurve ? e * p.points.length : e
              , v = p.getPoints(i);
            for (let x = 0; x < v.length; x++) {
                let E = v[x];
                o && o.equals(E) || (t.push(E),
                o = E)
            }
        }
        return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]),
        t
    }
    copy(e) {
        super.copy(e),
        this.curves = [];
        for (let t = 0, o = e.curves.length; t < o; t++) {
            let c = e.curves[t];
            this.curves.push(c.clone())
        }
        return this.autoClose = e.autoClose,
        this
    }
    toJSON() {
        let e = super.toJSON();
        e.autoClose = this.autoClose,
        e.curves = [];
        for (let t = 0, o = this.curves.length; t < o; t++) {
            let c = this.curves[t];
            e.curves.push(c.toJSON())
        }
        return e
    }
    fromJSON(e) {
        super.fromJSON(e),
        this.autoClose = e.autoClose,
        this.curves = [];
        for (let t = 0, o = e.curves.length; t < o; t++) {
            let c = e.curves[t];
            this.curves.push(new wI[c.type]().fromJSON(c))
        }
        return this
    }
}
  , Wm = class extends Nb {
    constructor(e) {
        super();
        this.type = "Path",
        this.currentPoint = new zt,
        e && this.setFromPoints(e)
    }
    setFromPoints(e) {
        this.moveTo(e[0].x, e[0].y);
        for (let t = 1, o = e.length; t < o; t++)
            this.lineTo(e[t].x, e[t].y);
        return this
    }
    moveTo(e, t) {
        return this.currentPoint.set(e, t),
        this
    }
    lineTo(e, t) {
        let o = new of(this.currentPoint.clone(),new zt(e,t));
        return this.curves.push(o),
        this.currentPoint.set(e, t),
        this
    }
    quadraticCurveTo(e, t, o, c) {
        let d = new Gm(this.currentPoint.clone(),new zt(e,t),new zt(o,c));
        return this.curves.push(d),
        this.currentPoint.set(o, c),
        this
    }
    bezierCurveTo(e, t, o, c, d, p) {
        let i = new Vm(this.currentPoint.clone(),new zt(e,t),new zt(o,c),new zt(d,p));
        return this.curves.push(i),
        this.currentPoint.set(d, p),
        this
    }
    splineThru(e) {
        let t = [this.currentPoint.clone()].concat(e)
          , o = new Hm(t);
        return this.curves.push(o),
        this.currentPoint.copy(e[e.length - 1]),
        this
    }
    arc(e, t, o, c, d, p) {
        let i = this.currentPoint.x
          , v = this.currentPoint.y;
        return this.absarc(e + i, t + v, o, c, d, p),
        this
    }
    absarc(e, t, o, c, d, p) {
        return this.absellipse(e, t, o, o, c, d, p),
        this
    }
    ellipse(e, t, o, c, d, p, i, v) {
        let x = this.currentPoint.x
          , E = this.currentPoint.y;
        return this.absellipse(e + x, t + E, o, c, d, p, i, v),
        this
    }
    absellipse(e, t, o, c, d, p, i, v) {
        let x = new sf(e,t,o,c,d,p,i,v);
        if (this.curves.length > 0) {
            let A = x.getPoint(0);
            A.equals(this.currentPoint) || this.lineTo(A.x, A.y)
        }
        this.curves.push(x);
        let E = x.getPoint(1);
        return this.currentPoint.copy(E),
        this
    }
    copy(e) {
        return super.copy(e),
        this.currentPoint.copy(e.currentPoint),
        this
    }
    toJSON() {
        let e = super.toJSON();
        return e.currentPoint = this.currentPoint.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.currentPoint.fromArray(e.currentPoint),
        this
    }
}
;
var FG = new Oe
  , BG = new Oe
  , UG = new Oe
  , VG = new yr;
var ih = class extends Wm {
    constructor(e) {
        super(e);
        this.uuid = Uo(),
        this.type = "Shape",
        this.holes = []
    }
    getPointsHoles(e) {
        let t = [];
        for (let o = 0, c = this.holes.length; o < c; o++)
            t[o] = this.holes[o].getPoints(e);
        return t
    }
    extractPoints(e) {
        return {
            shape: this.getPoints(e),
            holes: this.getPointsHoles(e)
        }
    }
    copy(e) {
        super.copy(e),
        this.holes = [];
        for (let t = 0, o = e.holes.length; t < o; t++) {
            let c = e.holes[t];
            this.holes.push(c.clone())
        }
        return this
    }
    toJSON() {
        let e = super.toJSON();
        e.uuid = this.uuid,
        e.holes = [];
        for (let t = 0, o = this.holes.length; t < o; t++) {
            let c = this.holes[t];
            e.holes.push(c.toJSON())
        }
        return e
    }
    fromJSON(e) {
        super.fromJSON(e),
        this.uuid = e.uuid,
        this.holes = [];
        for (let t = 0, o = e.holes.length; t < o; t++) {
            let c = e.holes[t];
            this.holes.push(new Wm().fromJSON(c))
        }
        return this
    }
}
  , y5 = {
    triangulate: function(r, e, t=2) {
        let o = e && e.length
          , c = o ? e[0] * t : r.length
          , d = TI(r, 0, c, t, !0)
          , p = [];
        if (!d || d.next === d.prev)
            return p;
        let i, v, x, E, A, C, I;
        if (o && (d = _5(r, e, d, t)),
        r.length > 80 * t) {
            i = x = r[0],
            v = E = r[1];
            for (let D = t; D < c; D += t)
                A = r[D],
                C = r[D + 1],
                A < i && (i = A),
                C < v && (v = C),
                A > x && (x = A),
                C > E && (E = C);
            I = Math.max(x - i, E - v),
            I = I !== 0 ? 1 / I : 0
        }
        return jm(d, p, t, i, v, I),
        p
    }
};
function TI(r, e, t, o, c) {
    let d, p;
    if (c === x5(r, e, t, o) > 0)
        for (d = e; d < t; d += o)
            p = EI(d, r[d], r[d + 1], p);
    else
        for (d = t - o; d >= e; d -= o)
            p = EI(d, r[d], r[d + 1], p);
    return p && A0(p, p.next) && (Xm(p),
    p = p.next),
    p
}
function xc(r, e) {
    if (!r)
        return r;
    e || (e = r);
    let t = r, o;
    do
        if (o = !1,
        !t.steiner && (A0(t, t.next) || dr(t.prev, t, t.next) === 0)) {
            if (Xm(t),
            t = e = t.prev,
            t === t.next)
                break;
            o = !0
        } else
            t = t.next;
    while (o || t !== e);
    return e
}
function jm(r, e, t, o, c, d, p) {
    if (!r)
        return;
    !p && d && E5(r, o, c, d);
    let i = r, v, x;
    for (; r.prev !== r.next; ) {
        if (v = r.prev,
        x = r.next,
        d ? b5(r, o, c, d) : v5(r)) {
            e.push(v.i / t),
            e.push(r.i / t),
            e.push(x.i / t),
            Xm(r),
            r = x.next,
            i = x.next;
            continue
        }
        if (r = x,
        r === i) {
            p ? p === 1 ? (r = w5(xc(r), e, t),
            jm(r, e, t, o, c, d, 2)) : p === 2 && T5(r, e, t, o, c, d) : jm(xc(r), e, t, o, c, d, 1);
            break
        }
    }
}
function v5(r) {
    let e = r.prev
      , t = r
      , o = r.next;
    if (dr(e, t, o) >= 0)
        return !1;
    let c = r.next.next;
    for (; c !== r.prev; ) {
        if (af(e.x, e.y, t.x, t.y, o.x, o.y, c.x, c.y) && dr(c.prev, c, c.next) >= 0)
            return !1;
        c = c.next
    }
    return !0
}
function b5(r, e, t, o) {
    let c = r.prev
      , d = r
      , p = r.next;
    if (dr(c, d, p) >= 0)
        return !1;
    let i = c.x < d.x ? c.x < p.x ? c.x : p.x : d.x < p.x ? d.x : p.x
      , v = c.y < d.y ? c.y < p.y ? c.y : p.y : d.y < p.y ? d.y : p.y
      , x = c.x > d.x ? c.x > p.x ? c.x : p.x : d.x > p.x ? d.x : p.x
      , E = c.y > d.y ? c.y > p.y ? c.y : p.y : d.y > p.y ? d.y : p.y
      , A = Fb(i, v, e, t, o)
      , C = Fb(x, E, e, t, o)
      , I = r.prevZ
      , D = r.nextZ;
    for (; I && I.z >= A && D && D.z <= C; ) {
        if (I !== r.prev && I !== r.next && af(c.x, c.y, d.x, d.y, p.x, p.y, I.x, I.y) && dr(I.prev, I, I.next) >= 0 || (I = I.prevZ,
        D !== r.prev && D !== r.next && af(c.x, c.y, d.x, d.y, p.x, p.y, D.x, D.y) && dr(D.prev, D, D.next) >= 0))
            return !1;
        D = D.nextZ
    }
    for (; I && I.z >= A; ) {
        if (I !== r.prev && I !== r.next && af(c.x, c.y, d.x, d.y, p.x, p.y, I.x, I.y) && dr(I.prev, I, I.next) >= 0)
            return !1;
        I = I.prevZ
    }
    for (; D && D.z <= C; ) {
        if (D !== r.prev && D !== r.next && af(c.x, c.y, d.x, d.y, p.x, p.y, D.x, D.y) && dr(D.prev, D, D.next) >= 0)
            return !1;
        D = D.nextZ
    }
    return !0
}
function w5(r, e, t) {
    let o = r;
    do {
        let c = o.prev
          , d = o.next.next;
        !A0(c, d) && SI(c, o, o.next, d) && Zm(c, d) && Zm(d, c) && (e.push(c.i / t),
        e.push(o.i / t),
        e.push(d.i / t),
        Xm(o),
        Xm(o.next),
        o = r = d),
        o = o.next
    } while (o !== r);
    return xc(o)
}
function T5(r, e, t, o, c, d) {
    let p = r;
    do {
        let i = p.next.next;
        for (; i !== p.prev; ) {
            if (p.i !== i.i && S5(p, i)) {
                let v = AI(p, i);
                p = xc(p, p.next),
                v = xc(v, v.next),
                jm(p, e, t, o, c, d),
                jm(v, e, t, o, c, d);
                return
            }
            i = i.next
        }
        p = p.next
    } while (p !== r)
}
function _5(r, e, t, o) {
    let c = [], d, p, i, v, x;
    for (d = 0,
    p = e.length; d < p; d++)
        i = e[d] * o,
        v = d < p - 1 ? e[d + 1] * o : r.length,
        x = TI(r, i, v, o, !1),
        x === x.next && (x.steiner = !0),
        c.push(I5(x));
    for (c.sort(A5),
    d = 0; d < c.length; d++)
        M5(c[d], t),
        t = xc(t, t.next);
    return t
}
function A5(r, e) {
    return r.x - e.x
}
function M5(r, e) {
    if (e = C5(r, e),
    e) {
        let t = AI(e, r);
        xc(e, e.next),
        xc(t, t.next)
    }
}
function C5(r, e) {
    let t = e, o = r.x, c = r.y, d = -Infinity, p;
    do {
        if (c <= t.y && c >= t.next.y && t.next.y !== t.y) {
            let C = t.x + (c - t.y) * (t.next.x - t.x) / (t.next.y - t.y);
            if (C <= o && C > d) {
                if (d = C,
                C === o) {
                    if (c === t.y)
                        return t;
                    if (c === t.next.y)
                        return t.next
                }
                p = t.x < t.next.x ? t : t.next
            }
        }
        t = t.next
    } while (t !== e);
    if (!p)
        return null;
    if (o === d)
        return p;
    let i = p, v = p.x, x = p.y, E = Infinity, A;
    t = p;
    do
        o >= t.x && t.x >= v && o !== t.x && af(c < x ? o : d, c, v, x, c < x ? d : o, c, t.x, t.y) && (A = Math.abs(c - t.y) / (o - t.x),
        Zm(t, r) && (A < E || A === E && (t.x > p.x || t.x === p.x && D5(p, t))) && (p = t,
        E = A)),
        t = t.next;
    while (t !== i);
    return p
}
function D5(r, e) {
    return dr(r.prev, r, e.prev) < 0 && dr(e.next, r, r.next) < 0
}
function E5(r, e, t, o) {
    let c = r;
    do
        c.z === null && (c.z = Fb(c.x, c.y, e, t, o)),
        c.prevZ = c.prev,
        c.nextZ = c.next,
        c = c.next;
    while (c !== r);
    c.prevZ.nextZ = null,
    c.prevZ = null,
    L5(c)
}
function L5(r) {
    let e, t, o, c, d, p, i, v, x = 1;
    do {
        for (t = r,
        r = null,
        d = null,
        p = 0; t; ) {
            for (p++,
            o = t,
            i = 0,
            e = 0; e < x && (i++,
            o = o.nextZ,
            !!o); e++)
                ;
            for (v = x; i > 0 || v > 0 && o; )
                i !== 0 && (v === 0 || !o || t.z <= o.z) ? (c = t,
                t = t.nextZ,
                i--) : (c = o,
                o = o.nextZ,
                v--),
                d ? d.nextZ = c : r = c,
                c.prevZ = d,
                d = c;
            t = o
        }
        d.nextZ = null,
        x *= 2
    } while (p > 1);
    return r
}
function Fb(r, e, t, o, c) {
    return r = 32767 * (r - t) * c,
    e = 32767 * (e - o) * c,
    r = (r | r << 8) & 16711935,
    r = (r | r << 4) & 252645135,
    r = (r | r << 2) & 858993459,
    r = (r | r << 1) & 1431655765,
    e = (e | e << 8) & 16711935,
    e = (e | e << 4) & 252645135,
    e = (e | e << 2) & 858993459,
    e = (e | e << 1) & 1431655765,
    r | e << 1
}
function I5(r) {
    let e = r
      , t = r;
    do
        (e.x < t.x || e.x === t.x && e.y < t.y) && (t = e),
        e = e.next;
    while (e !== r);
    return t
}
function af(r, e, t, o, c, d, p, i) {
    return (c - p) * (e - i) - (r - p) * (d - i) >= 0 && (r - p) * (o - i) - (t - p) * (e - i) >= 0 && (t - p) * (d - i) - (c - p) * (o - i) >= 0
}
function S5(r, e) {
    return r.next.i !== e.i && r.prev.i !== e.i && !R5(r, e) && (Zm(r, e) && Zm(e, r) && P5(r, e) && (dr(r.prev, r, e.prev) || dr(r, e.prev, e)) || A0(r, e) && dr(r.prev, r, r.next) > 0 && dr(e.prev, e, e.next) > 0)
}
function dr(r, e, t) {
    return (e.y - r.y) * (t.x - e.x) - (e.x - r.x) * (t.y - e.y)
}
function A0(r, e) {
    return r.x === e.x && r.y === e.y
}
function SI(r, e, t, o) {
    let c = I0(dr(r, e, t))
      , d = I0(dr(r, e, o))
      , p = I0(dr(t, o, r))
      , i = I0(dr(t, o, e));
    return !!(c !== d && p !== i || c === 0 && M0(r, t, e) || d === 0 && M0(r, o, e) || p === 0 && M0(t, r, o) || i === 0 && M0(t, e, o))
}
function M0(r, e, t) {
    return e.x <= Math.max(r.x, t.x) && e.x >= Math.min(r.x, t.x) && e.y <= Math.max(r.y, t.y) && e.y >= Math.min(r.y, t.y)
}
function I0(r) {
    return r > 0 ? 1 : r < 0 ? -1 : 0
}
function R5(r, e) {
    let t = r;
    do {
        if (t.i !== r.i && t.next.i !== r.i && t.i !== e.i && t.next.i !== e.i && SI(t, t.next, r, e))
            return !0;
        t = t.next
    } while (t !== r);
    return !1
}
function Zm(r, e) {
    return dr(r.prev, r, r.next) < 0 ? dr(r, e, r.next) >= 0 && dr(r, r.prev, e) >= 0 : dr(r, e, r.prev) < 0 || dr(r, r.next, e) < 0
}
function P5(r, e) {
    let t = r
      , o = !1
      , c = (r.x + e.x) / 2
      , d = (r.y + e.y) / 2;
    do
        t.y > d != t.next.y > d && t.next.y !== t.y && c < (t.next.x - t.x) * (d - t.y) / (t.next.y - t.y) + t.x && (o = !o),
        t = t.next;
    while (t !== r);
    return o
}
function AI(r, e) {
    let t = new Bb(r.i,r.x,r.y)
      , o = new Bb(e.i,e.x,e.y)
      , c = r.next
      , d = e.prev;
    return r.next = e,
    e.prev = r,
    t.next = c,
    c.prev = t,
    o.next = t,
    t.prev = o,
    d.next = o,
    o.prev = d,
    o
}
function EI(r, e, t, o) {
    let c = new Bb(r,e,t);
    return o ? (c.next = o.next,
    c.prev = o,
    o.next.prev = c,
    o.next = c) : (c.prev = c,
    c.next = c),
    c
}
function Xm(r) {
    r.next.prev = r.prev,
    r.prev.next = r.next,
    r.prevZ && (r.prevZ.nextZ = r.nextZ),
    r.nextZ && (r.nextZ.prevZ = r.prevZ)
}
function Bb(r, e, t) {
    this.i = r,
    this.x = e,
    this.y = t,
    this.prev = null,
    this.next = null,
    this.z = null,
    this.prevZ = null,
    this.nextZ = null,
    this.steiner = !1
}
function x5(r, e, t, o) {
    let c = 0;
    for (let d = e, p = t - o; d < t; d += o)
        c += (r[p] - r[d]) * (r[d + 1] + r[p + 1]),
        p = d;
    return c
}
var ba = class {
    static area(e) {
        let t = e.length
          , o = 0;
        for (let c = t - 1, d = 0; d < t; c = d++)
            o += e[c].x * e[d].y - e[d].x * e[c].y;
        return o * .5
    }
    static isClockWise(e) {
        return ba.area(e) < 0
    }
    static triangulateShape(e, t) {
        let o = []
          , c = []
          , d = [];
        MI(e),
        II(o, e);
        let p = e.length;
        t.forEach(MI);
        for (let v = 0; v < t.length; v++)
            c.push(p),
            p += t[v].length,
            II(o, t[v]);
        let i = y5.triangulate(o, c);
        for (let v = 0; v < i.length; v += 3)
            d.push(i.slice(v, v + 3));
        return d
    }
}
;
function MI(r) {
    let e = r.length;
    e > 2 && r[e - 1].equals(r[0]) && r.pop()
}
function II(r, e) {
    for (let t = 0; t < e.length; t++)
        r.push(e[t].x),
        r.push(e[t].y)
}
var cl = class extends Vi {
    constructor(e=new ih([new zt(.5,.5), new zt(-.5,.5), new zt(-.5,-.5), new zt(.5,-.5)]), t={}) {
        super();
        this.type = "ExtrudeGeometry",
        this.parameters = {
            shapes: e,
            options: t
        },
        e = Array.isArray(e) ? e : [e];
        let o = this
          , c = []
          , d = [];
        for (let i = 0, v = e.length; i < v; i++) {
            let x = e[i];
            p(x)
        }
        this.setAttribute("position", new xr(c,3)),
        this.setAttribute("uv", new xr(d,2)),
        this.computeVertexNormals();
        function p(i) {
            let v = []
              , x = t.curveSegments !== void 0 ? t.curveSegments : 12
              , E = t.steps !== void 0 ? t.steps : 1
              , A = t.depth !== void 0 ? t.depth : 1
              , C = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0
              , I = t.bevelThickness !== void 0 ? t.bevelThickness : .2
              , D = t.bevelSize !== void 0 ? t.bevelSize : I - .1
              , P = t.bevelOffset !== void 0 ? t.bevelOffset : 0
              , k = t.bevelSegments !== void 0 ? t.bevelSegments : 3
              , U = t.extrudePath
              , Z = t.UVGenerator !== void 0 ? t.UVGenerator : k5;
            t.amount !== void 0 && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."),
            A = t.amount);
            let K, X = !1, W, fe, ce, _e;
            U && (K = U.getSpacedPoints(E),
            X = !0,
            C = !1,
            W = U.computeFrenetFrames(E, !1),
            fe = new Oe,
            ce = new Oe,
            _e = new Oe),
            C || (k = 0,
            I = 0,
            D = 0,
            P = 0);
            let oe = i.extractPoints(x)
              , ee = oe.shape
              , j = oe.holes;
            if (!ba.isClockWise(ee)) {
                ee = ee.reverse();
                for (let ut = 0, ot = j.length; ut < ot; ut++) {
                    let xt = j[ut];
                    ba.isClockWise(xt) && (j[ut] = xt.reverse())
                }
            }
            let be = ba.triangulateShape(ee, j)
              , te = ee;
            for (let ut = 0, ot = j.length; ut < ot; ut++) {
                let xt = j[ut];
                ee = ee.concat(xt)
            }
            function ae(ut, ot, xt) {
                return ot || console.error("THREE.ExtrudeGeometry: vec does not exist"),
                ot.clone().multiplyScalar(xt).add(ut)
            }
            let se = ee.length
              , ke = be.length;
            function Be(ut, ot, xt) {
                let on, $t, Pn, kt = ut.x - ot.x, Zt = ut.y - ot.y, zn = xt.x - ut.x, Qt = xt.y - ut.y, xe = kt * kt + Zt * Zt, he = kt * Qt - Zt * zn;
                if (Math.abs(he) > Number.EPSILON) {
                    let Qe = Math.sqrt(xe)
                      , ft = Math.sqrt(zn * zn + Qt * Qt)
                      , St = ot.x - Zt / Qe
                      , Mt = ot.y + kt / Qe
                      , an = xt.x - Qt / ft
                      , Ie = xt.y + zn / ft
                      , Ct = ((an - St) * Qt - (Ie - Mt) * zn) / (kt * Qt - Zt * zn);
                    on = St + kt * Ct - ut.x,
                    $t = Mt + Zt * Ct - ut.y;
                    let ln = on * on + $t * $t;
                    if (ln <= 2)
                        return new zt(on,$t);
                    Pn = Math.sqrt(ln / 2)
                } else {
                    let Qe = !1;
                    kt > Number.EPSILON ? zn > Number.EPSILON && (Qe = !0) : kt < -Number.EPSILON ? zn < -Number.EPSILON && (Qe = !0) : Math.sign(Zt) === Math.sign(Qt) && (Qe = !0),
                    Qe ? (on = -Zt,
                    $t = kt,
                    Pn = Math.sqrt(xe)) : (on = kt,
                    $t = Zt,
                    Pn = Math.sqrt(xe / 2))
                }
                return new zt(on / Pn,$t / Pn)
            }
            let tt = [];
            for (let ut = 0, ot = te.length, xt = ot - 1, on = ut + 1; ut < ot; ut++,
            xt++,
            on++)
                xt === ot && (xt = 0),
                on === ot && (on = 0),
                tt[ut] = Be(te[ut], te[xt], te[on]);
            let Ke = [], bt, Et = tt.concat();
            for (let ut = 0, ot = j.length; ut < ot; ut++) {
                let xt = j[ut];
                bt = [];
                for (let on = 0, $t = xt.length, Pn = $t - 1, kt = on + 1; on < $t; on++,
                Pn++,
                kt++)
                    Pn === $t && (Pn = 0),
                    kt === $t && (kt = 0),
                    bt[on] = Be(xt[on], xt[Pn], xt[kt]);
                Ke.push(bt),
                Et = Et.concat(bt)
            }
            for (let ut = 0; ut < k; ut++) {
                let ot = ut / k
                  , xt = I * Math.cos(ot * Math.PI / 2)
                  , on = D * Math.sin(ot * Math.PI / 2) + P;
                for (let $t = 0, Pn = te.length; $t < Pn; $t++) {
                    let kt = ae(te[$t], tt[$t], on);
                    Tn(kt.x, kt.y, -xt)
                }
                for (let $t = 0, Pn = j.length; $t < Pn; $t++) {
                    let kt = j[$t];
                    bt = Ke[$t];
                    for (let Zt = 0, zn = kt.length; Zt < zn; Zt++) {
                        let Qt = ae(kt[Zt], bt[Zt], on);
                        Tn(Qt.x, Qt.y, -xt)
                    }
                }
            }
            let Gt = D + P;
            for (let ut = 0; ut < se; ut++) {
                let ot = C ? ae(ee[ut], Et[ut], Gt) : ee[ut];
                X ? (ce.copy(W.normals[0]).multiplyScalar(ot.x),
                fe.copy(W.binormals[0]).multiplyScalar(ot.y),
                _e.copy(K[0]).add(ce).add(fe),
                Tn(_e.x, _e.y, _e.z)) : Tn(ot.x, ot.y, 0)
            }
            for (let ut = 1; ut <= E; ut++)
                for (let ot = 0; ot < se; ot++) {
                    let xt = C ? ae(ee[ot], Et[ot], Gt) : ee[ot];
                    X ? (ce.copy(W.normals[ut]).multiplyScalar(xt.x),
                    fe.copy(W.binormals[ut]).multiplyScalar(xt.y),
                    _e.copy(K[ut]).add(ce).add(fe),
                    Tn(_e.x, _e.y, _e.z)) : Tn(xt.x, xt.y, A / E * ut)
                }
            for (let ut = k - 1; ut >= 0; ut--) {
                let ot = ut / k
                  , xt = I * Math.cos(ot * Math.PI / 2)
                  , on = D * Math.sin(ot * Math.PI / 2) + P;
                for (let $t = 0, Pn = te.length; $t < Pn; $t++) {
                    let kt = ae(te[$t], tt[$t], on);
                    Tn(kt.x, kt.y, A + xt)
                }
                for (let $t = 0, Pn = j.length; $t < Pn; $t++) {
                    let kt = j[$t];
                    bt = Ke[$t];
                    for (let Zt = 0, zn = kt.length; Zt < zn; Zt++) {
                        let Qt = ae(kt[Zt], bt[Zt], on);
                        X ? Tn(Qt.x, Qt.y + K[E - 1].y, K[E - 1].x + xt) : Tn(Qt.x, Qt.y, A + xt)
                    }
                }
            }
            Ye(),
            gn();
            function Ye() {
                let ut = c.length / 3;
                if (C) {
                    let ot = 0
                      , xt = se * ot;
                    for (let on = 0; on < ke; on++) {
                        let $t = be[on];
                        xn($t[2] + xt, $t[1] + xt, $t[0] + xt)
                    }
                    ot = E + k * 2,
                    xt = se * ot;
                    for (let on = 0; on < ke; on++) {
                        let $t = be[on];
                        xn($t[0] + xt, $t[1] + xt, $t[2] + xt)
                    }
                } else {
                    for (let ot = 0; ot < ke; ot++) {
                        let xt = be[ot];
                        xn(xt[2], xt[1], xt[0])
                    }
                    for (let ot = 0; ot < ke; ot++) {
                        let xt = be[ot];
                        xn(xt[0] + se * E, xt[1] + se * E, xt[2] + se * E)
                    }
                }
                o.addGroup(ut, c.length / 3 - ut, 0)
            }
            function gn() {
                let ut = c.length / 3
                  , ot = 0;
                gt(te, ot),
                ot += te.length;
                for (let xt = 0, on = j.length; xt < on; xt++) {
                    let $t = j[xt];
                    gt($t, ot),
                    ot += $t.length
                }
                o.addGroup(ut, c.length / 3 - ut, 1)
            }
            function gt(ut, ot) {
                let xt = ut.length;
                for (; --xt >= 0; ) {
                    let on = xt
                      , $t = xt - 1;
                    $t < 0 && ($t = ut.length - 1);
                    for (let Pn = 0, kt = E + k * 2; Pn < kt; Pn++) {
                        let Zt = se * Pn
                          , zn = se * (Pn + 1)
                          , Qt = ot + on + Zt
                          , xe = ot + $t + Zt
                          , he = ot + $t + zn
                          , Qe = ot + on + zn;
                        Dn(Qt, xe, he, Qe)
                    }
                }
            }
            function Tn(ut, ot, xt) {
                v.push(ut),
                v.push(ot),
                v.push(xt)
            }
            function xn(ut, ot, xt) {
                Bt(ut),
                Bt(ot),
                Bt(xt);
                let on = c.length / 3
                  , $t = Z.generateTopUV(o, c, on - 3, on - 2, on - 1);
                An($t[0]),
                An($t[1]),
                An($t[2])
            }
            function Dn(ut, ot, xt, on) {
                Bt(ut),
                Bt(ot),
                Bt(on),
                Bt(ot),
                Bt(xt),
                Bt(on);
                let $t = c.length / 3
                  , Pn = Z.generateSideWallUV(o, c, $t - 6, $t - 3, $t - 2, $t - 1);
                An(Pn[0]),
                An(Pn[1]),
                An(Pn[3]),
                An(Pn[1]),
                An(Pn[2]),
                An(Pn[3])
            }
            function Bt(ut) {
                c.push(v[ut * 3 + 0]),
                c.push(v[ut * 3 + 1]),
                c.push(v[ut * 3 + 2])
            }
            function An(ut) {
                d.push(ut.x),
                d.push(ut.y)
            }
        }
    }
    toJSON() {
        let e = super.toJSON()
          , t = this.parameters.shapes
          , o = this.parameters.options;
        return z5(t, o, e)
    }
    static fromJSON(e, t) {
        let o = [];
        for (let d = 0, p = e.shapes.length; d < p; d++) {
            let i = t[e.shapes[d]];
            o.push(i)
        }
        let c = e.options.extrudePath;
        return c !== void 0 && (e.options.extrudePath = new wI[c.type]().fromJSON(c)),
        new cl(o,e.options)
    }
}
  , k5 = {
    generateTopUV: function(r, e, t, o, c) {
        let d = e[t * 3]
          , p = e[t * 3 + 1]
          , i = e[o * 3]
          , v = e[o * 3 + 1]
          , x = e[c * 3]
          , E = e[c * 3 + 1];
        return [new zt(d,p), new zt(i,v), new zt(x,E)]
    },
    generateSideWallUV: function(r, e, t, o, c, d) {
        let p = e[t * 3]
          , i = e[t * 3 + 1]
          , v = e[t * 3 + 2]
          , x = e[o * 3]
          , E = e[o * 3 + 1]
          , A = e[o * 3 + 2]
          , C = e[c * 3]
          , I = e[c * 3 + 1]
          , D = e[c * 3 + 2]
          , P = e[d * 3]
          , k = e[d * 3 + 1]
          , U = e[d * 3 + 2];
        return Math.abs(i - E) < Math.abs(p - x) ? [new zt(p,1 - v), new zt(x,1 - A), new zt(C,1 - D), new zt(P,1 - U)] : [new zt(i,1 - v), new zt(E,1 - A), new zt(I,1 - D), new zt(k,1 - U)]
    }
};
function z5(r, e, t) {
    if (t.shapes = [],
    Array.isArray(r))
        for (let o = 0, c = r.length; o < c; o++) {
            let d = r[o];
            t.shapes.push(d.uuid)
        }
    else
        t.shapes.push(r.uuid);
    return e.extrudePath !== void 0 && (t.options.extrudePath = e.extrudePath.toJSON()),
    t
}
var lf = class extends Vi {
    constructor(e=new ih([new zt(0,.5), new zt(-.5,-.5), new zt(.5,-.5)]), t=12) {
        super();
        this.type = "ShapeGeometry",
        this.parameters = {
            shapes: e,
            curveSegments: t
        };
        let o = []
          , c = []
          , d = []
          , p = []
          , i = 0
          , v = 0;
        if (Array.isArray(e) === !1)
            x(e);
        else
            for (let E = 0; E < e.length; E++)
                x(e[E]),
                this.addGroup(i, v, E),
                i += v,
                v = 0;
        this.setIndex(o),
        this.setAttribute("position", new xr(c,3)),
        this.setAttribute("normal", new xr(d,3)),
        this.setAttribute("uv", new xr(p,2));
        function x(E) {
            let A = c.length / 3
              , C = E.extractPoints(t)
              , I = C.shape
              , D = C.holes;
            ba.isClockWise(I) === !1 && (I = I.reverse());
            for (let k = 0, U = D.length; k < U; k++) {
                let Z = D[k];
                ba.isClockWise(Z) === !0 && (D[k] = Z.reverse())
            }
            let P = ba.triangulateShape(I, D);
            for (let k = 0, U = D.length; k < U; k++) {
                let Z = D[k];
                I = I.concat(Z)
            }
            for (let k = 0, U = I.length; k < U; k++) {
                let Z = I[k];
                c.push(Z.x, Z.y, 0),
                d.push(0, 0, 1),
                p.push(Z.x, Z.y)
            }
            for (let k = 0, U = P.length; k < U; k++) {
                let Z = P[k]
                  , K = Z[0] + A
                  , X = Z[1] + A
                  , W = Z[2] + A;
                o.push(K, X, W),
                v += 3
            }
        }
    }
    toJSON() {
        let e = super.toJSON()
          , t = this.parameters.shapes;
        return O5(t, e)
    }
    static fromJSON(e, t) {
        let o = [];
        for (let c = 0, d = e.shapes.length; c < d; c++) {
            let p = t[e.shapes[c]];
            o.push(p)
        }
        return new lf(o,e.curveSegments)
    }
}
;
function O5(r, e) {
    if (e.shapes = [],
    Array.isArray(r))
        for (let t = 0, o = r.length; t < o; t++) {
            let c = r[t];
            e.shapes.push(c.uuid)
        }
    else
        e.shapes.push(r.uuid);
    return e
}
var C0 = class extends wr {
    constructor(e) {
        super();
        this.type = "ShadowMaterial",
        this.color = new In(0),
        this.transparent = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this
    }
}
;
C0.prototype.isShadowMaterial = !0;
var rh = class extends oo {
    constructor(e) {
        super(e);
        this.type = "RawShaderMaterial"
    }
}
;
rh.prototype.isRawShaderMaterial = !0;
var qm = class extends wr {
    constructor(e) {
        super();
        this.defines = {
            STANDARD: ""
        },
        this.type = "MeshStandardMaterial",
        this.color = new In(16777215),
        this.roughness = 1,
        this.metalness = 0,
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new In(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = Zu,
        this.normalScale = new zt(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.roughnessMap = null,
        this.metalnessMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.envMapIntensity = 1,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.flatShading = !1,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.defines = {
            STANDARD: ""
        },
        this.color.copy(e.color),
        this.roughness = e.roughness,
        this.metalness = e.metalness,
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.emissive.copy(e.emissive),
        this.emissiveMap = e.emissiveMap,
        this.emissiveIntensity = e.emissiveIntensity,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.roughnessMap = e.roughnessMap,
        this.metalnessMap = e.metalnessMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.envMapIntensity = e.envMapIntensity,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.flatShading = e.flatShading,
        this
    }
}
;
qm.prototype.isMeshStandardMaterial = !0;
var D0 = class extends qm {
    constructor(e) {
        super();
        this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        },
        this.type = "MeshPhysicalMaterial",
        this.clearcoatMap = null,
        this.clearcoatRoughness = 0,
        this.clearcoatRoughnessMap = null,
        this.clearcoatNormalScale = new zt(1,1),
        this.clearcoatNormalMap = null,
        this.ior = 1.5,
        Object.defineProperty(this, "reflectivity", {
            get: function() {
                return rs(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
            },
            set: function(t) {
                this.ior = (1 + .4 * t) / (1 - .4 * t)
            }
        }),
        this.sheenColor = new In(0),
        this.sheenColorMap = null,
        this.sheenRoughness = 1,
        this.sheenRoughnessMap = null,
        this.transmissionMap = null,
        this.thickness = 0,
        this.thicknessMap = null,
        this.attenuationDistance = 0,
        this.attenuationColor = new In(1,1,1),
        this.specularIntensity = 1,
        this.specularIntensityMap = null,
        this.specularColor = new In(1,1,1),
        this.specularColorMap = null,
        this._sheen = 0,
        this._clearcoat = 0,
        this._transmission = 0,
        this.setValues(e)
    }
    get sheen() {
        return this._sheen
    }
    set sheen(e) {
        this._sheen > 0 != e > 0 && this.version++,
        this._sheen = e
    }
    get clearcoat() {
        return this._clearcoat
    }
    set clearcoat(e) {
        this._clearcoat > 0 != e > 0 && this.version++,
        this._clearcoat = e
    }
    get transmission() {
        return this._transmission
    }
    set transmission(e) {
        this._transmission > 0 != e > 0 && this.version++,
        this._transmission = e
    }
    copy(e) {
        return super.copy(e),
        this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        },
        this.clearcoat = e.clearcoat,
        this.clearcoatMap = e.clearcoatMap,
        this.clearcoatRoughness = e.clearcoatRoughness,
        this.clearcoatRoughnessMap = e.clearcoatRoughnessMap,
        this.clearcoatNormalMap = e.clearcoatNormalMap,
        this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
        this.ior = e.ior,
        this.sheen = e.sheen,
        this.sheenColor.copy(e.sheenColor),
        this.sheenColorMap = e.sheenColorMap,
        this.sheenRoughness = e.sheenRoughness,
        this.sheenRoughnessMap = e.sheenRoughnessMap,
        this.transmission = e.transmission,
        this.transmissionMap = e.transmissionMap,
        this.thickness = e.thickness,
        this.thicknessMap = e.thicknessMap,
        this.attenuationDistance = e.attenuationDistance,
        this.attenuationColor.copy(e.attenuationColor),
        this.specularIntensity = e.specularIntensity,
        this.specularIntensityMap = e.specularIntensityMap,
        this.specularColor.copy(e.specularColor),
        this.specularColorMap = e.specularColorMap,
        this
    }
}
;
D0.prototype.isMeshPhysicalMaterial = !0;
var L0 = class extends wr {
    constructor(e) {
        super();
        this.type = "MeshPhongMaterial",
        this.color = new In(16777215),
        this.specular = new In(1118481),
        this.shininess = 30,
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new In(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = Zu,
        this.normalScale = new zt(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.combine = um,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.flatShading = !1,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.specular.copy(e.specular),
        this.shininess = e.shininess,
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.emissive.copy(e.emissive),
        this.emissiveMap = e.emissiveMap,
        this.emissiveIntensity = e.emissiveIntensity,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.specularMap = e.specularMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.combine = e.combine,
        this.reflectivity = e.reflectivity,
        this.refractionRatio = e.refractionRatio,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.flatShading = e.flatShading,
        this
    }
}
;
L0.prototype.isMeshPhongMaterial = !0;
var R0 = class extends wr {
    constructor(e) {
        super();
        this.defines = {
            TOON: ""
        },
        this.type = "MeshToonMaterial",
        this.color = new In(16777215),
        this.map = null,
        this.gradientMap = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new In(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = Zu,
        this.normalScale = new zt(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.alphaMap = null,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.gradientMap = e.gradientMap,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.emissive.copy(e.emissive),
        this.emissiveMap = e.emissiveMap,
        this.emissiveIntensity = e.emissiveIntensity,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.alphaMap = e.alphaMap,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this
    }
}
;
R0.prototype.isMeshToonMaterial = !0;
var P0 = class extends wr {
    constructor(e) {
        super();
        this.type = "MeshNormalMaterial",
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = Zu,
        this.normalScale = new zt(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.fog = !1,
        this.flatShading = !1,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.flatShading = e.flatShading,
        this
    }
}
;
P0.prototype.isMeshNormalMaterial = !0;
var k0 = class extends wr {
    constructor(e) {
        super();
        this.type = "MeshLambertMaterial",
        this.color = new In(16777215),
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new In(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.combine = um,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.emissive.copy(e.emissive),
        this.emissiveMap = e.emissiveMap,
        this.emissiveIntensity = e.emissiveIntensity,
        this.specularMap = e.specularMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.combine = e.combine,
        this.reflectivity = e.reflectivity,
        this.refractionRatio = e.refractionRatio,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this
    }
}
;
k0.prototype.isMeshLambertMaterial = !0;
var z0 = class extends wr {
    constructor(e) {
        super();
        this.defines = {
            MATCAP: ""
        },
        this.type = "MeshMatcapMaterial",
        this.color = new In(16777215),
        this.matcap = null,
        this.map = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = Zu,
        this.normalScale = new zt(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.alphaMap = null,
        this.flatShading = !1,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.defines = {
            MATCAP: ""
        },
        this.color.copy(e.color),
        this.matcap = e.matcap,
        this.map = e.map,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.alphaMap = e.alphaMap,
        this.flatShading = e.flatShading,
        this
    }
}
;
z0.prototype.isMeshMatcapMaterial = !0;
var O0 = class extends ll {
    constructor(e) {
        super();
        this.type = "LineDashedMaterial",
        this.scale = 1,
        this.dashSize = 3,
        this.gapSize = 1,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.scale = e.scale,
        this.dashSize = e.dashSize,
        this.gapSize = e.gapSize,
        this
    }
}
;
O0.prototype.isLineDashedMaterial = !0;
var N5 = {
    ShadowMaterial: C0,
    SpriteMaterial: Lm,
    RawShaderMaterial: rh,
    ShaderMaterial: oo,
    PointsMaterial: Fm,
    MeshPhysicalMaterial: D0,
    MeshStandardMaterial: qm,
    MeshPhongMaterial: L0,
    MeshToonMaterial: R0,
    MeshNormalMaterial: P0,
    MeshLambertMaterial: k0,
    MeshDepthMaterial: Mm,
    MeshDistanceMaterial: Im,
    MeshBasicMaterial: pc,
    MeshMatcapMaterial: z0,
    LineDashedMaterial: O0,
    LineBasicMaterial: ll,
    Material: wr
};
wr.fromType = function(r) {
    return new N5[r]
}
;
var tr = {
    arraySlice: function(r, e, t) {
        return tr.isTypedArray(r) ? new r.constructor(r.subarray(e, t !== void 0 ? t : r.length)) : r.slice(e, t)
    },
    convertArray: function(r, e, t) {
        return !r || !t && r.constructor === e ? r : typeof e.BYTES_PER_ELEMENT == "number" ? new e(r) : Array.prototype.slice.call(r)
    },
    isTypedArray: function(r) {
        return ArrayBuffer.isView(r) && !(r instanceof DataView)
    },
    getKeyframeOrder: function(r) {
        function e(c, d) {
            return r[c] - r[d]
        }
        let t = r.length
          , o = new Array(t);
        for (let c = 0; c !== t; ++c)
            o[c] = c;
        return o.sort(e),
        o
    },
    sortedArray: function(r, e, t) {
        let o = r.length
          , c = new r.constructor(o);
        for (let d = 0, p = 0; p !== o; ++d) {
            let i = t[d] * e;
            for (let v = 0; v !== e; ++v)
                c[p++] = r[i + v]
        }
        return c
    },
    flattenJSON: function(r, e, t, o) {
        let c = 1
          , d = r[0];
        for (; d !== void 0 && d[o] === void 0; )
            d = r[c++];
        if (d === void 0)
            return;
        let p = d[o];
        if (p !== void 0)
            if (Array.isArray(p))
                do
                    p = d[o],
                    p !== void 0 && (e.push(d.time),
                    t.push.apply(t, p)),
                    d = r[c++];
                while (d !== void 0);
            else if (p.toArray !== void 0)
                do
                    p = d[o],
                    p !== void 0 && (e.push(d.time),
                    p.toArray(t, t.length)),
                    d = r[c++];
                while (d !== void 0);
            else
                do
                    p = d[o],
                    p !== void 0 && (e.push(d.time),
                    t.push(p)),
                    d = r[c++];
                while (d !== void 0)
    },
    subclip: function(r, e, t, o, c=30) {
        let d = r.clone();
        d.name = e;
        let p = [];
        for (let v = 0; v < d.tracks.length; ++v) {
            let x = d.tracks[v]
              , E = x.getValueSize()
              , A = []
              , C = [];
            for (let I = 0; I < x.times.length; ++I) {
                let D = x.times[I] * c;
                if (!(D < t || D >= o)) {
                    A.push(x.times[I]);
                    for (let P = 0; P < E; ++P)
                        C.push(x.values[I * E + P])
                }
            }
            A.length !== 0 && (x.times = tr.convertArray(A, x.times.constructor),
            x.values = tr.convertArray(C, x.values.constructor),
            p.push(x))
        }
        d.tracks = p;
        let i = Infinity;
        for (let v = 0; v < d.tracks.length; ++v)
            i > d.tracks[v].times[0] && (i = d.tracks[v].times[0]);
        for (let v = 0; v < d.tracks.length; ++v)
            d.tracks[v].shift(-1 * i);
        return d.resetDuration(),
        d
    },
    makeClipAdditive: function(r, e=0, t=r, o=30) {
        o <= 0 && (o = 30);
        let c = t.tracks.length
          , d = e / o;
        for (let p = 0; p < c; ++p) {
            let i = t.tracks[p]
              , v = i.ValueTypeName;
            if (v === "bool" || v === "string")
                continue;
            let x = r.tracks.find(function(U) {
                return U.name === i.name && U.ValueTypeName === v
            });
            if (x === void 0)
                continue;
            let E = 0
              , A = i.getValueSize();
            i.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (E = A / 3);
            let C = 0
              , I = x.getValueSize();
            x.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (C = I / 3);
            let D = i.times.length - 1, P;
            if (d <= i.times[0]) {
                let U = E
                  , Z = A - E;
                P = tr.arraySlice(i.values, U, Z)
            } else if (d >= i.times[D]) {
                let U = D * A + E
                  , Z = U + A - E;
                P = tr.arraySlice(i.values, U, Z)
            } else {
                let U = i.createInterpolant()
                  , Z = E
                  , K = A - E;
                U.evaluate(d),
                P = tr.arraySlice(U.resultBuffer, Z, K)
            }
            v === "quaternion" && new Ur().fromArray(P).normalize().conjugate().toArray(P);
            let k = x.times.length;
            for (let U = 0; U < k; ++U) {
                let Z = U * I + C;
                if (v === "quaternion")
                    Ur.multiplyQuaternionsFlat(x.values, Z, P, 0, x.values, Z);
                else {
                    let K = I - C * 2;
                    for (let X = 0; X < K; ++X)
                        x.values[Z + X] -= P[X]
                }
            }
        }
        return r.blendMode = N1,
        r
    }
}
  , wa = class {
    constructor(e, t, o, c) {
        this.parameterPositions = e,
        this._cachedIndex = 0,
        this.resultBuffer = c !== void 0 ? c : new t.constructor(o),
        this.sampleValues = t,
        this.valueSize = o,
        this.settings = null,
        this.DefaultSettings_ = {}
    }
    evaluate(e) {
        let t = this.parameterPositions
          , o = this._cachedIndex
          , c = t[o]
          , d = t[o - 1];
        e: {
            t: {
                let p;
                n: {
                    i: if (!(e < c)) {
                        for (let i = o + 2; ; ) {
                            if (c === void 0) {
                                if (e < d)
                                    break i;
                                return o = t.length,
                                this._cachedIndex = o,
                                this.afterEnd_(o - 1, e, d)
                            }
                            if (o === i)
                                break;
                            if (d = c,
                            c = t[++o],
                            e < c)
                                break t
                        }
                        p = t.length;
                        break n
                    }
                    if (!(e >= d)) {
                        let i = t[1];
                        e < i && (o = 2,
                        d = i);
                        for (let v = o - 2; ; ) {
                            if (d === void 0)
                                return this._cachedIndex = 0,
                                this.beforeStart_(0, e, c);
                            if (o === v)
                                break;
                            if (c = d,
                            d = t[--o - 1],
                            e >= d)
                                break t
                        }
                        p = o,
                        o = 0;
                        break n
                    }
                    break e
                }
                for (; o < p; ) {
                    let i = o + p >>> 1;
                    e < t[i] ? p = i : o = i + 1
                }
                if (c = t[o],
                d = t[o - 1],
                d === void 0)
                    return this._cachedIndex = 0,
                    this.beforeStart_(0, e, c);
                if (c === void 0)
                    return o = t.length,
                    this._cachedIndex = o,
                    this.afterEnd_(o - 1, d, e)
            }
            this._cachedIndex = o,
            this.intervalChanged_(o, d, c)
        }
        return this.interpolate_(o, d, e, c)
    }
    getSettings_() {
        return this.settings || this.DefaultSettings_
    }
    copySampleValue_(e) {
        let t = this.resultBuffer
          , o = this.sampleValues
          , c = this.valueSize
          , d = e * c;
        for (let p = 0; p !== c; ++p)
            t[p] = o[d + p];
        return t
    }
    interpolate_() {
        throw new Error("call to abstract method")
    }
    intervalChanged_() {}
}
;
wa.prototype.beforeStart_ = wa.prototype.copySampleValue_;
wa.prototype.afterEnd_ = wa.prototype.copySampleValue_;
var Ub = class extends wa {
    constructor(e, t, o, c) {
        super(e, t, o, c);
        this._weightPrev = -0,
        this._offsetPrev = -0,
        this._weightNext = -0,
        this._offsetNext = -0,
        this.DefaultSettings_ = {
            endingStart: ju,
            endingEnd: ju
        }
    }
    intervalChanged_(e, t, o) {
        let c = this.parameterPositions
          , d = e - 2
          , p = e + 1
          , i = c[d]
          , v = c[p];
        if (i === void 0)
            switch (this.getSettings_().endingStart) {
            case Xu:
                d = e,
                i = 2 * t - o;
                break;
            case _m:
                d = c.length - 2,
                i = t + c[d] - c[d + 1];
                break;
            default:
                d = e,
                i = o
            }
        if (v === void 0)
            switch (this.getSettings_().endingEnd) {
            case Xu:
                p = e,
                v = 2 * o - t;
                break;
            case _m:
                p = 1,
                v = o + c[1] - c[0];
                break;
            default:
                p = e - 1,
                v = t
            }
        let x = (o - t) * .5
          , E = this.valueSize;
        this._weightPrev = x / (t - i),
        this._weightNext = x / (v - o),
        this._offsetPrev = d * E,
        this._offsetNext = p * E
    }
    interpolate_(e, t, o, c) {
        let d = this.resultBuffer
          , p = this.sampleValues
          , i = this.valueSize
          , v = e * i
          , x = v - i
          , E = this._offsetPrev
          , A = this._offsetNext
          , C = this._weightPrev
          , I = this._weightNext
          , D = (o - t) / (c - t)
          , P = D * D
          , k = P * D
          , U = -C * k + 2 * C * P - C * D
          , Z = (1 + C) * k + (-1.5 - 2 * C) * P + (-.5 + C) * D + 1
          , K = (-1 - I) * k + (1.5 + I) * P + .5 * D
          , X = I * k - I * P;
        for (let W = 0; W !== i; ++W)
            d[W] = U * p[E + W] + Z * p[x + W] + K * p[v + W] + X * p[A + W];
        return d
    }
}
  , N0 = class extends wa {
    constructor(e, t, o, c) {
        super(e, t, o, c)
    }
    interpolate_(e, t, o, c) {
        let d = this.resultBuffer
          , p = this.sampleValues
          , i = this.valueSize
          , v = e * i
          , x = v - i
          , E = (o - t) / (c - t)
          , A = 1 - E;
        for (let C = 0; C !== i; ++C)
            d[C] = p[x + C] * A + p[v + C] * E;
        return d
    }
}
  , Vb = class extends wa {
    constructor(e, t, o, c) {
        super(e, t, o, c)
    }
    interpolate_(e) {
        return this.copySampleValue_(e - 1)
    }
}
  , To = class {
    constructor(e, t, o, c) {
        if (e === void 0)
            throw new Error("THREE.KeyframeTrack: track name is undefined");
        if (t === void 0 || t.length === 0)
            throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
        this.name = e,
        this.times = tr.convertArray(t, this.TimeBufferType),
        this.values = tr.convertArray(o, this.ValueBufferType),
        this.setInterpolation(c || this.DefaultInterpolation)
    }
    static toJSON(e) {
        let t = e.constructor, o;
        if (t.toJSON !== this.toJSON)
            o = t.toJSON(e);
        else {
            o = {
                name: e.name,
                times: tr.convertArray(e.times, Array),
                values: tr.convertArray(e.values, Array)
            };
            let c = e.getInterpolation();
            c !== e.DefaultInterpolation && (o.interpolation = c)
        }
        return o.type = e.ValueTypeName,
        o
    }
    InterpolantFactoryMethodDiscrete(e) {
        return new Vb(this.times,this.values,this.getValueSize(),e)
    }
    InterpolantFactoryMethodLinear(e) {
        return new N0(this.times,this.values,this.getValueSize(),e)
    }
    InterpolantFactoryMethodSmooth(e) {
        return new Ub(this.times,this.values,this.getValueSize(),e)
    }
    setInterpolation(e) {
        let t;
        switch (e) {
        case mm:
            t = this.InterpolantFactoryMethodDiscrete;
            break;
        case gm:
            t = this.InterpolantFactoryMethodLinear;
            break;
        case Ry:
            t = this.InterpolantFactoryMethodSmooth;
            break
        }
        if (t === void 0) {
            let o = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
            if (this.createInterpolant === void 0)
                if (e !== this.DefaultInterpolation)
                    this.setInterpolation(this.DefaultInterpolation);
                else
                    throw new Error(o);
            return console.warn("THREE.KeyframeTrack:", o),
            this
        }
        return this.createInterpolant = t,
        this
    }
    getInterpolation() {
        switch (this.createInterpolant) {
        case this.InterpolantFactoryMethodDiscrete:
            return mm;
        case this.InterpolantFactoryMethodLinear:
            return gm;
        case this.InterpolantFactoryMethodSmooth:
            return Ry
        }
    }
    getValueSize() {
        return this.values.length / this.times.length
    }
    shift(e) {
        if (e !== 0) {
            let t = this.times;
            for (let o = 0, c = t.length; o !== c; ++o)
                t[o] += e
        }
        return this
    }
    scale(e) {
        if (e !== 1) {
            let t = this.times;
            for (let o = 0, c = t.length; o !== c; ++o)
                t[o] *= e
        }
        return this
    }
    trim(e, t) {
        let o = this.times
          , c = o.length
          , d = 0
          , p = c - 1;
        for (; d !== c && o[d] < e; )
            ++d;
        for (; p !== -1 && o[p] > t; )
            --p;
        if (++p,
        d !== 0 || p !== c) {
            d >= p && (p = Math.max(p, 1),
            d = p - 1);
            let i = this.getValueSize();
            this.times = tr.arraySlice(o, d, p),
            this.values = tr.arraySlice(this.values, d * i, p * i)
        }
        return this
    }
    validate() {
        let e = !0
          , t = this.getValueSize();
        t - Math.floor(t) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
        e = !1);
        let o = this.times
          , c = this.values
          , d = o.length;
        d === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this),
        e = !1);
        let p = null;
        for (let i = 0; i !== d; i++) {
            let v = o[i];
            if (typeof v == "number" && isNaN(v)) {
                console.error("THREE.KeyframeTrack: Time is not a valid number.", this, i, v),
                e = !1;
                break
            }
            if (p !== null && p > v) {
                console.error("THREE.KeyframeTrack: Out of order keys.", this, i, v, p),
                e = !1;
                break
            }
            p = v
        }
        if (c !== void 0 && tr.isTypedArray(c))
            for (let i = 0, v = c.length; i !== v; ++i) {
                let x = c[i];
                if (isNaN(x)) {
                    console.error("THREE.KeyframeTrack: Value is not a valid number.", this, i, x),
                    e = !1;
                    break
                }
            }
        return e
    }
    optimize() {
        let e = tr.arraySlice(this.times)
          , t = tr.arraySlice(this.values)
          , o = this.getValueSize()
          , c = this.getInterpolation() === Ry
          , d = e.length - 1
          , p = 1;
        for (let i = 1; i < d; ++i) {
            let v = !1
              , x = e[i]
              , E = e[i + 1];
            if (x !== E && (i !== 1 || x !== e[0]))
                if (c)
                    v = !0;
                else {
                    let A = i * o
                      , C = A - o
                      , I = A + o;
                    for (let D = 0; D !== o; ++D) {
                        let P = t[A + D];
                        if (P !== t[C + D] || P !== t[I + D]) {
                            v = !0;
                            break
                        }
                    }
                }
            if (v) {
                if (i !== p) {
                    e[p] = e[i];
                    let A = i * o
                      , C = p * o;
                    for (let I = 0; I !== o; ++I)
                        t[C + I] = t[A + I]
                }
                ++p
            }
        }
        if (d > 0) {
            e[p] = e[d];
            for (let i = d * o, v = p * o, x = 0; x !== o; ++x)
                t[v + x] = t[i + x];
            ++p
        }
        return p !== e.length ? (this.times = tr.arraySlice(e, 0, p),
        this.values = tr.arraySlice(t, 0, p * o)) : (this.times = e,
        this.values = t),
        this
    }
    clone() {
        let e = tr.arraySlice(this.times, 0)
          , t = tr.arraySlice(this.values, 0)
          , o = this.constructor
          , c = new o(this.name,e,t);
        return c.createInterpolant = this.createInterpolant,
        c
    }
}
;
To.prototype.TimeBufferType = Float32Array;
To.prototype.ValueBufferType = Float32Array;
To.prototype.DefaultInterpolation = gm;
var vc = class extends To {
}
;
vc.prototype.ValueTypeName = "bool";
vc.prototype.ValueBufferType = Array;
vc.prototype.DefaultInterpolation = mm;
vc.prototype.InterpolantFactoryMethodLinear = void 0;
vc.prototype.InterpolantFactoryMethodSmooth = void 0;
var F0 = class extends To {
}
;
F0.prototype.ValueTypeName = "color";
var cf = class extends To {
}
;
cf.prototype.ValueTypeName = "number";
var Gb = class extends wa {
    constructor(e, t, o, c) {
        super(e, t, o, c)
    }
    interpolate_(e, t, o, c) {
        let d = this.resultBuffer
          , p = this.sampleValues
          , i = this.valueSize
          , v = (o - t) / (c - t)
          , x = e * i;
        for (let E = x + i; x !== E; x += 4)
            Ur.slerpFlat(d, 0, p, x - i, p, x, v);
        return d
    }
}
  , sh = class extends To {
    InterpolantFactoryMethodLinear(e) {
        return new Gb(this.times,this.values,this.getValueSize(),e)
    }
}
;
sh.prototype.ValueTypeName = "quaternion";
sh.prototype.DefaultInterpolation = gm;
sh.prototype.InterpolantFactoryMethodSmooth = void 0;
var bc = class extends To {
}
;
bc.prototype.ValueTypeName = "string";
bc.prototype.ValueBufferType = Array;
bc.prototype.DefaultInterpolation = mm;
bc.prototype.InterpolantFactoryMethodLinear = void 0;
bc.prototype.InterpolantFactoryMethodSmooth = void 0;
var uf = class extends To {
}
;
uf.prototype.ValueTypeName = "vector";
var B0 = class {
    constructor(e, t=-1, o, c=Py) {
        this.name = e,
        this.tracks = o,
        this.duration = t,
        this.blendMode = c,
        this.uuid = Uo(),
        this.duration < 0 && this.resetDuration()
    }
    static parse(e) {
        let t = []
          , o = e.tracks
          , c = 1 / (e.fps || 1);
        for (let p = 0, i = o.length; p !== i; ++p)
            t.push(F5(o[p]).scale(c));
        let d = new this(e.name,e.duration,t,e.blendMode);
        return d.uuid = e.uuid,
        d
    }
    static toJSON(e) {
        let t = []
          , o = e.tracks
          , c = {
            name: e.name,
            duration: e.duration,
            tracks: t,
            uuid: e.uuid,
            blendMode: e.blendMode
        };
        for (let d = 0, p = o.length; d !== p; ++d)
            t.push(To.toJSON(o[d]));
        return c
    }
    static CreateFromMorphTargetSequence(e, t, o, c) {
        let d = t.length
          , p = [];
        for (let i = 0; i < d; i++) {
            let v = []
              , x = [];
            v.push((i + d - 1) % d, i, (i + 1) % d),
            x.push(0, 1, 0);
            let E = tr.getKeyframeOrder(v);
            v = tr.sortedArray(v, 1, E),
            x = tr.sortedArray(x, 1, E),
            !c && v[0] === 0 && (v.push(d),
            x.push(x[0])),
            p.push(new cf(".morphTargetInfluences[" + t[i].name + "]",v,x).scale(1 / o))
        }
        return new this(e,-1,p)
    }
    static findByName(e, t) {
        let o = e;
        if (!Array.isArray(e)) {
            let c = e;
            o = c.geometry && c.geometry.animations || c.animations
        }
        for (let c = 0; c < o.length; c++)
            if (o[c].name === t)
                return o[c];
        return null
    }
    static CreateClipsFromMorphTargetSequences(e, t, o) {
        let c = {}
          , d = /^([\w-]*?)([\d]+)$/;
        for (let i = 0, v = e.length; i < v; i++) {
            let x = e[i]
              , E = x.name.match(d);
            if (E && E.length > 1) {
                let A = E[1]
                  , C = c[A];
                C || (c[A] = C = []),
                C.push(x)
            }
        }
        let p = [];
        for (let i in c)
            p.push(this.CreateFromMorphTargetSequence(i, c[i], t, o));
        return p
    }
    static parseAnimation(e, t) {
        if (!e)
            return console.error("THREE.AnimationClip: No animation in JSONLoader data."),
            null;
        let o = function(A, C, I, D, P) {
            if (I.length !== 0) {
                let k = []
                  , U = [];
                tr.flattenJSON(I, k, U, D),
                k.length !== 0 && P.push(new A(C,k,U))
            }
        }
          , c = []
          , d = e.name || "default"
          , p = e.fps || 30
          , i = e.blendMode
          , v = e.length || -1
          , x = e.hierarchy || [];
        for (let A = 0; A < x.length; A++) {
            let C = x[A].keys;
            if (!(!C || C.length === 0))
                if (C[0].morphTargets) {
                    let I = {}, D;
                    for (D = 0; D < C.length; D++)
                        if (C[D].morphTargets)
                            for (let P = 0; P < C[D].morphTargets.length; P++)
                                I[C[D].morphTargets[P]] = -1;
                    for (let P in I) {
                        let k = []
                          , U = [];
                        for (let Z = 0; Z !== C[D].morphTargets.length; ++Z) {
                            let K = C[D];
                            k.push(K.time),
                            U.push(K.morphTarget === P ? 1 : 0)
                        }
                        c.push(new cf(".morphTargetInfluence[" + P + "]",k,U))
                    }
                    v = I.length * p
                } else {
                    let I = ".bones[" + t[A].name + "]";
                    o(uf, I + ".position", C, "pos", c),
                    o(sh, I + ".quaternion", C, "rot", c),
                    o(uf, I + ".scale", C, "scl", c)
                }
        }
        return c.length === 0 ? null : new this(d,v,c,i)
    }
    resetDuration() {
        let e = this.tracks
          , t = 0;
        for (let o = 0, c = e.length; o !== c; ++o) {
            let d = this.tracks[o];
            t = Math.max(t, d.times[d.times.length - 1])
        }
        return this.duration = t,
        this
    }
    trim() {
        for (let e = 0; e < this.tracks.length; e++)
            this.tracks[e].trim(0, this.duration);
        return this
    }
    validate() {
        let e = !0;
        for (let t = 0; t < this.tracks.length; t++)
            e = e && this.tracks[t].validate();
        return e
    }
    optimize() {
        for (let e = 0; e < this.tracks.length; e++)
            this.tracks[e].optimize();
        return this
    }
    clone() {
        let e = [];
        for (let t = 0; t < this.tracks.length; t++)
            e.push(this.tracks[t].clone());
        return new this.constructor(this.name,this.duration,e,this.blendMode)
    }
    toJSON() {
        return this.constructor.toJSON(this)
    }
}
;
function B5(r) {
    switch (r.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
        return cf;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
        return uf;
    case "color":
        return F0;
    case "quaternion":
        return sh;
    case "bool":
    case "boolean":
        return vc;
    case "string":
        return bc
    }
    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + r)
}
function F5(r) {
    if (r.type === void 0)
        throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
    let e = B5(r.type);
    if (r.times === void 0) {
        let t = []
          , o = [];
        tr.flattenJSON(r.keys, t, o, "value"),
        r.times = t,
        r.values = o
    }
    return e.parse !== void 0 ? e.parse(r) : new e(r.name,r.times,r.values,r.interpolation)
}
var oh = {
    enabled: !1,
    files: {},
    add: function(r, e) {
        this.enabled !== !1 && (this.files[r] = e)
    },
    get: function(r) {
        if (this.enabled !== !1)
            return this.files[r]
    },
    remove: function(r) {
        delete this.files[r]
    },
    clear: function() {
        this.files = {}
    }
}
  , Hb = class {
    constructor(e, t, o) {
        let c = this, d = !1, p = 0, i = 0, v, x = [];
        this.onStart = void 0,
        this.onLoad = e,
        this.onProgress = t,
        this.onError = o,
        this.itemStart = function(E) {
            i++,
            d === !1 && c.onStart !== void 0 && c.onStart(E, p, i),
            d = !0
        }
        ,
        this.itemEnd = function(E) {
            p++,
            c.onProgress !== void 0 && c.onProgress(E, p, i),
            p === i && (d = !1,
            c.onLoad !== void 0 && c.onLoad())
        }
        ,
        this.itemError = function(E) {
            c.onError !== void 0 && c.onError(E)
        }
        ,
        this.resolveURL = function(E) {
            return v ? v(E) : E
        }
        ,
        this.setURLModifier = function(E) {
            return v = E,
            this
        }
        ,
        this.addHandler = function(E, A) {
            return x.push(E, A),
            this
        }
        ,
        this.removeHandler = function(E) {
            let A = x.indexOf(E);
            return A !== -1 && x.splice(A, 2),
            this
        }
        ,
        this.getHandler = function(E) {
            for (let A = 0, C = x.length; A < C; A += 2) {
                let I = x[A]
                  , D = x[A + 1];
                if (I.global && (I.lastIndex = 0),
                I.test(E))
                    return D
            }
            return null
        }
    }
}
  , CI = new Hb
  , Ta = class {
    constructor(e) {
        this.manager = e !== void 0 ? e : CI,
        this.crossOrigin = "anonymous",
        this.withCredentials = !1,
        this.path = "",
        this.resourcePath = "",
        this.requestHeader = {}
    }
    load() {}
    loadAsync(e, t) {
        let o = this;
        return new Promise(function(c, d) {
            o.load(e, c, t, d)
        }
        )
    }
    parse() {}
    setCrossOrigin(e) {
        return this.crossOrigin = e,
        this
    }
    setWithCredentials(e) {
        return this.withCredentials = e,
        this
    }
    setPath(e) {
        return this.path = e,
        this
    }
    setResourcePath(e) {
        return this.resourcePath = e,
        this
    }
    setRequestHeader(e) {
        return this.requestHeader = e,
        this
    }
}
  , ul = {}
  , Wb = class extends Ta {
    constructor(e) {
        super(e)
    }
    load(e, t, o, c) {
        e === void 0 && (e = ""),
        this.path !== void 0 && (e = this.path + e),
        e = this.manager.resolveURL(e);
        let d = oh.get(e);
        if (d !== void 0)
            return this.manager.itemStart(e),
            setTimeout(()=>{
                t && t(d),
                this.manager.itemEnd(e)
            }
            , 0),
            d;
        if (ul[e] !== void 0) {
            ul[e].push({
                onLoad: t,
                onProgress: o,
                onError: c
            });
            return
        }
        ul[e] = [],
        ul[e].push({
            onLoad: t,
            onProgress: o,
            onError: c
        });
        let p = new Request(e,{
            headers: new Headers(this.requestHeader),
            credentials: this.withCredentials ? "include" : "same-origin"
        })
          , i = this.mimeType
          , v = this.responseType;
        fetch(p).then(x=>{
            if (x.status === 200 || x.status === 0) {
                if (x.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."),
                typeof ReadableStream == "undefined" || x.body === void 0 || x.body.getReader === void 0)
                    return x;
                let E = ul[e]
                  , A = x.body.getReader()
                  , C = x.headers.get("Content-Length")
                  , I = C ? parseInt(C) : 0
                  , D = I !== 0
                  , P = 0
                  , k = new ReadableStream({
                    start(U) {
                        Z();
                        function Z() {
                            A.read().then(({done: K, value: X})=>{
                                if (K)
                                    U.close();
                                else {
                                    P += X.byteLength;
                                    let W = new ProgressEvent("progress",{
                                        lengthComputable: D,
                                        loaded: P,
                                        total: I
                                    });
                                    for (let fe = 0, ce = E.length; fe < ce; fe++) {
                                        let _e = E[fe];
                                        _e.onProgress && _e.onProgress(W)
                                    }
                                    U.enqueue(X),
                                    Z()
                                }
                            }
                            )
                        }
                    }
                });
                return new Response(k)
            } else
                throw Error(`fetch for "${x.url}" responded with ${x.status}: ${x.statusText}`)
        }
        ).then(x=>{
            switch (v) {
            case "arraybuffer":
                return x.arrayBuffer();
            case "blob":
                return x.blob();
            case "document":
                return x.text().then(E=>new DOMParser().parseFromString(E, i));
            case "json":
                return x.json();
            default:
                if (i === void 0)
                    return x.text();
                {
                    let A = /charset="?([^;"\s]*)"?/i.exec(i)
                      , C = A && A[1] ? A[1].toLowerCase() : void 0
                      , I = new TextDecoder(C);
                    return x.arrayBuffer().then(D=>I.decode(D))
                }
            }
        }
        ).then(x=>{
            oh.add(e, x);
            let E = ul[e];
            delete ul[e];
            for (let A = 0, C = E.length; A < C; A++) {
                let I = E[A];
                I.onLoad && I.onLoad(x)
            }
        }
        ).catch(x=>{
            let E = ul[e];
            if (E === void 0)
                throw this.manager.itemError(e),
                x;
            delete ul[e];
            for (let A = 0, C = E.length; A < C; A++) {
                let I = E[A];
                I.onError && I.onError(x)
            }
            this.manager.itemError(e)
        }
        ).finally(()=>{
            this.manager.itemEnd(e)
        }
        ),
        this.manager.itemStart(e)
    }
    setResponseType(e) {
        return this.responseType = e,
        this
    }
    setMimeType(e) {
        return this.mimeType = e,
        this
    }
}
;
var U0 = class extends Ta {
    constructor(e) {
        super(e)
    }
    load(e, t, o, c) {
        this.path !== void 0 && (e = this.path + e),
        e = this.manager.resolveURL(e);
        let d = this
          , p = oh.get(e);
        if (p !== void 0)
            return d.manager.itemStart(e),
            setTimeout(function() {
                t && t(p),
                d.manager.itemEnd(e)
            }, 0),
            p;
        let i = xm("img");
        function v() {
            E(),
            oh.add(e, this),
            t && t(this),
            d.manager.itemEnd(e)
        }
        function x(A) {
            E(),
            c && c(A),
            d.manager.itemError(e),
            d.manager.itemEnd(e)
        }
        function E() {
            i.removeEventListener("load", v, !1),
            i.removeEventListener("error", x, !1)
        }
        return i.addEventListener("load", v, !1),
        i.addEventListener("error", x, !1),
        e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (i.crossOrigin = this.crossOrigin),
        d.manager.itemStart(e),
        i.src = e,
        i
    }
}
  , jb = class extends Ta {
    constructor(e) {
        super(e)
    }
    load(e, t, o, c) {
        let d = new jd
          , p = new U0(this.manager);
        p.setCrossOrigin(this.crossOrigin),
        p.setPath(this.path);
        let i = 0;
        function v(x) {
            p.load(e[x], function(E) {
                d.images[x] = E,
                i++,
                i === 6 && (d.needsUpdate = !0,
                t && t(d))
            }, void 0, c)
        }
        for (let x = 0; x < e.length; ++x)
            v(x);
        return d
    }
}
;
var Xb = class extends Ta {
    constructor(e) {
        super(e)
    }
    load(e, t, o, c) {
        let d = new Ar
          , p = new U0(this.manager);
        return p.setCrossOrigin(this.crossOrigin),
        p.setPath(this.path),
        p.load(e, function(i) {
            d.image = i,
            d.needsUpdate = !0,
            t !== void 0 && t(d)
        }, o, c),
        d
    }
}
  , Eo = class extends Ai {
    constructor(e, t=1) {
        super();
        this.type = "Light",
        this.color = new In(e),
        this.intensity = t
    }
    dispose() {}
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.intensity = e.intensity,
        this
    }
    toJSON(e) {
        let t = super.toJSON(e);
        return t.object.color = this.color.getHex(),
        t.object.intensity = this.intensity,
        this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()),
        this.distance !== void 0 && (t.object.distance = this.distance),
        this.angle !== void 0 && (t.object.angle = this.angle),
        this.decay !== void 0 && (t.object.decay = this.decay),
        this.penumbra !== void 0 && (t.object.penumbra = this.penumbra),
        this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()),
        t
    }
}
;
Eo.prototype.isLight = !0;
var Zb = class extends Eo {
    constructor(e, t, o) {
        super(e, o);
        this.type = "HemisphereLight",
        this.position.copy(Ai.DefaultUp),
        this.updateMatrix(),
        this.groundColor = new In(t)
    }
    copy(e) {
        return Eo.prototype.copy.call(this, e),
        this.groundColor.copy(e.groundColor),
        this
    }
}
;
Zb.prototype.isHemisphereLight = !0;
var DI = new Fn
  , LI = new Oe
  , RI = new Oe
  , V0 = class {
    constructor(e) {
        this.camera = e,
        this.bias = 0,
        this.normalBias = 0,
        this.radius = 1,
        this.blurSamples = 8,
        this.mapSize = new zt(512,512),
        this.map = null,
        this.mapPass = null,
        this.matrix = new Fn,
        this.autoUpdate = !0,
        this.needsUpdate = !1,
        this._frustum = new Zd,
        this._frameExtents = new zt(1,1),
        this._viewportCount = 1,
        this._viewports = [new Ui(0,0,1,1)]
    }
    getViewportCount() {
        return this._viewportCount
    }
    getFrustum() {
        return this._frustum
    }
    updateMatrices(e) {
        let t = this.camera
          , o = this.matrix;
        LI.setFromMatrixPosition(e.matrixWorld),
        t.position.copy(LI),
        RI.setFromMatrixPosition(e.target.matrixWorld),
        t.lookAt(RI),
        t.updateMatrixWorld(),
        DI.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
        this._frustum.setFromProjectionMatrix(DI),
        o.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
        o.multiply(t.projectionMatrix),
        o.multiply(t.matrixWorldInverse)
    }
    getViewport(e) {
        return this._viewports[e]
    }
    getFrameExtents() {
        return this._frameExtents
    }
    dispose() {
        this.map && this.map.dispose(),
        this.mapPass && this.mapPass.dispose()
    }
    copy(e) {
        return this.camera = e.camera.clone(),
        this.bias = e.bias,
        this.radius = e.radius,
        this.mapSize.copy(e.mapSize),
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
    toJSON() {
        let e = {};
        return this.bias !== 0 && (e.bias = this.bias),
        this.normalBias !== 0 && (e.normalBias = this.normalBias),
        this.radius !== 1 && (e.radius = this.radius),
        (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()),
        e.camera = this.camera.toJSON(!1).object,
        delete e.camera.matrix,
        e
    }
}
  , qb = class extends V0 {
    constructor() {
        super(new os(50,1,.5,500));
        this.focus = 1
    }
    updateMatrices(e) {
        let t = this.camera
          , o = B1 * 2 * e.angle * this.focus
          , c = this.mapSize.width / this.mapSize.height
          , d = e.distance || t.far;
        (o !== t.fov || c !== t.aspect || d !== t.far) && (t.fov = o,
        t.aspect = c,
        t.far = d,
        t.updateProjectionMatrix()),
        super.updateMatrices(e)
    }
    copy(e) {
        return super.copy(e),
        this.focus = e.focus,
        this
    }
}
;
qb.prototype.isSpotLightShadow = !0;
var Kb = class extends Eo {
    constructor(e, t, o=0, c=Math.PI / 3, d=0, p=1) {
        super(e, t);
        this.type = "SpotLight",
        this.position.copy(Ai.DefaultUp),
        this.updateMatrix(),
        this.target = new Ai,
        this.distance = o,
        this.angle = c,
        this.penumbra = d,
        this.decay = p,
        this.shadow = new qb
    }
    get power() {
        return this.intensity * Math.PI
    }
    set power(e) {
        this.intensity = e / Math.PI
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(e) {
        return super.copy(e),
        this.distance = e.distance,
        this.angle = e.angle,
        this.penumbra = e.penumbra,
        this.decay = e.decay,
        this.target = e.target.clone(),
        this.shadow = e.shadow.clone(),
        this
    }
}
;
Kb.prototype.isSpotLight = !0;
var PI = new Fn
  , Km = new Oe
  , Yb = new Oe
  , Jb = class extends V0 {
    constructor() {
        super(new os(90,1,.5,500));
        this._frameExtents = new zt(4,2),
        this._viewportCount = 6,
        this._viewports = [new Ui(2,1,1,1), new Ui(0,1,1,1), new Ui(3,1,1,1), new Ui(1,1,1,1), new Ui(3,0,1,1), new Ui(1,0,1,1)],
        this._cubeDirections = [new Oe(1,0,0), new Oe(-1,0,0), new Oe(0,0,1), new Oe(0,0,-1), new Oe(0,1,0), new Oe(0,-1,0)],
        this._cubeUps = [new Oe(0,1,0), new Oe(0,1,0), new Oe(0,1,0), new Oe(0,1,0), new Oe(0,0,1), new Oe(0,0,-1)]
    }
    updateMatrices(e, t=0) {
        let o = this.camera
          , c = this.matrix
          , d = e.distance || o.far;
        d !== o.far && (o.far = d,
        o.updateProjectionMatrix()),
        Km.setFromMatrixPosition(e.matrixWorld),
        o.position.copy(Km),
        Yb.copy(o.position),
        Yb.add(this._cubeDirections[t]),
        o.up.copy(this._cubeUps[t]),
        o.lookAt(Yb),
        o.updateMatrixWorld(),
        c.makeTranslation(-Km.x, -Km.y, -Km.z),
        PI.multiplyMatrices(o.projectionMatrix, o.matrixWorldInverse),
        this._frustum.setFromProjectionMatrix(PI)
    }
}
;
Jb.prototype.isPointLightShadow = !0;
var $b = class extends Eo {
    constructor(e, t, o=0, c=1) {
        super(e, t);
        this.type = "PointLight",
        this.distance = o,
        this.decay = c,
        this.shadow = new Jb
    }
    get power() {
        return this.intensity * 4 * Math.PI
    }
    set power(e) {
        this.intensity = e / (4 * Math.PI)
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(e) {
        return super.copy(e),
        this.distance = e.distance,
        this.decay = e.decay,
        this.shadow = e.shadow.clone(),
        this
    }
}
;
$b.prototype.isPointLight = !0;
var Qb = class extends V0 {
    constructor() {
        super(new Sm(-5,5,5,-5,.5,500))
    }
}
;
Qb.prototype.isDirectionalLightShadow = !0;
var ew = class extends Eo {
    constructor(e, t) {
        super(e, t);
        this.type = "DirectionalLight",
        this.position.copy(Ai.DefaultUp),
        this.updateMatrix(),
        this.target = new Ai,
        this.shadow = new Qb
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(e) {
        return super.copy(e),
        this.target = e.target.clone(),
        this.shadow = e.shadow.clone(),
        this
    }
}
;
ew.prototype.isDirectionalLight = !0;
var tw = class extends Eo {
    constructor(e, t) {
        super(e, t);
        this.type = "AmbientLight"
    }
}
;
tw.prototype.isAmbientLight = !0;
var nw = class extends Eo {
    constructor(e, t, o=10, c=10) {
        super(e, t);
        this.type = "RectAreaLight",
        this.width = o,
        this.height = c
    }
    get power() {
        return this.intensity * this.width * this.height * Math.PI
    }
    set power(e) {
        this.intensity = e / (this.width * this.height * Math.PI)
    }
    copy(e) {
        return super.copy(e),
        this.width = e.width,
        this.height = e.height,
        this
    }
    toJSON(e) {
        let t = super.toJSON(e);
        return t.object.width = this.width,
        t.object.height = this.height,
        t
    }
}
;
nw.prototype.isRectAreaLight = !0;
var G0 = class {
    constructor() {
        this.coefficients = [];
        for (let e = 0; e < 9; e++)
            this.coefficients.push(new Oe)
    }
    set(e) {
        for (let t = 0; t < 9; t++)
            this.coefficients[t].copy(e[t]);
        return this
    }
    zero() {
        for (let e = 0; e < 9; e++)
            this.coefficients[e].set(0, 0, 0);
        return this
    }
    getAt(e, t) {
        let o = e.x
          , c = e.y
          , d = e.z
          , p = this.coefficients;
        return t.copy(p[0]).multiplyScalar(.282095),
        t.addScaledVector(p[1], .488603 * c),
        t.addScaledVector(p[2], .488603 * d),
        t.addScaledVector(p[3], .488603 * o),
        t.addScaledVector(p[4], 1.092548 * (o * c)),
        t.addScaledVector(p[5], 1.092548 * (c * d)),
        t.addScaledVector(p[6], .315392 * (3 * d * d - 1)),
        t.addScaledVector(p[7], 1.092548 * (o * d)),
        t.addScaledVector(p[8], .546274 * (o * o - c * c)),
        t
    }
    getIrradianceAt(e, t) {
        let o = e.x
          , c = e.y
          , d = e.z
          , p = this.coefficients;
        return t.copy(p[0]).multiplyScalar(.886227),
        t.addScaledVector(p[1], 2 * .511664 * c),
        t.addScaledVector(p[2], 2 * .511664 * d),
        t.addScaledVector(p[3], 2 * .511664 * o),
        t.addScaledVector(p[4], 2 * .429043 * o * c),
        t.addScaledVector(p[5], 2 * .429043 * c * d),
        t.addScaledVector(p[6], .743125 * d * d - .247708),
        t.addScaledVector(p[7], 2 * .429043 * o * d),
        t.addScaledVector(p[8], .429043 * (o * o - c * c)),
        t
    }
    add(e) {
        for (let t = 0; t < 9; t++)
            this.coefficients[t].add(e.coefficients[t]);
        return this
    }
    addScaledSH(e, t) {
        for (let o = 0; o < 9; o++)
            this.coefficients[o].addScaledVector(e.coefficients[o], t);
        return this
    }
    scale(e) {
        for (let t = 0; t < 9; t++)
            this.coefficients[t].multiplyScalar(e);
        return this
    }
    lerp(e, t) {
        for (let o = 0; o < 9; o++)
            this.coefficients[o].lerp(e.coefficients[o], t);
        return this
    }
    equals(e) {
        for (let t = 0; t < 9; t++)
            if (!this.coefficients[t].equals(e.coefficients[t]))
                return !1;
        return !0
    }
    copy(e) {
        return this.set(e.coefficients)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    fromArray(e, t=0) {
        let o = this.coefficients;
        for (let c = 0; c < 9; c++)
            o[c].fromArray(e, t + c * 3);
        return this
    }
    toArray(e=[], t=0) {
        let o = this.coefficients;
        for (let c = 0; c < 9; c++)
            o[c].toArray(e, t + c * 3);
        return e
    }
    static getBasisAt(e, t) {
        let o = e.x
          , c = e.y
          , d = e.z;
        t[0] = .282095,
        t[1] = .488603 * c,
        t[2] = .488603 * d,
        t[3] = .488603 * o,
        t[4] = 1.092548 * o * c,
        t[5] = 1.092548 * c * d,
        t[6] = .315392 * (3 * d * d - 1),
        t[7] = 1.092548 * o * d,
        t[8] = .546274 * (o * o - c * c)
    }
}
;
G0.prototype.isSphericalHarmonics3 = !0;
var Ym = class extends Eo {
    constructor(e=new G0, t=1) {
        super(void 0, t);
        this.sh = e
    }
    copy(e) {
        return super.copy(e),
        this.sh.copy(e.sh),
        this
    }
    fromJSON(e) {
        return this.intensity = e.intensity,
        this.sh.fromArray(e.sh),
        this
    }
    toJSON(e) {
        let t = super.toJSON(e);
        return t.object.sh = this.sh.toArray(),
        t
    }
}
;
Ym.prototype.isLightProbe = !0;
var iw = class {
    static decodeText(e) {
        if (typeof TextDecoder != "undefined")
            return new TextDecoder().decode(e);
        let t = "";
        for (let o = 0, c = e.length; o < c; o++)
            t += String.fromCharCode(e[o]);
        try {
            return decodeURIComponent(escape(t))
        } catch (o) {
            return t
        }
    }
    static extractUrlBase(e) {
        let t = e.lastIndexOf("/");
        return t === -1 ? "./" : e.slice(0, t + 1)
    }
    static resolveURL(e, t) {
        return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
        /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e)
    }
}
  , rw = class extends Vi {
    constructor() {
        super();
        this.type = "InstancedBufferGeometry",
        this.instanceCount = Infinity
    }
    copy(e) {
        return super.copy(e),
        this.instanceCount = e.instanceCount,
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
    toJSON() {
        let e = super.toJSON(this);
        return e.instanceCount = this.instanceCount,
        e.isInstancedBufferGeometry = !0,
        e
    }
}
;
rw.prototype.isInstancedBufferGeometry = !0;
var sw = class extends Ta {
    constructor(e) {
        super(e);
        typeof createImageBitmap == "undefined" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),
        typeof fetch == "undefined" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
        this.options = {
            premultiplyAlpha: "none"
        }
    }
    setOptions(e) {
        return this.options = e,
        this
    }
    load(e, t, o, c) {
        e === void 0 && (e = ""),
        this.path !== void 0 && (e = this.path + e),
        e = this.manager.resolveURL(e);
        let d = this
          , p = oh.get(e);
        if (p !== void 0)
            return d.manager.itemStart(e),
            setTimeout(function() {
                t && t(p),
                d.manager.itemEnd(e)
            }, 0),
            p;
        let i = {};
        i.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include",
        i.headers = this.requestHeader,
        fetch(e, i).then(function(v) {
            return v.blob()
        }).then(function(v) {
            return createImageBitmap(v, Object.assign(d.options, {
                colorSpaceConversion: "none"
            }))
        }).then(function(v) {
            oh.add(e, v),
            t && t(v),
            d.manager.itemEnd(e)
        }).catch(function(v) {
            c && c(v),
            d.manager.itemError(e),
            d.manager.itemEnd(e)
        }),
        d.manager.itemStart(e)
    }
}
;
sw.prototype.isImageBitmapLoader = !0;
var H0, kI = {
    getContext: function() {
        return H0 === void 0 && (H0 = new (window.AudioContext || window.webkitAudioContext)),
        H0
    },
    setContext: function(r) {
        H0 = r
    }
}, ow = class extends Ta {
    constructor(e) {
        super(e)
    }
    load(e, t, o, c) {
        let d = this
          , p = new Wb(this.manager);
        p.setResponseType("arraybuffer"),
        p.setPath(this.path),
        p.setRequestHeader(this.requestHeader),
        p.setWithCredentials(this.withCredentials),
        p.load(e, function(i) {
            try {
                let v = i.slice(0);
                kI.getContext().decodeAudioData(v, function(E) {
                    t(E)
                })
            } catch (v) {
                c ? c(v) : console.error(v),
                d.manager.itemError(e)
            }
        }, o, c)
    }
}
, aw = class extends Ym {
    constructor(e, t, o=1) {
        super(void 0, o);
        let c = new In().set(e)
          , d = new In().set(t)
          , p = new Oe(c.r,c.g,c.b)
          , i = new Oe(d.r,d.g,d.b)
          , v = Math.sqrt(Math.PI)
          , x = v * Math.sqrt(.75);
        this.sh.coefficients[0].copy(p).add(i).multiplyScalar(v),
        this.sh.coefficients[1].copy(p).sub(i).multiplyScalar(x)
    }
}
;
aw.prototype.isHemisphereLightProbe = !0;
var lw = class extends Ym {
    constructor(e, t=1) {
        super(void 0, t);
        let o = new In().set(e);
        this.sh.coefficients[0].set(o.r, o.g, o.b).multiplyScalar(2 * Math.sqrt(Math.PI))
    }
}
;
lw.prototype.isAmbientLightProbe = !0;
var cw = class extends Ai {
    constructor(e) {
        super();
        this.type = "Audio",
        this.listener = e,
        this.context = e.context,
        this.gain = this.context.createGain(),
        this.gain.connect(e.getInput()),
        this.autoplay = !1,
        this.buffer = null,
        this.detune = 0,
        this.loop = !1,
        this.loopStart = 0,
        this.loopEnd = 0,
        this.offset = 0,
        this.duration = void 0,
        this.playbackRate = 1,
        this.isPlaying = !1,
        this.hasPlaybackControl = !0,
        this.source = null,
        this.sourceType = "empty",
        this._startedAt = 0,
        this._progress = 0,
        this._connected = !1,
        this.filters = []
    }
    getOutput() {
        return this.gain
    }
    setNodeSource(e) {
        return this.hasPlaybackControl = !1,
        this.sourceType = "audioNode",
        this.source = e,
        this.connect(),
        this
    }
    setMediaElementSource(e) {
        return this.hasPlaybackControl = !1,
        this.sourceType = "mediaNode",
        this.source = this.context.createMediaElementSource(e),
        this.connect(),
        this
    }
    setMediaStreamSource(e) {
        return this.hasPlaybackControl = !1,
        this.sourceType = "mediaStreamNode",
        this.source = this.context.createMediaStreamSource(e),
        this.connect(),
        this
    }
    setBuffer(e) {
        return this.buffer = e,
        this.sourceType = "buffer",
        this.autoplay && this.play(),
        this
    }
    play(e=0) {
        if (this.isPlaying === !0) {
            console.warn("THREE.Audio: Audio is already playing.");
            return
        }
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        this._startedAt = this.context.currentTime + e;
        let t = this.context.createBufferSource();
        return t.buffer = this.buffer,
        t.loop = this.loop,
        t.loopStart = this.loopStart,
        t.loopEnd = this.loopEnd,
        t.onended = this.onEnded.bind(this),
        t.start(this._startedAt, this._progress + this.offset, this.duration),
        this.isPlaying = !0,
        this.source = t,
        this.setDetune(this.detune),
        this.setPlaybackRate(this.playbackRate),
        this.connect()
    }
    pause() {
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        return this.isPlaying === !0 && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate,
        this.loop === !0 && (this._progress = this._progress % (this.duration || this.buffer.duration)),
        this.source.stop(),
        this.source.onended = null,
        this.isPlaying = !1),
        this
    }
    stop() {
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        return this._progress = 0,
        this.source.stop(),
        this.source.onended = null,
        this.isPlaying = !1,
        this
    }
    connect() {
        if (this.filters.length > 0) {
            this.source.connect(this.filters[0]);
            for (let e = 1, t = this.filters.length; e < t; e++)
                this.filters[e - 1].connect(this.filters[e]);
            this.filters[this.filters.length - 1].connect(this.getOutput())
        } else
            this.source.connect(this.getOutput());
        return this._connected = !0,
        this
    }
    disconnect() {
        if (this.filters.length > 0) {
            this.source.disconnect(this.filters[0]);
            for (let e = 1, t = this.filters.length; e < t; e++)
                this.filters[e - 1].disconnect(this.filters[e]);
            this.filters[this.filters.length - 1].disconnect(this.getOutput())
        } else
            this.source.disconnect(this.getOutput());
        return this._connected = !1,
        this
    }
    getFilters() {
        return this.filters
    }
    setFilters(e) {
        return e || (e = []),
        this._connected === !0 ? (this.disconnect(),
        this.filters = e.slice(),
        this.connect()) : this.filters = e.slice(),
        this
    }
    setDetune(e) {
        if (this.detune = e,
        this.source.detune !== void 0)
            return this.isPlaying === !0 && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01),
            this
    }
    getDetune() {
        return this.detune
    }
    getFilter() {
        return this.getFilters()[0]
    }
    setFilter(e) {
        return this.setFilters(e ? [e] : [])
    }
    setPlaybackRate(e) {
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        return this.playbackRate = e,
        this.isPlaying === !0 && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01),
        this
    }
    getPlaybackRate() {
        return this.playbackRate
    }
    onEnded() {
        this.isPlaying = !1
    }
    getLoop() {
        return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."),
        !1) : this.loop
    }
    setLoop(e) {
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        return this.loop = e,
        this.isPlaying === !0 && (this.source.loop = this.loop),
        this
    }
    setLoopStart(e) {
        return this.loopStart = e,
        this
    }
    setLoopEnd(e) {
        return this.loopEnd = e,
        this
    }
    getVolume() {
        return this.gain.gain.value
    }
    setVolume(e) {
        return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01),
        this
    }
}
;
var uw = class {
    constructor(e, t=2048) {
        this.analyser = e.context.createAnalyser(),
        this.analyser.fftSize = t,
        this.data = new Uint8Array(this.analyser.frequencyBinCount),
        e.getOutput().connect(this.analyser)
    }
    getFrequencyData() {
        return this.analyser.getByteFrequencyData(this.data),
        this.data
    }
    getAverageFrequency() {
        let e = 0
          , t = this.getFrequencyData();
        for (let o = 0; o < t.length; o++)
            e += t[o];
        return e / t.length
    }
}
  , hw = class {
    constructor(e, t, o) {
        this.binding = e,
        this.valueSize = o;
        let c, d, p;
        switch (t) {
        case "quaternion":
            c = this._slerp,
            d = this._slerpAdditive,
            p = this._setAdditiveIdentityQuaternion,
            this.buffer = new Float64Array(o * 6),
            this._workIndex = 5;
            break;
        case "string":
        case "bool":
            c = this._select,
            d = this._select,
            p = this._setAdditiveIdentityOther,
            this.buffer = new Array(o * 5);
            break;
        default:
            c = this._lerp,
            d = this._lerpAdditive,
            p = this._setAdditiveIdentityNumeric,
            this.buffer = new Float64Array(o * 5)
        }
        this._mixBufferRegion = c,
        this._mixBufferRegionAdditive = d,
        this._setIdentity = p,
        this._origIndex = 3,
        this._addIndex = 4,
        this.cumulativeWeight = 0,
        this.cumulativeWeightAdditive = 0,
        this.useCount = 0,
        this.referenceCount = 0
    }
    accumulate(e, t) {
        let o = this.buffer
          , c = this.valueSize
          , d = e * c + c
          , p = this.cumulativeWeight;
        if (p === 0) {
            for (let i = 0; i !== c; ++i)
                o[d + i] = o[i];
            p = t
        } else {
            p += t;
            let i = t / p;
            this._mixBufferRegion(o, d, 0, i, c)
        }
        this.cumulativeWeight = p
    }
    accumulateAdditive(e) {
        let t = this.buffer
          , o = this.valueSize
          , c = o * this._addIndex;
        this.cumulativeWeightAdditive === 0 && this._setIdentity(),
        this._mixBufferRegionAdditive(t, c, 0, e, o),
        this.cumulativeWeightAdditive += e
    }
    apply(e) {
        let t = this.valueSize
          , o = this.buffer
          , c = e * t + t
          , d = this.cumulativeWeight
          , p = this.cumulativeWeightAdditive
          , i = this.binding;
        if (this.cumulativeWeight = 0,
        this.cumulativeWeightAdditive = 0,
        d < 1) {
            let v = t * this._origIndex;
            this._mixBufferRegion(o, c, v, 1 - d, t)
        }
        p > 0 && this._mixBufferRegionAdditive(o, c, this._addIndex * t, 1, t);
        for (let v = t, x = t + t; v !== x; ++v)
            if (o[v] !== o[v + t]) {
                i.setValue(o, c);
                break
            }
    }
    saveOriginalState() {
        let e = this.binding
          , t = this.buffer
          , o = this.valueSize
          , c = o * this._origIndex;
        e.getValue(t, c);
        for (let d = o, p = c; d !== p; ++d)
            t[d] = t[c + d % o];
        this._setIdentity(),
        this.cumulativeWeight = 0,
        this.cumulativeWeightAdditive = 0
    }
    restoreOriginalState() {
        let e = this.valueSize * 3;
        this.binding.setValue(this.buffer, e)
    }
    _setAdditiveIdentityNumeric() {
        let e = this._addIndex * this.valueSize
          , t = e + this.valueSize;
        for (let o = e; o < t; o++)
            this.buffer[o] = 0
    }
    _setAdditiveIdentityQuaternion() {
        this._setAdditiveIdentityNumeric(),
        this.buffer[this._addIndex * this.valueSize + 3] = 1
    }
    _setAdditiveIdentityOther() {
        let e = this._origIndex * this.valueSize
          , t = this._addIndex * this.valueSize;
        for (let o = 0; o < this.valueSize; o++)
            this.buffer[t + o] = this.buffer[e + o]
    }
    _select(e, t, o, c, d) {
        if (c >= .5)
            for (let p = 0; p !== d; ++p)
                e[t + p] = e[o + p]
    }
    _slerp(e, t, o, c) {
        Ur.slerpFlat(e, t, e, t, e, o, c)
    }
    _slerpAdditive(e, t, o, c, d) {
        let p = this._workIndex * d;
        Ur.multiplyQuaternionsFlat(e, p, e, t, e, o),
        Ur.slerpFlat(e, t, e, t, e, p, c)
    }
    _lerp(e, t, o, c, d) {
        let p = 1 - c;
        for (let i = 0; i !== d; ++i) {
            let v = t + i;
            e[v] = e[v] * p + e[o + i] * c
        }
    }
    _lerpAdditive(e, t, o, c, d) {
        for (let p = 0; p !== d; ++p) {
            let i = t + p;
            e[i] = e[i] + e[o + p] * c
        }
    }
}
  , dw = "\\[\\]\\.:\\/"
  , U5 = new RegExp("[" + dw + "]","g")
  , fw = "[^" + dw + "]"
  , V5 = "[^" + dw.replace("\\.", "") + "]"
  , G5 = /((?:WC+[\/:])*)/.source.replace("WC", fw)
  , H5 = /(WCOD+)?/.source.replace("WCOD", V5)
  , W5 = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", fw)
  , j5 = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", fw)
  , X5 = new RegExp("^" + G5 + H5 + W5 + j5 + "$")
  , Z5 = ["material", "materials", "bones"]
  , zI = class {
    constructor(e, t, o) {
        let c = o || wi.parseTrackName(t);
        this._targetGroup = e,
        this._bindings = e.subscribe_(t, c)
    }
    getValue(e, t) {
        this.bind();
        let o = this._targetGroup.nCachedObjects_
          , c = this._bindings[o];
        c !== void 0 && c.getValue(e, t)
    }
    setValue(e, t) {
        let o = this._bindings;
        for (let c = this._targetGroup.nCachedObjects_, d = o.length; c !== d; ++c)
            o[c].setValue(e, t)
    }
    bind() {
        let e = this._bindings;
        for (let t = this._targetGroup.nCachedObjects_, o = e.length; t !== o; ++t)
            e[t].bind()
    }
    unbind() {
        let e = this._bindings;
        for (let t = this._targetGroup.nCachedObjects_, o = e.length; t !== o; ++t)
            e[t].unbind()
    }
}
  , wi = class {
    constructor(e, t, o) {
        this.path = t,
        this.parsedPath = o || wi.parseTrackName(t),
        this.node = wi.findNode(e, this.parsedPath.nodeName) || e,
        this.rootNode = e,
        this.getValue = this._getValue_unbound,
        this.setValue = this._setValue_unbound
    }
    static create(e, t, o) {
        return e && e.isAnimationObjectGroup ? new wi.Composite(e,t,o) : new wi(e,t,o)
    }
    static sanitizeNodeName(e) {
        return e.replace(/\s/g, "_").replace(U5, "")
    }
    static parseTrackName(e) {
        let t = X5.exec(e);
        if (t === null)
            throw new Error("PropertyBinding: Cannot parse trackName: " + e);
        let o = {
            nodeName: t[2],
            objectName: t[3],
            objectIndex: t[4],
            propertyName: t[5],
            propertyIndex: t[6]
        }
          , c = o.nodeName && o.nodeName.lastIndexOf(".");
        if (c !== void 0 && c !== -1) {
            let d = o.nodeName.substring(c + 1);
            Z5.indexOf(d) !== -1 && (o.nodeName = o.nodeName.substring(0, c),
            o.objectName = d)
        }
        if (o.propertyName === null || o.propertyName.length === 0)
            throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
        return o
    }
    static findNode(e, t) {
        if (t === void 0 || t === "" || t === "." || t === -1 || t === e.name || t === e.uuid)
            return e;
        if (e.skeleton) {
            let o = e.skeleton.getBoneByName(t);
            if (o !== void 0)
                return o
        }
        if (e.children) {
            let o = function(d) {
                for (let p = 0; p < d.length; p++) {
                    let i = d[p];
                    if (i.name === t || i.uuid === t)
                        return i;
                    let v = o(i.children);
                    if (v)
                        return v
                }
                return null
            }
              , c = o(e.children);
            if (c)
                return c
        }
        return null
    }
    _getValue_unavailable() {}
    _setValue_unavailable() {}
    _getValue_direct(e, t) {
        e[t] = this.targetObject[this.propertyName]
    }
    _getValue_array(e, t) {
        let o = this.resolvedProperty;
        for (let c = 0, d = o.length; c !== d; ++c)
            e[t++] = o[c]
    }
    _getValue_arrayElement(e, t) {
        e[t] = this.resolvedProperty[this.propertyIndex]
    }
    _getValue_toArray(e, t) {
        this.resolvedProperty.toArray(e, t)
    }
    _setValue_direct(e, t) {
        this.targetObject[this.propertyName] = e[t]
    }
    _setValue_direct_setNeedsUpdate(e, t) {
        this.targetObject[this.propertyName] = e[t],
        this.targetObject.needsUpdate = !0
    }
    _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
        this.targetObject[this.propertyName] = e[t],
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_array(e, t) {
        let o = this.resolvedProperty;
        for (let c = 0, d = o.length; c !== d; ++c)
            o[c] = e[t++]
    }
    _setValue_array_setNeedsUpdate(e, t) {
        let o = this.resolvedProperty;
        for (let c = 0, d = o.length; c !== d; ++c)
            o[c] = e[t++];
        this.targetObject.needsUpdate = !0
    }
    _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
        let o = this.resolvedProperty;
        for (let c = 0, d = o.length; c !== d; ++c)
            o[c] = e[t++];
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_arrayElement(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t]
    }
    _setValue_arrayElement_setNeedsUpdate(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t],
        this.targetObject.needsUpdate = !0
    }
    _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t],
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_fromArray(e, t) {
        this.resolvedProperty.fromArray(e, t)
    }
    _setValue_fromArray_setNeedsUpdate(e, t) {
        this.resolvedProperty.fromArray(e, t),
        this.targetObject.needsUpdate = !0
    }
    _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
        this.resolvedProperty.fromArray(e, t),
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _getValue_unbound(e, t) {
        this.bind(),
        this.getValue(e, t)
    }
    _setValue_unbound(e, t) {
        this.bind(),
        this.setValue(e, t)
    }
    bind() {
        let e = this.node
          , t = this.parsedPath
          , o = t.objectName
          , c = t.propertyName
          , d = t.propertyIndex;
        if (e || (e = wi.findNode(this.rootNode, t.nodeName) || this.rootNode,
        this.node = e),
        this.getValue = this._getValue_unavailable,
        this.setValue = this._setValue_unavailable,
        !e) {
            console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
            return
        }
        if (o) {
            let x = t.objectIndex;
            switch (o) {
            case "materials":
                if (!e.material) {
                    console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                    return
                }
                if (!e.material.materials) {
                    console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                    return
                }
                e = e.material.materials;
                break;
            case "bones":
                if (!e.skeleton) {
                    console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                    return
                }
                e = e.skeleton.bones;
                for (let E = 0; E < e.length; E++)
                    if (e[E].name === x) {
                        x = E;
                        break
                    }
                break;
            default:
                if (e[o] === void 0) {
                    console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                    return
                }
                e = e[o]
            }
            if (x !== void 0) {
                if (e[x] === void 0) {
                    console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                    return
                }
                e = e[x]
            }
        }
        let p = e[c];
        if (p === void 0) {
            let x = t.nodeName;
            console.error("THREE.PropertyBinding: Trying to update property for track: " + x + "." + c + " but it wasn't found.", e);
            return
        }
        let i = this.Versioning.None;
        this.targetObject = e,
        e.needsUpdate !== void 0 ? i = this.Versioning.NeedsUpdate : e.matrixWorldNeedsUpdate !== void 0 && (i = this.Versioning.MatrixWorldNeedsUpdate);
        let v = this.BindingType.Direct;
        if (d !== void 0) {
            if (c === "morphTargetInfluences") {
                if (!e.geometry) {
                    console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                    return
                }
                if (e.geometry.isBufferGeometry) {
                    if (!e.geometry.morphAttributes) {
                        console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                        return
                    }
                    e.morphTargetDictionary[d] !== void 0 && (d = e.morphTargetDictionary[d])
                } else {
                    console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
                    return
                }
            }
            v = this.BindingType.ArrayElement,
            this.resolvedProperty = p,
            this.propertyIndex = d
        } else
            p.fromArray !== void 0 && p.toArray !== void 0 ? (v = this.BindingType.HasFromToArray,
            this.resolvedProperty = p) : Array.isArray(p) ? (v = this.BindingType.EntireArray,
            this.resolvedProperty = p) : this.propertyName = c;
        this.getValue = this.GetterByBindingType[v],
        this.setValue = this.SetterByBindingTypeAndVersioning[v][i]
    }
    unbind() {
        this.node = null,
        this.getValue = this._getValue_unbound,
        this.setValue = this._setValue_unbound
    }
}
;
wi.Composite = zI;
wi.prototype.BindingType = {
    Direct: 0,
    EntireArray: 1,
    ArrayElement: 2,
    HasFromToArray: 3
};
wi.prototype.Versioning = {
    None: 0,
    NeedsUpdate: 1,
    MatrixWorldNeedsUpdate: 2
};
wi.prototype.GetterByBindingType = [wi.prototype._getValue_direct, wi.prototype._getValue_array, wi.prototype._getValue_arrayElement, wi.prototype._getValue_toArray];
wi.prototype.SetterByBindingTypeAndVersioning = [[wi.prototype._setValue_direct, wi.prototype._setValue_direct_setNeedsUpdate, wi.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [wi.prototype._setValue_array, wi.prototype._setValue_array_setNeedsUpdate, wi.prototype._setValue_array_setMatrixWorldNeedsUpdate], [wi.prototype._setValue_arrayElement, wi.prototype._setValue_arrayElement_setNeedsUpdate, wi.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [wi.prototype._setValue_fromArray, wi.prototype._setValue_fromArray_setNeedsUpdate, wi.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];
var pw = class {
    constructor() {
        this.uuid = Uo(),
        this._objects = Array.prototype.slice.call(arguments),
        this.nCachedObjects_ = 0;
        let e = {};
        this._indicesByUUID = e;
        for (let o = 0, c = arguments.length; o !== c; ++o)
            e[arguments[o].uuid] = o;
        this._paths = [],
        this._parsedPaths = [],
        this._bindings = [],
        this._bindingsIndicesByPath = {};
        let t = this;
        this.stats = {
            objects: {
                get total() {
                    return t._objects.length
                },
                get inUse() {
                    return this.total - t.nCachedObjects_
                }
            },
            get bindingsPerObject() {
                return t._bindings.length
            }
        }
    }
    add() {
        let e = this._objects, t = this._indicesByUUID, o = this._paths, c = this._parsedPaths, d = this._bindings, p = d.length, i, v = e.length, x = this.nCachedObjects_;
        for (let E = 0, A = arguments.length; E !== A; ++E) {
            let C = arguments[E]
              , I = C.uuid
              , D = t[I];
            if (D === void 0) {
                D = v++,
                t[I] = D,
                e.push(C);
                for (let P = 0, k = p; P !== k; ++P)
                    d[P].push(new wi(C,o[P],c[P]))
            } else if (D < x) {
                i = e[D];
                let P = --x
                  , k = e[P];
                t[k.uuid] = D,
                e[D] = k,
                t[I] = P,
                e[P] = C;
                for (let U = 0, Z = p; U !== Z; ++U) {
                    let K = d[U]
                      , X = K[P]
                      , W = K[D];
                    K[D] = X,
                    W === void 0 && (W = new wi(C,o[U],c[U])),
                    K[P] = W
                }
            } else
                e[D] !== i && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
        }
        this.nCachedObjects_ = x
    }
    remove() {
        let e = this._objects
          , t = this._indicesByUUID
          , o = this._bindings
          , c = o.length
          , d = this.nCachedObjects_;
        for (let p = 0, i = arguments.length; p !== i; ++p) {
            let v = arguments[p]
              , x = v.uuid
              , E = t[x];
            if (E !== void 0 && E >= d) {
                let A = d++
                  , C = e[A];
                t[C.uuid] = E,
                e[E] = C,
                t[x] = A,
                e[A] = v;
                for (let I = 0, D = c; I !== D; ++I) {
                    let P = o[I]
                      , k = P[A]
                      , U = P[E];
                    P[E] = k,
                    P[A] = U
                }
            }
        }
        this.nCachedObjects_ = d
    }
    uncache() {
        let e = this._objects
          , t = this._indicesByUUID
          , o = this._bindings
          , c = o.length
          , d = this.nCachedObjects_
          , p = e.length;
        for (let i = 0, v = arguments.length; i !== v; ++i) {
            let x = arguments[i]
              , E = x.uuid
              , A = t[E];
            if (A !== void 0)
                if (delete t[E],
                A < d) {
                    let C = --d
                      , I = e[C]
                      , D = --p
                      , P = e[D];
                    t[I.uuid] = A,
                    e[A] = I,
                    t[P.uuid] = C,
                    e[C] = P,
                    e.pop();
                    for (let k = 0, U = c; k !== U; ++k) {
                        let Z = o[k]
                          , K = Z[C]
                          , X = Z[D];
                        Z[A] = K,
                        Z[C] = X,
                        Z.pop()
                    }
                } else {
                    let C = --p
                      , I = e[C];
                    C > 0 && (t[I.uuid] = A),
                    e[A] = I,
                    e.pop();
                    for (let D = 0, P = c; D !== P; ++D) {
                        let k = o[D];
                        k[A] = k[C],
                        k.pop()
                    }
                }
        }
        this.nCachedObjects_ = d
    }
    subscribe_(e, t) {
        let o = this._bindingsIndicesByPath
          , c = o[e]
          , d = this._bindings;
        if (c !== void 0)
            return d[c];
        let p = this._paths
          , i = this._parsedPaths
          , v = this._objects
          , x = v.length
          , E = this.nCachedObjects_
          , A = new Array(x);
        c = d.length,
        o[e] = c,
        p.push(e),
        i.push(t),
        d.push(A);
        for (let C = E, I = v.length; C !== I; ++C) {
            let D = v[C];
            A[C] = new wi(D,e,t)
        }
        return A
    }
    unsubscribe_(e) {
        let t = this._bindingsIndicesByPath
          , o = t[e];
        if (o !== void 0) {
            let c = this._paths
              , d = this._parsedPaths
              , p = this._bindings
              , i = p.length - 1
              , v = p[i]
              , x = e[i];
            t[x] = o,
            p[o] = v,
            p.pop(),
            d[o] = d[i],
            d.pop(),
            c[o] = c[i],
            c.pop()
        }
    }
}
;
pw.prototype.isAnimationObjectGroup = !0;
var OI = class {
    constructor(e, t, o=null, c=t.blendMode) {
        this._mixer = e,
        this._clip = t,
        this._localRoot = o,
        this.blendMode = c;
        let d = t.tracks
          , p = d.length
          , i = new Array(p)
          , v = {
            endingStart: ju,
            endingEnd: ju
        };
        for (let x = 0; x !== p; ++x) {
            let E = d[x].createInterpolant(null);
            i[x] = E,
            E.settings = v
        }
        this._interpolantSettings = v,
        this._interpolants = i,
        this._propertyBindings = new Array(p),
        this._cacheIndex = null,
        this._byClipCacheIndex = null,
        this._timeScaleInterpolant = null,
        this._weightInterpolant = null,
        this.loop = i2,
        this._loopCount = -1,
        this._startTime = null,
        this.time = 0,
        this.timeScale = 1,
        this._effectiveTimeScale = 1,
        this.weight = 1,
        this._effectiveWeight = 1,
        this.repetitions = Infinity,
        this.paused = !1,
        this.enabled = !0,
        this.clampWhenFinished = !1,
        this.zeroSlopeAtStart = !0,
        this.zeroSlopeAtEnd = !0
    }
    play() {
        return this._mixer._activateAction(this),
        this
    }
    stop() {
        return this._mixer._deactivateAction(this),
        this.reset()
    }
    reset() {
        return this.paused = !1,
        this.enabled = !0,
        this.time = 0,
        this._loopCount = -1,
        this._startTime = null,
        this.stopFading().stopWarping()
    }
    isRunning() {
        return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this)
    }
    isScheduled() {
        return this._mixer._isActiveAction(this)
    }
    startAt(e) {
        return this._startTime = e,
        this
    }
    setLoop(e, t) {
        return this.loop = e,
        this.repetitions = t,
        this
    }
    setEffectiveWeight(e) {
        return this.weight = e,
        this._effectiveWeight = this.enabled ? e : 0,
        this.stopFading()
    }
    getEffectiveWeight() {
        return this._effectiveWeight
    }
    fadeIn(e) {
        return this._scheduleFading(e, 0, 1)
    }
    fadeOut(e) {
        return this._scheduleFading(e, 1, 0)
    }
    crossFadeFrom(e, t, o) {
        if (e.fadeOut(t),
        this.fadeIn(t),
        o) {
            let c = this._clip.duration
              , d = e._clip.duration
              , p = d / c
              , i = c / d;
            e.warp(1, p, t),
            this.warp(i, 1, t)
        }
        return this
    }
    crossFadeTo(e, t, o) {
        return e.crossFadeFrom(this, t, o)
    }
    stopFading() {
        let e = this._weightInterpolant;
        return e !== null && (this._weightInterpolant = null,
        this._mixer._takeBackControlInterpolant(e)),
        this
    }
    setEffectiveTimeScale(e) {
        return this.timeScale = e,
        this._effectiveTimeScale = this.paused ? 0 : e,
        this.stopWarping()
    }
    getEffectiveTimeScale() {
        return this._effectiveTimeScale
    }
    setDuration(e) {
        return this.timeScale = this._clip.duration / e,
        this.stopWarping()
    }
    syncWith(e) {
        return this.time = e.time,
        this.timeScale = e.timeScale,
        this.stopWarping()
    }
    halt(e) {
        return this.warp(this._effectiveTimeScale, 0, e)
    }
    warp(e, t, o) {
        let c = this._mixer
          , d = c.time
          , p = this.timeScale
          , i = this._timeScaleInterpolant;
        i === null && (i = c._lendControlInterpolant(),
        this._timeScaleInterpolant = i);
        let v = i.parameterPositions
          , x = i.sampleValues;
        return v[0] = d,
        v[1] = d + o,
        x[0] = e / p,
        x[1] = t / p,
        this
    }
    stopWarping() {
        let e = this._timeScaleInterpolant;
        return e !== null && (this._timeScaleInterpolant = null,
        this._mixer._takeBackControlInterpolant(e)),
        this
    }
    getMixer() {
        return this._mixer
    }
    getClip() {
        return this._clip
    }
    getRoot() {
        return this._localRoot || this._mixer._root
    }
    _update(e, t, o, c) {
        if (!this.enabled) {
            this._updateWeight(e);
            return
        }
        let d = this._startTime;
        if (d !== null) {
            let v = (e - d) * o;
            if (v < 0 || o === 0)
                return;
            this._startTime = null,
            t = o * v
        }
        t *= this._updateTimeScale(e);
        let p = this._updateTime(t)
          , i = this._updateWeight(e);
        if (i > 0) {
            let v = this._interpolants
              , x = this._propertyBindings;
            switch (this.blendMode) {
            case N1:
                for (let E = 0, A = v.length; E !== A; ++E)
                    v[E].evaluate(p),
                    x[E].accumulateAdditive(i);
                break;
            case Py:
            default:
                for (let E = 0, A = v.length; E !== A; ++E)
                    v[E].evaluate(p),
                    x[E].accumulate(c, i)
            }
        }
    }
    _updateWeight(e) {
        let t = 0;
        if (this.enabled) {
            t = this.weight;
            let o = this._weightInterpolant;
            if (o !== null) {
                let c = o.evaluate(e)[0];
                t *= c,
                e > o.parameterPositions[1] && (this.stopFading(),
                c === 0 && (this.enabled = !1))
            }
        }
        return this._effectiveWeight = t,
        t
    }
    _updateTimeScale(e) {
        let t = 0;
        if (!this.paused) {
            t = this.timeScale;
            let o = this._timeScaleInterpolant;
            o !== null && (t *= o.evaluate(e)[0],
            e > o.parameterPositions[1] && (this.stopWarping(),
            t === 0 ? this.paused = !0 : this.timeScale = t))
        }
        return this._effectiveTimeScale = t,
        t
    }
    _updateTime(e) {
        let t = this._clip.duration
          , o = this.loop
          , c = this.time + e
          , d = this._loopCount
          , p = o === r2;
        if (e === 0)
            return d === -1 ? c : p && (d & 1) == 1 ? t - c : c;
        if (o === n2) {
            d === -1 && (this._loopCount = 0,
            this._setEndings(!0, !0, !1));
            e: {
                if (c >= t)
                    c = t;
                else if (c < 0)
                    c = 0;
                else {
                    this.time = c;
                    break e
                }
                this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                this.time = c,
                this._mixer.dispatchEvent({
                    type: "finished",
                    action: this,
                    direction: e < 0 ? -1 : 1
                })
            }
        } else {
            if (d === -1 && (e >= 0 ? (d = 0,
            this._setEndings(!0, this.repetitions === 0, p)) : this._setEndings(this.repetitions === 0, !0, p)),
            c >= t || c < 0) {
                let i = Math.floor(c / t);
                c -= t * i,
                d += Math.abs(i);
                let v = this.repetitions - d;
                if (v <= 0)
                    this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                    c = e > 0 ? t : 0,
                    this.time = c,
                    this._mixer.dispatchEvent({
                        type: "finished",
                        action: this,
                        direction: e > 0 ? 1 : -1
                    });
                else {
                    if (v === 1) {
                        let x = e < 0;
                        this._setEndings(x, !x, p)
                    } else
                        this._setEndings(!1, !1, p);
                    this._loopCount = d,
                    this.time = c,
                    this._mixer.dispatchEvent({
                        type: "loop",
                        action: this,
                        loopDelta: i
                    })
                }
            } else
                this.time = c;
            if (p && (d & 1) == 1)
                return t - c
        }
        return c
    }
    _setEndings(e, t, o) {
        let c = this._interpolantSettings;
        o ? (c.endingStart = Xu,
        c.endingEnd = Xu) : (e ? c.endingStart = this.zeroSlopeAtStart ? Xu : ju : c.endingStart = _m,
        t ? c.endingEnd = this.zeroSlopeAtEnd ? Xu : ju : c.endingEnd = _m)
    }
    _scheduleFading(e, t, o) {
        let c = this._mixer
          , d = c.time
          , p = this._weightInterpolant;
        p === null && (p = c._lendControlInterpolant(),
        this._weightInterpolant = p);
        let i = p.parameterPositions
          , v = p.sampleValues;
        return i[0] = d,
        v[0] = t,
        i[1] = d + e,
        v[1] = o,
        this
    }
}
  , mw = class extends Bo {
    constructor(e) {
        super();
        this._root = e,
        this._initMemoryManager(),
        this._accuIndex = 0,
        this.time = 0,
        this.timeScale = 1
    }
    _bindAction(e, t) {
        let o = e._localRoot || this._root
          , c = e._clip.tracks
          , d = c.length
          , p = e._propertyBindings
          , i = e._interpolants
          , v = o.uuid
          , x = this._bindingsByRootAndName
          , E = x[v];
        E === void 0 && (E = {},
        x[v] = E);
        for (let A = 0; A !== d; ++A) {
            let C = c[A]
              , I = C.name
              , D = E[I];
            if (D !== void 0)
                ++D.referenceCount,
                p[A] = D;
            else {
                if (D = p[A],
                D !== void 0) {
                    D._cacheIndex === null && (++D.referenceCount,
                    this._addInactiveBinding(D, v, I));
                    continue
                }
                let P = t && t._propertyBindings[A].binding.parsedPath;
                D = new hw(wi.create(o, I, P),C.ValueTypeName,C.getValueSize()),
                ++D.referenceCount,
                this._addInactiveBinding(D, v, I),
                p[A] = D
            }
            i[A].resultBuffer = D.buffer
        }
    }
    _activateAction(e) {
        if (!this._isActiveAction(e)) {
            if (e._cacheIndex === null) {
                let o = (e._localRoot || this._root).uuid
                  , c = e._clip.uuid
                  , d = this._actionsByClip[c];
                this._bindAction(e, d && d.knownActions[0]),
                this._addInactiveAction(e, c, o)
            }
            let t = e._propertyBindings;
            for (let o = 0, c = t.length; o !== c; ++o) {
                let d = t[o];
                d.useCount++ == 0 && (this._lendBinding(d),
                d.saveOriginalState())
            }
            this._lendAction(e)
        }
    }
    _deactivateAction(e) {
        if (this._isActiveAction(e)) {
            let t = e._propertyBindings;
            for (let o = 0, c = t.length; o !== c; ++o) {
                let d = t[o];
                --d.useCount == 0 && (d.restoreOriginalState(),
                this._takeBackBinding(d))
            }
            this._takeBackAction(e)
        }
    }
    _initMemoryManager() {
        this._actions = [],
        this._nActiveActions = 0,
        this._actionsByClip = {},
        this._bindings = [],
        this._nActiveBindings = 0,
        this._bindingsByRootAndName = {},
        this._controlInterpolants = [],
        this._nActiveControlInterpolants = 0;
        let e = this;
        this.stats = {
            actions: {
                get total() {
                    return e._actions.length
                },
                get inUse() {
                    return e._nActiveActions
                }
            },
            bindings: {
                get total() {
                    return e._bindings.length
                },
                get inUse() {
                    return e._nActiveBindings
                }
            },
            controlInterpolants: {
                get total() {
                    return e._controlInterpolants.length
                },
                get inUse() {
                    return e._nActiveControlInterpolants
                }
            }
        }
    }
    _isActiveAction(e) {
        let t = e._cacheIndex;
        return t !== null && t < this._nActiveActions
    }
    _addInactiveAction(e, t, o) {
        let c = this._actions
          , d = this._actionsByClip
          , p = d[t];
        if (p === void 0)
            p = {
                knownActions: [e],
                actionByRoot: {}
            },
            e._byClipCacheIndex = 0,
            d[t] = p;
        else {
            let i = p.knownActions;
            e._byClipCacheIndex = i.length,
            i.push(e)
        }
        e._cacheIndex = c.length,
        c.push(e),
        p.actionByRoot[o] = e
    }
    _removeInactiveAction(e) {
        let t = this._actions
          , o = t[t.length - 1]
          , c = e._cacheIndex;
        o._cacheIndex = c,
        t[c] = o,
        t.pop(),
        e._cacheIndex = null;
        let d = e._clip.uuid
          , p = this._actionsByClip
          , i = p[d]
          , v = i.knownActions
          , x = v[v.length - 1]
          , E = e._byClipCacheIndex;
        x._byClipCacheIndex = E,
        v[E] = x,
        v.pop(),
        e._byClipCacheIndex = null;
        let A = i.actionByRoot
          , C = (e._localRoot || this._root).uuid;
        delete A[C],
        v.length === 0 && delete p[d],
        this._removeInactiveBindingsForAction(e)
    }
    _removeInactiveBindingsForAction(e) {
        let t = e._propertyBindings;
        for (let o = 0, c = t.length; o !== c; ++o) {
            let d = t[o];
            --d.referenceCount == 0 && this._removeInactiveBinding(d)
        }
    }
    _lendAction(e) {
        let t = this._actions
          , o = e._cacheIndex
          , c = this._nActiveActions++
          , d = t[c];
        e._cacheIndex = c,
        t[c] = e,
        d._cacheIndex = o,
        t[o] = d
    }
    _takeBackAction(e) {
        let t = this._actions
          , o = e._cacheIndex
          , c = --this._nActiveActions
          , d = t[c];
        e._cacheIndex = c,
        t[c] = e,
        d._cacheIndex = o,
        t[o] = d
    }
    _addInactiveBinding(e, t, o) {
        let c = this._bindingsByRootAndName
          , d = this._bindings
          , p = c[t];
        p === void 0 && (p = {},
        c[t] = p),
        p[o] = e,
        e._cacheIndex = d.length,
        d.push(e)
    }
    _removeInactiveBinding(e) {
        let t = this._bindings
          , o = e.binding
          , c = o.rootNode.uuid
          , d = o.path
          , p = this._bindingsByRootAndName
          , i = p[c]
          , v = t[t.length - 1]
          , x = e._cacheIndex;
        v._cacheIndex = x,
        t[x] = v,
        t.pop(),
        delete i[d],
        Object.keys(i).length === 0 && delete p[c]
    }
    _lendBinding(e) {
        let t = this._bindings
          , o = e._cacheIndex
          , c = this._nActiveBindings++
          , d = t[c];
        e._cacheIndex = c,
        t[c] = e,
        d._cacheIndex = o,
        t[o] = d
    }
    _takeBackBinding(e) {
        let t = this._bindings
          , o = e._cacheIndex
          , c = --this._nActiveBindings
          , d = t[c];
        e._cacheIndex = c,
        t[c] = e,
        d._cacheIndex = o,
        t[o] = d
    }
    _lendControlInterpolant() {
        let e = this._controlInterpolants
          , t = this._nActiveControlInterpolants++
          , o = e[t];
        return o === void 0 && (o = new N0(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer),
        o.__cacheIndex = t,
        e[t] = o),
        o
    }
    _takeBackControlInterpolant(e) {
        let t = this._controlInterpolants
          , o = e.__cacheIndex
          , c = --this._nActiveControlInterpolants
          , d = t[c];
        e.__cacheIndex = c,
        t[c] = e,
        d.__cacheIndex = o,
        t[o] = d
    }
    clipAction(e, t, o) {
        let c = t || this._root
          , d = c.uuid
          , p = typeof e == "string" ? B0.findByName(c, e) : e
          , i = p !== null ? p.uuid : e
          , v = this._actionsByClip[i]
          , x = null;
        if (o === void 0 && (p !== null ? o = p.blendMode : o = Py),
        v !== void 0) {
            let A = v.actionByRoot[d];
            if (A !== void 0 && A.blendMode === o)
                return A;
            x = v.knownActions[0],
            p === null && (p = x._clip)
        }
        if (p === null)
            return null;
        let E = new OI(this,p,t,o);
        return this._bindAction(E, x),
        this._addInactiveAction(E, i, d),
        E
    }
    existingAction(e, t) {
        let o = t || this._root
          , c = o.uuid
          , d = typeof e == "string" ? B0.findByName(o, e) : e
          , p = d ? d.uuid : e
          , i = this._actionsByClip[p];
        return i !== void 0 && i.actionByRoot[c] || null
    }
    stopAllAction() {
        let e = this._actions
          , t = this._nActiveActions;
        for (let o = t - 1; o >= 0; --o)
            e[o].stop();
        return this
    }
    update(e) {
        e *= this.timeScale;
        let t = this._actions
          , o = this._nActiveActions
          , c = this.time += e
          , d = Math.sign(e)
          , p = this._accuIndex ^= 1;
        for (let x = 0; x !== o; ++x)
            t[x]._update(c, e, d, p);
        let i = this._bindings
          , v = this._nActiveBindings;
        for (let x = 0; x !== v; ++x)
            i[x].apply(p);
        return this
    }
    setTime(e) {
        this.time = 0;
        for (let t = 0; t < this._actions.length; t++)
            this._actions[t].time = 0;
        return this.update(e)
    }
    getRoot() {
        return this._root
    }
    uncacheClip(e) {
        let t = this._actions
          , o = e.uuid
          , c = this._actionsByClip
          , d = c[o];
        if (d !== void 0) {
            let p = d.knownActions;
            for (let i = 0, v = p.length; i !== v; ++i) {
                let x = p[i];
                this._deactivateAction(x);
                let E = x._cacheIndex
                  , A = t[t.length - 1];
                x._cacheIndex = null,
                x._byClipCacheIndex = null,
                A._cacheIndex = E,
                t[E] = A,
                t.pop(),
                this._removeInactiveBindingsForAction(x)
            }
            delete c[o]
        }
    }
    uncacheRoot(e) {
        let t = e.uuid
          , o = this._actionsByClip;
        for (let p in o) {
            let i = o[p].actionByRoot
              , v = i[t];
            v !== void 0 && (this._deactivateAction(v),
            this._removeInactiveAction(v))
        }
        let c = this._bindingsByRootAndName
          , d = c[t];
        if (d !== void 0)
            for (let p in d) {
                let i = d[p];
                i.restoreOriginalState(),
                this._removeInactiveBinding(i)
            }
    }
    uncacheAction(e, t) {
        let o = this.existingAction(e, t);
        o !== null && (this._deactivateAction(o),
        this._removeInactiveAction(o))
    }
}
;
mw.prototype._controlInterpolantsResultBuffer = new Float32Array(1);
var Jm = class {
    constructor(e) {
        typeof e == "string" && (console.warn("THREE.Uniform: Type parameter is no longer needed."),
        e = arguments[1]),
        this.value = e
    }
    clone() {
        return new Jm(this.value.clone === void 0 ? this.value : this.value.clone())
    }
}
  , gw = class extends th {
    constructor(e, t, o=1) {
        super(e, t);
        this.meshPerAttribute = o
    }
    copy(e) {
        return super.copy(e),
        this.meshPerAttribute = e.meshPerAttribute,
        this
    }
    clone(e) {
        let t = super.clone(e);
        return t.meshPerAttribute = this.meshPerAttribute,
        t
    }
    toJSON(e) {
        let t = super.toJSON(e);
        return t.isInstancedInterleavedBuffer = !0,
        t.meshPerAttribute = this.meshPerAttribute,
        t
    }
}
;
gw.prototype.isInstancedInterleavedBuffer = !0;
var _w = class {
    constructor(e, t, o, c, d) {
        this.buffer = e,
        this.type = t,
        this.itemSize = o,
        this.elementSize = c,
        this.count = d,
        this.version = 0
    }
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    setBuffer(e) {
        return this.buffer = e,
        this
    }
    setType(e, t) {
        return this.type = e,
        this.elementSize = t,
        this
    }
    setItemSize(e) {
        return this.itemSize = e,
        this
    }
    setCount(e) {
        return this.count = e,
        this
    }
}
;
_w.prototype.isGLBufferAttribute = !0;
var $m = class {
    constructor(e=1, t=0, o=0) {
        return this.radius = e,
        this.phi = t,
        this.theta = o,
        this
    }
    set(e, t, o) {
        return this.radius = e,
        this.phi = t,
        this.theta = o,
        this
    }
    copy(e) {
        return this.radius = e.radius,
        this.phi = e.phi,
        this.theta = e.theta,
        this
    }
    makeSafe() {
        let e = 1e-6;
        return this.phi = Math.max(e, Math.min(Math.PI - e, this.phi)),
        this
    }
    setFromVector3(e) {
        return this.setFromCartesianCoords(e.x, e.y, e.z)
    }
    setFromCartesianCoords(e, t, o) {
        return this.radius = Math.sqrt(e * e + t * t + o * o),
        this.radius === 0 ? (this.theta = 0,
        this.phi = 0) : (this.theta = Math.atan2(e, o),
        this.phi = Math.acos(rs(t / this.radius, -1, 1))),
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
;
var NI = new zt
  , ah = class {
    constructor(e=new zt(Infinity,Infinity), t=new zt(-Infinity,-Infinity)) {
        this.min = e,
        this.max = t
    }
    set(e, t) {
        return this.min.copy(e),
        this.max.copy(t),
        this
    }
    setFromPoints(e) {
        this.makeEmpty();
        for (let t = 0, o = e.length; t < o; t++)
            this.expandByPoint(e[t]);
        return this
    }
    setFromCenterAndSize(e, t) {
        let o = NI.copy(t).multiplyScalar(.5);
        return this.min.copy(e).sub(o),
        this.max.copy(e).add(o),
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.min.copy(e.min),
        this.max.copy(e.max),
        this
    }
    makeEmpty() {
        return this.min.x = this.min.y = Infinity,
        this.max.x = this.max.y = -Infinity,
        this
    }
    isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y
    }
    getCenter(e) {
        return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
    }
    getSize(e) {
        return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min)
    }
    expandByPoint(e) {
        return this.min.min(e),
        this.max.max(e),
        this
    }
    expandByVector(e) {
        return this.min.sub(e),
        this.max.add(e),
        this
    }
    expandByScalar(e) {
        return this.min.addScalar(-e),
        this.max.addScalar(e),
        this
    }
    containsPoint(e) {
        return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y)
    }
    containsBox(e) {
        return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y
    }
    getParameter(e, t) {
        return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y))
    }
    intersectsBox(e) {
        return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y)
    }
    clampPoint(e, t) {
        return t.copy(e).clamp(this.min, this.max)
    }
    distanceToPoint(e) {
        return NI.copy(e).clamp(this.min, this.max).sub(e).length()
    }
    intersect(e) {
        return this.min.max(e.min),
        this.max.min(e.max),
        this
    }
    union(e) {
        return this.min.min(e.min),
        this.max.max(e.max),
        this
    }
    translate(e) {
        return this.min.add(e),
        this.max.add(e),
        this
    }
    equals(e) {
        return e.min.equals(this.min) && e.max.equals(this.max)
    }
}
;
ah.prototype.isBox2 = !0;
var FI = new Oe
  , W0 = new Oe
  , yw = class {
    constructor(e=new Oe, t=new Oe) {
        this.start = e,
        this.end = t
    }
    set(e, t) {
        return this.start.copy(e),
        this.end.copy(t),
        this
    }
    copy(e) {
        return this.start.copy(e.start),
        this.end.copy(e.end),
        this
    }
    getCenter(e) {
        return e.addVectors(this.start, this.end).multiplyScalar(.5)
    }
    delta(e) {
        return e.subVectors(this.end, this.start)
    }
    distanceSq() {
        return this.start.distanceToSquared(this.end)
    }
    distance() {
        return this.start.distanceTo(this.end)
    }
    at(e, t) {
        return this.delta(t).multiplyScalar(e).add(this.start)
    }
    closestPointToPointParameter(e, t) {
        FI.subVectors(e, this.start),
        W0.subVectors(this.end, this.start);
        let o = W0.dot(W0)
          , d = W0.dot(FI) / o;
        return t && (d = rs(d, 0, 1)),
        d
    }
    closestPointToPoint(e, t, o) {
        let c = this.closestPointToPointParameter(e, t);
        return this.delta(o).multiplyScalar(c).add(this.start)
    }
    applyMatrix4(e) {
        return this.start.applyMatrix4(e),
        this.end.applyMatrix4(e),
        this
    }
    equals(e) {
        return e.start.equals(this.start) && e.end.equals(this.end)
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
;
var wc = new Oe
  , j0 = new Fn
  , xw = new Fn
  , vw = class extends rf {
    constructor(e) {
        let t = BI(e)
          , o = new Vi
          , c = []
          , d = []
          , p = new In(0,0,1)
          , i = new In(0,1,0);
        for (let x = 0; x < t.length; x++) {
            let E = t[x];
            E.parent && E.parent.isBone && (c.push(0, 0, 0),
            c.push(0, 0, 0),
            d.push(p.r, p.g, p.b),
            d.push(i.r, i.g, i.b))
        }
        o.setAttribute("position", new xr(c,3)),
        o.setAttribute("color", new xr(d,3));
        let v = new ll({
            vertexColors: !0,
            depthTest: !1,
            depthWrite: !1,
            toneMapped: !1,
            transparent: !0
        });
        super(o, v);
        this.type = "SkeletonHelper",
        this.isSkeletonHelper = !0,
        this.root = e,
        this.bones = t,
        this.matrix = e.matrixWorld,
        this.matrixAutoUpdate = !1
    }
    updateMatrixWorld(e) {
        let t = this.bones
          , o = this.geometry
          , c = o.getAttribute("position");
        xw.copy(this.root.matrixWorld).invert();
        for (let d = 0, p = 0; d < t.length; d++) {
            let i = t[d];
            i.parent && i.parent.isBone && (j0.multiplyMatrices(xw, i.matrixWorld),
            wc.setFromMatrixPosition(j0),
            c.setXYZ(p, wc.x, wc.y, wc.z),
            j0.multiplyMatrices(xw, i.parent.matrixWorld),
            wc.setFromMatrixPosition(j0),
            c.setXYZ(p + 1, wc.x, wc.y, wc.z),
            p += 2)
        }
        o.getAttribute("position").needsUpdate = !0,
        super.updateMatrixWorld(e)
    }
}
;
function BI(r) {
    let e = [];
    r.isBone === !0 && e.push(r);
    for (let t = 0; t < r.children.length; t++)
        e.push.apply(e, BI(r.children[t]));
    return e
}
var bw = class extends rf {
    constructor(e=10, t=10, o=4473924, c=8947848) {
        o = new In(o),
        c = new In(c);
        let d = t / 2
          , p = e / t
          , i = e / 2
          , v = []
          , x = [];
        for (let C = 0, I = 0, D = -i; C <= t; C++,
        D += p) {
            v.push(-i, 0, D, i, 0, D),
            v.push(D, 0, -i, D, 0, i);
            let P = C === d ? o : c;
            P.toArray(x, I),
            I += 3,
            P.toArray(x, I),
            I += 3,
            P.toArray(x, I),
            I += 3,
            P.toArray(x, I),
            I += 3
        }
        let E = new Vi;
        E.setAttribute("position", new xr(v,3)),
        E.setAttribute("color", new xr(x,3));
        let A = new ll({
            vertexColors: !0,
            toneMapped: !1
        });
        super(E, A);
        this.type = "GridHelper"
    }
}
;
var X0 = class extends rf {
    constructor(e=1) {
        let t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e]
          , o = [1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1]
          , c = new Vi;
        c.setAttribute("position", new xr(t,3)),
        c.setAttribute("color", new xr(o,3));
        let d = new ll({
            vertexColors: !0,
            toneMapped: !1
        });
        super(c, d);
        this.type = "AxesHelper"
    }
    setColors(e, t, o) {
        let c = new In
          , d = this.geometry.attributes.color.array;
        return c.set(e),
        c.toArray(d, 0),
        c.toArray(d, 3),
        c.set(t),
        c.toArray(d, 6),
        c.toArray(d, 9),
        c.set(o),
        c.toArray(d, 12),
        c.toArray(d, 15),
        this.geometry.attributes.color.needsUpdate = !0,
        this
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose()
    }
}
;
var UI = new ArrayBuffer(4)
  , GG = new Float32Array(UI)
  , HG = new Uint32Array(UI)
  , Ea = new Uint32Array(512)
  , Sa = new Uint32Array(512);
for (let r = 0; r < 256; ++r) {
    let e = r - 127;
    e < -27 ? (Ea[r] = 0,
    Ea[r | 256] = 32768,
    Sa[r] = 24,
    Sa[r | 256] = 24) : e < -14 ? (Ea[r] = 1024 >> -e - 14,
    Ea[r | 256] = 1024 >> -e - 14 | 32768,
    Sa[r] = -e - 1,
    Sa[r | 256] = -e - 1) : e <= 15 ? (Ea[r] = e + 15 << 10,
    Ea[r | 256] = e + 15 << 10 | 32768,
    Sa[r] = 13,
    Sa[r | 256] = 13) : e < 128 ? (Ea[r] = 31744,
    Ea[r | 256] = 64512,
    Sa[r] = 24,
    Sa[r | 256] = 24) : (Ea[r] = 31744,
    Ea[r | 256] = 64512,
    Sa[r] = 13,
    Sa[r | 256] = 13)
}
var VI = new Uint32Array(2048)
  , Qm = new Uint32Array(64)
  , q5 = new Uint32Array(64);
for (let r = 1; r < 1024; ++r) {
    let e = r << 13
      , t = 0;
    for (; (e & 8388608) == 0; )
        e <<= 1,
        t -= 8388608;
    e &= ~8388608,
    t += 947912704,
    VI[r] = e | t
}
for (let r = 1024; r < 2048; ++r)
    VI[r] = 939524096 + (r - 1024 << 13);
for (let r = 1; r < 31; ++r)
    Qm[r] = r << 23;
Qm[31] = 1199570944;
Qm[32] = 2147483648;
for (let r = 33; r < 63; ++r)
    Qm[r] = 2147483648 + (r - 32 << 23);
Qm[63] = 3347054592;
for (let r = 1; r < 64; ++r)
    r !== 32 && (q5[r] = 1024);
qs.create = function(r, e) {
    return console.log("THREE.Curve.create() has been deprecated"),
    r.prototype = Object.create(qs.prototype),
    r.prototype.constructor = r,
    r.prototype.getPoint = e,
    r
}
;
Wm.prototype.fromPoints = function(r) {
    return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."),
    this.setFromPoints(r)
}
;
bw.prototype.setColors = function() {
    console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
}
;
vw.prototype.update = function() {
    console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
}
;
Ta.prototype.extractUrlBase = function(r) {
    return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."),
    iw.extractUrlBase(r)
}
;
Ta.Handlers = {
    add: function() {
        console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")
    },
    get: function() {
        console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")
    }
};
ah.prototype.center = function(r) {
    return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."),
    this.getCenter(r)
}
;
ah.prototype.empty = function() {
    return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."),
    this.isEmpty()
}
;
ah.prototype.isIntersectionBox = function(r) {
    return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."),
    this.intersectsBox(r)
}
;
ah.prototype.size = function(r) {
    return console.warn("THREE.Box2: .size() has been renamed to .getSize()."),
    this.getSize(r)
}
;
io.prototype.center = function(r) {
    return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),
    this.getCenter(r)
}
;
io.prototype.empty = function() {
    return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),
    this.isEmpty()
}
;
io.prototype.isIntersectionBox = function(r) {
    return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),
    this.intersectsBox(r)
}
;
io.prototype.isIntersectionSphere = function(r) {
    return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),
    this.intersectsSphere(r)
}
;
io.prototype.size = function(r) {
    return console.warn("THREE.Box3: .size() has been renamed to .getSize()."),
    this.getSize(r)
}
;
il.prototype.toVector3 = function() {
    console.error("THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead")
}
;
uc.prototype.empty = function() {
    return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."),
    this.isEmpty()
}
;
Zd.prototype.setFromMatrix = function(r) {
    return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."),
    this.setFromProjectionMatrix(r)
}
;
yw.prototype.center = function(r) {
    return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."),
    this.getCenter(r)
}
;
Fr.prototype.flattenToArrayOffset = function(r, e) {
    return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),
    this.toArray(r, e)
}
;
Fr.prototype.multiplyVector3 = function(r) {
    return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),
    r.applyMatrix3(this)
}
;
Fr.prototype.multiplyVector3Array = function() {
    console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
}
;
Fr.prototype.applyToBufferAttribute = function(r) {
    return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."),
    r.applyMatrix3(this)
}
;
Fr.prototype.applyToVector3Array = function() {
    console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
}
;
Fr.prototype.getInverse = function(r) {
    return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),
    this.copy(r).invert()
}
;
Fn.prototype.extractPosition = function(r) {
    return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),
    this.copyPosition(r)
}
;
Fn.prototype.flattenToArrayOffset = function(r, e) {
    return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),
    this.toArray(r, e)
}
;
Fn.prototype.getPosition = function() {
    return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),
    new Oe().setFromMatrixColumn(this, 3)
}
;
Fn.prototype.setRotationFromQuaternion = function(r) {
    return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),
    this.makeRotationFromQuaternion(r)
}
;
Fn.prototype.multiplyToArray = function() {
    console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
}
;
Fn.prototype.multiplyVector3 = function(r) {
    return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."),
    r.applyMatrix4(this)
}
;
Fn.prototype.multiplyVector4 = function(r) {
    return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),
    r.applyMatrix4(this)
}
;
Fn.prototype.multiplyVector3Array = function() {
    console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
}
;
Fn.prototype.rotateAxis = function(r) {
    console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),
    r.transformDirection(this)
}
;
Fn.prototype.crossVector = function(r) {
    return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),
    r.applyMatrix4(this)
}
;
Fn.prototype.translate = function() {
    console.error("THREE.Matrix4: .translate() has been removed.")
}
;
Fn.prototype.rotateX = function() {
    console.error("THREE.Matrix4: .rotateX() has been removed.")
}
;
Fn.prototype.rotateY = function() {
    console.error("THREE.Matrix4: .rotateY() has been removed.")
}
;
Fn.prototype.rotateZ = function() {
    console.error("THREE.Matrix4: .rotateZ() has been removed.")
}
;
Fn.prototype.rotateByAxis = function() {
    console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
}
;
Fn.prototype.applyToBufferAttribute = function(r) {
    return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."),
    r.applyMatrix4(this)
}
;
Fn.prototype.applyToVector3Array = function() {
    console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
}
;
Fn.prototype.makeFrustum = function(r, e, t, o, c, d) {
    return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."),
    this.makePerspective(r, e, o, t, c, d)
}
;
Fn.prototype.getInverse = function(r) {
    return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),
    this.copy(r).invert()
}
;
Wo.prototype.isIntersectionLine = function(r) {
    return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),
    this.intersectsLine(r)
}
;
Ur.prototype.multiplyVector3 = function(r) {
    return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),
    r.applyQuaternion(this)
}
;
Ur.prototype.inverse = function() {
    return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."),
    this.invert()
}
;
dc.prototype.isIntersectionBox = function(r) {
    return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),
    this.intersectsBox(r)
}
;
dc.prototype.isIntersectionPlane = function(r) {
    return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),
    this.intersectsPlane(r)
}
;
dc.prototype.isIntersectionSphere = function(r) {
    return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),
    this.intersectsSphere(r)
}
;
yr.prototype.area = function() {
    return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),
    this.getArea()
}
;
yr.prototype.barycoordFromPoint = function(r, e) {
    return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),
    this.getBarycoord(r, e)
}
;
yr.prototype.midpoint = function(r) {
    return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."),
    this.getMidpoint(r)
}
;
yr.prototypenormal = function(r) {
    return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),
    this.getNormal(r)
}
;
yr.prototype.plane = function(r) {
    return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."),
    this.getPlane(r)
}
;
yr.barycoordFromPoint = function(r, e, t, o, c) {
    return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),
    yr.getBarycoord(r, e, t, o, c)
}
;
yr.normal = function(r, e, t, o) {
    return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),
    yr.getNormal(r, e, t, o)
}
;
ih.prototype.extractAllPoints = function(r) {
    return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."),
    this.extractPoints(r)
}
;
ih.prototype.extrude = function(r) {
    return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."),
    new cl(this,r)
}
;
ih.prototype.makeGeometry = function(r) {
    return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."),
    new lf(this,r)
}
;
zt.prototype.fromAttribute = function(r, e, t) {
    return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."),
    this.fromBufferAttribute(r, e, t)
}
;
zt.prototype.distanceToManhattan = function(r) {
    return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),
    this.manhattanDistanceTo(r)
}
;
zt.prototype.lengthManhattan = function() {
    return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."),
    this.manhattanLength()
}
;
Oe.prototype.setEulerFromRotationMatrix = function() {
    console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
}
;
Oe.prototype.setEulerFromQuaternion = function() {
    console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
}
;
Oe.prototype.getPositionFromMatrix = function(r) {
    return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),
    this.setFromMatrixPosition(r)
}
;
Oe.prototype.getScaleFromMatrix = function(r) {
    return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),
    this.setFromMatrixScale(r)
}
;
Oe.prototype.getColumnFromMatrix = function(r, e) {
    return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),
    this.setFromMatrixColumn(e, r)
}
;
Oe.prototype.applyProjection = function(r) {
    return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."),
    this.applyMatrix4(r)
}
;
Oe.prototype.fromAttribute = function(r, e, t) {
    return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."),
    this.fromBufferAttribute(r, e, t)
}
;
Oe.prototype.distanceToManhattan = function(r) {
    return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),
    this.manhattanDistanceTo(r)
}
;
Oe.prototype.lengthManhattan = function() {
    return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."),
    this.manhattanLength()
}
;
Ui.prototype.fromAttribute = function(r, e, t) {
    return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."),
    this.fromBufferAttribute(r, e, t)
}
;
Ui.prototype.lengthManhattan = function() {
    return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."),
    this.manhattanLength()
}
;
Ai.prototype.getChildByName = function(r) {
    return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),
    this.getObjectByName(r)
}
;
Ai.prototype.renderDepth = function() {
    console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
}
;
Ai.prototype.translate = function(r, e) {
    return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),
    this.translateOnAxis(e, r)
}
;
Ai.prototype.getWorldRotation = function() {
    console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")
}
;
Ai.prototype.applyMatrix = function(r) {
    return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."),
    this.applyMatrix4(r)
}
;
Object.defineProperties(Ai.prototype, {
    eulerOrder: {
        get: function() {
            return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
            this.rotation.order
        },
        set: function(r) {
            console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
            this.rotation.order = r
        }
    },
    useQuaternion: {
        get: function() {
            console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
        },
        set: function() {
            console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
        }
    }
});
Ir.prototype.setDrawMode = function() {
    console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
}
;
Object.defineProperties(Ir.prototype, {
    drawMode: {
        get: function() {
            return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."),
            s2
        },
        set: function() {
            console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
        }
    }
});
g0.prototype.initBones = function() {
    console.error("THREE.SkinnedMesh: initBones() has been removed.")
}
;
os.prototype.setLens = function(r, e) {
    console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."),
    e !== void 0 && (this.filmGauge = e),
    this.setFocalLength(r)
}
;
Object.defineProperties(Eo.prototype, {
    onlyShadow: {
        set: function() {
            console.warn("THREE.Light: .onlyShadow has been removed.")
        }
    },
    shadowCameraFov: {
        set: function(r) {
            console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),
            this.shadow.camera.fov = r
        }
    },
    shadowCameraLeft: {
        set: function(r) {
            console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),
            this.shadow.camera.left = r
        }
    },
    shadowCameraRight: {
        set: function(r) {
            console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),
            this.shadow.camera.right = r
        }
    },
    shadowCameraTop: {
        set: function(r) {
            console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),
            this.shadow.camera.top = r
        }
    },
    shadowCameraBottom: {
        set: function(r) {
            console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),
            this.shadow.camera.bottom = r
        }
    },
    shadowCameraNear: {
        set: function(r) {
            console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),
            this.shadow.camera.near = r
        }
    },
    shadowCameraFar: {
        set: function(r) {
            console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),
            this.shadow.camera.far = r
        }
    },
    shadowCameraVisible: {
        set: function() {
            console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
        }
    },
    shadowBias: {
        set: function(r) {
            console.warn("THREE.Light: .shadowBias is now .shadow.bias."),
            this.shadow.bias = r
        }
    },
    shadowDarkness: {
        set: function() {
            console.warn("THREE.Light: .shadowDarkness has been removed.")
        }
    },
    shadowMapWidth: {
        set: function(r) {
            console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),
            this.shadow.mapSize.width = r
        }
    },
    shadowMapHeight: {
        set: function(r) {
            console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),
            this.shadow.mapSize.height = r
        }
    }
});
Object.defineProperties(or.prototype, {
    length: {
        get: function() {
            return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."),
            this.array.length
        }
    },
    dynamic: {
        get: function() {
            return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),
            this.usage === ym
        },
        set: function() {
            console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),
            this.setUsage(ym)
        }
    }
});
or.prototype.setDynamic = function(r) {
    return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."),
    this.setUsage(r === !0 ? ym : Cd),
    this
}
;
or.prototype.copyIndicesArray = function() {
    console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
}
,
or.prototype.setArray = function() {
    console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
}
;
Vi.prototype.addIndex = function(r) {
    console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),
    this.setIndex(r)
}
;
Vi.prototype.addAttribute = function(r, e) {
    return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."),
    !(e && e.isBufferAttribute) && !(e && e.isInterleavedBufferAttribute) ? (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),
    this.setAttribute(r, new or(arguments[1],arguments[2]))) : r === "index" ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),
    this.setIndex(e),
    this) : this.setAttribute(r, e)
}
;
Vi.prototype.addDrawCall = function(r, e, t) {
    t !== void 0 && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),
    console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),
    this.addGroup(r, e)
}
;
Vi.prototype.clearDrawCalls = function() {
    console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),
    this.clearGroups()
}
;
Vi.prototype.computeOffsets = function() {
    console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
}
;
Vi.prototype.removeAttribute = function(r) {
    return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."),
    this.deleteAttribute(r)
}
;
Vi.prototype.applyMatrix = function(r) {
    return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."),
    this.applyMatrix4(r)
}
;
Object.defineProperties(Vi.prototype, {
    drawcalls: {
        get: function() {
            return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),
            this.groups
        }
    },
    offsets: {
        get: function() {
            return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),
            this.groups
        }
    }
});
th.prototype.setDynamic = function(r) {
    return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."),
    this.setUsage(r === !0 ? ym : Cd),
    this
}
;
th.prototype.setArray = function() {
    console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
}
;
cl.prototype.getArrays = function() {
    console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")
}
;
cl.prototype.addShapeList = function() {
    console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")
}
;
cl.prototype.addShape = function() {
    console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")
}
;
$d.prototype.dispose = function() {
    console.error("THREE.Scene: .dispose() has been removed.")
}
;
Jm.prototype.onUpdate = function() {
    return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."),
    this
}
;
Object.defineProperties(wr.prototype, {
    wrapAround: {
        get: function() {
            console.warn("THREE.Material: .wrapAround has been removed.")
        },
        set: function() {
            console.warn("THREE.Material: .wrapAround has been removed.")
        }
    },
    overdraw: {
        get: function() {
            console.warn("THREE.Material: .overdraw has been removed.")
        },
        set: function() {
            console.warn("THREE.Material: .overdraw has been removed.")
        }
    },
    wrapRGB: {
        get: function() {
            return console.warn("THREE.Material: .wrapRGB has been removed."),
            new In
        }
    },
    shading: {
        get: function() {
            console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
        },
        set: function(r) {
            console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."),
            this.flatShading = r === s1
        }
    },
    stencilMask: {
        get: function() {
            return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."),
            this.stencilFuncMask
        },
        set: function(r) {
            console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."),
            this.stencilFuncMask = r
        }
    },
    vertexTangents: {
        get: function() {
            console.warn("THREE." + this.type + ": .vertexTangents has been removed.")
        },
        set: function() {
            console.warn("THREE." + this.type + ": .vertexTangents has been removed.")
        }
    }
});
Object.defineProperties(oo.prototype, {
    derivatives: {
        get: function() {
            return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),
            this.extensions.derivatives
        },
        set: function(r) {
            console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),
            this.extensions.derivatives = r
        }
    }
});
zi.prototype.clearTarget = function(r, e, t, o) {
    console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."),
    this.setRenderTarget(r),
    this.clear(e, t, o)
}
;
zi.prototype.animate = function(r) {
    console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."),
    this.setAnimationLoop(r)
}
;
zi.prototype.getCurrentRenderTarget = function() {
    return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."),
    this.getRenderTarget()
}
;
zi.prototype.getMaxAnisotropy = function() {
    return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."),
    this.capabilities.getMaxAnisotropy()
}
;
zi.prototype.getPrecision = function() {
    return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."),
    this.capabilities.precision
}
;
zi.prototype.resetGLState = function() {
    return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."),
    this.state.reset()
}
;
zi.prototype.supportsFloatTextures = function() {
    return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),
    this.extensions.get("OES_texture_float")
}
;
zi.prototype.supportsHalfFloatTextures = function() {
    return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),
    this.extensions.get("OES_texture_half_float")
}
;
zi.prototype.supportsStandardDerivatives = function() {
    return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),
    this.extensions.get("OES_standard_derivatives")
}
;
zi.prototype.supportsCompressedTextureS3TC = function() {
    return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),
    this.extensions.get("WEBGL_compressed_texture_s3tc")
}
;
zi.prototype.supportsCompressedTexturePVRTC = function() {
    return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),
    this.extensions.get("WEBGL_compressed_texture_pvrtc")
}
;
zi.prototype.supportsBlendMinMax = function() {
    return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),
    this.extensions.get("EXT_blend_minmax")
}
;
zi.prototype.supportsVertexTextures = function() {
    return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."),
    this.capabilities.vertexTextures
}
;
zi.prototype.supportsInstancedArrays = function() {
    return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),
    this.extensions.get("ANGLE_instanced_arrays")
}
;
zi.prototype.enableScissorTest = function(r) {
    console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),
    this.setScissorTest(r)
}
;
zi.prototype.initMaterial = function() {
    console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
}
;
zi.prototype.addPrePlugin = function() {
    console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
}
;
zi.prototype.addPostPlugin = function() {
    console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
}
;
zi.prototype.updateShadowMap = function() {
    console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
}
;
zi.prototype.setFaceCulling = function() {
    console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
}
;
zi.prototype.allocTextureUnit = function() {
    console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")
}
;
zi.prototype.setTexture = function() {
    console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")
}
;
zi.prototype.setTexture2D = function() {
    console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")
}
;
zi.prototype.setTextureCube = function() {
    console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")
}
;
zi.prototype.getActiveMipMapLevel = function() {
    return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."),
    this.getActiveMipmapLevel()
}
;
Object.defineProperties(zi.prototype, {
    shadowMapEnabled: {
        get: function() {
            return this.shadowMap.enabled
        },
        set: function(r) {
            console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),
            this.shadowMap.enabled = r
        }
    },
    shadowMapType: {
        get: function() {
            return this.shadowMap.type
        },
        set: function(r) {
            console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),
            this.shadowMap.type = r
        }
    },
    shadowMapCullFace: {
        get: function() {
            console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
        },
        set: function() {
            console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
        }
    },
    context: {
        get: function() {
            return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."),
            this.getContext()
        }
    },
    vr: {
        get: function() {
            return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),
            this.xr
        }
    },
    gammaInput: {
        get: function() {
            return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."),
            !1
        },
        set: function() {
            console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")
        }
    },
    gammaOutput: {
        get: function() {
            return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),
            !1
        },
        set: function(r) {
            console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),
            this.outputEncoding = r === !0 ? er : ya
        }
    },
    toneMappingWhitePoint: {
        get: function() {
            return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."),
            1
        },
        set: function() {
            console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")
        }
    },
    gammaFactor: {
        get: function() {
            return console.warn("THREE.WebGLRenderer: .gammaFactor has been removed."),
            2
        },
        set: function() {
            console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.")
        }
    }
});
Object.defineProperties(nI.prototype, {
    cullFace: {
        get: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
        },
        set: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
        }
    },
    renderReverseSided: {
        get: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
        },
        set: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
        }
    },
    renderSingleSided: {
        get: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
        },
        set: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
        }
    }
});
Object.defineProperties(Cs.prototype, {
    wrapS: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),
            this.texture.wrapS
        },
        set: function(r) {
            console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),
            this.texture.wrapS = r
        }
    },
    wrapT: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),
            this.texture.wrapT
        },
        set: function(r) {
            console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),
            this.texture.wrapT = r
        }
    },
    magFilter: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),
            this.texture.magFilter
        },
        set: function(r) {
            console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),
            this.texture.magFilter = r
        }
    },
    minFilter: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),
            this.texture.minFilter
        },
        set: function(r) {
            console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),
            this.texture.minFilter = r
        }
    },
    anisotropy: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),
            this.texture.anisotropy
        },
        set: function(r) {
            console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),
            this.texture.anisotropy = r
        }
    },
    offset: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),
            this.texture.offset
        },
        set: function(r) {
            console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),
            this.texture.offset = r
        }
    },
    repeat: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),
            this.texture.repeat
        },
        set: function(r) {
            console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),
            this.texture.repeat = r
        }
    },
    format: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),
            this.texture.format
        },
        set: function(r) {
            console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),
            this.texture.format = r
        }
    },
    type: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),
            this.texture.type
        },
        set: function(r) {
            console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),
            this.texture.type = r
        }
    },
    generateMipmaps: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),
            this.texture.generateMipmaps
        },
        set: function(r) {
            console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),
            this.texture.generateMipmaps = r
        }
    }
});
cw.prototype.load = function(r) {
    console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
    let e = this;
    return new ow().load(r, function(o) {
        e.setBuffer(o)
    }),
    this
}
;
uw.prototype.getData = function() {
    return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."),
    this.getFrequencyData()
}
;
Em.prototype.updateCubeMap = function(r, e) {
    return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),
    this.update(r, e)
}
;
Em.prototype.clear = function(r, e, t, o) {
    return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."),
    this.renderTarget.clear(r, e, t, o)
}
;
el.crossOrigin = void 0;
el.loadTexture = function(r, e, t, o) {
    console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
    let c = new Xb;
    c.setCrossOrigin(this.crossOrigin);
    let d = c.load(r, t, void 0, o);
    return e && (d.mapping = e),
    d
}
;
el.loadTextureCube = function(r, e, t, o) {
    console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
    let c = new jb;
    c.setCrossOrigin(this.crossOrigin);
    let d = c.load(r, t, void 0, o);
    return e && (d.mapping = e),
    d
}
;
el.loadCompressedTexture = function() {
    console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
}
;
el.loadCompressedTextureCube = function() {
    console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
}
;
typeof __THREE_DEVTOOLS__ != "undefined" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{
    detail: {
        revision: Ty
    }
}));
typeof window != "undefined" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = Ty);
var GI = {
    type: "change"
}
  , ww = {
    type: "start"
}
  , HI = {
    type: "end"
}
  , Tw = class extends Bo {
    constructor(e, t) {
        super();
        t === void 0 && console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.'),
        t === document && console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'),
        this.object = e,
        this.domElement = t,
        this.domElement.style.touchAction = "none",
        this.enabled = !0,
        this.target = new Oe,
        this.minDistance = 0,
        this.maxDistance = Infinity,
        this.minZoom = 0,
        this.maxZoom = Infinity,
        this.minPolarAngle = 0,
        this.maxPolarAngle = Math.PI,
        this.minAzimuthAngle = -Infinity,
        this.maxAzimuthAngle = Infinity,
        this.enableDamping = !1,
        this.dampingFactor = .05,
        this.enableZoom = !0,
        this.zoomSpeed = 1,
        this.enableRotate = !0,
        this.rotateSpeed = 1,
        this.enablePan = !0,
        this.panSpeed = 1,
        this.screenSpacePanning = !0,
        this.keyPanSpeed = 7,
        this.autoRotate = !1,
        this.autoRotateSpeed = 2,
        this.keys = {
            LEFT: "ArrowLeft",
            UP: "ArrowUp",
            RIGHT: "ArrowRight",
            BOTTOM: "ArrowDown"
        },
        this.mouseButtons = {
            LEFT: tc.ROTATE,
            MIDDLE: tc.DOLLY,
            RIGHT: tc.PAN
        },
        this.touches = {
            ONE: nc.ROTATE,
            TWO: nc.DOLLY_PAN
        },
        this.target0 = this.target.clone(),
        this.position0 = this.object.position.clone(),
        this.zoom0 = this.object.zoom,
        this._domElementKeyEvents = null,
        this.getPolarAngle = function() {
            return i.phi
        }
        ,
        this.getAzimuthalAngle = function() {
            return i.theta
        }
        ,
        this.getDistance = function() {
            return this.object.position.distanceTo(this.target)
        }
        ,
        this.listenToKeyEvents = function(Ie) {
            Ie.addEventListener("keydown", Qt),
            this._domElementKeyEvents = Ie
        }
        ,
        this.saveState = function() {
            o.target0.copy(o.target),
            o.position0.copy(o.object.position),
            o.zoom0 = o.object.zoom
        }
        ,
        this.reset = function() {
            o.target.copy(o.target0),
            o.object.position.copy(o.position0),
            o.object.zoom = o.zoom0,
            o.object.updateProjectionMatrix(),
            o.dispatchEvent(GI),
            o.update(),
            d = c.NONE
        }
        ,
        this.update = function() {
            let Ie = new Oe
              , Ct = new Ur().setFromUnitVectors(e.up, new Oe(0,1,0))
              , ln = Ct.clone().invert()
              , Kt = new Oe
              , Ge = new Ur
              , Wt = 2 * Math.PI;
            return function() {
                let _n = o.object.position;
                Ie.copy(_n).sub(o.target),
                Ie.applyQuaternion(Ct),
                i.setFromVector3(Ie),
                o.autoRotate && d === c.NONE && oe(ce()),
                o.enableDamping ? (i.theta += v.theta * o.dampingFactor,
                i.phi += v.phi * o.dampingFactor) : (i.theta += v.theta,
                i.phi += v.phi);
                let Ft = o.minAzimuthAngle
                  , nn = o.maxAzimuthAngle;
                return isFinite(Ft) && isFinite(nn) && (Ft < -Math.PI ? Ft += Wt : Ft > Math.PI && (Ft -= Wt),
                nn < -Math.PI ? nn += Wt : nn > Math.PI && (nn -= Wt),
                Ft <= nn ? i.theta = Math.max(Ft, Math.min(nn, i.theta)) : i.theta = i.theta > (Ft + nn) / 2 ? Math.max(Ft, i.theta) : Math.min(nn, i.theta)),
                i.phi = Math.max(o.minPolarAngle, Math.min(o.maxPolarAngle, i.phi)),
                i.makeSafe(),
                i.radius *= x,
                i.radius = Math.max(o.minDistance, Math.min(o.maxDistance, i.radius)),
                o.enableDamping === !0 ? o.target.addScaledVector(E, o.dampingFactor) : o.target.add(E),
                Ie.setFromSpherical(i),
                Ie.applyQuaternion(ln),
                _n.copy(o.target).add(Ie),
                o.object.lookAt(o.target),
                o.enableDamping === !0 ? (v.theta *= 1 - o.dampingFactor,
                v.phi *= 1 - o.dampingFactor,
                E.multiplyScalar(1 - o.dampingFactor)) : (v.set(0, 0, 0),
                E.set(0, 0, 0)),
                x = 1,
                A || Kt.distanceToSquared(o.object.position) > p || 8 * (1 - Ge.dot(o.object.quaternion)) > p ? (o.dispatchEvent(GI),
                Kt.copy(o.object.position),
                Ge.copy(o.object.quaternion),
                A = !1,
                !0) : !1
            }
        }(),
        this.dispose = function() {
            o.domElement.removeEventListener("contextmenu", Qe),
            o.domElement.removeEventListener("pointerdown", xt),
            o.domElement.removeEventListener("pointercancel", Pn),
            o.domElement.removeEventListener("wheel", zn),
            o.domElement.removeEventListener("pointermove", on),
            o.domElement.removeEventListener("pointerup", $t),
            o._domElementKeyEvents !== null && o._domElementKeyEvents.removeEventListener("keydown", Qt)
        }
        ;
        let o = this
          , c = {
            NONE: -1,
            ROTATE: 0,
            DOLLY: 1,
            PAN: 2,
            TOUCH_ROTATE: 3,
            TOUCH_PAN: 4,
            TOUCH_DOLLY_PAN: 5,
            TOUCH_DOLLY_ROTATE: 6
        }
          , d = c.NONE
          , p = 1e-6
          , i = new $m
          , v = new $m
          , x = 1
          , E = new Oe
          , A = !1
          , C = new zt
          , I = new zt
          , D = new zt
          , P = new zt
          , k = new zt
          , U = new zt
          , Z = new zt
          , K = new zt
          , X = new zt
          , W = []
          , fe = {};
        function ce() {
            return 2 * Math.PI / 60 / 60 * o.autoRotateSpeed
        }
        function _e() {
            return Math.pow(.95, o.zoomSpeed)
        }
        function oe(Ie) {
            v.theta -= Ie
        }
        function ee(Ie) {
            v.phi -= Ie
        }
        let j = function() {
            let Ie = new Oe;
            return function(ln, Kt) {
                Ie.setFromMatrixColumn(Kt, 0),
                Ie.multiplyScalar(-ln),
                E.add(Ie)
            }
        }()
          , ne = function() {
            let Ie = new Oe;
            return function(ln, Kt) {
                o.screenSpacePanning === !0 ? Ie.setFromMatrixColumn(Kt, 1) : (Ie.setFromMatrixColumn(Kt, 0),
                Ie.crossVectors(o.object.up, Ie)),
                Ie.multiplyScalar(ln),
                E.add(Ie)
            }
        }()
          , be = function() {
            let Ie = new Oe;
            return function(ln, Kt) {
                let Ge = o.domElement;
                if (o.object.isPerspectiveCamera) {
                    let Wt = o.object.position;
                    Ie.copy(Wt).sub(o.target);
                    let Ut = Ie.length();
                    Ut *= Math.tan(o.object.fov / 2 * Math.PI / 180),
                    j(2 * ln * Ut / Ge.clientHeight, o.object.matrix),
                    ne(2 * Kt * Ut / Ge.clientHeight, o.object.matrix)
                } else
                    o.object.isOrthographicCamera ? (j(ln * (o.object.right - o.object.left) / o.object.zoom / Ge.clientWidth, o.object.matrix),
                    ne(Kt * (o.object.top - o.object.bottom) / o.object.zoom / Ge.clientHeight, o.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),
                    o.enablePan = !1)
            }
        }();
        function te(Ie) {
            o.object.isPerspectiveCamera ? x /= Ie : o.object.isOrthographicCamera ? (o.object.zoom = Math.max(o.minZoom, Math.min(o.maxZoom, o.object.zoom * Ie)),
            o.object.updateProjectionMatrix(),
            A = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),
            o.enableZoom = !1)
        }
        function ae(Ie) {
            o.object.isPerspectiveCamera ? x *= Ie : o.object.isOrthographicCamera ? (o.object.zoom = Math.max(o.minZoom, Math.min(o.maxZoom, o.object.zoom / Ie)),
            o.object.updateProjectionMatrix(),
            A = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),
            o.enableZoom = !1)
        }
        function se(Ie) {
            C.set(Ie.clientX, Ie.clientY)
        }
        function ke(Ie) {
            Z.set(Ie.clientX, Ie.clientY)
        }
        function Be(Ie) {
            P.set(Ie.clientX, Ie.clientY)
        }
        function tt(Ie) {
            I.set(Ie.clientX, Ie.clientY),
            D.subVectors(I, C).multiplyScalar(o.rotateSpeed);
            let Ct = o.domElement;
            oe(2 * Math.PI * D.x / Ct.clientHeight),
            ee(2 * Math.PI * D.y / Ct.clientHeight),
            C.copy(I),
            o.update()
        }
        function Ke(Ie) {
            K.set(Ie.clientX, Ie.clientY),
            X.subVectors(K, Z),
            X.y > 0 ? te(_e()) : X.y < 0 && ae(_e()),
            Z.copy(K),
            o.update()
        }
        function bt(Ie) {
            k.set(Ie.clientX, Ie.clientY),
            U.subVectors(k, P).multiplyScalar(o.panSpeed),
            be(U.x, U.y),
            P.copy(k),
            o.update()
        }
        function Et(Ie) {
            Ie.deltaY < 0 ? ae(_e()) : Ie.deltaY > 0 && te(_e()),
            o.update()
        }
        function Gt(Ie) {
            let Ct = !1;
            switch (Ie.code) {
            case o.keys.UP:
                be(0, o.keyPanSpeed),
                Ct = !0;
                break;
            case o.keys.BOTTOM:
                be(0, -o.keyPanSpeed),
                Ct = !0;
                break;
            case o.keys.LEFT:
                be(o.keyPanSpeed, 0),
                Ct = !0;
                break;
            case o.keys.RIGHT:
                be(-o.keyPanSpeed, 0),
                Ct = !0;
                break
            }
            Ct && (Ie.preventDefault(),
            o.update())
        }
        function Ye() {
            if (W.length === 1)
                C.set(W[0].pageX, W[0].pageY);
            else {
                let Ie = .5 * (W[0].pageX + W[1].pageX)
                  , Ct = .5 * (W[0].pageY + W[1].pageY);
                C.set(Ie, Ct)
            }
        }
        function gn() {
            if (W.length === 1)
                P.set(W[0].pageX, W[0].pageY);
            else {
                let Ie = .5 * (W[0].pageX + W[1].pageX)
                  , Ct = .5 * (W[0].pageY + W[1].pageY);
                P.set(Ie, Ct)
            }
        }
        function gt() {
            let Ie = W[0].pageX - W[1].pageX
              , Ct = W[0].pageY - W[1].pageY
              , ln = Math.sqrt(Ie * Ie + Ct * Ct);
            Z.set(0, ln)
        }
        function Tn() {
            o.enableZoom && gt(),
            o.enablePan && gn()
        }
        function xn() {
            o.enableZoom && gt(),
            o.enableRotate && Ye()
        }
        function Dn(Ie) {
            if (W.length == 1)
                I.set(Ie.pageX, Ie.pageY);
            else {
                let ln = an(Ie)
                  , Kt = .5 * (Ie.pageX + ln.x)
                  , Ge = .5 * (Ie.pageY + ln.y);
                I.set(Kt, Ge)
            }
            D.subVectors(I, C).multiplyScalar(o.rotateSpeed);
            let Ct = o.domElement;
            oe(2 * Math.PI * D.x / Ct.clientHeight),
            ee(2 * Math.PI * D.y / Ct.clientHeight),
            C.copy(I)
        }
        function Bt(Ie) {
            if (W.length === 1)
                k.set(Ie.pageX, Ie.pageY);
            else {
                let Ct = an(Ie)
                  , ln = .5 * (Ie.pageX + Ct.x)
                  , Kt = .5 * (Ie.pageY + Ct.y);
                k.set(ln, Kt)
            }
            U.subVectors(k, P).multiplyScalar(o.panSpeed),
            be(U.x, U.y),
            P.copy(k)
        }
        function An(Ie) {
            let Ct = an(Ie)
              , ln = Ie.pageX - Ct.x
              , Kt = Ie.pageY - Ct.y
              , Ge = Math.sqrt(ln * ln + Kt * Kt);
            K.set(0, Ge),
            X.set(0, Math.pow(K.y / Z.y, o.zoomSpeed)),
            te(X.y),
            Z.copy(K)
        }
        function ut(Ie) {
            o.enableZoom && An(Ie),
            o.enablePan && Bt(Ie)
        }
        function ot(Ie) {
            o.enableZoom && An(Ie),
            o.enableRotate && Dn(Ie)
        }
        function xt(Ie) {
            o.enabled !== !1 && (W.length === 0 && (o.domElement.setPointerCapture(Ie.pointerId),
            o.domElement.addEventListener("pointermove", on),
            o.domElement.addEventListener("pointerup", $t)),
            ft(Ie),
            Ie.pointerType === "touch" ? xe(Ie) : kt(Ie))
        }
        function on(Ie) {
            o.enabled !== !1 && (Ie.pointerType === "touch" ? he(Ie) : Zt(Ie))
        }
        function $t(Ie) {
            St(Ie),
            W.length === 0 && (o.domElement.releasePointerCapture(Ie.pointerId),
            o.domElement.removeEventListener("pointermove", on),
            o.domElement.removeEventListener("pointerup", $t)),
            o.dispatchEvent(HI),
            d = c.NONE
        }
        function Pn(Ie) {
            St(Ie)
        }
        function kt(Ie) {
            let Ct;
            switch (Ie.button) {
            case 0:
                Ct = o.mouseButtons.LEFT;
                break;
            case 1:
                Ct = o.mouseButtons.MIDDLE;
                break;
            case 2:
                Ct = o.mouseButtons.RIGHT;
                break;
            default:
                Ct = -1
            }
            switch (Ct) {
            case tc.DOLLY:
                if (o.enableZoom === !1)
                    return;
                ke(Ie),
                d = c.DOLLY;
                break;
            case tc.ROTATE:
                if (Ie.ctrlKey || Ie.metaKey || Ie.shiftKey) {
                    if (o.enablePan === !1)
                        return;
                    Be(Ie),
                    d = c.PAN
                } else {
                    if (o.enableRotate === !1)
                        return;
                    se(Ie),
                    d = c.ROTATE
                }
                break;
            case tc.PAN:
                if (Ie.ctrlKey || Ie.metaKey || Ie.shiftKey) {
                    if (o.enableRotate === !1)
                        return;
                    se(Ie),
                    d = c.ROTATE
                } else {
                    if (o.enablePan === !1)
                        return;
                    Be(Ie),
                    d = c.PAN
                }
                break;
            default:
                d = c.NONE
            }
            d !== c.NONE && o.dispatchEvent(ww)
        }
        function Zt(Ie) {
            if (o.enabled !== !1)
                switch (d) {
                case c.ROTATE:
                    if (o.enableRotate === !1)
                        return;
                    tt(Ie);
                    break;
                case c.DOLLY:
                    if (o.enableZoom === !1)
                        return;
                    Ke(Ie);
                    break;
                case c.PAN:
                    if (o.enablePan === !1)
                        return;
                    bt(Ie);
                    break
                }
        }
        function zn(Ie) {
            o.enabled === !1 || o.enableZoom === !1 || d !== c.NONE || (Ie.preventDefault(),
            o.dispatchEvent(ww),
            Et(Ie),
            o.dispatchEvent(HI))
        }
        function Qt(Ie) {
            o.enabled === !1 || o.enablePan === !1 || Gt(Ie)
        }
        function xe(Ie) {
            switch (Mt(Ie),
            W.length) {
            case 1:
                switch (o.touches.ONE) {
                case nc.ROTATE:
                    if (o.enableRotate === !1)
                        return;
                    Ye(),
                    d = c.TOUCH_ROTATE;
                    break;
                case nc.PAN:
                    if (o.enablePan === !1)
                        return;
                    gn(),
                    d = c.TOUCH_PAN;
                    break;
                default:
                    d = c.NONE
                }
                break;
            case 2:
                switch (o.touches.TWO) {
                case nc.DOLLY_PAN:
                    if (o.enableZoom === !1 && o.enablePan === !1)
                        return;
                    Tn(),
                    d = c.TOUCH_DOLLY_PAN;
                    break;
                case nc.DOLLY_ROTATE:
                    if (o.enableZoom === !1 && o.enableRotate === !1)
                        return;
                    xn(),
                    d = c.TOUCH_DOLLY_ROTATE;
                    break;
                default:
                    d = c.NONE
                }
                break;
            default:
                d = c.NONE
            }
            d !== c.NONE && o.dispatchEvent(ww)
        }
        function he(Ie) {
            switch (Mt(Ie),
            d) {
            case c.TOUCH_ROTATE:
                if (o.enableRotate === !1)
                    return;
                Dn(Ie),
                o.update();
                break;
            case c.TOUCH_PAN:
                if (o.enablePan === !1)
                    return;
                Bt(Ie),
                o.update();
                break;
            case c.TOUCH_DOLLY_PAN:
                if (o.enableZoom === !1 && o.enablePan === !1)
                    return;
                ut(Ie),
                o.update();
                break;
            case c.TOUCH_DOLLY_ROTATE:
                if (o.enableZoom === !1 && o.enableRotate === !1)
                    return;
                ot(Ie),
                o.update();
                break;
            default:
                d = c.NONE
            }
        }
        function Qe(Ie) {
            o.enabled !== !1 && Ie.preventDefault()
        }
        function ft(Ie) {
            W.push(Ie)
        }
        function St(Ie) {
            delete fe[Ie.pointerId];
            for (let Ct = 0; Ct < W.length; Ct++)
                if (W[Ct].pointerId == Ie.pointerId) {
                    W.splice(Ct, 1);
                    return
                }
        }
        function Mt(Ie) {
            let Ct = fe[Ie.pointerId];
            Ct === void 0 && (Ct = new zt,
            fe[Ie.pointerId] = Ct),
            Ct.set(Ie.pageX, Ie.pageY)
        }
        function an(Ie) {
            let Ct = Ie.pointerId === W[0].pointerId ? W[1] : W[0];
            return fe[Ct.pointerId]
        }
        o.domElement.addEventListener("contextmenu", Qe),
        o.domElement.addEventListener("pointerdown", xt),
        o.domElement.addEventListener("pointercancel", Pn),
        o.domElement.addEventListener("wheel", zn, {
            passive: !1
        }),
        this.update()
    }
}
;
var eg = class extends Ai {
    constructor(e=document.createElement("div")) {
        super();
        this.element = e,
        this.element.style.position = "absolute",
        this.element.style.userSelect = "none",
        this.element.setAttribute("draggable", !1),
        this.addEventListener("removed", function() {
            this.traverse(function(t) {
                t.element instanceof Element && t.element.parentNode !== null && t.element.parentNode.removeChild(t.element)
            })
        })
    }
    copy(e, t) {
        return super.copy(e, t),
        this.element = e.element.cloneNode(!0),
        this
    }
}
;
eg.prototype.isCSS2DObject = !0;
var Tc = new Oe
  , WI = new Fn
  , jI = new Fn
  , XI = new Oe
  , ZI = new Oe
  , Ew = class {
    constructor(e={}) {
        let t = this, o, c, d, p, i = {
            objects: new WeakMap
        }, v = e.element !== void 0 ? e.element : document.createElement("div");
        v.style.overflow = "hidden",
        this.domElement = v,
        this.getSize = function() {
            return {
                width: o,
                height: c
            }
        }
        ,
        this.render = function(I, D) {
            I.autoUpdate === !0 && I.updateMatrixWorld(),
            D.parent === null && D.updateMatrixWorld(),
            WI.copy(D.matrixWorldInverse),
            jI.multiplyMatrices(D.projectionMatrix, WI),
            x(I, I, D),
            C(I)
        }
        ,
        this.setSize = function(I, D) {
            o = I,
            c = D,
            d = o / 2,
            p = c / 2,
            v.style.width = I + "px",
            v.style.height = D + "px"
        }
        ;
        function x(I, D, P) {
            if (I.isCSS2DObject) {
                Tc.setFromMatrixPosition(I.matrixWorld),
                Tc.applyMatrix4(jI);
                let k = I.visible === !0 && Tc.z >= -1 && Tc.z <= 1 && I.layers.test(P.layers) === !0;
                if (I.element.style.display = k === !0 ? "" : "none",
                k === !0) {
                    I.onBeforeRender(t, D, P);
                    let Z = I.element;
                    /apple/i.test(navigator.vendor) ? Z.style.transform = "translate(-50%,-50%) translate(" + Math.round(Tc.x * d + d) + "px," + Math.round(-Tc.y * p + p) + "px)" : Z.style.transform = "translate(-50%,-50%) translate(" + (Tc.x * d + d) + "px," + (-Tc.y * p + p) + "px)",
                    Z.parentNode !== v && v.appendChild(Z),
                    I.onAfterRender(t, D, P)
                }
                let U = {
                    distanceToCameraSquared: E(P, I)
                };
                i.objects.set(I, U)
            }
            for (let k = 0, U = I.children.length; k < U; k++)
                x(I.children[k], D, P)
        }
        function E(I, D) {
            return XI.setFromMatrixPosition(I.matrixWorld),
            ZI.setFromMatrixPosition(D.matrixWorld),
            XI.distanceToSquared(ZI)
        }
        function A(I) {
            let D = [];
            return I.traverse(function(P) {
                P.isCSS2DObject && D.push(P)
            }),
            D
        }
        function C(I) {
            let D = A(I).sort(function(k, U) {
                if (k.renderOrder !== U.renderOrder)
                    return U.renderOrder - k.renderOrder;
                let Z = i.objects.get(k).distanceToCameraSquared
                  , K = i.objects.get(U).distanceToCameraSquared;
                return Z - K
            })
              , P = D.length;
            for (let k = 0, U = D.length; k < U; k++)
                D[k].element.style.zIndex = P - k
        }
    }
}
;
function qI(r) {
    let e = [];
    for (let v = 0; v < r.length; v++)
        e.push(r[v][0][0].elevation);
    let t = [Math.min(...e), Math.max(...e) + .1]
      , o = t[0]
      , c = 0
      , d = []
      , p = 0
      , i = [];
    for (; o < t[1] && c < e.length - 1; )
        Math.abs(o - e[c]) < Math.abs(o - e[c + 1]) ? d.push(c) : d.push(c + 1),
        i.push([c, c + 1]),
        p = o,
        o += .1,
        o > e[c + 1] && c++;
    return {
        output: d,
        domain: [e[0], p],
        range: t,
        elevations: e,
        bracket: i
    }
}
function KI(r) {
    let e = {
        0: ["#242424", "#14466c", "#0FCBFF", "#1D9E00", "#95F44C", "#FFF700", "#FF9F0F", "#EB7900", "#FF1F1F", "#AD1100", "#FFB8F5", "#CA57FF", "#4A009E"],
        1: ["#ffffff", "#FC52FF", "#871FFF", "#0011CC", "#0088CC", "#B3F0FF", "#42FF42", "#009402", "#A3A3A3", "#8A0000", "#FF5269", "#FFB3E0", "#FFF1C2", "#FF9214", "#B85C00", "#572100", "#000000"],
        2: ["#ffffff", "#FC52FF", "#871FFF", "#0011CC", "#0088CC", "#B3F0FF", "#42FF42", "#009402", "#A3A3A3", "#8A0000", "#FF5269", "#FFB3E0", "#FFF1C2", "#FF9214", "#B85C00", "#572100", "#000000"]
    }
      , t = {
        0: [0, 80],
        1: [-300, 300],
        2: [-300, 300]
    }
      , o = {
        0: [0, 10, 20, 25, 30, 35, 40, 45, 50, 60, 65, 70, 80],
        1: [-300, -140, -120, -100, -80, -60, -40, -20, 0, 20, 40, 60, 80, 100, 120, 140, 300],
        2: [-300, -140, -120, -100, -80, -60, -40, -20, 0, 20, 40, 60, 80, 100, 120, 140, 300]
    }
      , c = e[r]
      , d = o[r]
      , p = document.createElement("CANVAS");
    p.width = 1200,
    p.height = 1;
    var i = p.getContext("2d");
    i.clearRect(0, 0, p.width, p.height);
    var v = i.createLinearGradient(0, 0, 1200, 0)
      , x = t[r][1]
      , E = t[r][0]
      , A = c.length;
    for (let C = 0; C < A; ++C)
        v.addColorStop((d[C] - E) / (x - E), c[C]);
    return i.fillStyle = v,
    i.fillRect(0, 0, 1200, 10),
    i.getImageData(0, 0, 1200, 1)
}
function Sw(r) {
    let e = document.createElement("CANVAS");
    e.width = 100,
    e.height = 50;
    let t = 10
      , o = e.getContext("2d")
      , c = 0
      , d = 0
      , p = 100
      , i = 50;
    return r === "selected" && (o.fillStyle = "#0FB7E5"),
    r === "unselected" && (o.fillStyle = "#949494"),
    o.beginPath(),
    o.moveTo(c + t, d),
    o.lineTo(c + p - t, d),
    o.quadraticCurveTo(c + p, d, c + p, d + t),
    o.lineTo(c + p, d + i - t),
    o.quadraticCurveTo(c + p, d + i, c + p - t, d + i),
    o.lineTo(c + t, d + i),
    o.quadraticCurveTo(c, d + i, c, d + i - t),
    o.lineTo(c, d + t),
    o.quadraticCurveTo(c, d, c + t, d),
    o.closePath(),
    o.fill(),
    o.getImageData(0, 0, p, i)
}
var Aw = "http://www.w3.org/1999/xhtml"
  , YI = {
    svg: "http://www.w3.org/2000/svg",
    xhtml: Aw,
    xlink: "http://www.w3.org/1999/xlink",
    xml: "http://www.w3.org/XML/1998/namespace",
    xmlns: "http://www.w3.org/2000/xmlns/"
};
function JI(r) {
    var e = r += ""
      , t = e.indexOf(":");
    return t >= 0 && (e = r.slice(0, t)) !== "xmlns" && (r = r.slice(t + 1)),
    YI.hasOwnProperty(e) ? {
        space: YI[e],
        local: r
    } : r
}
function h4(r) {
    return function() {
        var e = this.ownerDocument
          , t = this.namespaceURI;
        return t === Aw && e.documentElement.namespaceURI === Aw ? e.createElement(r) : e.createElementNS(t, r)
    }
}
function d4(r) {
    return function() {
        return this.ownerDocument.createElementNS(r.space, r.local)
    }
}
function $I(r) {
    var e = JI(r);
    return (e.local ? d4 : h4)(e)
}
function f4() {}
function QI(r) {
    return r == null ? f4 : function() {
        return this.querySelector(r)
    }
}
function p4(r) {
    typeof r != "function" && (r = QI(r));
    for (var e = this._groups, t = e.length, o = new Array(t), c = 0; c < t; ++c)
        for (var d = e[c], p = d.length, i = o[c] = new Array(p), v, x, E = 0; E < p; ++E)
            (v = d[E]) && (x = r.call(v, v.__data__, E, d)) && ("__data__"in v && (x.__data__ = v.__data__),
            i[E] = x);
    return new So(o,this._parents)
}
function m4(r) {
    return r == null ? [] : Array.isArray(r) ? r : Array.from(r)
}
function g4() {
    return []
}
function _4(r) {
    return r == null ? g4 : function() {
        return this.querySelectorAll(r)
    }
}
function y4(r) {
    return function() {
        return m4(r.apply(this, arguments))
    }
}
function x4(r) {
    typeof r == "function" ? r = y4(r) : r = _4(r);
    for (var e = this._groups, t = e.length, o = [], c = [], d = 0; d < t; ++d)
        for (var p = e[d], i = p.length, v, x = 0; x < i; ++x)
            (v = p[x]) && (o.push(r.call(v, v.__data__, x, p)),
            c.push(v));
    return new So(o,c)
}
function v4(r) {
    return function() {
        return this.matches(r)
    }
}
function eC(r) {
    return function(e) {
        return e.matches(r)
    }
}
var b4 = Array.prototype.find;
function w4(r) {
    return function() {
        return b4.call(this.children, r)
    }
}
function T4() {
    return this.firstElementChild
}
function E4(r) {
    return this.select(r == null ? T4 : w4(typeof r == "function" ? r : eC(r)))
}
var S4 = Array.prototype.filter;
function A4() {
    return Array.from(this.children)
}
function M4(r) {
    return function() {
        return S4.call(this.children, r)
    }
}
function I4(r) {
    return this.selectAll(r == null ? A4 : M4(typeof r == "function" ? r : eC(r)))
}
function C4(r) {
    typeof r != "function" && (r = v4(r));
    for (var e = this._groups, t = e.length, o = new Array(t), c = 0; c < t; ++c)
        for (var d = e[c], p = d.length, i = o[c] = [], v, x = 0; x < p; ++x)
            (v = d[x]) && r.call(v, v.__data__, x, d) && i.push(v);
    return new So(o,this._parents)
}
function tC(r) {
    return new Array(r.length)
}
function D4() {
    return new So(this._enter || this._groups.map(tC),this._parents)
}
function Z0(r, e) {
    this.ownerDocument = r.ownerDocument,
    this.namespaceURI = r.namespaceURI,
    this._next = null,
    this._parent = r,
    this.__data__ = e
}
Z0.prototype = {
    constructor: Z0,
    appendChild: function(r) {
        return this._parent.insertBefore(r, this._next)
    },
    insertBefore: function(r, e) {
        return this._parent.insertBefore(r, e)
    },
    querySelector: function(r) {
        return this._parent.querySelector(r)
    },
    querySelectorAll: function(r) {
        return this._parent.querySelectorAll(r)
    }
};
function L4(r) {
    return function() {
        return r
    }
}
function R4(r, e, t, o, c, d) {
    for (var p = 0, i, v = e.length, x = d.length; p < x; ++p)
        (i = e[p]) ? (i.__data__ = d[p],
        o[p] = i) : t[p] = new Z0(r,d[p]);
    for (; p < v; ++p)
        (i = e[p]) && (c[p] = i)
}
function P4(r, e, t, o, c, d, p) {
    var i, v, x = new Map, E = e.length, A = d.length, C = new Array(E), I;
    for (i = 0; i < E; ++i)
        (v = e[i]) && (C[i] = I = p.call(v, v.__data__, i, e) + "",
        x.has(I) ? c[i] = v : x.set(I, v));
    for (i = 0; i < A; ++i)
        I = p.call(r, d[i], i, d) + "",
        (v = x.get(I)) ? (o[i] = v,
        v.__data__ = d[i],
        x.delete(I)) : t[i] = new Z0(r,d[i]);
    for (i = 0; i < E; ++i)
        (v = e[i]) && x.get(C[i]) === v && (c[i] = v)
}
function k4(r) {
    return r.__data__
}
function O4(r, e) {
    if (!arguments.length)
        return Array.from(this, k4);
    var t = e ? P4 : R4
      , o = this._parents
      , c = this._groups;
    typeof r != "function" && (r = L4(r));
    for (var d = c.length, p = new Array(d), i = new Array(d), v = new Array(d), x = 0; x < d; ++x) {
        var E = o[x]
          , A = c[x]
          , C = A.length
          , I = z4(r.call(E, E && E.__data__, x, o))
          , D = I.length
          , P = i[x] = new Array(D)
          , k = p[x] = new Array(D)
          , U = v[x] = new Array(C);
        t(E, A, P, k, U, I, e);
        for (var Z = 0, K = 0, X, W; Z < D; ++Z)
            if (X = P[Z]) {
                for (Z >= K && (K = Z + 1); !(W = k[K]) && ++K < D; )
                    ;
                X._next = W || null
            }
    }
    return p = new So(p,o),
    p._enter = i,
    p._exit = v,
    p
}
function z4(r) {
    return typeof r == "object" && "length"in r ? r : Array.from(r)
}
function N4() {
    return new So(this._exit || this._groups.map(tC),this._parents)
}
function F4(r, e, t) {
    var o = this.enter()
      , c = this
      , d = this.exit();
    return typeof r == "function" ? (o = r(o),
    o && (o = o.selection())) : o = o.append(r + ""),
    e != null && (c = e(c),
    c && (c = c.selection())),
    t == null ? d.remove() : t(d),
    o && c ? o.merge(c).order() : c
}
function B4(r) {
    for (var e = r.selection ? r.selection() : r, t = this._groups, o = e._groups, c = t.length, d = o.length, p = Math.min(c, d), i = new Array(c), v = 0; v < p; ++v)
        for (var x = t[v], E = o[v], A = x.length, C = i[v] = new Array(A), I, D = 0; D < A; ++D)
            (I = x[D] || E[D]) && (C[D] = I);
    for (; v < c; ++v)
        i[v] = t[v];
    return new So(i,this._parents)
}
function U4() {
    for (var r = this._groups, e = -1, t = r.length; ++e < t; )
        for (var o = r[e], c = o.length - 1, d = o[c], p; --c >= 0; )
            (p = o[c]) && (d && p.compareDocumentPosition(d) ^ 4 && d.parentNode.insertBefore(p, d),
            d = p);
    return this
}
function G4(r) {
    r || (r = V4);
    function e(A, C) {
        return A && C ? r(A.__data__, C.__data__) : !A - !C
    }
    for (var t = this._groups, o = t.length, c = new Array(o), d = 0; d < o; ++d) {
        for (var p = t[d], i = p.length, v = c[d] = new Array(i), x, E = 0; E < i; ++E)
            (x = p[E]) && (v[E] = x);
        v.sort(e)
    }
    return new So(c,this._parents).order()
}
function V4(r, e) {
    return r < e ? -1 : r > e ? 1 : r >= e ? 0 : NaN
}
function H4() {
    var r = arguments[0];
    return arguments[0] = this,
    r.apply(null, arguments),
    this
}
function W4() {
    return Array.from(this)
}
function j4() {
    for (var r = this._groups, e = 0, t = r.length; e < t; ++e)
        for (var o = r[e], c = 0, d = o.length; c < d; ++c) {
            var p = o[c];
            if (p)
                return p
        }
    return null
}
function X4() {
    let r = 0;
    for (let e of this)
        ++r;
    return r
}
function Z4() {
    return !this.node()
}
function q4(r) {
    for (var e = this._groups, t = 0, o = e.length; t < o; ++t)
        for (var c = e[t], d = 0, p = c.length, i; d < p; ++d)
            (i = c[d]) && r.call(i, i.__data__, d, c);
    return this
}
function K4(r) {
    return function() {
        this.removeAttribute(r)
    }
}
function Y4(r) {
    return function() {
        this.removeAttributeNS(r.space, r.local)
    }
}
function J4(r, e) {
    return function() {
        this.setAttribute(r, e)
    }
}
function $4(r, e) {
    return function() {
        this.setAttributeNS(r.space, r.local, e)
    }
}
function Q4(r, e) {
    return function() {
        var t = e.apply(this, arguments);
        t == null ? this.removeAttribute(r) : this.setAttribute(r, t)
    }
}
function eU(r, e) {
    return function() {
        var t = e.apply(this, arguments);
        t == null ? this.removeAttributeNS(r.space, r.local) : this.setAttributeNS(r.space, r.local, t)
    }
}
function tU(r, e) {
    var t = JI(r);
    if (arguments.length < 2) {
        var o = this.node();
        return t.local ? o.getAttributeNS(t.space, t.local) : o.getAttribute(t)
    }
    return this.each((e == null ? t.local ? Y4 : K4 : typeof e == "function" ? t.local ? eU : Q4 : t.local ? $4 : J4)(t, e))
}
function nC(r) {
    return r.ownerDocument && r.ownerDocument.defaultView || r.document && r || r.defaultView
}
function nU(r) {
    return function() {
        this.style.removeProperty(r)
    }
}
function iU(r, e, t) {
    return function() {
        this.style.setProperty(r, e, t)
    }
}
function rU(r, e, t) {
    return function() {
        var o = e.apply(this, arguments);
        o == null ? this.style.removeProperty(r) : this.style.setProperty(r, o, t)
    }
}
function oU(r, e, t) {
    return arguments.length > 1 ? this.each((e == null ? nU : typeof e == "function" ? rU : iU)(r, e, t ?? "")) : sU(this.node(), r)
}
function sU(r, e) {
    return r.style.getPropertyValue(e) || nC(r).getComputedStyle(r, null).getPropertyValue(e)
}
function aU(r) {
    return function() {
        delete this[r]
    }
}
function lU(r, e) {
    return function() {
        this[r] = e
    }
}
function cU(r, e) {
    return function() {
        var t = e.apply(this, arguments);
        t == null ? delete this[r] : this[r] = t
    }
}
function uU(r, e) {
    return arguments.length > 1 ? this.each((e == null ? aU : typeof e == "function" ? cU : lU)(r, e)) : this.node()[r]
}
function iC(r) {
    return r.trim().split(/^|\s+/)
}
function Mw(r) {
    return r.classList || new rC(r)
}
function rC(r) {
    this._node = r,
    this._names = iC(r.getAttribute("class") || "")
}
rC.prototype = {
    add: function(r) {
        var e = this._names.indexOf(r);
        e < 0 && (this._names.push(r),
        this._node.setAttribute("class", this._names.join(" ")))
    },
    remove: function(r) {
        var e = this._names.indexOf(r);
        e >= 0 && (this._names.splice(e, 1),
        this._node.setAttribute("class", this._names.join(" ")))
    },
    contains: function(r) {
        return this._names.indexOf(r) >= 0
    }
};
function sC(r, e) {
    for (var t = Mw(r), o = -1, c = e.length; ++o < c; )
        t.add(e[o])
}
function oC(r, e) {
    for (var t = Mw(r), o = -1, c = e.length; ++o < c; )
        t.remove(e[o])
}
function hU(r) {
    return function() {
        sC(this, r)
    }
}
function dU(r) {
    return function() {
        oC(this, r)
    }
}
function fU(r, e) {
    return function() {
        (e.apply(this, arguments) ? sC : oC)(this, r)
    }
}
function pU(r, e) {
    var t = iC(r + "");
    if (arguments.length < 2) {
        for (var o = Mw(this.node()), c = -1, d = t.length; ++c < d; )
            if (!o.contains(t[c]))
                return !1;
        return !0
    }
    return this.each((typeof e == "function" ? fU : e ? hU : dU)(t, e))
}
function mU() {
    this.textContent = ""
}
function gU(r) {
    return function() {
        this.textContent = r
    }
}
function _U(r) {
    return function() {
        var e = r.apply(this, arguments);
        this.textContent = e ?? ""
    }
}
function yU(r) {
    return arguments.length ? this.each(r == null ? mU : (typeof r == "function" ? _U : gU)(r)) : this.node().textContent
}
function xU() {
    this.innerHTML = ""
}
function vU(r) {
    return function() {
        this.innerHTML = r
    }
}
function bU(r) {
    return function() {
        var e = r.apply(this, arguments);
        this.innerHTML = e ?? ""
    }
}
function wU(r) {
    return arguments.length ? this.each(r == null ? xU : (typeof r == "function" ? bU : vU)(r)) : this.node().innerHTML
}
function TU() {
    this.nextSibling && this.parentNode.appendChild(this)
}
function EU() {
    return this.each(TU)
}
function SU() {
    this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild)
}
function AU() {
    return this.each(SU)
}
function MU(r) {
    var e = typeof r == "function" ? r : $I(r);
    return this.select(function() {
        return this.appendChild(e.apply(this, arguments))
    })
}
function IU() {
    return null
}
function CU(r, e) {
    var t = typeof r == "function" ? r : $I(r)
      , o = e == null ? IU : typeof e == "function" ? e : QI(e);
    return this.select(function() {
        return this.insertBefore(t.apply(this, arguments), o.apply(this, arguments) || null)
    })
}
function DU() {
    var r = this.parentNode;
    r && r.removeChild(this)
}
function LU() {
    return this.each(DU)
}
function RU() {
    var r = this.cloneNode(!1)
      , e = this.parentNode;
    return e ? e.insertBefore(r, this.nextSibling) : r
}
function PU() {
    var r = this.cloneNode(!0)
      , e = this.parentNode;
    return e ? e.insertBefore(r, this.nextSibling) : r
}
function kU(r) {
    return this.select(r ? PU : RU)
}
function zU(r) {
    return arguments.length ? this.property("__data__", r) : this.node().__data__
}
function OU(r) {
    return function(e) {
        r.call(this, e, this.__data__)
    }
}
function NU(r) {
    return r.trim().split(/^|\s+/).map(function(e) {
        var t = ""
          , o = e.indexOf(".");
        return o >= 0 && (t = e.slice(o + 1),
        e = e.slice(0, o)),
        {
            type: e,
            name: t
        }
    })
}
function FU(r) {
    return function() {
        var e = this.__on;
        if (!!e) {
            for (var t = 0, o = -1, c = e.length, d; t < c; ++t)
                d = e[t],
                (!r.type || d.type === r.type) && d.name === r.name ? this.removeEventListener(d.type, d.listener, d.options) : e[++o] = d;
            ++o ? e.length = o : delete this.__on
        }
    }
}
function BU(r, e, t) {
    return function() {
        var o = this.__on, c, d = OU(e);
        if (o) {
            for (var p = 0, i = o.length; p < i; ++p)
                if ((c = o[p]).type === r.type && c.name === r.name) {
                    this.removeEventListener(c.type, c.listener, c.options),
                    this.addEventListener(c.type, c.listener = d, c.options = t),
                    c.value = e;
                    return
                }
        }
        this.addEventListener(r.type, d, t),
        c = {
            type: r.type,
            name: r.name,
            value: e,
            listener: d,
            options: t
        },
        o ? o.push(c) : this.__on = [c]
    }
}
function UU(r, e, t) {
    var o = NU(r + ""), c, d = o.length, p;
    if (arguments.length < 2) {
        var i = this.node().__on;
        if (i) {
            for (var v = 0, x = i.length, E; v < x; ++v)
                for (c = 0,
                E = i[v]; c < d; ++c)
                    if ((p = o[c]).type === E.type && p.name === E.name)
                        return E.value
        }
        return
    }
    for (i = e ? BU : FU,
    c = 0; c < d; ++c)
        this.each(i(o[c], e, t));
    return this
}
function aC(r, e, t) {
    var o = nC(r)
      , c = o.CustomEvent;
    typeof c == "function" ? c = new c(e,t) : (c = o.document.createEvent("Event"),
    t ? (c.initEvent(e, t.bubbles, t.cancelable),
    c.detail = t.detail) : c.initEvent(e, !1, !1)),
    r.dispatchEvent(c)
}
function VU(r, e) {
    return function() {
        return aC(this, r, e)
    }
}
function GU(r, e) {
    return function() {
        return aC(this, r, e.apply(this, arguments))
    }
}
function HU(r, e) {
    return this.each((typeof e == "function" ? GU : VU)(r, e))
}
function *WU() {
    for (var r = this._groups, e = 0, t = r.length; e < t; ++e)
        for (var o = r[e], c = 0, d = o.length, p; c < d; ++c)
            (p = o[c]) && (yield p)
}
var jU = [null];
function So(r, e) {
    this._groups = r,
    this._parents = e
}
function XU() {
    return this
}
So.prototype = {
    constructor: So,
    select: p4,
    selectAll: x4,
    selectChild: E4,
    selectChildren: I4,
    filter: C4,
    data: O4,
    enter: D4,
    exit: N4,
    join: F4,
    merge: B4,
    selection: XU,
    order: U4,
    sort: G4,
    call: H4,
    nodes: W4,
    node: j4,
    size: X4,
    empty: Z4,
    each: q4,
    attr: tU,
    style: oU,
    property: uU,
    classed: pU,
    text: yU,
    html: wU,
    raise: EU,
    lower: AU,
    append: MU,
    insert: CU,
    remove: LU,
    clone: kU,
    datum: zU,
    on: UU,
    dispatch: HU,
    [Symbol.iterator]: WU
};
function Ec(r) {
    return typeof r == "string" ? new So([[document.querySelector(r)]],[document.documentElement]) : new So([[r]],jU)
}
var ZU = {
    value: ()=>{}
};
function lC() {
    for (var r = 0, e = arguments.length, t = {}, o; r < e; ++r) {
        if (!(o = arguments[r] + "") || o in t || /[\s.]/.test(o))
            throw new Error("illegal type: " + o);
        t[o] = []
    }
    return new q0(t)
}
function q0(r) {
    this._ = r
}
function qU(r, e) {
    return r.trim().split(/^|\s+/).map(function(t) {
        var o = ""
          , c = t.indexOf(".");
        if (c >= 0 && (o = t.slice(c + 1),
        t = t.slice(0, c)),
        t && !e.hasOwnProperty(t))
            throw new Error("unknown type: " + t);
        return {
            type: t,
            name: o
        }
    })
}
q0.prototype = lC.prototype = {
    constructor: q0,
    on: function(r, e) {
        var t = this._, o = qU(r + "", t), c, d = -1, p = o.length;
        if (arguments.length < 2) {
            for (; ++d < p; )
                if ((c = (r = o[d]).type) && (c = KU(t[c], r.name)))
                    return c;
            return
        }
        if (e != null && typeof e != "function")
            throw new Error("invalid callback: " + e);
        for (; ++d < p; )
            if (c = (r = o[d]).type)
                t[c] = cC(t[c], r.name, e);
            else if (e == null)
                for (c in t)
                    t[c] = cC(t[c], r.name, null);
        return this
    },
    copy: function() {
        var r = {}
          , e = this._;
        for (var t in e)
            r[t] = e[t].slice();
        return new q0(r)
    },
    call: function(r, e) {
        if ((c = arguments.length - 2) > 0)
            for (var t = new Array(c), o = 0, c, d; o < c; ++o)
                t[o] = arguments[o + 2];
        if (!this._.hasOwnProperty(r))
            throw new Error("unknown type: " + r);
        for (d = this._[r],
        o = 0,
        c = d.length; o < c; ++o)
            d[o].value.apply(e, t)
    },
    apply: function(r, e, t) {
        if (!this._.hasOwnProperty(r))
            throw new Error("unknown type: " + r);
        for (var o = this._[r], c = 0, d = o.length; c < d; ++c)
            o[c].value.apply(e, t)
    }
};
function KU(r, e) {
    for (var t = 0, o = r.length, c; t < o; ++t)
        if ((c = r[t]).name === e)
            return c.value
}
function cC(r, e, t) {
    for (var o = 0, c = r.length; o < c; ++o)
        if (r[o].name === e) {
            r[o] = ZU,
            r = r.slice(0, o).concat(r.slice(o + 1));
            break
        }
    return t != null && r.push({
        name: e,
        value: t
    }),
    r
}
function YU(r) {
    let e;
    for (; e = r.sourceEvent; )
        r = e;
    return r
}
function uC(r, e) {
    if (r = YU(r),
    e === void 0 && (e = r.currentTarget),
    e) {
        var t = e.ownerSVGElement || e;
        if (t.createSVGPoint) {
            var o = t.createSVGPoint();
            return o.x = r.clientX,
            o.y = r.clientY,
            o = o.matrixTransform(e.getScreenCTM().inverse()),
            [o.x, o.y]
        }
        if (e.getBoundingClientRect) {
            var c = e.getBoundingClientRect();
            return [r.clientX - c.left - e.clientLeft, r.clientY - c.top - e.clientTop]
        }
    }
    return [r.pageX, r.pageY]
}
var JU = {
    passive: !1
}
  , tg = {
    capture: !0,
    passive: !1
};
function Iw(r) {
    r.stopImmediatePropagation()
}
function hf(r) {
    r.preventDefault(),
    r.stopImmediatePropagation()
}
function $U(r) {
    var e = r.document.documentElement
      , t = Ec(r).on("dragstart.drag", hf, tg);
    "onselectstart"in e ? t.on("selectstart.drag", hf, tg) : (e.__noselect = e.style.MozUserSelect,
    e.style.MozUserSelect = "none")
}
function QU(r, e) {
    var t = r.document.documentElement
      , o = Ec(r).on("dragstart.drag", null);
    e && (o.on("click.drag", hf, tg),
    setTimeout(function() {
        o.on("click.drag", null)
    }, 0)),
    "onselectstart"in t ? o.on("selectstart.drag", null) : (t.style.MozUserSelect = t.__noselect,
    delete t.__noselect)
}
var K0 = r=>()=>r;
function Cw(r, {sourceEvent: e, subject: t, target: o, identifier: c, active: d, x: p, y: i, dx: v, dy: x, dispatch: E}) {
    Object.defineProperties(this, {
        type: {
            value: r,
            enumerable: !0,
            configurable: !0
        },
        sourceEvent: {
            value: e,
            enumerable: !0,
            configurable: !0
        },
        subject: {
            value: t,
            enumerable: !0,
            configurable: !0
        },
        target: {
            value: o,
            enumerable: !0,
            configurable: !0
        },
        identifier: {
            value: c,
            enumerable: !0,
            configurable: !0
        },
        active: {
            value: d,
            enumerable: !0,
            configurable: !0
        },
        x: {
            value: p,
            enumerable: !0,
            configurable: !0
        },
        y: {
            value: i,
            enumerable: !0,
            configurable: !0
        },
        dx: {
            value: v,
            enumerable: !0,
            configurable: !0
        },
        dy: {
            value: x,
            enumerable: !0,
            configurable: !0
        },
        _: {
            value: E
        }
    })
}
Cw.prototype.on = function() {
    var r = this._.on.apply(this._, arguments);
    return r === this._ ? this : r
}
;
function e6(r) {
    return !r.ctrlKey && !r.button
}
function t6() {
    return this.parentNode
}
function n6(r, e) {
    return e ?? {
        x: r.x,
        y: r.y
    }
}
function i6() {
    return navigator.maxTouchPoints || "ontouchstart"in this
}
function hC() {
    var r = e6, e = t6, t = n6, o = i6, c = {}, d = lC("start", "drag", "end"), p = 0, i, v, x, E, A = 0;
    function C(X) {
        X.on("mousedown.drag", I).filter(o).on("touchstart.drag", k).on("touchmove.drag", U, JU).on("touchend.drag touchcancel.drag", Z).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)")
    }
    function I(X, W) {
        if (!(E || !r.call(this, X, W))) {
            var fe = K(this, e.call(this, X, W), X, W, "mouse");
            !fe || (Ec(X.view).on("mousemove.drag", D, tg).on("mouseup.drag", P, tg),
            $U(X.view),
            Iw(X),
            x = !1,
            i = X.clientX,
            v = X.clientY,
            fe("start", X))
        }
    }
    function D(X) {
        if (hf(X),
        !x) {
            var W = X.clientX - i
              , fe = X.clientY - v;
            x = W * W + fe * fe > A
        }
        c.mouse("drag", X)
    }
    function P(X) {
        Ec(X.view).on("mousemove.drag mouseup.drag", null),
        QU(X.view, x),
        hf(X),
        c.mouse("end", X)
    }
    function k(X, W) {
        if (!!r.call(this, X, W)) {
            var fe = X.changedTouches, ce = e.call(this, X, W), _e = fe.length, oe, ee;
            for (oe = 0; oe < _e; ++oe)
                (ee = K(this, ce, X, W, fe[oe].identifier, fe[oe])) && (Iw(X),
                ee("start", X, fe[oe]))
        }
    }
    function U(X) {
        var W = X.changedTouches, fe = W.length, ce, _e;
        for (ce = 0; ce < fe; ++ce)
            (_e = c[W[ce].identifier]) && (hf(X),
            _e("drag", X, W[ce]))
    }
    function Z(X) {
        var W = X.changedTouches, fe = W.length, ce, _e;
        for (E && clearTimeout(E),
        E = setTimeout(function() {
            E = null
        }, 500),
        ce = 0; ce < fe; ++ce)
            (_e = c[W[ce].identifier]) && (Iw(X),
            _e("end", X, W[ce]))
    }
    function K(X, W, fe, ce, _e, oe) {
        var ee = d.copy(), j = uC(oe || fe, W), ne, be, te;
        if ((te = t.call(X, new Cw("beforestart",{
            sourceEvent: fe,
            target: C,
            identifier: _e,
            active: p,
            x: j[0],
            y: j[1],
            dx: 0,
            dy: 0,
            dispatch: ee
        }), ce)) != null)
            return ne = te.x - j[0] || 0,
            be = te.y - j[1] || 0,
            function ae(se, ke, Be) {
                var tt = j, Ke;
                switch (se) {
                case "start":
                    c[_e] = ae,
                    Ke = p++;
                    break;
                case "end":
                    delete c[_e],
                    --p;
                case "drag":
                    j = uC(Be || ke, W),
                    Ke = p;
                    break
                }
                ee.call(se, X, new Cw(se,{
                    sourceEvent: ke,
                    subject: te,
                    target: C,
                    identifier: _e,
                    active: Ke,
                    x: j[0] + ne,
                    y: j[1] + be,
                    dx: j[0] - tt[0],
                    dy: j[1] - tt[1],
                    dispatch: ee
                }), ce)
            }
    }
    return C.filter = function(X) {
        return arguments.length ? (r = typeof X == "function" ? X : K0(!!X),
        C) : r
    }
    ,
    C.container = function(X) {
        return arguments.length ? (e = typeof X == "function" ? X : K0(X),
        C) : e
    }
    ,
    C.subject = function(X) {
        return arguments.length ? (t = typeof X == "function" ? X : K0(X),
        C) : t
    }
    ,
    C.touchable = function(X) {
        return arguments.length ? (o = typeof X == "function" ? X : K0(!!X),
        C) : o
    }
    ,
    C.on = function() {
        var X = d.on.apply(d, arguments);
        return X === d ? C : X
    }
    ,
    C.clickDistance = function(X) {
        return arguments.length ? (A = (X = +X) * X,
        C) : Math.sqrt(A)
    }
    ,
    C
}
var {REFLECTIVITY: ng, VELOCITY: ig, VELOCITY_DEALIASED: rg, CC: sg, PHI: og, ZDR: ag, SW: lg} = Vs
  , hl = -160
  , dl = 160
  , Sc = {
    [ng]: [0, 80],
    [ig]: [hl, dl],
    [rg]: [hl, dl],
    [sg]: [.2, 1.05],
    [og]: [-2, 10],
    [ag]: [-8, 8],
    [lg]: [0, 60]
}
  , Dw = {
    [ng]: ["#242424", "#14466c", "#0FCBFF", "#1D9E00", "#95F44C", "#FFF700", "#FF9F0F", "#EB7900", "#FF1F1F", "#AD1100", "#FFB8F5", "#CA57FF", "#4A009E"],
    [ig]: ["#ffffff", "#FC52FF", "#871FFF", "#0011CC", "#0088CC", "#B3F0FF", "#42FF42", "#009402", "#A3A3A3", "#8A0000", "#FF5269", "#FFB3E0", "#FFF1C2", "#FF9214", "#B85C00", "#572100", "#000000"],
    [rg]: ["#ffffff", "#FC52FF", "#871FFF", "#0011CC", "#0088CC", "#B3F0FF", "#42FF42", "#009402", "#A3A3A3", "#8A0000", "#FF5269", "#FFB3E0", "#FFF1C2", "#FF9214", "#B85C00", "#572100", "#000000"],
    [sg]: ["#000000", "#949494", "#7593FF", "#0045BD", "#ADF4FF", "#00FA32", "#FFD53D", "#F01000", "#C20047", "#FFB8D8", "#FFEBF2"],
    [og]: ["#8b898c", "#403e41", "#520008", "#e575bd", "#a27abf", "#6df2f4", "#29c042", "#0afb0e", "#fefb06", "#ff820c"],
    [ag]: ["#242424", "#afafaf", "#B980FF", "#0000a3", "#6bf0ff", "#3dff64", "#f5ff2e", "#ffa30f", "#e61300", "#ff6bb5", "#ffe0e6"],
    [lg]: ["#242424", "#afafaf", "#ff700a", "#b30000", "#f000ac", "#8800c2", "#e0fcff", "#b4eb00", "#7dd100"]
}
  , r6 = {
    [ng]: [0, 10, 20, 30, 40, 50, 60, 70, 80],
    [ig]: [-160, -120, -80, -40, 0, 40, 80, 120, 160],
    [rg]: [-160, -120, -80, -40, 0, 40, 80, 120, 160],
    [sg]: [.2, 1.05],
    [og]: [-2, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
    [ag]: [-8, 0, 1, 2, 3, 4, 5, 6, 7, 8],
    [lg]: [0, 10, 15, 20, 25, 30, 35, 40, 60]
}
  , dC = {
    [ng]: "dBZ",
    [ig]: "kt",
    [rg]: "kt",
    [sg]: "",
    [og]: "deg km-1",
    [ag]: "dB",
    [lg]: "kt"
}
  , Lw = {
    [ng]: [0, 10, 20, 25, 30, 35, 40, 45, 50, 60, 65, 70, 80],
    [ig]: [hl, -140, -120, -100, -80, -60, -40, -20, 0, 20, 40, 60, 80, 100, 120, 140, dl],
    [rg]: [hl, -140, -120, -100, -80, -60, -40, -20, 0, 20, 40, 60, 80, 100, 120, 140, dl],
    [sg]: [.2, .4, .55, .65, .8, .85, .95, .975, 1, 1.04, 1.05],
    [og]: [-2, -.5, 0, 1.5, 2, 3, 4, 5, 7, 10],
    [ag]: [-8, 0, .25, .5, 1.5, 2, 2.5, 3.5, 5, 6, 8],
    [lg]: [0, 10, 15, 20, 25, 30, 35, 40, 60]
};
function fC(r, e, t) {
    let o = r
      , c = e;
    function d(p) {
        let i = Dw[p]
          , v = Lw[p];
        c.clearRect(0, 0, o.width, o.height);
        let x = c.createLinearGradient(0, 0, o.width, 0)
          , E = Sc[p][1]
          , A = Sc[p][0]
          , C = i.length;
        for (let I = 0; I < C; ++I)
            x.addColorStop((v[I] - A) / (E - A), i[I]);
        c.fillStyle = x,
        c.fillRect(0, 0, o.width, 10)
    }
    return {
        render: d
    }
}
function pC(r) {
    let e = r.getContext("2d")
      , t = window.devicePixelRatio || 1;
    r.width = r.clientWidth * t,
    r.height = r.clientHeight * t,
    e.scale(t, t);
    function o(c) {
        if (!e || c === void 0)
            return;
        e.clearRect(0, 0, r.width, r.height);
        let d = Dw[c]
          , p = Lw[c]
          , i = r6[c]
          , v = e.createLinearGradient(25, 0, 275, 0)
          , x = Sc[c][1]
          , E = Sc[c][0]
          , A = d.length;
        for (let I = 0; I < A; ++I)
            v.addColorStop((p[I] - E) / (x - E), d[I]);
        e.fillStyle = v,
        e.fillRect(25, 15, 250, 10),
        e.fillStyle = "black",
        e.strokeStyle = "white",
        e.textAlign = "center";
        let C = 25;
        for (let I = 0; I < i.length; I += 1) {
            let D = (i[I] - E) / (x - E);
            e.lineWidth = 3,
            e.strokeText(i[I], D * 250 + C, 36),
            e.lineWidth = 1.5,
            e.fillText(i[I], D * 250 + C, 36)
        }
        e.textAlign = "left",
        e.lineWidth = 3,
        e.strokeText(dC[c], 25, 10),
        e.lineWidth = 1.5,
        e.fillText(dC[c], 25, 10)
    }
    return {
        render: o
    }
}
function Rw(r, e) {
    let t = Dw[e]
      , o = Lw[e]
      , c = document.createElement("CANVAS");
    c.width = 1200,
    c.height = 1;
    let d = c.getContext("2d");
    d.clearRect(0, 0, c.width, c.height);
    let p = d.createLinearGradient(0, 0, 1200, 0)
      , i = Sc[e][1]
      , v = Sc[e][0]
      , x = t.length;
    for (let C = 0; C < x; ++C)
        p.addColorStop((o[C] - v) / (i - v), t[C]);
    d.fillStyle = p,
    d.fillRect(0, 0, 1200, 1);
    let E = d.getImageData(0, 0, 1200, 1)
      , A = r.createTexture();
    return r.activeTexture(r.TEXTURE7),
    r.bindTexture(r.TEXTURE_2D, A),
    r.texImage2D(r.TEXTURE_2D, 0, r.RGBA, r.RGBA, r.UNSIGNED_BYTE, E),
    r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_S, r.CLAMP_TO_EDGE),
    r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_T, r.CLAMP_TO_EDGE),
    r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MIN_FILTER, r.LINEAR),
    {
        imageData: E,
        texture: A
    }
}
function mC(r, e, t) {
    let o = r.slice();
    return o[27] = e[t],
    o
}
function gC(r) {
    let e, t = r[27] + "", o, c, d;
    return {
        c() {
            e = qe("option"),
            o = Un(t),
            c = It(),
            e.__value = d = r[27],
            e.value = e.__value
        },
        m(p, i) {
            yn(p, e, i),
            Se(e, o),
            Se(e, c)
        },
        p: Hn,
        d(p) {
            p && mn(e)
        }
    }
}
function s6(r) {
    let e, t, o, c, d, p, i, v, x, E, A, C, I, D, P, k, U, Z, K, X, W, fe, ce, _e, oe, ee = r[4], j = [];
    for (let ne = 0; ne < ee.length; ne += 1)
        j[ne] = gC(mC(r, ee, ne));
    return {
        c() {
            e = qe("div"),
            t = qe("div"),
            o = qe("p"),
            o.textContent = "Edit transparency",
            c = It(),
            d = qe("div"),
            p = qe("button"),
            p.textContent = "Reset",
            i = It(),
            v = qe("button"),
            v.textContent = "Close",
            x = It(),
            E = qe("div"),
            A = qe("span"),
            A.textContent = "Presets",
            C = It(),
            I = qe("select");
            for (let ne = 0; ne < j.length; ne += 1)
                j[ne].c();
            D = It(),
            P = qe("div"),
            k = qe("div"),
            U = qe("canvas"),
            Z = It(),
            K = qe("p"),
            K.textContent = "opaque",
            X = It(),
            W = qe("p"),
            W.textContent = "transparent",
            fe = It(),
            ce = qe("canvas"),
            je(o, "class", "title svelte-171bwmt"),
            je(p, "class", "reset svelte-171bwmt"),
            je(v, "class", "close svelte-171bwmt"),
            je(d, "class", "button-container svelte-171bwmt"),
            je(I, "class", "s svelte-171bwmt"),
            r[3] === void 0 && jl(()=>r[9].call(I)),
            je(E, "class", "preset-container svelte-171bwmt"),
            je(t, "class", "top svelte-171bwmt"),
            je(U, "class", "window svelte-171bwmt"),
            je(K, "class", "opaque svelte-171bwmt"),
            je(W, "class", "transparent svelte-171bwmt"),
            je(k, "class", "canvas-wrapper"),
            je(ce, "class", "colorbar svelte-171bwmt"),
            je(P, "class", "window-wrapper svelte-171bwmt"),
            je(e, "class", "menu3d-wrapper svelte-171bwmt"),
            Gn(e, "hidden", !r[0])
        },
        m(ne, be) {
            yn(ne, e, be),
            Se(e, t),
            Se(t, o),
            Se(t, c),
            Se(t, d),
            Se(d, p),
            Se(d, i),
            Se(d, v),
            Se(t, x),
            Se(t, E),
            Se(E, A),
            Se(E, C),
            Se(E, I);
            for (let te = 0; te < j.length; te += 1)
                j[te].m(I, null);
            bu(I, r[3]),
            Se(e, D),
            Se(e, P),
            Se(P, k),
            Se(k, U),
            r[10](U),
            Se(k, Z),
            Se(k, K),
            Se(k, X),
            Se(k, W),
            Se(P, fe),
            Se(P, ce),
            r[11](ce),
            _e || (oe = [wn(p, "click", r[5]), wn(v, "click", r[6]), wn(I, "change", r[9]), wn(I, "change", r[7])],
            _e = !0)
        },
        p(ne, [be]) {
            if (be & 16) {
                ee = ne[4];
                let te;
                for (te = 0; te < ee.length; te += 1) {
                    let ae = mC(ne, ee, te);
                    j[te] ? j[te].p(ae, be) : (j[te] = gC(ae),
                    j[te].c(),
                    j[te].m(I, null))
                }
                for (; te < j.length; te += 1)
                    j[te].d(1);
                j.length = ee.length
            }
            be & 24 && bu(I, ne[3]),
            be & 1 && Gn(e, "hidden", !ne[0])
        },
        i: Hn,
        o: Hn,
        d(ne) {
            ne && mn(e),
            As(j, ne),
            r[10](null),
            r[11](null),
            _e = !1,
            Wi(oe)
        }
    }
}
function o6(r, e, t) {
    let {REFLECTIVITY: o, VELOCITY: c, VELOCITY_DEALIASED: d} = Vs, p, i, v, x, E = new Array(350), A = [], C, I = "Default", D = ["Default", "Hail", "Hurricane", "Snow"], {imageData: P=void 0} = e, {showTrans: k} = e;
    function U({x: te, y: ae}) {
        te < 10 && (te = 10),
        ae < 10 && (ae = 10),
        te > 360 && (te = 360),
        ae > 210 && (ae = 210),
        A = [te, ae]
    }
    function Z({x: te, y: ae}) {
        let se = !1;
        te < 10 && (te = 10,
        se = !0),
        ae < 10 && (ae = 10),
        te > 360 && (te = 360,
        se = !0),
        ae > 210 && (ae = 210);
        let ke = A[1]
          , Be = A[0]
          , tt = Math.abs(te - Be);
        if (se) {
            A = [te, ae];
            return
        }
        if (te - Be < 0)
            for (let Ke = te; Ke < Be; Ke++) {
                let bt = ae * ((Be - Ke) / tt) + ke * ((Ke - te) / tt);
                E[Ke - 10] = (Math.min(Math.max(bt, 10), 210) - 10) / 200
            }
        else
            for (let Ke = Be; Ke < te; Ke++) {
                let bt = ke * ((te - Ke) / tt) + ae * ((Ke - Be) / tt);
                E[Ke - 10] = (Math.min(Math.max(bt, 10), 210) - 10) / 200
            }
        te >= 10 && te <= 360 && (E[te - 10] = (Math.min(Math.max(ae, 10), 210) - 10) / 200),
        A = [te, ae]
    }
    function K() {
        v.clearRect(0, 0, p.width, p.height),
        v.fillStyle = "black",
        v.fillRect(10, 10, 350, 200),
        v.strokeStyle = "white",
        v.lineWidth = 3,
        v.lineJoin = "round",
        v.lineCap = "round",
        v.beginPath(),
        v.moveTo(10, E[0] * 200 + 10);
        for (let te = 1; te < E.length; te++)
            v.lineTo(te + 10, E[te] * 200 + 10);
        v.stroke()
    }
    function X() {
        if (!p)
            return;
        let te = window.devicePixelRatio || 1;
        t(1, p.style.width = "370px", p),
        t(1, p.style.height = "220px", p),
        t(1, p.width = p.clientWidth * te, p),
        t(1, p.height = p.clientHeight * te, p),
        v.scale(te, te),
        C.render(o),
        K()
    }
    function W() {
        if (!!i) {
            t(2, i.style.width = "350px", i),
            t(2, i.style.height = "20px", i),
            t(2, i.width = i.clientWidth, i),
            t(2, i.height = i.clientHeight, i),
            C.render(o),
            t(8, P = x.getImageData(0, 0, 350, 1));
            for (let te = 0; te < E.length; te++)
                t(8, P.data[4 * te + 3] = 255 * (1 - E[te]), P)
        }
    }
    function fe() {
        if (C.render(o),
        x.canvas.width !== 0) {
            t(8, P = x.getImageData(0, 0, 350, 1));
            for (let te = 0; te < E.length; te++)
                t(8, P.data[4 * te + 3] = 255 * (1 - E[te]), P)
        }
    }
    function ce(te) {
        if (te === "Snow") {
            for (let ae = 0; ae < 15; ae++)
                E[ae] = 1;
            for (let ae = 15; ae < 90; ae++)
                E[ae] = 1 - Math.pow((ae - 15) / 200, 1.5);
            for (let ae = 90; ae < 105; ae++)
                E[ae] = 1;
            for (let ae = 105; ae < 350; ae++)
                E[ae] = 1 - Math.min(1, Math.pow((ae - 105) / 200, .35))
        }
        if (te === "Default") {
            for (let ae = 0; ae < 25; ae++)
                E[ae] = 1;
            for (let ae = 25; ae < E.length; ae++)
                E[ae] = Math.min(1 - Math.pow(ae / 350, 1), 1)
        }
        if (te === "Hail") {
            for (let ae = 0; ae < 15; ae++)
                E[ae] = 1;
            for (let ae = 15; ae < 90; ae++)
                E[ae] = 1 - Math.pow((ae - 15) / 200, 1.5);
            for (let ae = 90; ae < 200; ae++)
                E[ae] = 1;
            for (let ae = 200; ae < 270; ae++)
                E[ae] = 1 - Math.pow((ae - 200) / 175, 2);
            for (let ae = 270; ae < 280; ae++)
                E[ae] = 1;
            for (let ae = 280; ae < 350; ae++)
                E[ae] = 1 - Math.min(1, Math.pow((ae - 280) / 200, .15))
        }
        if (te === "Hurricane") {
            for (let ae = 0; ae < 15; ae++)
                E[ae] = 1;
            for (let ae = 15; ae < 90; ae++)
                E[ae] = 1 - Math.pow((ae - 15) / 200, 1.5);
            for (let ae = 90; ae < 150; ae++)
                E[ae] = 1;
            for (let ae = 150; ae < 350; ae++)
                E[ae] = 1 - Math.min(1, Math.pow((ae - 150) / 200, .35))
        }
    }
    Ha(()=>{
        new IntersectionObserver(X).observe(p),
        new IntersectionObserver(W).observe(i),
        ce("Default"),
        v = p.getContext("2d"),
        x = i.getContext("2d", {
            willReadFrequently: !0
        });
        let se = window.devicePixelRatio || 1;
        t(1, p.style.width = "370px", p),
        t(1, p.style.height = "220px", p),
        t(1, p.width = p.clientWidth * se, p),
        t(1, p.height = p.clientHeight * se, p),
        v.scale(se, se),
        t(2, i.style.width = "350px", i),
        t(2, i.style.height = "20px", i),
        t(2, i.width = i.clientWidth, i),
        t(2, i.height = i.clientHeight, i),
        C = fC(i, x, se),
        C.render(o),
        Ec(p).call(hC().container(p).on("start", U).on("drag", Z).on("end", fe).on("start.render drag.render", K)),
        K(),
        fe()
    }
    );
    function _e() {
        ce(I),
        K(),
        fe()
    }
    function oe() {
        t(0, k = !1)
    }
    function ee() {
        ce(I),
        K(),
        fe()
    }
    function j() {
        I = Op(this),
        t(3, I),
        t(4, D)
    }
    function ne(te) {
        Bi[te ? "unshift" : "push"](()=>{
            p = te,
            t(1, p)
        }
        )
    }
    function be(te) {
        Bi[te ? "unshift" : "push"](()=>{
            i = te,
            t(2, i)
        }
        )
    }
    return r.$$set = te=>{
        "imageData"in te && t(8, P = te.imageData),
        "showTrans"in te && t(0, k = te.showTrans)
    }
    ,
    [k, p, i, I, D, _e, oe, ee, P, j, ne, be]
}
var _C = class extends mi {
    constructor(e) {
        super();
        _i(this, e, o6, s6, di, {
            imageData: 8,
            showTrans: 0
        })
    }
}
  , yC = _C;
function xC(r) {
    let e, t, o;
    return {
        c() {
            e = qe("div"),
            t = qe("p"),
            o = Un(r[4]),
            je(e, "class", "inc svelte-6pvw7y")
        },
        m(c, d) {
            yn(c, e, d),
            Se(e, t),
            Se(t, o)
        },
        p(c, d) {
            d[0] & 16 && gi(o, c[4])
        },
        d(c) {
            c && mn(e)
        }
    }
}
function vC(r) {
    let e, t, o;
    return {
        c() {
            e = qe("button"),
            e.innerHTML = `<div class="circle svelte-6pvw7y"></div> 
            <div class="circle svelte-6pvw7y"></div> 
            <div class="circle svelte-6pvw7y"></div>`,
            je(e, "class", "svelte-6pvw7y")
        },
        m(c, d) {
            yn(c, e, d),
            t || (o = wn(e, "click", r[8]),
            t = !0)
        },
        p: Hn,
        d(c) {
            c && mn(e),
            t = !1,
            o()
        }
    }
}
function bC(r) {
    let e;
    return {
        c() {
            e = qe("div"),
            e.innerHTML = `<div class="scene svelte-6pvw7y"><div class="cube svelte-6pvw7y"><div class="cube__face cube__face--front svelte-6pvw7y"></div> 
                <div class="cube__face cube__face--back svelte-6pvw7y"></div> 
                <div class="cube__face cube__face--right svelte-6pvw7y"></div> 
                <div class="cube__face cube__face--left svelte-6pvw7y"></div> 
                <div class="cube__face cube__face--top svelte-6pvw7y"></div> 
                <div class="cube__face cube__face--bottom svelte-6pvw7y"></div></div></div>`,
            je(e, "class", "loader svelte-6pvw7y")
        },
        m(t, o) {
            yn(t, e, o)
        },
        d(t) {
            t && mn(e)
        }
    }
}
function a6(r) {
    let e, t, o, c, d, p, i, v, x, E, A, C, I = r[6] === !1 && wC === !0 && xC(r), D = r[1] === r[7] && vC(r), P = r[6] === !0 && bC(r);
    function k(K) {
        r[16](K)
    }
    function U(K) {
        r[17](K)
    }
    let Z = {};
    return r[5] !== void 0 && (Z.showTrans = r[5]),
    r[0] !== void 0 && (Z.imageData = r[0]),
    x = new yC({
        props: Z
    }),
    Bi.push(()=>ha(x, "showTrans", k)),
    Bi.push(()=>ha(x, "imageData", U)),
    {
        c() {
            e = qe("div"),
            t = qe("canvas"),
            o = It(),
            c = qe("div"),
            d = It(),
            I && I.c(),
            p = It(),
            D && D.c(),
            i = It(),
            P && P.c(),
            v = It(),
            Qi(x.$$.fragment),
            je(t, "class", "can svelte-6pvw7y"),
            je(t, "id", "can"),
            je(c, "class", "v svelte-6pvw7y"),
            je(e, "class", "wrapper svelte-6pvw7y")
        },
        m(K, X) {
            yn(K, e, X),
            Se(e, t),
            r[15](t),
            Se(e, o),
            Se(e, c),
            Se(e, d),
            I && I.m(e, null),
            Se(e, p),
            D && D.m(e, null),
            Se(e, i),
            P && P.m(e, null),
            Se(e, v),
            qi(x, e, null),
            r[18](e),
            C = !0
        },
        p(K, X) {
            K[6] === !1 && wC === !0 ? I ? I.p(K, X) : (I = xC(K),
            I.c(),
            I.m(e, p)) : I && (I.d(1),
            I = null),
            K[1] === K[7] ? D ? D.p(K, X) : (D = vC(K),
            D.c(),
            D.m(e, i)) : D && (D.d(1),
            D = null),
            K[6] === !0 ? P || (P = bC(K),
            P.c(),
            P.m(e, v)) : P && (P.d(1),
            P = null);
            let W = {};
            !E && X[0] & 32 && (E = !0,
            W.showTrans = K[5],
            ua(()=>E = !1)),
            !A && X[0] & 1 && (A = !0,
            W.imageData = K[0],
            ua(()=>A = !1)),
            x.$set(W)
        },
        i(K) {
            C || (Wn(x.$$.fragment, K),
            C = !0)
        },
        o(K) {
            ri(x.$$.fragment, K),
            C = !1
        },
        d(K) {
            K && mn(e),
            r[15](null),
            I && I.d(),
            D && D.d(),
            P && P.d(),
            Ki(x),
            r[18](null)
        }
    }
}
var TC = 1e-5
  , wC = !0;
function Y0(r, e, t, o) {
    let c = o * (Math.PI / 180)
      , d = t * (Math.PI / 180)
      , p = e * (Math.PI / 180)
      , i = r * (Math.PI / 180)
      , v = Math.fround(Math.sin(Math.fround(p)) * Math.sin(Math.fround(c))) + Math.fround(Math.cos(Math.fround(p)) * Math.cos(Math.fround(c)) * Math.cos(Math.fround(d - i)))
      , x = Math.sin(p) * Math.sin(c) + Math.cos(p) * Math.cos(c) * Math.cos(d - i)
      , E = Math.acos(x)
      , A = Math.fround(Math.acos(v))
      , C = E / Math.sin(E)
      , I = C * Math.cos(c) * Math.sin(d - i) * 6371e3
      , D = C * (Math.cos(p) * Math.sin(c) - Math.sin(p) * Math.cos(c) * Math.cos(d - i)) * 6371e3;
    return [I, D]
}
function l6(r, e, t) {
    let o, c, d, p, i, v, x, E;
    Ht(r, zr, kt=>t(1, o = kt)),
    Ht(r, Ms, kt=>t(11, c = kt)),
    Ht(r, Ou, kt=>t(12, d = kt)),
    Ht(r, zu, kt=>t(13, p = kt)),
    Ht(r, Xa, kt=>t(6, i = kt)),
    Ht(r, ui, kt=>t(35, v = kt)),
    Ht(r, ai, kt=>t(36, x = kt)),
    Ht(r, Hs, kt=>t(14, E = kt));
    let {MODE3D: A, CROSS: C} = Yr, I, D, P, k, U, Z, K, X, W, fe = "", ce = [], _e, oe, ee, j = !1, ne = new Float32Array(108), be = new Float32Array(18), te = new Uint8Array([255, 255, 255, 255]), ae = new ac(new Uint8Array([255]),1,1,1);
    ae.format = pm,
    ae.minFilter = Di,
    ae.magFilter = Di,
    ae.unpackAlignment = 1,
    ae.needsUpdate = !0;
    let se = new al(te,1,1,is);
    se.minFilter = Di,
    se.magFilter = Di,
    se.unpackAlignment = 1,
    se.needsUpdate = !0;
    let ke = `
        in vec3 position;
        uniform mat4 modelMatrix;
		uniform mat4 modelViewMatrix;
        uniform mat4 projectionMatrix;
        uniform mat4 viewMatrix;

        uniform vec3 u_eye_pos;
        out vec3 outPosition;

        void main() {
            vec3 dif = vec3(position.xyz) - u_eye_pos;

            vec4 outpos = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);
            outPosition = position.xyz;
            gl_Position = outpos;
        }
    `
      , Be = `

        precision highp float;
        precision highp sampler3D;

        uniform vec3 u_eye_pos;
        uniform sampler3D volume;
        uniform highp sampler2D table;
        uniform highp sampler2D tf;
        uniform highp sampler2D bracket;
        uniform vec3 u_plane_center;
        uniform vec3 u_plane_normal;

        //values held in texture
        uniform vec2 u_table_domain;
        //for decoding
        uniform float u_table_max;

        uniform float u_scale;
        uniform float u_offset;
        uniform float u_bin1;
        uniform float u_ngates;
        uniform float u_binMax;
        uniform float u_num_elevations;

        in vec3 outPosition;
        out vec4 color;

        float intersect_plane(vec3 dir) {
            float denominator = dot(u_plane_normal, dir);
            if (abs(denominator) > 0.0001) {
                vec3 difference = u_plane_center - u_eye_pos;
                float t = dot(difference, u_plane_normal)/denominator;

                if (t > 0.000000001) {
                    return t;
                }
            }

            return -1.0;
        }

        float lint(vec4 inputs, float c) {
            
            float y0 = inputs.y;
            float y1 = inputs.w;
            float x0 = inputs.x;
            float x1 = inputs.z;
            if (x1 < x0) {
                return 0.0;
            }
            float x = c;
            float y = y0*(1.0-((x-x0)/(x1-x0)))
            + y1*((x-x0)/(x1-x0));

            return y;
        }

        void main() {
            float b = 0.0;
            float newBelow = 0.0;
            float belowVal = 0.0;
            vec4 below = vec4(0,0,0,0);
            vec4 above = vec4(0,0,0,0);
            float elevation = 0.0;
            float d = 0.0;

        

            vec3 p = outPosition;

            
                //spherical radius
               
                vec3 pcopy = p;
                pcopy.y = pcopy.y/3.0;
                float r = sqrt(p.x*p.x + pcopy.y*pcopy.y + p.z*p.z);

                b = mod(degrees(atan(p.z, p.x)) + 90.0, 360.0);

                elevation = degrees(atan(pcopy.y/sqrt(p.x*p.x + p.z*p.z)));
                d = sqrt(r*r - pcopy.y*pcopy.y);

                //advance if above or below highest or lowest elevation
                if (elevation > u_table_domain.y || elevation < u_table_domain.x) {
                    color = vec4(0,0,0,0);
                    return;
                }

                //get idxs of two closest 
                vec4 two = texture(bracket, vec2((elevation - u_table_domain.x)/(u_table_domain.y-u_table_domain.x), 0.0));

                //need number of levels as uniform
                float aboveZ = (two.y*255.0)/u_num_elevations;
                float belowZ = (two.x*255.0)/u_num_elevations;

                above = texture(table, vec2(aboveZ, 0.0));
                below = texture(table, vec2(belowZ, 0.0));

                //elevations above and below in degrees
                float aboveVal = (above.x+above.y*(1.0/255.0))
                        *(u_table_max - u_table_domain.x) + u_table_domain.x;

                belowVal = (below.x+below.y*(1.0/255.0))
                        *(u_table_max - u_table_domain.x) + u_table_domain.x;

                if (elevation < belowVal) {
                    belowZ = (two.x*255.0 - 1.0)/u_num_elevations;
                    aboveZ = (two.y*255.0 - 1.0)/u_num_elevations;
                    above = texture(table, vec2(aboveZ, 0.0));
                    below = texture(table, vec2(belowZ, 0.0));
                    //elevations above and below in degrees
                    aboveVal = (above.x+above.y*(1.0/255.0))
                            *(u_table_max - u_table_domain.x) + u_table_domain.x;
                    belowVal = (below.x+below.y*(1.0/255.0))
                            *(u_table_max - u_table_domain.x) + u_table_domain.x;
                } else if (elevation > aboveVal) {
                    belowZ = (two.x*255.0 + 1.0)/u_num_elevations;
                    aboveZ = (two.y*255.0 + 1.0)/u_num_elevations;
                    above = texture(table, vec2(aboveZ, 0.0));
                    below = texture(table, vec2(belowZ, 0.0));
                    //elevations above and below in degrees
                    aboveVal = (above.x+above.y*(1.0/255.0))
                            *(u_table_max - u_table_domain.x) + u_table_domain.x;
                    belowVal = (below.x+below.y*(1.0/255.0))
                            *(u_table_max - u_table_domain.x) + u_table_domain.x;
                }

                //get whether elevation closer to beam above or below
                float average = (aboveVal + belowVal)/2.0;
                float closestStep = step(average, elevation);

                float newAbove = d/cos(radians(aboveVal));
                newBelow = d/cos(radians(belowVal));

                if (newAbove < u_bin1 || newBelow < u_bin1 || newAbove > u_binMax || newBelow > u_binMax) {
                    color = vec4(0,0,0,0);
                    return;
                } else {
                    newAbove = newAbove - u_bin1;
                    newBelow = newBelow - u_bin1;
                }
                float newVal;
                //was closer to below
                if (closestStep == 0.0) {
                    newVal = texture(volume, vec3(newBelow/u_ngates, b/360.0, belowZ)).r;
                } else { //was closer to above
                    newVal = texture(volume, vec3(newAbove/u_ngates, b/360.0, aboveZ)).r;
                }

                //Needs to be divided by range_max in km
                float valAbove = texture(volume, vec3(newAbove/u_ngates, b/360.0, aboveZ)).r;
                float valBelow = texture(volume, vec3(newBelow/u_ngates, b/360.0, belowZ)).r;

                vec4 forLint = vec4(belowVal, valBelow, aboveVal, valAbove);
                newVal = lint(forLint, elevation);

                float dbzVal = (newVal*255.0 - u_offset)/u_scale;

                if (dbzVal < 10.0) {
                    color = vec4(0,0,0,0);
                    return;
                }

                vec4 val_color = vec4(texture(tf, vec2(max(dbzVal,0.0)/80.0, 0.0)).rgb, 1.0);

                color = val_color;
            

            //color = vec4(t_hit/100.0, 0.0, 0.0, 1.0);
        }
    `
      , tt = `
        in vec3 position;
        uniform mat4 modelMatrix;
		uniform mat4 modelViewMatrix;
        uniform mat4 projectionMatrix;
        uniform mat4 viewMatrix;
        //uniform mat4 modelMatrix;
        
        //uniform vec3 cameraPos;
        uniform vec3 u_eye_pos;
        uniform vec2 u_radar_pos;
        uniform float u_height_scale;

        //out vec3 vOrigin;
        //out vec3 vDirection;
        out vec3 vray_dir;

        mat4 scaling;

        void main() {


            vec3 pcopy = vec3(position.x, position.y, position.z);
            vec3 dif = pcopy - u_eye_pos;
            vray_dir = dif;
           
            vec4 outpos = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);

            gl_Position = outpos;
        
        }
    `
      , Ke = `
        precision highp float;
        precision highp sampler3D;

        in vec3 vray_dir;
        out vec4 color;

        uniform vec3 u_eye_pos;
        uniform vec2 u_x_domain;
        uniform vec2 u_y_domain;
        uniform vec2 u_z_domain;
        uniform sampler3D volume;
        uniform highp sampler2D table;
        uniform highp sampler2D tf;
        uniform highp sampler2D bracket;

        //values held in texture
        uniform vec2 u_table_domain;
        //for decoding
        uniform float u_table_max;

        uniform float u_scale;
        uniform float u_offset;
        uniform float u_bin1;
        uniform float u_ngates;
        uniform float u_binMax;
        uniform float u_num_elevations;

        vec2 intersect_box(vec3 dir) {
            vec3 inv_dir = 1.0 / dir;

            vec3 box_min = vec3(u_x_domain.x, u_y_domain.x, u_z_domain.x);
            vec3 box_max = vec3(u_x_domain.y, u_y_domain.y, u_z_domain.y);
            
            vec3 tmin_tmp = (box_min - u_eye_pos) * inv_dir;
            vec3 tmax_tmp = (box_max - u_eye_pos) * inv_dir;
            vec3 tmin = min(tmin_tmp, tmax_tmp);
            vec3 tmax = max(tmin_tmp, tmax_tmp);
            float t0 = max(tmin.x, max(tmin.y, tmin.z));
            float t1 = min(tmax.x, min(tmax.y, tmax.z));
            return vec2(t0, t1);
        }


        float lint(vec4 inputs, float c) {
            
            float y0 = inputs.y;
            float y1 = inputs.w;
            float x0 = inputs.x;
            float x1 = inputs.z;
            if (x1 < x0) {
                return 0.0;
            }
            float x = c;
            float y = y0*(1.0-((x-x0)/(x1-x0)))
            + y1*((x-x0)/(x1-x0));

            return y;
        }

        // Pseudo-random number gen from
        // http://www.reedbeta.com/blog/quick-and-easy-gpu-random-numbers-in-d3d11/
        // with some tweaks for the range of values
        float wang_hash(int seed) {
            seed = (seed ^ 61) ^ (seed >> 16);
            seed *= 9;
            seed = seed ^ (seed >> 4);
            seed *= 0x27d4eb2d;
            seed = seed ^ (seed >> 15);
            return float(seed % 2147483647) / float(2147483647);
        }
        

        void main(){
            vec3 ray_dir = normalize(vray_dir);

            vec2 t_hit = intersect_box(ray_dir);
            
            if (t_hit.x > t_hit.y) {
                color = vec4(0,0,0,0);
                return;
            }

            t_hit.x = max(t_hit.x, 0.0);
            
            float b = 0.0;
            float newBelow = 0.0;
            float belowVal = 0.0;
            vec4 below = vec4(0,0,0,0);
            vec4 above = vec4(0,0,0,0);
            float elevation = 0.0;
            
            float d = 0.0;
            float outt = 0.0;
            int broke = 0;
            
            float dt = 0.25;

            //vec3 p = u_eye_pos + (t_hit.x * ray_dir);
            

            //float offset = wang_hash(int(gl_FragCoord.x + 400.0 * gl_FragCoord.y));

            vec3 p = u_eye_pos + (t_hit.x) * ray_dir;

            for (float t = t_hit.x; t < t_hit.y; t += dt) {
                //spherical radius
               
                vec3 pcopy = p;
                pcopy.y = pcopy.y/3.0;
               
                float r = sqrt(p.x*p.x + pcopy.y*pcopy.y + p.z*p.z);

                b = mod(degrees(atan(p.z, p.x)) + 90.0, 360.0);

                elevation = degrees(atan(pcopy.y/sqrt(p.x*p.x + p.z*p.z)));
                d = sqrt(r*r - pcopy.y*pcopy.y);

                //advance if above or below highest or lowest elevation
                if (elevation > u_table_domain.y || elevation < u_table_domain.x) {
                   p += ray_dir * dt;
                   continue;
                }

                //get idxs of two closest 
                vec4 two = texture(bracket, vec2((elevation - u_table_domain.x)/(u_table_domain.y - u_table_domain.x), 0.0));

                //need number of levels as uniform
                float aboveZ = (two.y*255.0)/u_num_elevations;
                float belowZ = (two.x*255.0)/u_num_elevations;

                above = texture(table, vec2(aboveZ, 0.0));
                below = texture(table, vec2(belowZ, 0.0));

                //elevations above and below in degrees
                float aboveVal = (above.x+above.y*(1.0/255.0))
                        *(u_table_max - u_table_domain.x) + u_table_domain.x;

                belowVal = (below.x+below.y*(1.0/255.0))
                        *(u_table_max - u_table_domain.x) + u_table_domain.x;


                if (elevation < belowVal) {
                    belowZ = (two.x*255.0 - 1.0)/u_num_elevations;
                    aboveZ = (two.y*255.0 - 1.0)/u_num_elevations;
                    above = texture(table, vec2(aboveZ, 0.0));
                    below = texture(table, vec2(belowZ, 0.0));
                    //elevations above and below in degrees
                    aboveVal = (above.x+above.y*(1.0/255.0))
                            *(u_table_max - u_table_domain.x) + u_table_domain.x;
                    belowVal = (below.x+below.y*(1.0/255.0))
                            *(u_table_max - u_table_domain.x) + u_table_domain.x;
                } else if (elevation > aboveVal) {
                    belowZ = (two.x*255.0 + 1.0)/u_num_elevations;
                    aboveZ = (two.y*255.0 + 1.0)/u_num_elevations;
                    above = texture(table, vec2(aboveZ, 0.0));
                    below = texture(table, vec2(belowZ, 0.0));
                    //elevations above and below in degrees
                    aboveVal = (above.x+above.y*(1.0/255.0))
                            *(u_table_max - u_table_domain.x) + u_table_domain.x;
                    belowVal = (below.x+below.y*(1.0/255.0))
                            *(u_table_max - u_table_domain.x) + u_table_domain.x;
                }

                float newAbove = d/cos(radians(aboveVal));
                newBelow = d/cos(radians(belowVal));

                //if (newAbove < u_bin1 || newBelow < u_bin1) {
                if (newAbove < u_bin1 || newBelow < u_bin1 || newAbove > u_binMax || newBelow > u_binMax) {
                    p += ray_dir * dt;
                    continue;
                } else {
                    newAbove = newAbove - u_bin1;
                    newBelow = newBelow - u_bin1;
                }

                //Needs to be divided by range_max in km
                float valAbove = texture(volume, vec3(newAbove/u_ngates, b/360.0, aboveZ)).r;
                float valBelow = texture(volume, vec3(newBelow/u_ngates, b/360.0, belowZ)).r;

                vec4 forLint = vec4(belowVal, valBelow, aboveVal, valAbove);
                float newVal = lint(forLint, elevation);

                float dbzVal = (newVal*255.0 - u_offset)/u_scale;

                vec4 val_color = vec4(texture(tf, vec2(max(dbzVal,0.0)/80.0, 0.0)).rgba);
                float alpha = 1.0-pow((1.0 - val_color.a),0.3);
                //float alpha = 1.0 - (1.0 - val_color.a);
                color.rgb += (1.0 - color.a) * alpha * val_color.rgb;
                color.a += (1.0 - color.a) * alpha;

                if (color.a >= 0.95) {
                    break;
                }
                p += ray_dir * dt;  
            } 
        }
    `;
    function bt() {
        o === A && (gt.clear(),
        P.remove(U),
        ce.forEach(kt=>P.remove(kt)),
        P.add(k),
        t(4, fe = "Drag bounding box on map.")),
        o === C && (t(5, j = !1),
        gt.clear(),
        P.remove(k),
        P.add(U),
        t(4, fe = "Drag line on map."))
    }
    function Et(kt=o) {
        if (P && gt) {
            if (gt.clear(),
            kt === A) {
                P.remove(k);
                for (let Zt = 0; Zt < ne.length; Zt++)
                    k.geometry.attributes.position.needsUpdate = !0,
                    k.geometry.attributes.position.array[Zt] = 0
            } else {
                P.remove(U);
                for (let Zt = 0; Zt < be.length; Zt++)
                    U.geometry.attributes.position.needsUpdate = !0,
                    U.geometry.attributes.position.array[Zt] = 0
            }
            kt === C && ce.forEach(Zt=>P.remove(Zt))
        }
    }
    function Gt() {
        if (d === null || !E.lat || !E.lon)
            return;
        P.getObjectByName("meshPlane") || P.add(U);
        let kt = d[0], Zt = d[1], zn = Y0(E.lon, E.lat, kt.lng, kt.lat), Qt = Y0(E.lon, E.lat, Zt.lng, Zt.lat), xe = Qt[0] / 1e3, he = zn[0] / 1e3, Qe = -zn[1] / 1e3, ft = -Qt[1] / 1e3, St = 6e4 / 1e3, Mt = 0, an = [xe - he, ft - Qe], Ie = [(xe + he) / 2, (ft + Qe) / 2, St / 3], Ct;
        if (Math.abs(an[0]) < TC)
            Ct = [1, 0, 0];
        else if (Math.abs(an[1]) < TC)
            Ct = [0, 1, 0];
        else {
            let nn = [1, -an[0] / an[1]]
              , Jt = Math.sqrt(nn[0] * nn[0] + nn[1] * nn[1]);
            Ct = [nn[0] / Jt, nn[1] / Jt, 0]
        }
        an[0] * -Ct[1] + an[1] * Ct[0] > 0 && (Ct = Ct.map(nn=>-nn));
        let Kt = new Float32Array([he, Mt, Qe, xe, Mt, ft, he, St, Qe, he, St, Qe, xe, Mt, ft, xe, St, ft]);
        U.geometry.attributes.position.needsUpdate = !0;
        for (let nn = 0; nn < Kt.length; nn++)
            U.geometry.attributes.position.array[nn] = Kt[nn];
        let Ge = xe - he, Wt = ft - Qe, Ut = Math.sqrt(Ge * Ge + Wt * Wt), _n = St, Ft;
        if (xn && Tn) {
            if (Ut > _n) {
                let nn = Math.atan(Math.tan(Tn.fov * Math.PI / 180 / 2) * Tn.aspect);
                Ft = Ut / 2 / Math.tan(nn)
            } else
                Ft = _n / 2 / Math.tan(Tn.fov * Math.PI / 180 / 2);
            Ft *= 1.1,
            Tn.position.set(Ie[0] + Ct[0] * Ft, Ie[2] + Ct[2] * Ft, Ie[1] + Ct[1] * Ft),
            xn.target = new Oe(Ie[0],Ie[2],Ie[1]),
            U.material.uniforms.u_plane_normal.value = new Oe(Ct[0],Ct[2],Ct[1]),
            U.material.uniforms.u_plane_center.value = new Oe(Ie[0],Ie[2],Ie[1]),
            xn.update(),
            ce[0].position.copy(new Oe(he,Mt,Qe)),
            ce[1].position.copy(new Oe(xe,Mt,ft)),
            P.getObjectByName("A") || ce.forEach(nn=>P.add(nn))
        }
        Bt()
    }
    function Ye() {
        if (p === null || !E.lat || !E.lon)
            return;
        P.getObjectByName("mesh") || P.add(k);
        let kt = p[0]
          , Zt = p[1]
          , zn = Y0(E.lon, E.lat, kt.lng, kt.lat)
          , Qt = Y0(E.lon, E.lat, Zt.lng, Zt.lat)
          , xe = Qt[0] / 1e3
          , he = zn[0] / 1e3
          , Qe = -zn[1] / 1e3
          , ft = -Qt[1] / 1e3
          , St = 6e4 / 1e3
          , Mt = 0
          , an = (Qe + ft) / 2
          , Ie = (he + xe) / 2;
        k.material.uniforms.u_x_domain.value = new zt(he,xe),
        k.material.uniforms.u_y_domain.value = new zt(Mt,St),
        k.material.uniforms.u_z_domain.value = new zt(Qe,ft);
        let Ct = new Float32Array([he, Mt, ft, xe, Mt, ft, he, St, ft, he, St, ft, xe, Mt, ft, xe, St, ft, xe, Mt, ft, xe, Mt, Qe, xe, St, ft, xe, St, ft, xe, Mt, Qe, xe, St, Qe, xe, Mt, Qe, he, Mt, Qe, xe, St, Qe, xe, St, Qe, he, Mt, Qe, he, St, Qe, he, Mt, Qe, he, Mt, ft, he, St, Qe, he, St, Qe, he, Mt, ft, he, St, ft, xe, St, Qe, he, St, Qe, xe, St, ft, xe, St, ft, he, St, Qe, he, St, ft, xe, Mt, ft, he, Mt, ft, xe, Mt, Qe, xe, Mt, Qe, he, Mt, ft, he, Mt, Qe])
          , ln = new Float32Array([he, Mt, ft, xe, Mt, ft, xe, St, ft, he, St, ft, he, Mt, Qe, he, St, Qe, xe, St, Qe, xe, Mt, Qe, he, St, Qe, he, St, ft, xe, St, ft, xe, St, Qe, he, Mt, Qe, xe, Mt, Qe, xe, Mt, ft, he, Mt, ft, xe, Mt, Qe, xe, St, Qe, xe, St, ft, xe, Mt, ft, he, Mt, Qe, he, Mt, ft, he, St, ft, he, St, Qe])
          , Kt = [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23];
        k.geometry.attributes.position.needsUpdate = !0;
        for (let Ge = 0; Ge < Ct.length; Ge++)
            k.geometry.attributes.position.array[Ge] = Ct[Ge];
        if (xn && Tn) {
            let Ge = Math.abs(he - xe)
              , Wt = Math.abs(Qe - ft)
              , Ut = Math.max(Ge, Wt) / 1.5;
            Tn.position.set(Ie + Ut, 70, an + Ut),
            xn.target = new Oe(Ie,10,an),
            xn.update()
        }
        Bt()
    }
    function gn() {
        let kt, Zt, zn, Qt, xe, he, Qe, ft = c[v[0].file];
        if (ft && ft.float && ft.size)
            kt = ft.float,
            Zt = ft.size,
            zn = ft.scale,
            Qt = ft.offset,
            xe = ft.bin1,
            he = ft.binMax,
            Qe = ft.ngates;
        else
            return;
        let St = 999
          , Mt = -999;
        for (let Ft = 0; Ft < kt.length; Ft++)
            kt[Ft] > Mt && (Mt = kt[Ft]),
            kt[Ft] < St && (St = kt[Ft]);
        K && K.dispose(),
        K = new ac(kt,Zt[0],Zt[1],Zt[2]),
        K.format = pm,
        K.minFilter = ns,
        K.magFilter = ns,
        K.wrapS = Vu,
        K.wrapT = Vu,
        K.unpackAlignment = 1,
        K.needsUpdate = !0,
        k.material.uniforms.volume.value = K,
        U.material.uniforms.volume.value = K;
        let an = qI(x[v[0].file].scans)
          , Ie = an.output
          , Ct = an.domain
          , ln = an.elevations
          , Kt = an.bracket
          , Ge = an.range;
        k.material.uniforms.u_table_domain.value = Ct,
        k.material.uniforms.u_table_max.value = Ge[1],
        k.material.uniforms.u_scale.value = zn,
        k.material.uniforms.u_offset.value = Qt,
        k.material.uniforms.u_bin1.value = xe / 1e3,
        k.material.uniforms.u_ngates.value = Qe,
        k.material.uniforms.u_binMax.value = he / 1e3,
        k.material.uniforms.u_num_elevations.value = Zt[2] - 1,
        U.material.uniforms.u_table_domain.value = Ct,
        U.material.uniforms.u_table_max.value = Ge[1],
        U.material.uniforms.u_scale.value = zn,
        U.material.uniforms.u_offset.value = Qt,
        U.material.uniforms.u_bin1.value = xe / 1e3,
        U.material.uniforms.u_ngates.value = Qe,
        U.material.uniforms.u_binMax.value = he / 1e3,
        U.material.uniforms.u_num_elevations.value = Zt[2] - 1;
        let Wt = KI(0)
          , Ut = new Uint8Array(ln.length * 4)
          , _n = new Uint8Array(Ie.length * 4);
        for (let Ft = 0; Ft < ln.length; Ft++) {
            let nn = (ln[Ft] - Ge[0]) / (Ge[1] - Ge[0])
              , Jt = nn * 255
              , Ln = Math.floor(nn * 255) / 255
              , Zn = Jt % 1
              , Vn = Math.floor(Zn * 255)
              , Tr = Ln * 255;
            Ut[Ft * 4] = Tr,
            Ut[Ft * 4 + 1] = Vn
        }
        for (let Ft = 0; Ft < Kt.length; Ft++)
            _n[Ft * 4] = Kt[Ft][0],
            _n[Ft * 4 + 1] = Kt[Ft][1];
        X && X.dispose(),
        X = new al(Ut,ln.length,1,is),
        oe && oe.dispose(),
        _e && _e.dispose(),
        _e = new al(ee.data,ee.data.length / 4,1,is),
        oe = new al(Wt.data,Wt.data.length / 4,1,is),
        W && W.dispose(),
        W = new al(_n,Ie.length,1,is),
        X.minFilter = Di,
        X.magFilter = Di,
        X.unpackAlignment = 1,
        X.needsUpdate = !0,
        _e.minFilter = Di,
        _e.magFilter = Di,
        _e.unpackAlignment = 1,
        _e.needsUpdate = !0,
        oe.minFilter = Di,
        oe.magFilter = Di,
        oe.unpackAlignment = 1,
        oe.needsUpdate = !0,
        W.minFilter = Di,
        W.magFilter = Di,
        W.unpackAlignment = 1,
        W.needsUpdate = !0,
        k.material.uniforms.table.value = X,
        k.material.uniforms.tf.value = _e,
        k.material.uniforms.bracket.value = W,
        U.material.uniforms.table.value = X,
        U.material.uniforms.tf.value = oe,
        U.material.uniforms.bracket.value = W,
        bn(Xa, i = !1, i),
        (o === A || o === C) && Bt()
    }
    let gt, Tn, xn, Dn;
    function Bt() {
        k && o === A ? k.material.uniforms.u_eye_pos.value.copy(Tn.position) : U && o === C && U.material.uniforms.u_eye_pos.value.copy(Tn.position),
        gt.render(P, Tn),
        Z.render(P, Tn)
    }
    function An() {
        !I || (Tn.aspect = I.clientWidth / I.clientHeight,
        Tn.updateProjectionMatrix(),
        gt.setSize(I.clientWidth, I.clientHeight),
        Z.setSize(I.clientWidth, I.clientHeight),
        Bt())
    }
    Ha(()=>{
        new IntersectionObserver(An).observe(I),
        gt = new zi({
            canvas: I
        });
        let Zt = document.getElementById("can");
        gt.setSize(Zt.clientWidth, Zt.clientHeight),
        Tn = new os(75,Zt.clientWidth / Zt.clientHeight,.001,1e3),
        Tn.position.set(100, 0, 100),
        Z = new Ew,
        Z.setSize(Zt.clientWidth, Zt.clientHeight),
        Z.domElement.style.position = "absolute",
        Z.domElement.style.top = "0px",
        Z.domElement.style.pointerEvents = "none",
        D.appendChild(Z.domElement);
        let zn = document.createElement("div");
        zn.className = "crosslabel",
        zn.textContent = "A";
        let Qt = document.createElement("div");
        Qt.className = "crosslabel",
        Qt.textContent = "B",
        ce.push(new eg(zn)),
        ce.push(new eg(Qt)),
        ce[0].name = "A",
        ce[1].name = "B",
        P = new $d,
        P.background = new In(7368816),
        xn = new Tw(Tn,gt.domElement),
        xn.target = new Oe(0,0,0),
        xn.enableZoom = !0;
        let xe = new va(10,10,10)
          , he = new pc({
            color: 65280,
            wireframe: !1
        });
        Dn = new Ir(xe,he),
        Dn.position.set(0, 0, 0);
        let Qe = new X0(50)
          , ft = new rh({
            glslVersion: Dd,
            uniforms: {
                volume: {
                    value: ae
                },
                u_eye_pos: {
                    value: new Oe
                },
                u_x_domain: {
                    value: new zt
                },
                u_y_domain: {
                    value: new zt
                },
                u_z_domain: {
                    value: new zt
                },
                u_table_domain: {
                    value: new zt
                },
                u_table_max: {
                    value: 0
                },
                u_radar_pos: {
                    value: new zt
                },
                u_height_scale: {
                    value: 0
                },
                u_scale: {
                    value: 0
                },
                u_offset: {
                    value: 0
                },
                u_bin1: {
                    value: 0
                },
                u_ngates: {
                    value: 0
                },
                u_binMax: {
                    value: 0
                },
                u_num_elevations: {
                    value: 0
                },
                table: {
                    value: se
                },
                tf: {
                    value: se
                },
                bracket: {
                    value: se
                }
            },
            vertexShader: tt,
            fragmentShader: Ke,
            transparent: !0,
            side: Zs
        })
          , St = new rh({
            glslVersion: Dd,
            uniforms: {
                volume: {
                    value: ae
                },
                u_eye_pos: {
                    value: new Oe
                },
                u_plane_center: {
                    value: new Oe
                },
                u_plane_normal: {
                    value: new Oe
                },
                u_table_domain: {
                    value: new zt
                },
                u_table_max: {
                    value: 0
                },
                u_radar_pos: {
                    value: new zt
                },
                u_height_scale: {
                    value: 0
                },
                u_scale: {
                    value: 0
                },
                u_offset: {
                    value: 0
                },
                u_bin1: {
                    value: 0
                },
                u_ngates: {
                    value: 0
                },
                u_binMax: {
                    value: 0
                },
                u_num_elevations: {
                    value: 0
                },
                table: {
                    value: se
                },
                tf: {
                    value: se
                },
                bracket: {
                    value: se
                }
            },
            vertexShader: ke,
            fragmentShader: Be,
            transparent: !0,
            side: $a
        })
          , Mt = new Vi
          , an = new Vi;
        Mt.setAttribute("position", new or(ne,3)),
        an.setAttribute("position", new or(be,3)),
        k = new Ir(Mt,ft),
        k.frustumCulled = !1,
        U = new Ir(an,St),
        U.frustumCulled = !1,
        U.name = "meshPlane",
        k.name = "mesh",
        xn.addEventListener("change", Bt),
        Bt()
    }
    );
    function ut() {
        if (_e) {
            _e.needsUpdate = !0;
            let kt = ee.data
              , Zt = _e.image.data
              , zn = _e.image.width * _e.image.height;
            for (let Qt = 0; Qt < zn; Qt++) {
                let xe = Qt * 4;
                Zt[xe] = kt[xe],
                Zt[xe + 1] = kt[xe + 1],
                Zt[xe + 2] = kt[xe + 2],
                Zt[xe + 3] = kt[xe + 3]
            }
            Bt()
        }
    }
    function ot() {
        t(5, j = !j)
    }
    function xt(kt) {
        Bi[kt ? "unshift" : "push"](()=>{
            I = kt,
            t(2, I)
        }
        )
    }
    function on(kt) {
        j = kt,
        t(5, j)
    }
    function $t(kt) {
        ee = kt,
        t(0, ee)
    }
    function Pn(kt) {
        Bi[kt ? "unshift" : "push"](()=>{
            D = kt,
            t(3, D)
        }
        )
    }
    return r.$$.update = ()=>{
        if (r.$$.dirty[0] & 16384) {
            e: Et()
        }
        if (r.$$.dirty[0] & 2) {
            e: bt()
        }
        if (r.$$.dirty[0] & 8192) {
            e: Ye()
        }
        if (r.$$.dirty[0] & 4096) {
            e: Gt()
        }
        if (r.$$.dirty[0] & 2048) {
            e: gn()
        }
        if (r.$$.dirty[0] & 1) {
            e: ut()
        }
    }
    ,
    [ee, o, I, D, fe, j, i, A, ot, Et, gn, c, d, p, E, xt, on, $t, Pn]
}
var EC = class extends mi {
    constructor(e) {
        super();
        _i(this, e, l6, a6, di, {
            removeMeshes: 9,
            loadTexture: 10
        }, null, [-1, -1])
    }
    get removeMeshes() {
        return this.$$.ctx[9]
    }
    get loadTexture() {
        return this.$$.ctx[10]
    }
}
  , SC = EC;
function AC(r, e, t) {
    let o = r.slice();
    return o[29] = e[t],
    o
}
function MC(r, e, t) {
    let o = r.slice();
    return o[32] = e[t],
    o
}
function IC(r) {
    let e, t, o, c, d, p;
    return {
        c() {
            e = qe("div"),
            o = It(),
            c = qe("button"),
            c.innerHTML = `<svg class="trash svelte-18jl7v3" version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 468.36 468.36" style="enable-background:new 0 0 468.36 468.36;" xml:space="preserve"><g><g><path d="M381.048,64.229l-71.396,0.031L309.624,0L158.666,0.064l0.027,64.26l-71.405,0.031l0.024,60.056h293.76L381.048,64.229z
                        M189.274,30.652l89.759-0.04l0.016,33.66l-89.759,0.04L189.274,30.652z"></path><path d="M87.312,468.36h293.76V139.71H87.312V468.36z M303.042,184.588h15.301v238.891h-15.301V184.588z M226.542,184.588h15.3
                        v238.891h-15.3V184.588z M150.042,184.588h15.3v238.891h-15.3V184.588z"></path></g></g></svg>`,
            je(e, "class", t = "arrow " + r[8] + " svelte-18jl7v3"),
            je(c, "class", "trashbutton svelte-18jl7v3")
        },
        m(i, v) {
            yn(i, e, v),
            yn(i, o, v),
            yn(i, c, v),
            d || (p = [wn(e, "click", r[9]), wn(c, "click", r[11])],
            d = !0)
        },
        p(i, v) {
            v[0] & 256 && t !== (t = "arrow " + i[8] + " svelte-18jl7v3") && je(e, "class", t)
        },
        d(i) {
            i && mn(e),
            i && mn(o),
            i && mn(c),
            d = !1,
            Wi(p)
        }
    }
}
function DC(r) {
    let e, t = r[3], o = [];
    for (let c = 0; c < t.length; c += 1)
        o[c] = CC(AC(r, t, c));
    return {
        c() {
            for (let c = 0; c < o.length; c += 1)
                o[c].c();
            e = xu()
        },
        m(c, d) {
            for (let p = 0; p < o.length; p += 1)
                o[p].m(c, d);
            yn(c, e, d)
        },
        p(c, d) {
            if (d[0] & 1055) {
                t = c[3];
                let p;
                for (p = 0; p < t.length; p += 1) {
                    let i = AC(c, t, p);
                    o[p] ? o[p].p(i, d) : (o[p] = CC(i),
                    o[p].c(),
                    o[p].m(e.parentNode, e))
                }
                for (; p < o.length; p += 1)
                    o[p].d(1);
                o.length = t.length
            }
        },
        d(c) {
            As(o, c),
            c && mn(e)
        }
    }
}
function LC(r) {
    let e, t, o = r[32][0].date.toUTCString() + "", c, d, p;
    return {
        c() {
            e = qe("div"),
            t = qe("span"),
            c = Un(o),
            je(t, "class", "spanclass svelte-18jl7v3"),
            Gn(t, "active", r[0] === r[4] + "-" + r[32][0].idx),
            je(e, "class", "item svelte-18jl7v3")
        },
        m(i, v) {
            yn(i, e, v),
            Se(e, t),
            Se(t, c),
            d || (p = wn(t, "click", function() {
                Wl(r[10]({
                    scan: r[32],
                    fileName: r[1],
                    station: r[2],
                    fileNumber: r[4]
                })) && r[10]({
                    scan: r[32],
                    fileName: r[1],
                    station: r[2],
                    fileNumber: r[4]
                }).apply(this, arguments)
            }),
            d = !0)
        },
        p(i, v) {
            r = i,
            v[0] & 8 && o !== (o = r[32][0].date.toUTCString() + "") && gi(c, o),
            v[0] & 25 && Gn(t, "active", r[0] === r[4] + "-" + r[32][0].idx)
        },
        d(i) {
            i && mn(e),
            d = !1,
            p()
        }
    }
}
function CC(r) {
    let e, t = r[29][0][0].elevation.toFixed(1) + "", o, c, d, p, i, v = r[29], x = [];
    for (let E = 0; E < v.length; E += 1)
        x[E] = LC(MC(r, v, E));
    return {
        c() {
            e = qe("h3"),
            o = Un(t),
            c = Un("°"),
            d = It(),
            p = qe("div");
            for (let E = 0; E < x.length; E += 1)
                x[E].c();
            i = It(),
            je(e, "class", "svelte-18jl7v3"),
            je(p, "class", "listul svelte-18jl7v3")
        },
        m(E, A) {
            yn(E, e, A),
            Se(e, o),
            Se(e, c),
            yn(E, d, A),
            yn(E, p, A);
            for (let C = 0; C < x.length; C += 1)
                x[C].m(p, null);
            Se(p, i)
        },
        p(E, A) {
            if (A[0] & 8 && t !== (t = E[29][0][0].elevation.toFixed(1) + "") && gi(o, t),
            A[0] & 1055) {
                v = E[29];
                let C;
                for (C = 0; C < v.length; C += 1) {
                    let I = MC(E, v, C);
                    x[C] ? x[C].p(I, A) : (x[C] = LC(I),
                    x[C].c(),
                    x[C].m(p, i))
                }
                for (; C < x.length; C += 1)
                    x[C].d(1);
                x.length = v.length
            }
        },
        d(E) {
            E && mn(e),
            E && mn(d),
            E && mn(p),
            As(x, E)
        }
    }
}
function c6(r) {
    let e, t, o, c, d, p, i, v, x, E, A, C, I, D, P, k = (r[6] === void 0 ? "" : r[6]) + "", U, Z, K, X = (r[2] === void 0 ? "" : r[2]) + "", W, fe, ce, _e, oe = r[2] && IC(r), ee = r[2] && DC(r);
    return {
        c() {
            e = qe("div"),
            t = qe("div"),
            o = qe("table"),
            c = qe("tbody"),
            d = qe("tr"),
            d.innerHTML = `<td class="large svelte-18jl7v3">File</td> 
                    <td class="svelte-18jl7v3">VCP</td> 
                    <td class="svelte-18jl7v3">Radar</td>`,
            p = It(),
            i = qe("tr"),
            v = qe("td"),
            x = qe("div"),
            E = qe("div"),
            A = It(),
            C = qe("span"),
            I = Un(r[1]),
            D = It(),
            P = qe("td"),
            U = Un(k),
            Z = It(),
            K = qe("td"),
            W = Un(X),
            fe = It(),
            oe && oe.c(),
            ce = It(),
            _e = qe("div"),
            ee && ee.c(),
            je(E, "class", "progress svelte-18jl7v3"),
            vu(E, "width", (r[5] >= 0 ? r[5] * 250 : 0) + "px"),
            vu(C, "position", "absolute"),
            je(x, "class", "relative-table svelte-18jl7v3"),
            je(v, "class", "large content svelte-18jl7v3"),
            je(P, "class", "content svelte-18jl7v3"),
            je(K, "class", "content svelte-18jl7v3"),
            je(o, "class", "svelte-18jl7v3"),
            je(t, "class", "table-wrapper svelte-18jl7v3"),
            je(_e, "class", "svelte-18jl7v3"),
            Gn(_e, "none", !r[7]),
            je(e, "class", "table-content svelte-18jl7v3")
        },
        m(j, ne) {
            yn(j, e, ne),
            Se(e, t),
            Se(t, o),
            Se(o, c),
            Se(c, d),
            Se(c, p),
            Se(c, i),
            Se(i, v),
            Se(v, x),
            Se(x, E),
            Se(x, A),
            Se(x, C),
            Se(C, I),
            Se(i, D),
            Se(i, P),
            Se(P, U),
            Se(i, Z),
            Se(i, K),
            Se(K, W),
            Se(t, fe),
            oe && oe.m(t, null),
            Se(e, ce),
            Se(e, _e),
            ee && ee.m(_e, null)
        },
        p(j, ne) {
            ne[0] & 32 && vu(E, "width", (j[5] >= 0 ? j[5] * 250 : 0) + "px"),
            ne[0] & 2 && gi(I, j[1]),
            ne[0] & 64 && k !== (k = (j[6] === void 0 ? "" : j[6]) + "") && gi(U, k),
            ne[0] & 4 && X !== (X = (j[2] === void 0 ? "" : j[2]) + "") && gi(W, X),
            j[2] ? oe ? oe.p(j, ne) : (oe = IC(j),
            oe.c(),
            oe.m(t, null)) : oe && (oe.d(1),
            oe = null),
            j[2] ? ee ? ee.p(j, ne) : (ee = DC(j),
            ee.c(),
            ee.m(_e, null)) : ee && (ee.d(1),
            ee = null),
            ne[0] & 128 && Gn(_e, "none", !j[7])
        },
        i: Hn,
        o: Hn,
        d(j) {
            j && mn(e),
            oe && oe.d(),
            ee && ee.d()
        }
    }
}
function u6(r, e, t) {
    let o, c, d, p, i, v, x, E, A;
    Ht(r, Is, se=>t(16, c = se)),
    Ht(r, Ms, se=>t(17, d = se)),
    Ht(r, bs, se=>t(18, p = se)),
    Ht(r, Hs, se=>t(19, i = se)),
    Ht(r, Ws, se=>t(20, v = se)),
    Ht(r, ui, se=>t(15, x = se)),
    Ht(r, ai, se=>t(21, E = se)),
    Ht(r, $r, se=>t(22, A = se));
    let {REFLECTIVITY: C, VELOCITY: I, VELOCITY_DEALIASED: D} = Vs
      , {fileName: P} = e
      , {station: k} = e
      , {localScans: U} = e
      , {fileNumber: Z} = e
      , {percent: K} = e
      , {vcp: X} = e
      , {active: W=void 0} = e
      , {scans: fe} = e
      , {idxs: ce} = e
      , {radarMetadata: _e} = e
      , oe = !0
      , ee = {
        [C]: 0,
        [I]: 1,
        [D]: 2
    }
      , j = go();
    function ne() {
        t(7, oe = !oe)
    }
    function be(se) {
        t(0, W = se.fileName + se.scan[0].idx),
        j.logStore(se)
    }
    function te() {
        let se = E
          , ke = A;
        Object.assign(ke, {
            fileNames: [],
            elevations: [],
            stations: [],
            scans: []
        }),
        ke.fileNames = [],
        ke.stations = [],
        ke.scans = {},
        ke.elevations = {};
        let Be = {}
          , tt = {};
        for (let Ke = 0; Ke < se.length; Ke++)
            se[Ke] != null && (ke.fileNames.push(se[Ke].fileName),
            ke.stations.indexOf(se[Ke].station) < 0 && ke.stations.push(se[Ke].station),
            se[Ke].station in Be ? Be[se[Ke].station] = Be[se[Ke].station].concat(Object.keys(se[Ke].idxs)) : Be[se[Ke].station] = Object.keys(se[Ke].idxs),
            se[Ke].station in tt ? tt[se[Ke].station] = tt[se[Ke].station].concat(se[Ke].scans) : tt[se[Ke].station] = se[Ke].scans);
        for (let Ke = 0; Ke < ke.stations.length; Ke++) {
            let bt = ke.stations[Ke];
            ke.elevations[bt] = [],
            ke.scans[bt] = {},
            ke.elevations[bt] = Array.from(new Set(Be[bt])).sort(function(Gt, Ye) {
                return +Gt - +Ye
            });
            let Et = tt[bt];
            for (let Gt = 0; Gt < ke.elevations[bt].length; Gt++)
                ke.scans[bt][ke.elevations[bt][Gt]] = [];
            for (let Gt = 0; Gt < Et.length; Gt++)
                ke.scans[bt][Et[Gt][0][0].rounded].push(...Et[Gt]);
            for (let Gt in ke.scans[bt])
                ke.scans[bt][Gt] = ke.scans[bt][Gt].sort(function(Ye, gn) {
                    return Ye[0].date - gn[0].date
                })
        }
    }
    function ae() {
        bn(ai, E[Z] = void 0, E),
        Z === x[0].file && (bn(ui, x = [{
            elevation: null,
            file: null,
            type: null,
            dealiased: null,
            scan: null
        }, {
            elevation: null,
            file: null,
            type: null,
            dealiased: null,
            scan: null
        }], x),
        bn(Ws, v = null, v),
        bn(Hs, i = {}, i)),
        bn(bs, p[Z] = void 0, p),
        bn(Ms, d[Z] = void 0, d),
        c.postMessage({
            message: "deleteFile",
            data: {
                fileNum: Z,
                fileName: P
            }
        })
    }
    return r.$$set = se=>{
        "fileName"in se && t(1, P = se.fileName),
        "station"in se && t(2, k = se.station),
        "localScans"in se && t(3, U = se.localScans),
        "fileNumber"in se && t(4, Z = se.fileNumber),
        "percent"in se && t(5, K = se.percent),
        "vcp"in se && t(6, X = se.vcp),
        "active"in se && t(0, W = se.active),
        "scans"in se && t(12, fe = se.scans),
        "idxs"in se && t(13, ce = se.idxs),
        "radarMetadata"in se && t(14, _e = se.radarMetadata)
    }
    ,
    r.$$.update = ()=>{
        if (r.$$.dirty[0] & 128) {
            e: t(8, o = oe ? "down" : "up")
        }
        if (r.$$.dirty[0] & 32768) {
            e: t(0, W = x[0] && x[0].scan ? x[0].scan.scan[0].fileNumber + "-" + x[0].scan.scan[0].idx : void 0)
        }
    }
    ,
    [W, P, k, U, Z, K, X, oe, o, ne, be, ae, fe, ce, _e, x]
}
var RC = class extends mi {
    constructor(e) {
        super();
        _i(this, e, u6, c6, di, {
            fileName: 1,
            station: 2,
            localScans: 3,
            fileNumber: 4,
            percent: 5,
            vcp: 6,
            active: 0,
            scans: 12,
            idxs: 13,
            radarMetadata: 14
        }, null, [-1, -1])
    }
}
  , PC = RC;
function kC(r, e, t) {
    let o = r.slice();
    return o[7] = e[t],
    o
}
function zC(r) {
    let e, t, o, c, d = [r[7], {
        localScans: r[7].scans
    }];
    function p(x) {
        r[5](x)
    }
    function i(x) {
        r[6](x)
    }
    let v = {};
    for (let x = 0; x < d.length; x += 1)
        v = mv(v, d[x]);
    return r[0] !== void 0 && (v.active = r[0]),
    r[1] !== void 0 && (v.loading = r[1]),
    e = new PC({
        props: v
    }),
    Bi.push(()=>ha(e, "active", p)),
    Bi.push(()=>ha(e, "loading", i)),
    {
        c() {
            Qi(e.$$.fragment)
        },
        m(x, E) {
            qi(e, x, E),
            c = !0
        },
        p(x, E) {
            let A = E & 4 ? wv(d, [Tv(x[7]), {
                localScans: x[7].scans
            }]) : {};
            !t && E & 1 && (t = !0,
            A.active = x[0],
            ua(()=>t = !1)),
            !o && E & 2 && (o = !0,
            A.loading = x[1],
            ua(()=>o = !1)),
            e.$set(A)
        },
        i(x) {
            c || (Wn(e.$$.fragment, x),
            c = !0)
        },
        o(x) {
            ri(e.$$.fragment, x),
            c = !1
        },
        d(x) {
            Ki(e, x)
        }
    }
}
function OC(r) {
    let e, t, o = r[7] && r[7].scans && zC(r);
    return {
        c() {
            o && o.c(),
            e = xu()
        },
        m(c, d) {
            o && o.m(c, d),
            yn(c, e, d),
            t = !0
        },
        p(c, d) {
            c[7] && c[7].scans ? o ? (o.p(c, d),
            d & 4 && Wn(o, 1)) : (o = zC(c),
            o.c(),
            Wn(o, 1),
            o.m(e.parentNode, e)) : o && (eo(),
            ri(o, 1, 1, ()=>{
                o = null
            }
            ),
            to())
        },
        i(c) {
            t || (Wn(o),
            t = !0)
        },
        o(c) {
            ri(o),
            t = !1
        },
        d(c) {
            o && o.d(c),
            c && mn(e)
        }
    }
}
function h6(r) {
    let e, t, o = r[2], c = [];
    for (let p = 0; p < o.length; p += 1)
        c[p] = OC(kC(r, o, p));
    let d = p=>ri(c[p], 1, 1, ()=>{
        c[p] = null
    }
    );
    return {
        c() {
            e = qe("div");
            for (let p = 0; p < c.length; p += 1)
                c[p].c();
            je(e, "class", "scroll svelte-1kipxq3")
        },
        m(p, i) {
            yn(p, e, i);
            for (let v = 0; v < c.length; v += 1)
                c[v].m(e, null);
            t = !0
        },
        p(p, [i]) {
            if (i & 7) {
                o = p[2];
                let v;
                for (v = 0; v < o.length; v += 1) {
                    let x = kC(p, o, v);
                    c[v] ? (c[v].p(x, i),
                    Wn(c[v], 1)) : (c[v] = OC(x),
                    c[v].c(),
                    Wn(c[v], 1),
                    c[v].m(e, null))
                }
                for (eo(),
                v = o.length; v < c.length; v += 1)
                    d(v);
                to()
            }
        },
        i(p) {
            if (!t) {
                for (let i = 0; i < o.length; i += 1)
                    Wn(c[i]);
                t = !0
            }
        },
        o(p) {
            c = c.filter(Boolean);
            for (let i = 0; i < c.length; i += 1)
                ri(c[i]);
            t = !1
        },
        d(p) {
            p && mn(e),
            As(c, p)
        }
    }
}
function d6(r, e, t) {
    let o, c, d;
    Ht(r, $r, E=>t(3, o = E)),
    Ht(r, ui, E=>t(4, c = E)),
    Ht(r, ai, E=>t(2, d = E));
    let p, i;
    function v(E) {
        p = E,
        t(0, p)
    }
    function x(E) {
        i = E,
        t(1, i)
    }
    return r.$$.update = ()=>{
        if (r.$$.dirty & 16) {
            e: Nr.setStates()
        }
        if (r.$$.dirty & 8) {
            e: Nr.setSites()
        }
    }
    ,
    [p, i, d, o, c, v, x]
}
var NC = class extends mi {
    constructor(e) {
        super();
        _i(this, e, d6, h6, di, {})
    }
}
  , FC = NC;
function BC(r, e, t) {
    let o = r.slice();
    return o[13] = e[t],
    o
}
function UC(r, e, t) {
    let o = r.slice();
    return o[16] = e[t],
    o
}
function GC(r) {
    let e, t, o, c, d, p, i, v = (r[2] === void 0 || r[7][r[2]] === void 0 ? "" : r[7][r[2]].fileName) + "", x, E, A, C = (r[2] === void 0 || r[7][r[2]] === void 0 ? "" : r[7][r[2]].vcp) + "", I, D, P, k = (r[2] === void 0 || r[7][r[2]] === void 0 ? "" : r[7][r[2]].station) + "", U, Z, K, X, W, fe, ce = (r[8] ? "Stop" : "Animate") + "", _e, oe, ee, j, ne, be, te = r[5] > 0 && VC(r);
    return {
        c() {
            e = qe("div"),
            t = qe("table"),
            o = qe("tbody"),
            c = qe("tr"),
            c.innerHTML = `<td class="file svelte-hbmvhi">File</td> 
                    <td class="vcp svelte-hbmvhi">VCP</td> 
                    <td class="station svelte-hbmvhi">Radar</td>`,
            d = It(),
            p = qe("tr"),
            i = qe("td"),
            x = Un(v),
            E = It(),
            A = qe("td"),
            I = Un(C),
            D = It(),
            P = qe("td"),
            U = Un(k),
            Z = It(),
            K = qe("div"),
            X = qe("button"),
            X.innerHTML = '<svg class="arrow svelte-hbmvhi" viewBox="0 0 48 102" fill="none" xmlns="http://www.w3.org/2000/svg"><g filter="url(#filter0_d_15_133)"><path d="M4.09662 46.9999L43.9302 0.305731L43.7629 93.8363L4.09662 46.9999Z" fill="white"></path></g><defs><filter id="filter0_d_15_133" x="0.0966797" y="0.305725" width="47.8336" height="101.531" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB"><feFlood flood-opacity="0" result="BackgroundImageFix"></feFlood><feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"></feColorMatrix><feOffset dy="4"></feOffset><feGaussianBlur stdDeviation="2"></feGaussianBlur><feComposite in2="hardAlpha" operator="out"></feComposite><feColorMatrix type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.25 0"></feColorMatrix><feBlend mode="normal" in2="BackgroundImageFix" result="effect1_dropShadow_15_133"></feBlend><feBlend mode="normal" in="SourceGraphic" in2="effect1_dropShadow_15_133" result="shape"></feBlend></filter></defs></svg>',
            W = It(),
            fe = qe("button"),
            _e = Un(ce),
            oe = It(),
            ee = qe("button"),
            ee.innerHTML = '<svg class="arrow svelte-hbmvhi" viewBox="0 0 48 102" fill="none" xmlns="http://www.w3.org/2000/svg"><g filter="url(#filter0_d_15_134)"><path d="M44 47L4.25 0.234627L4.25 93.7654L44 47Z" fill="white"></path></g><defs><filter id="filter0_d_15_134" x="0.25" y="0.234619" width="47.75" height="101.531" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB"><feFlood flood-opacity="0" result="BackgroundImageFix"></feFlood><feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"></feColorMatrix><feOffset dy="4"></feOffset><feGaussianBlur stdDeviation="2"></feGaussianBlur><feComposite in2="hardAlpha" operator="out"></feComposite><feColorMatrix type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.25 0"></feColorMatrix><feBlend mode="normal" in2="BackgroundImageFix" result="effect1_dropShadow_15_134"></feBlend><feBlend mode="normal" in="SourceGraphic" in2="effect1_dropShadow_15_134" result="shape"></feBlend></filter></defs></svg>',
            j = It(),
            te && te.c(),
            je(i, "class", "content file svelte-hbmvhi"),
            je(A, "class", "content vcp svelte-hbmvhi"),
            je(P, "class", "content station svelte-hbmvhi"),
            je(t, "class", "svelte-hbmvhi"),
            je(X, "class", "arrowbutton svelte-hbmvhi"),
            je(fe, "class", "loopButton svelte-hbmvhi"),
            je(ee, "class", "arrowbutton svelte-hbmvhi"),
            je(K, "class", "pncontainer svelte-hbmvhi"),
            je(e, "class", "tc svelte-hbmvhi")
        },
        m(ae, se) {
            yn(ae, e, se),
            Se(e, t),
            Se(t, o),
            Se(o, c),
            Se(o, d),
            Se(o, p),
            Se(p, i),
            Se(i, x),
            Se(p, E),
            Se(p, A),
            Se(A, I),
            Se(p, D),
            Se(p, P),
            Se(P, U),
            Se(e, Z),
            Se(e, K),
            Se(K, X),
            Se(K, W),
            Se(K, fe),
            Se(fe, _e),
            Se(K, oe),
            Se(K, ee),
            Se(K, j),
            te && te.m(K, null),
            ne || (be = [wn(X, "click", Nr.previous), wn(fe, "click", Nr.handleAnimateClick), wn(ee, "click", Nr.advance)],
            ne = !0)
        },
        p(ae, se) {
            se & 132 && v !== (v = (ae[2] === void 0 || ae[7][ae[2]] === void 0 ? "" : ae[7][ae[2]].fileName) + "") && gi(x, v),
            se & 132 && C !== (C = (ae[2] === void 0 || ae[7][ae[2]] === void 0 ? "" : ae[7][ae[2]].vcp) + "") && gi(I, C),
            se & 132 && k !== (k = (ae[2] === void 0 || ae[7][ae[2]] === void 0 ? "" : ae[7][ae[2]].station) + "") && gi(U, k),
            se & 256 && ce !== (ce = (ae[8] ? "Stop" : "Animate") + "") && gi(_e, ce),
            ae[5] > 0 ? te ? te.p(ae, se) : (te = VC(ae),
            te.c(),
            te.m(K, null)) : te && (te.d(1),
            te = null)
        },
        d(ae) {
            ae && mn(e),
            te && te.d(),
            ne = !1,
            Wi(be)
        }
    }
}
function VC(r) {
    let e, t = r[6] + 1 + "", o, c, d;
    return {
        c() {
            e = qe("div"),
            o = Un(t),
            c = Un("/"),
            d = Un(r[5]),
            je(e, "class", "idx svelte-hbmvhi")
        },
        m(p, i) {
            yn(p, e, i),
            Se(e, o),
            Se(e, c),
            Se(e, d)
        },
        p(p, i) {
            i & 64 && t !== (t = p[6] + 1 + "") && gi(o, t),
            i & 32 && gi(d, p[5])
        },
        d(p) {
            p && mn(e)
        }
    }
}
function jC(r) {
    let e, t, o, c = r[13] + "", d, p, i, v, x, E, A = r[9] === r[10] && HC(r), C = r[0].elevations[r[13]], I = [];
    for (let D = 0; D < C.length; D += 1)
        I[D] = WC(UC(r, C, D));
    return {
        c() {
            e = qe("div"),
            t = qe("div"),
            o = qe("p"),
            d = Un(c),
            p = Un(" elevations"),
            i = It(),
            A && A.c(),
            v = It(),
            x = qe("div");
            for (let D = 0; D < I.length; D += 1)
                I[D].c();
            E = It(),
            je(o, "class", "buttonlabel svelte-hbmvhi"),
            je(t, "class", "site-header svelte-hbmvhi"),
            je(x, "class", "buttoncontainer svelte-hbmvhi"),
            je(e, "class", "stationContainer svelte-hbmvhi")
        },
        m(D, P) {
            yn(D, e, P),
            Se(e, t),
            Se(t, o),
            Se(o, d),
            Se(o, p),
            Se(t, i),
            A && A.m(t, null),
            Se(e, v),
            Se(e, x);
            for (let k = 0; k < I.length; k += 1)
                I[k].m(x, null);
            Se(e, E)
        },
        p(D, P) {
            if (P & 1 && c !== (c = D[13] + "") && gi(d, c),
            D[9] === D[10] ? A ? A.p(D, P) : (A = HC(D),
            A.c(),
            A.m(t, null)) : A && (A.d(1),
            A = null),
            P & 25) {
                C = D[0].elevations[D[13]];
                let k;
                for (k = 0; k < C.length; k += 1) {
                    let U = UC(D, C, k);
                    I[k] ? I[k].p(U, P) : (I[k] = WC(U),
                    I[k].c(),
                    I[k].m(x, null))
                }
                for (; k < I.length; k += 1)
                    I[k].d(1);
                I.length = C.length
            }
        },
        d(D) {
            D && mn(e),
            A && A.d(),
            As(I, D)
        }
    }
}
function HC(r) {
    let e, t, o;
    return {
        c() {
            e = qe("button"),
            e.textContent = "Load last five",
            je(e, "class", "loadButton svelte-hbmvhi")
        },
        m(c, d) {
            yn(c, e, d),
            t || (o = wn(e, "click", Nr.handleLoadClick),
            t = !0)
        },
        p: Hn,
        d(c) {
            c && mn(e),
            t = !1,
            o()
        }
    }
}
function WC(r) {
    let e, t = r[16] + "", o, c, d, p;
    return {
        c() {
            e = qe("button"),
            o = Un(t),
            c = Un("°"),
            je(e, "class", "ebutton svelte-hbmvhi"),
            Gn(e, "activebutton", r[16] === r[3] && r[4] === r[13])
        },
        m(i, v) {
            yn(i, e, v),
            Se(e, o),
            Se(e, c),
            d || (p = wn(e, "click", function() {
                Wl(Nr.handleClick({
                    elevation: r[16],
                    station: r[13]
                })) && Nr.handleClick({
                    elevation: r[16],
                    station: r[13]
                }).apply(this, arguments)
            }),
            d = !0)
        },
        p(i, v) {
            r = i,
            v & 1 && t !== (t = r[16] + "") && gi(o, t),
            v & 25 && Gn(e, "activebutton", r[16] === r[3] && r[4] === r[13])
        },
        d(i) {
            i && mn(e),
            d = !1,
            p()
        }
    }
}
function XC(r) {
    let e, t = r[13] && jC(r);
    return {
        c() {
            t && t.c(),
            e = xu()
        },
        m(o, c) {
            t && t.m(o, c),
            yn(o, e, c)
        },
        p(o, c) {
            o[13] ? t ? t.p(o, c) : (t = jC(o),
            t.c(),
            t.m(e.parentNode, e)) : t && (t.d(1),
            t = null)
        },
        d(o) {
            t && t.d(o),
            o && mn(e)
        }
    }
}
function f6(r) {
    let e, t, o = r[1][0].scan && GC(r), c = r[0].stations, d = [];
    for (let p = 0; p < c.length; p += 1)
        d[p] = XC(BC(r, c, p));
    return {
        c() {
            o && o.c(),
            e = It(),
            t = qe("div");
            for (let p = 0; p < d.length; p += 1)
                d[p].c();
            je(t, "class", "scroll svelte-hbmvhi")
        },
        m(p, i) {
            o && o.m(p, i),
            yn(p, e, i),
            yn(p, t, i);
            for (let v = 0; v < d.length; v += 1)
                d[v].m(t, null)
        },
        p(p, [i]) {
            if (p[1][0].scan ? o ? o.p(p, i) : (o = GC(p),
            o.c(),
            o.m(e.parentNode, e)) : o && (o.d(1),
            o = null),
            i & 1561) {
                c = p[0].stations;
                let v;
                for (v = 0; v < c.length; v += 1) {
                    let x = BC(p, c, v);
                    d[v] ? d[v].p(x, i) : (d[v] = XC(x),
                    d[v].c(),
                    d[v].m(t, null))
                }
                for (; v < d.length; v += 1)
                    d[v].d(1);
                d.length = c.length
            }
        },
        i: Hn,
        o: Hn,
        d(p) {
            o && o.d(p),
            p && mn(e),
            p && mn(t),
            As(d, p)
        }
    }
}
function p6(r, e, t) {
    let o, c, d, p, i;
    Ht(r, $r, k=>t(0, o = k)),
    Ht(r, ui, k=>t(1, c = k)),
    Ht(r, ai, k=>t(7, d = k)),
    Ht(r, _o, k=>t(8, p = k)),
    Ht(r, js, k=>t(9, i = k));
    let {LIVE: v} = Gs, x, E, A, C, I, D;
    function P() {
        let k = Nr.setValues();
        t(2, x = k.fileIdx),
        t(5, C = k.max),
        I = k.idx,
        t(3, E = k.elevation_state),
        t(4, A = k.station_state),
        t(6, D = k.currentIdx)
    }
    return r.$$.update = ()=>{
        if (r.$$.dirty & 2) {
            e: Nr.setStates(),
            P()
        }
        if (r.$$.dirty & 1) {
            e: Nr.setSites(),
            P()
        }
    }
    ,
    [o, c, x, E, A, C, D, d, p, i, v]
}
var ZC = class extends mi {
    constructor(e) {
        super();
        _i(this, e, p6, f6, di, {})
    }
}
  , qC = ZC;
function KC(r) {
    let e, t, o;
    return {
        c() {
            e = qe("div"),
            t = It(),
            o = qe("div"),
            o.textContent = "Loading live",
            je(e, "class", "lds-dual-ring svelte-7qu9tz"),
            je(o, "class", "of svelte-7qu9tz")
        },
        m(c, d) {
            yn(c, e, d),
            yn(c, t, d),
            yn(c, o, d)
        },
        d(c) {
            c && mn(e),
            c && mn(t),
            c && mn(o)
        }
    }
}
function m6(r) {
    let e, t;
    return e = new FC({}),
    {
        c() {
            Qi(e.$$.fragment)
        },
        m(o, c) {
            qi(e, o, c),
            t = !0
        },
        p: Hn,
        i(o) {
            t || (Wn(e.$$.fragment, o),
            t = !0)
        },
        o(o) {
            ri(e.$$.fragment, o),
            t = !1
        },
        d(o) {
            Ki(e, o)
        }
    }
}
function g6(r) {
    let e, t, o = {};
    return e = new qC({
        props: o
    }),
    r[17](e),
    {
        c() {
            Qi(e.$$.fragment)
        },
        m(c, d) {
            qi(e, c, d),
            t = !0
        },
        p(c, d) {
            let p = {};
            e.$set(p)
        },
        i(c) {
            t || (Wn(e.$$.fragment, c),
            t = !0)
        },
        o(c) {
            ri(e.$$.fragment, c),
            t = !1
        },
        d(c) {
            r[17](null),
            Ki(e, c)
        }
    }
}
function _6(r) {
    let e, t, o, c, d, p, i, v, x, E, A, C, I, D, P, k, U, Z, K, X, W, fe, ce, _e, oe, ee, j = r[4] && KC(r);
    U = new hM({});
    let ne = [g6, m6]
      , be = [];
    function te(se, ke) {
        return se[3] === se[10] ? 0 : se[3] === se[9] ? 1 : -1
    }
    ~(K = te(r, -1)) && (X = be[K] = ne[K](r));
    let ae = {};
    return ce = new SC({
        props: ae
    }),
    r[18](ce),
    {
        c() {
            e = qe("div"),
            t = qe("div"),
            o = qe("div"),
            c = qe("label"),
            d = qe("input"),
            i = Un(`
                Elevation View`),
            v = It(),
            x = qe("label"),
            E = qe("input"),
            C = Un(`
                    File View`),
            I = It(),
            D = qe("div"),
            j && j.c(),
            P = It(),
            k = qe("div"),
            Qi(U.$$.fragment),
            Z = It(),
            X && X.c(),
            W = It(),
            fe = qe("div"),
            Qi(ce.$$.fragment),
            je(d, "type", "radio"),
            d.__value = p = 1,
            d.value = d.__value,
            je(d, "class", "svelte-7qu9tz"),
            r[15][0].push(d),
            je(c, "class", "svelte-7qu9tz"),
            je(E, "type", "radio"),
            E.__value = A = 2,
            E.value = E.__value,
            je(E, "class", "svelte-7qu9tz"),
            r[15][0].push(E),
            je(x, "class", "svelte-7qu9tz"),
            je(o, "class", "nested svelte-7qu9tz"),
            je(k, "class", "fddiv svelte-7qu9tz"),
            Gn(k, "hidden", r[5] === r[11]),
            je(D, "class", "right-nested svelte-7qu9tz"),
            je(t, "class", "radios svelte-7qu9tz"),
            je(fe, "class", "svelte-7qu9tz"),
            Gn(fe, "hidden", !(r[6] === r[7] || r[6] === r[8])),
            je(e, "class", "menu svelte-7qu9tz")
        },
        m(se, ke) {
            yn(se, e, ke),
            Se(e, t),
            Se(t, o),
            Se(o, c),
            Se(c, d),
            d.checked = d.__value === r[2],
            Se(c, i),
            Se(o, v),
            Se(o, x),
            Se(x, E),
            E.checked = E.__value === r[2],
            Se(x, C),
            Se(t, I),
            Se(t, D),
            j && j.m(D, null),
            Se(D, P),
            Se(D, k),
            qi(U, k, null),
            Se(e, Z),
            ~K && be[K].m(e, null),
            Se(e, W),
            Se(e, fe),
            qi(ce, fe, null),
            _e = !0,
            oe || (ee = [wn(d, "keydown", Ga(r[13])), wn(d, "change", r[14]), wn(E, "keydown", Ga(r[12])), wn(E, "change", r[16])],
            oe = !0)
        },
        p(se, [ke]) {
            ke & 4 && (d.checked = d.__value === se[2]),
            ke & 4 && (E.checked = E.__value === se[2]),
            se[4] ? j || (j = KC(se),
            j.c(),
            j.m(D, P)) : j && (j.d(1),
            j = null),
            ke & 2080 && Gn(k, "hidden", se[5] === se[11]);
            let Be = K;
            K = te(se, ke),
            K === Be ? ~K && be[K].p(se, ke) : (X && (eo(),
            ri(be[Be], 1, 1, ()=>{
                be[Be] = null
            }
            ),
            to()),
            ~K ? (X = be[K],
            X ? X.p(se, ke) : (X = be[K] = ne[K](se),
            X.c()),
            Wn(X, 1),
            X.m(e, W)) : X = null);
            let tt = {};
            ce.$set(tt),
            ke & 448 && Gn(fe, "hidden", !(se[6] === se[7] || se[6] === se[8]))
        },
        i(se) {
            _e || (Wn(U.$$.fragment, se),
            Wn(X),
            Wn(ce.$$.fragment, se),
            _e = !0)
        },
        o(se) {
            ri(U.$$.fragment, se),
            ri(X),
            ri(ce.$$.fragment, se),
            _e = !1
        },
        d(se) {
            se && mn(e),
            r[15][0].splice(r[15][0].indexOf(d), 1),
            r[15][0].splice(r[15][0].indexOf(E), 1),
            j && j.d(),
            Ki(U),
            ~K && be[K].d(),
            r[18](null),
            Ki(ce),
            oe = !1,
            Wi(ee)
        }
    }
}
function y6(r, e, t) {
    let o, c, d, p;
    Ht(r, cm, _e=>t(3, o = _e)),
    Ht(r, Qr, _e=>t(4, c = _e)),
    Ht(r, js, _e=>t(5, d = _e)),
    Ht(r, zr, _e=>t(6, p = _e));
    let {MODE3D: i, CROSS: v} = Yr
      , {FILE: x, ELEVATION: E} = pd
      , {HISTORICAL: A, LIVE: C} = Gs
      , I = 1
      , {canvas: D=void 0} = e
      , {elevationFunctions: P=void 0} = e
      , k = {
        1: E,
        2: x
    }
      , U = [[]];
    function Z(_e) {
        Wa.call(this, r, _e)
    }
    function K(_e) {
        Wa.call(this, r, _e)
    }
    function X() {
        I = this.__value,
        t(2, I)
    }
    function W() {
        I = this.__value,
        t(2, I)
    }
    function fe(_e) {
        Bi[_e ? "unshift" : "push"](()=>{
            P = _e,
            t(1, P)
        }
        )
    }
    function ce(_e) {
        Bi[_e ? "unshift" : "push"](()=>{
            D = _e,
            t(0, D)
        }
        )
    }
    return r.$$set = _e=>{
        "canvas"in _e && t(0, D = _e.canvas),
        "elevationFunctions"in _e && t(1, P = _e.elevationFunctions)
    }
    ,
    r.$$.update = ()=>{
        if (r.$$.dirty & 4) {
            e: bn(cm, o = k[I], o)
        }
    }
    ,
    [D, P, I, o, c, d, p, i, v, x, E, C, Z, K, X, U, W, fe, ce]
}
var YC = class extends mi {
    constructor(e) {
        super();
        _i(this, e, y6, _6, di, {
            canvas: 0,
            elevationFunctions: 1
        })
    }
}
  , JC = YC;
function $C() {
    throw new Error("setTimeout has not been defined")
}
function QC() {
    throw new Error("clearTimeout has not been defined")
}
var Ac = $C, Mc = QC, df;
typeof window != "undefined" ? df = window : typeof self != "undefined" ? df = self : df = {};
typeof df.setTimeout == "function" && (Ac = setTimeout);
typeof df.clearTimeout == "function" && (Mc = clearTimeout);
function e3(r) {
    if (Ac === setTimeout)
        return setTimeout(r, 0);
    if ((Ac === $C || !Ac) && setTimeout)
        return Ac = setTimeout,
        setTimeout(r, 0);
    try {
        return Ac(r, 0)
    } catch (e) {
        try {
            return Ac.call(null, r, 0)
        } catch (t) {
            return Ac.call(this, r, 0)
        }
    }
}
function x6(r) {
    if (Mc === clearTimeout)
        return clearTimeout(r);
    if ((Mc === QC || !Mc) && clearTimeout)
        return Mc = clearTimeout,
        clearTimeout(r);
    try {
        return Mc(r)
    } catch (e) {
        try {
            return Mc.call(null, r)
        } catch (t) {
            return Mc.call(this, r)
        }
    }
}
var fl = [], ff = !1, lh, J0 = -1;
function v6() {
    !ff || !lh || (ff = !1,
    lh.length ? fl = lh.concat(fl) : J0 = -1,
    fl.length && t3())
}
function t3() {
    if (!ff) {
        var r = e3(v6);
        ff = !0;
        for (var e = fl.length; e; ) {
            for (lh = fl,
            fl = []; ++J0 < e; )
                lh && lh[J0].run();
            J0 = -1,
            e = fl.length
        }
        lh = null,
        ff = !1,
        x6(r)
    }
}
function b6(r) {
    var e = new Array(arguments.length - 1);
    if (arguments.length > 1)
        for (var t = 1; t < arguments.length; t++)
            e[t - 1] = arguments[t];
    fl.push(new n3(r,e)),
    fl.length === 1 && !ff && e3(t3)
}
function n3(r, e) {
    this.fun = r,
    this.array = e
}
n3.prototype.run = function() {
    this.fun.apply(null, this.array)
}
;
var w6 = "browser"
  , T6 = "browser"
  , E6 = !0
  , S6 = []
  , A6 = ""
  , M6 = {}
  , I6 = {}
  , C6 = {};
function ch() {}
var D6 = ch
  , L6 = ch
  , R6 = ch
  , P6 = ch
  , k6 = ch
  , z6 = ch
  , O6 = ch;
function N6(r) {
    throw new Error("process.binding is not supported")
}
function F6() {
    return "/"
}
function B6(r) {
    throw new Error("process.chdir is not supported")
}
function U6() {
    return 0
}
var pf = df.performance || {}
  , V6 = pf.now || pf.mozNow || pf.msNow || pf.oNow || pf.webkitNow || function() {
    return new Date().getTime()
}
;
function G6(r) {
    var e = V6.call(pf) * .001
      , t = Math.floor(e)
      , o = Math.floor(e % 1 * 1e9);
    return r && (t = t - r[0],
    o = o - r[1],
    o < 0 && (t--,
    o += 1e9)),
    [t, o]
}
var H6 = new Date;
function W6() {
    var r = new Date
      , e = r - H6;
    return e / 1e3
}
var i3 = {
    nextTick: b6,
    title: w6,
    browser: E6,
    env: {
        NODE_ENV: "production"
    },
    argv: S6,
    version: A6,
    versions: M6,
    on: D6,
    addListener: L6,
    once: R6,
    off: P6,
    removeListener: k6,
    removeAllListeners: z6,
    emit: O6,
    binding: N6,
    cwd: F6,
    chdir: B6,
    umask: U6,
    hrtime: G6,
    platform: T6,
    release: I6,
    config: C6,
    uptime: W6
}
  , j6 = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {};
function Z6(r, e, t) {
    return t = {
        path: e,
        exports: {},
        require: function(o, c) {
            return X6(o, c ?? t.path)
        }
    },
    r(t, t.exports),
    t.exports
}
function X6() {
    throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs")
}
var q6 = Z6(function(r, e) {
    (function(t, o) {
        r.exports = o()
    }
    )(j6, function() {
        var t, o, c;
        function d(i, v) {
            if (!t)
                t = v;
            else if (!o)
                o = v;
            else {
                var x = "self.onerror = function() { console.error('An error occurred while parsing the WebWorker bundle. This is most likely due to improper transpilation by Babel; please see https://docs.mapbox.com/mapbox-gl-js/guides/install/#transpiling'); }; var sharedChunk = {}; (" + t + ")(sharedChunk); (" + o + ")(sharedChunk); self.onerror = null;"
                  , E = {};
                t(E),
                c = v(E),
                typeof window != "undefined" && window && window.URL && window.URL.createObjectURL && (c.workerUrl = window.URL.createObjectURL(new Blob([x],{
                    type: "text/javascript"
                })))
            }
        }
        d(["exports"], function(i) {
            var v = typeof self != "undefined" ? self : {}
              , x = "2.13.0";
            let E, A = {
                API_URL: "https://api.mapbox.com",
                get API_URL_REGEX() {
                    if (E == null) {
                        let s = /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/|\?|$)/i;
                        try {
                            E = i3.env.API_URL_REGEX != null ? new RegExp(i3.env.API_URL_REGEX) : s
                        } catch (n) {
                            E = s
                        }
                    }
                    return E
                },
                get API_TILEJSON_REGEX() {
                    return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/v[0-9]*\/.*\.json.*$)/i
                },
                get API_SPRITE_REGEX() {
                    return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*\/sprite.*\..*$)/i
                },
                get API_FONTS_REGEX() {
                    return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/fonts\/v[0-9]*\/)(.*\.pbf.*$)/i
                },
                get API_STYLE_REGEX() {
                    return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*$)/i
                },
                get API_CDN_URL_REGEX() {
                    return /^((https?:)?\/\/)?api\.mapbox\.c(n|om)(\/mapbox-gl-js\/)(.*$)/i
                },
                get EVENTS_URL() {
                    return this.API_URL ? this.API_URL.indexOf("https://api.mapbox.cn") === 0 ? "https://events.mapbox.cn/events/v2" : this.API_URL.indexOf("https://api.mapbox.com") === 0 ? "https://events.mapbox.com/events/v2" : null : null
                },
                SESSION_PATH: "/map-sessions/v1",
                FEEDBACK_URL: "https://apps.mapbox.com/feedback",
                TILE_URL_VERSION: "v4",
                RASTER_URL_PREFIX: "raster/v1",
                REQUIRE_ACCESS_TOKEN: !0,
                ACCESS_TOKEN: null,
                MAX_PARALLEL_IMAGE_REQUESTS: 16
            }, C = {
                supported: !1,
                testSupport: function(s) {
                    !P && D && (k ? U(s) : I = s)
                }
            }, I, D, P = !1, k = !1;
            function U(s) {
                let n = s.createTexture();
                s.bindTexture(s.TEXTURE_2D, n);
                try {
                    if (s.texImage2D(s.TEXTURE_2D, 0, s.RGBA, s.RGBA, s.UNSIGNED_BYTE, D),
                    s.isContextLost())
                        return;
                    C.supported = !0
                } catch (a) {}
                s.deleteTexture(n),
                P = !0
            }
            v.document && (D = v.document.createElement("img"),
            D.onload = function() {
                I && U(I),
                I = null,
                k = !0
            }
            ,
            D.onerror = function() {
                P = !0,
                I = null
            }
            ,
            D.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=");
            let Z = "01";
            var K = X;
            function X(s, n, a, u) {
                this.cx = 3 * s,
                this.bx = 3 * (a - s) - this.cx,
                this.ax = 1 - this.cx - this.bx,
                this.cy = 3 * n,
                this.by = 3 * (u - n) - this.cy,
                this.ay = 1 - this.cy - this.by,
                this.p1x = s,
                this.p1y = n,
                this.p2x = a,
                this.p2y = u
            }
            X.prototype = {
                sampleCurveX: function(s) {
                    return ((this.ax * s + this.bx) * s + this.cx) * s
                },
                sampleCurveY: function(s) {
                    return ((this.ay * s + this.by) * s + this.cy) * s
                },
                sampleCurveDerivativeX: function(s) {
                    return (3 * this.ax * s + 2 * this.bx) * s + this.cx
                },
                solveCurveX: function(s, n) {
                    if (n === void 0 && (n = 1e-6),
                    s < 0)
                        return 0;
                    if (s > 1)
                        return 1;
                    for (var a = s, u = 0; u < 8; u++) {
                        var f = this.sampleCurveX(a) - s;
                        if (Math.abs(f) < n)
                            return a;
                        var g = this.sampleCurveDerivativeX(a);
                        if (Math.abs(g) < 1e-6)
                            break;
                        a -= f / g
                    }
                    var y = 0
                      , w = 1;
                    for (a = s,
                    u = 0; u < 20 && (f = this.sampleCurveX(a),
                    !(Math.abs(f - s) < n)); u++)
                        s > f ? y = a : w = a,
                        a = .5 * (w - y) + y;
                    return a
                },
                solve: function(s, n) {
                    return this.sampleCurveY(this.solveCurveX(s, n))
                }
            };
            var W = fe;
            function fe(s, n) {
                this.x = s,
                this.y = n
            }
            fe.prototype = {
                clone: function() {
                    return new fe(this.x,this.y)
                },
                add: function(s) {
                    return this.clone()._add(s)
                },
                sub: function(s) {
                    return this.clone()._sub(s)
                },
                multByPoint: function(s) {
                    return this.clone()._multByPoint(s)
                },
                divByPoint: function(s) {
                    return this.clone()._divByPoint(s)
                },
                mult: function(s) {
                    return this.clone()._mult(s)
                },
                div: function(s) {
                    return this.clone()._div(s)
                },
                rotate: function(s) {
                    return this.clone()._rotate(s)
                },
                rotateAround: function(s, n) {
                    return this.clone()._rotateAround(s, n)
                },
                matMult: function(s) {
                    return this.clone()._matMult(s)
                },
                unit: function() {
                    return this.clone()._unit()
                },
                perp: function() {
                    return this.clone()._perp()
                },
                round: function() {
                    return this.clone()._round()
                },
                mag: function() {
                    return Math.sqrt(this.x * this.x + this.y * this.y)
                },
                equals: function(s) {
                    return this.x === s.x && this.y === s.y
                },
                dist: function(s) {
                    return Math.sqrt(this.distSqr(s))
                },
                distSqr: function(s) {
                    var n = s.x - this.x
                      , a = s.y - this.y;
                    return n * n + a * a
                },
                angle: function() {
                    return Math.atan2(this.y, this.x)
                },
                angleTo: function(s) {
                    return Math.atan2(this.y - s.y, this.x - s.x)
                },
                angleWith: function(s) {
                    return this.angleWithSep(s.x, s.y)
                },
                angleWithSep: function(s, n) {
                    return Math.atan2(this.x * n - this.y * s, this.x * s + this.y * n)
                },
                _matMult: function(s) {
                    var n = s[2] * this.x + s[3] * this.y;
                    return this.x = s[0] * this.x + s[1] * this.y,
                    this.y = n,
                    this
                },
                _add: function(s) {
                    return this.x += s.x,
                    this.y += s.y,
                    this
                },
                _sub: function(s) {
                    return this.x -= s.x,
                    this.y -= s.y,
                    this
                },
                _mult: function(s) {
                    return this.x *= s,
                    this.y *= s,
                    this
                },
                _div: function(s) {
                    return this.x /= s,
                    this.y /= s,
                    this
                },
                _multByPoint: function(s) {
                    return this.x *= s.x,
                    this.y *= s.y,
                    this
                },
                _divByPoint: function(s) {
                    return this.x /= s.x,
                    this.y /= s.y,
                    this
                },
                _unit: function() {
                    return this._div(this.mag()),
                    this
                },
                _perp: function() {
                    var s = this.y;
                    return this.y = this.x,
                    this.x = -s,
                    this
                },
                _rotate: function(s) {
                    var n = Math.cos(s)
                      , a = Math.sin(s)
                      , u = a * this.x + n * this.y;
                    return this.x = n * this.x - a * this.y,
                    this.y = u,
                    this
                },
                _rotateAround: function(s, n) {
                    var a = Math.cos(s)
                      , u = Math.sin(s)
                      , f = n.y + u * (this.x - n.x) + a * (this.y - n.y);
                    return this.x = n.x + a * (this.x - n.x) - u * (this.y - n.y),
                    this.y = f,
                    this
                },
                _round: function() {
                    return this.x = Math.round(this.x),
                    this.y = Math.round(this.y),
                    this
                }
            },
            fe.convert = function(s) {
                return s instanceof fe ? s : Array.isArray(s) ? new fe(s[0],s[1]) : s
            }
            ;
            let ce = Math.PI / 180
              , _e = 180 / Math.PI;
            function oe(s) {
                return s * ce
            }
            function ee(s) {
                return s * _e
            }
            let j = [[0, 0], [1, 0], [1, 1], [0, 1]];
            function ne(s) {
                if (s <= 0)
                    return 0;
                if (s >= 1)
                    return 1;
                let n = s * s
                  , a = n * s;
                return 4 * (s < .5 ? a : 3 * (s - n) + a - .75)
            }
            function be(s, n, a, u) {
                let f = new K(s,n,a,u);
                return function(g) {
                    return f.solve(g)
                }
            }
            let te = be(.25, .1, .25, 1);
            function ae(s, n, a) {
                return Math.min(a, Math.max(n, s))
            }
            function se(s, n, a) {
                return (a = ae((a - s) / (n - s), 0, 1)) * a * (3 - 2 * a)
            }
            function ke(s, n, a) {
                let u = a - n
                  , f = ((s - n) % u + u) % u + n;
                return f === n ? a : f
            }
            function Be(s, n, a) {
                if (!s.length)
                    return a(null, []);
                let u = s.length
                  , f = new Array(s.length)
                  , g = null;
                s.forEach((y,w)=>{
                    n(y, (S,M)=>{
                        S && (g = S),
                        f[w] = M,
                        --u == 0 && a(g, f)
                    }
                    )
                }
                )
            }
            function tt(s) {
                let n = [];
                for (let a in s)
                    n.push(s[a]);
                return n
            }
            function Ke(s, ...n) {
                for (let a of n)
                    for (let u in a)
                        s[u] = a[u];
                return s
            }
            let bt = 1;
            function Et() {
                return bt++
            }
            function Gt() {
                return function s(n) {
                    return n ? (n ^ Math.random() * (16 >> n / 4)).toString(16) : ([1e7] + -[1e3] + -4e3 + -8e3 + -1e11).replace(/[018]/g, s)
                }()
            }
            function Ye(s) {
                return s <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(s) / Math.LN2))
            }
            function gn(s) {
                return !!s && /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(s)
            }
            function gt(s, n) {
                s.forEach(a=>{
                    n[a] && (n[a] = n[a].bind(n))
                }
                )
            }
            function Tn(s, n) {
                return s.indexOf(n, s.length - n.length) !== -1
            }
            function xn(s, n, a) {
                let u = {};
                for (let f in s)
                    u[f] = n.call(a || this, s[f], f, s);
                return u
            }
            function Dn(s, n, a) {
                let u = {};
                for (let f in s)
                    n.call(a || this, s[f], f, s) && (u[f] = s[f]);
                return u
            }
            function Bt(s) {
                return Array.isArray(s) ? s.map(Bt) : typeof s == "object" && s ? xn(s, Bt) : s
            }
            let An = {};
            function ut(s) {
                An[s] || (typeof console != "undefined" && console.warn(s),
                An[s] = !0)
            }
            function ot(s, n, a) {
                return (a.y - s.y) * (n.x - s.x) > (n.y - s.y) * (a.x - s.x)
            }
            function xt(s) {
                let n = 0;
                for (let a, u, f = 0, g = s.length, y = g - 1; f < g; y = f++)
                    a = s[f],
                    u = s[y],
                    n += (u.x - a.x) * (a.y + u.y);
                return n
            }
            function on() {
                return typeof WorkerGlobalScope != "undefined" && typeof self != "undefined" && self instanceof WorkerGlobalScope
            }
            function $t(s) {
                let n = {};
                if (s.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (a,u,f,g)=>{
                    let y = f || g;
                    return n[u] = !y || y.toLowerCase(),
                    ""
                }
                ),
                n["max-age"]) {
                    let a = parseInt(n["max-age"], 10);
                    isNaN(a) ? delete n["max-age"] : n["max-age"] = a
                }
                return n
            }
            let Pn = null;
            function kt(s) {
                if (Pn == null) {
                    let n = s.navigator ? s.navigator.userAgent : null;
                    Pn = !!s.safari || !(!n || !(/\b(iPad|iPhone|iPod)\b/.test(n) || n.match("Safari") && !n.match("Chrome")))
                }
                return Pn
            }
            function Zt(s) {
                try {
                    let n = v[s];
                    return n.setItem("_mapbox_test_", 1),
                    n.removeItem("_mapbox_test_"),
                    !0
                } catch (n) {
                    return !1
                }
            }
            function zn(s, n) {
                return [s[4 * n], s[4 * n + 1], s[4 * n + 2], s[4 * n + 3]]
            }
            let Qt = "mapbox-tiles", xe, he, Qe = 500, ft = 50;
            function St() {
                try {
                    return v.caches
                } catch (s) {}
            }
            function Mt() {
                St() && !xe && (xe = v.caches.open(Qt))
            }
            function an(s) {
                let n = s.indexOf("?");
                if (n < 0)
                    return s;
                let a = function(f) {
                    let g = f.indexOf("?");
                    return g > 0 ? f.slice(g + 1).split("&") : []
                }(s)
                  , u = a.filter(f=>{
                    let g = f.split("=");
                    return g[0] === "language" || g[0] === "worldview"
                }
                );
                return u.length ? `${s.slice(0, n)}?${u.join("&")}` : s.slice(0, n)
            }
            let Ie = 1 / 0
              , Ct = {
                Unknown: "Unknown",
                Style: "Style",
                Source: "Source",
                Tile: "Tile",
                Glyphs: "Glyphs",
                SpriteImage: "SpriteImage",
                SpriteJSON: "SpriteJSON",
                Image: "Image"
            };
            typeof Object.freeze == "function" && Object.freeze(Ct);
            class ln extends Error {
                constructor(n, a, u) {
                    a === 401 && Vn(u) && (n += ": you may have provided an invalid Mapbox access token. See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes"),
                    super(n),
                    this.status = a,
                    this.url = u
                }
                toString() {
                    return `${this.name}: ${this.message} (${this.status}): ${this.url}`
                }
            }
            let Kt = on() ? ()=>self.worker && self.worker.referrer : ()=>(v.location.protocol === "blob:" ? v.parent : v).location.href
              , Ge = function(s, n) {
                if (!(/^file:/.test(a = s.url) || /^file:/.test(Kt()) && !/^\w+:/.test(a))) {
                    if (v.fetch && v.Request && v.AbortController && v.Request.prototype.hasOwnProperty("signal"))
                        return function(u, f) {
                            let g = new v.AbortController
                              , y = new v.Request(u.url,{
                                method: u.method || "GET",
                                body: u.body,
                                credentials: u.credentials,
                                headers: u.headers,
                                referrer: Kt(),
                                signal: g.signal
                            })
                              , w = !1
                              , S = !1
                              , M = (z = y.url).indexOf("sku=") > 0 && Vn(z);
                            var z;
                            u.type === "json" && y.headers.set("Accept", "application/json");
                            let N = (H,q,Q)=>{
                                if (S)
                                    return;
                                if (H && H.message !== "SecurityError" && ut(H),
                                q && Q)
                                    return B(q);
                                let de = Date.now();
                                v.fetch(y).then(Me=>{
                                    if (Me.ok) {
                                        let Pe = M ? Me.clone() : null;
                                        return B(Me, Pe, de)
                                    }
                                    return f(new ln(Me.statusText,Me.status,u.url))
                                }
                                ).catch(Me=>{
                                    Me.name !== "AbortError" && f(new Error(`${Me.message} ${u.url}`))
                                }
                                )
                            }
                              , B = (H,q,Q)=>{
                                (u.type === "arrayBuffer" ? H.arrayBuffer() : u.type === "json" ? H.json() : H.text()).then(de=>{
                                    S || (q && Q && function(Me, Pe, we) {
                                        if (Mt(),
                                        !xe)
                                            return;
                                        let Le = {
                                            status: Pe.status,
                                            statusText: Pe.statusText,
                                            headers: new v.Headers
                                        };
                                        Pe.headers.forEach((at,it)=>Le.headers.set(it, at));
                                        let Ue = $t(Pe.headers.get("Cache-Control") || "");
                                        if (Ue["no-store"])
                                            return;
                                        Ue["max-age"] && Le.headers.set("Expires", new Date(we + 1e3 * Ue["max-age"]).toUTCString());
                                        let Ne = Le.headers.get("Expires");
                                        Ne && (new Date(Ne).getTime() - we < 42e4 || function(at, it) {
                                            if (he === void 0)
                                                try {
                                                    new Response(new ReadableStream),
                                                    he = !0
                                                } catch (_t) {
                                                    he = !1
                                                }
                                            he ? it(at.body) : at.blob().then(it)
                                        }(Pe, at=>{
                                            let it = new v.Response(at,Le);
                                            Mt(),
                                            xe && xe.then(_t=>_t.put(an(Me.url), it)).catch(_t=>ut(_t.message))
                                        }
                                        ))
                                    }(y, q, Q),
                                    w = !0,
                                    f(null, de, H.headers.get("Cache-Control"), H.headers.get("Expires")))
                                }
                                ).catch(de=>{
                                    S || f(new Error(de.message))
                                }
                                )
                            }
                            ;
                            return M ? function(H, q) {
                                if (Mt(),
                                !xe)
                                    return q(null);
                                let Q = an(H.url);
                                xe.then(de=>{
                                    de.match(Q).then(Me=>{
                                        let Pe = function(we) {
                                            if (!we)
                                                return !1;
                                            let Le = new Date(we.headers.get("Expires") || 0)
                                              , Ue = $t(we.headers.get("Cache-Control") || "");
                                            return Le > Date.now() && !Ue["no-cache"]
                                        }(Me);
                                        de.delete(Q),
                                        Pe && de.put(Q, Me.clone()),
                                        q(null, Me, Pe)
                                    }
                                    ).catch(q)
                                }
                                ).catch(q)
                            }(y, N) : N(null, null),
                            {
                                cancel: ()=>{
                                    S = !0,
                                    w || g.abort()
                                }
                            }
                        }(s, n);
                    if (on() && self.worker && self.worker.actor)
                        return self.worker.actor.send("getResource", s, n, void 0, !0)
                }
                var a;
                return function(u, f) {
                    let g = new v.XMLHttpRequest;
                    g.open(u.method || "GET", u.url, !0),
                    u.type === "arrayBuffer" && (g.responseType = "arraybuffer");
                    for (let y in u.headers)
                        g.setRequestHeader(y, u.headers[y]);
                    return u.type === "json" && (g.responseType = "text",
                    g.setRequestHeader("Accept", "application/json")),
                    g.withCredentials = u.credentials === "include",
                    g.onerror = ()=>{
                        f(new Error(g.statusText))
                    }
                    ,
                    g.onload = ()=>{
                        if ((g.status >= 200 && g.status < 300 || g.status === 0) && g.response !== null) {
                            let y = g.response;
                            if (u.type === "json")
                                try {
                                    y = JSON.parse(g.response)
                                } catch (w) {
                                    return f(w)
                                }
                            f(null, y, g.getResponseHeader("Cache-Control"), g.getResponseHeader("Expires"))
                        } else
                            f(new ln(g.statusText,g.status,u.url))
                    }
                    ,
                    g.send(u.body),
                    {
                        cancel: ()=>g.abort()
                    }
                }(s, n)
            }
              , Wt = function(s, n) {
                return Ge(Ke(s, {
                    type: "arrayBuffer"
                }), n)
            };
            function Ut(s) {
                let n = v.document.createElement("a");
                return n.href = s,
                n.protocol === v.document.location.protocol && n.host === v.document.location.host
            }
            let _n = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=", Ft, nn;
            Ft = [],
            nn = 0;
            let Jt = function(s, n) {
                if (C.supported && (s.headers || (s.headers = {}),
                s.headers.accept = "image/webp,*/*"),
                nn >= A.MAX_PARALLEL_IMAGE_REQUESTS) {
                    let g = {
                        requestParameters: s,
                        callback: n,
                        cancelled: !1,
                        cancel() {
                            this.cancelled = !0
                        }
                    };
                    return Ft.push(g),
                    g
                }
                nn++;
                let a = !1
                  , u = ()=>{
                    if (!a)
                        for (a = !0,
                        nn--; Ft.length && nn < A.MAX_PARALLEL_IMAGE_REQUESTS; ) {
                            let g = Ft.shift()
                              , {requestParameters: y, callback: w, cancelled: S} = g;
                            S || (g.cancel = Jt(y, w).cancel)
                        }
                }
                  , f = Wt(s, (g,y,w,S)=>{
                    u(),
                    g ? n(g) : y && (v.createImageBitmap ? function(M, z) {
                        let N = new v.Blob([new Uint8Array(M)],{
                            type: "image/png"
                        });
                        v.createImageBitmap(N).then(B=>{
                            z(null, B)
                        }
                        ).catch(B=>{
                            z(new Error(`Could not load image because of ${B.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`))
                        }
                        )
                    }(y, (M,z)=>n(M, z, w, S)) : function(M, z) {
                        let N = new v.Image
                          , B = v.URL;
                        N.onload = ()=>{
                            z(null, N),
                            B.revokeObjectURL(N.src),
                            N.onload = null,
                            v.requestAnimationFrame(()=>{
                                N.src = _n
                            }
                            )
                        }
                        ,
                        N.onerror = ()=>z(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
                        let H = new v.Blob([new Uint8Array(M)],{
                            type: "image/png"
                        });
                        N.src = M.byteLength ? B.createObjectURL(H) : _n
                    }(y, (M,z)=>n(M, z, w, S)))
                }
                );
                return {
                    cancel: ()=>{
                        f.cancel(),
                        u()
                    }
                }
            }
              , Ln = "NO_ACCESS_TOKEN";
            function Zn(s) {
                return s.indexOf("mapbox:") === 0
            }
            function Vn(s) {
                return A.API_URL_REGEX.test(s)
            }
            function Tr(s) {
                return A.API_CDN_URL_REGEX.test(s)
            }
            function fr(s) {
                return A.API_STYLE_REGEX.test(s) && !Rs(s)
            }
            function Rs(s) {
                return A.API_SPRITE_REGEX.test(s)
            }
            let Cr = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;
            function Vr(s) {
                let n = s.match(Cr);
                if (!n)
                    throw new Error("Unable to parse URL object");
                return {
                    protocol: n[1],
                    authority: n[2],
                    path: n[3] || "/",
                    params: n[4] ? n[4].split("&") : []
                }
            }
            function Gr(s) {
                let n = s.params.length ? `?${s.params.join("&")}` : "";
                return `${s.protocol}://${s.authority}${s.path}${n}`
            }
            function Ps(s) {
                if (!s)
                    return null;
                let n = s.split(".");
                if (!n || n.length !== 3)
                    return null;
                try {
                    return JSON.parse(decodeURIComponent(v.atob(n[1]).split("").map(a=>"%" + ("00" + a.charCodeAt(0).toString(16)).slice(-2)).join("")))
                } catch (a) {
                    return null
                }
            }
            class ds {
                constructor(n) {
                    this.type = n,
                    this.anonId = null,
                    this.eventData = {},
                    this.queue = [],
                    this.pendingRequest = null
                }
                getStorageKey(n) {
                    let a = Ps(A.ACCESS_TOKEN)
                      , u = "";
                    return u = a && a.u ? v.btoa(encodeURIComponent(a.u).replace(/%([0-9A-F]{2})/g, (f,g)=>String.fromCharCode(Number("0x" + g)))) : A.ACCESS_TOKEN || "",
                    n ? `mapbox.eventData.${n}:${u}` : `mapbox.eventData:${u}`
                }
                fetchEventData() {
                    let n = Zt("localStorage")
                      , a = this.getStorageKey()
                      , u = this.getStorageKey("uuid");
                    if (n)
                        try {
                            let f = v.localStorage.getItem(a);
                            f && (this.eventData = JSON.parse(f));
                            let g = v.localStorage.getItem(u);
                            g && (this.anonId = g)
                        } catch (f) {
                            ut("Unable to read from LocalStorage")
                        }
                }
                saveEventData() {
                    let n = Zt("localStorage")
                      , a = this.getStorageKey()
                      , u = this.getStorageKey("uuid");
                    if (n)
                        try {
                            v.localStorage.setItem(u, this.anonId),
                            Object.keys(this.eventData).length >= 1 && v.localStorage.setItem(a, JSON.stringify(this.eventData))
                        } catch (f) {
                            ut("Unable to write to LocalStorage")
                        }
                }
                processRequests(n) {}
                postEvent(n, a, u, f) {
                    if (!A.EVENTS_URL)
                        return;
                    let g = Vr(A.EVENTS_URL);
                    g.params.push(`access_token=${f || A.ACCESS_TOKEN || ""}`);
                    let y = {
                        event: this.type,
                        created: new Date(n).toISOString()
                    }
                      , w = a ? Ke(y, a) : y
                      , S = {
                        url: Gr(g),
                        headers: {
                            "Content-Type": "text/plain"
                        },
                        body: JSON.stringify([w])
                    };
                    this.pendingRequest = function(M, z) {
                        return Ge(Ke(M, {
                            method: "POST"
                        }), z)
                    }(S, M=>{
                        this.pendingRequest = null,
                        u(M),
                        this.saveEventData(),
                        this.processRequests(f)
                    }
                    )
                }
                queueRequest(n, a) {
                    this.queue.push(n),
                    this.processRequests(a)
                }
            }
            let Te = new class extends ds {
                constructor(s) {
                    super("appUserTurnstile"),
                    this._customAccessToken = s
                }
                postTurnstileEvent(s, n) {
                    A.EVENTS_URL && A.ACCESS_TOKEN && Array.isArray(s) && s.some(a=>Zn(a) || Vn(a)) && this.queueRequest(Date.now(), n)
                }
                processRequests(s) {
                    if (this.pendingRequest || this.queue.length === 0)
                        return;
                    this.anonId && this.eventData.lastSuccess && this.eventData.tokenU || this.fetchEventData();
                    let n = Ps(A.ACCESS_TOKEN)
                      , a = n ? n.u : A.ACCESS_TOKEN
                      , u = a !== this.eventData.tokenU;
                    gn(this.anonId) || (this.anonId = Gt(),
                    u = !0);
                    let f = this.queue.shift();
                    if (this.eventData.lastSuccess) {
                        let g = new Date(this.eventData.lastSuccess)
                          , y = new Date(f)
                          , w = (f - this.eventData.lastSuccess) / 864e5;
                        u = u || w >= 1 || w < -1 || g.getDate() !== y.getDate()
                    } else
                        u = !0;
                    u ? this.postEvent(f, {
                        sdkIdentifier: "mapbox-gl-js",
                        sdkVersion: x,
                        skuId: Z,
                        "enabled.telemetry": !1,
                        userId: this.anonId
                    }, g=>{
                        g || (this.eventData.lastSuccess = f,
                        this.eventData.tokenU = a)
                    }
                    , s) : this.processRequests()
                }
            }
              , Y = Te.postTurnstileEvent.bind(Te)
              , F = new class extends ds {
                constructor() {
                    super("map.load"),
                    this.success = {},
                    this.skuToken = ""
                }
                postMapLoadEvent(s, n, a, u) {
                    this.skuToken = n,
                    this.errorCb = u,
                    A.EVENTS_URL && (a || A.ACCESS_TOKEN ? this.queueRequest({
                        id: s,
                        timestamp: Date.now()
                    }, a) : this.errorCb(new Error(Ln)))
                }
                processRequests(s) {
                    if (this.pendingRequest || this.queue.length === 0)
                        return;
                    let {id: n, timestamp: a} = this.queue.shift();
                    n && this.success[n] || (this.anonId || this.fetchEventData(),
                    gn(this.anonId) || (this.anonId = Gt()),
                    this.postEvent(a, {
                        sdkIdentifier: "mapbox-gl-js",
                        sdkVersion: x,
                        skuId: Z,
                        skuToken: this.skuToken,
                        userId: this.anonId
                    }, u=>{
                        u ? this.errorCb(u) : n && (this.success[n] = !0)
                    }
                    , s))
                }
            }
              , $ = F.postMapLoadEvent.bind(F)
              , ie = new class extends ds {
                constructor() {
                    super("gljs.performance")
                }
                postPerformanceEvent(s, n) {
                    A.EVENTS_URL && (s || A.ACCESS_TOKEN) && this.queueRequest({
                        timestamp: Date.now(),
                        performanceData: n
                    }, s)
                }
                processRequests(s) {
                    if (this.pendingRequest || this.queue.length === 0)
                        return;
                    let {timestamp: n, performanceData: a} = this.queue.shift()
                      , u = function(f) {
                        let g = v.performance.getEntriesByType("resource")
                          , y = v.performance.getEntriesByType("mark")
                          , w = function(B) {
                            let H = {};
                            if (B) {
                                for (let q in B)
                                    if (q !== "other")
                                        for (let Q of B[q]) {
                                            let de = `${q}ResolveRangeMin`
                                              , Me = `${q}ResolveRangeMax`
                                              , Pe = `${q}RequestCount`
                                              , we = `${q}RequestCachedCount`;
                                            H[de] = Math.min(H[de] || 1 / 0, Q.startTime),
                                            H[Me] = Math.max(H[Me] || -1 / 0, Q.responseEnd);
                                            let Le = Ue=>{
                                                H[Ue] === void 0 && (H[Ue] = 0),
                                                ++H[Ue]
                                            }
                                            ;
                                            Q.transferSize !== void 0 && Q.transferSize === 0 && Le(we),
                                            Le(Pe)
                                        }
                            }
                            return H
                        }(function(B, H) {
                            let q = {};
                            if (B)
                                for (let Q of B) {
                                    let de = H(Q);
                                    q[de] === void 0 && (q[de] = []),
                                    q[de].push(Q)
                                }
                            return q
                        }(g, et))
                          , S = v.devicePixelRatio
                          , M = v.navigator.connection || v.navigator.mozConnection || v.navigator.webkitConnection
                          , z = {
                            counters: [],
                            metadata: [],
                            attributes: []
                        }
                          , N = (B,H,q)=>{
                            q != null && B.push({
                                name: H,
                                value: q.toString()
                            })
                        }
                        ;
                        for (let B in w)
                            N(z.counters, B, w[B]);
                        if (f.interactionRange[0] !== 1 / 0 && f.interactionRange[1] !== -1 / 0 && (N(z.counters, "interactionRangeMin", f.interactionRange[0]),
                        N(z.counters, "interactionRangeMax", f.interactionRange[1])),
                        y)
                            for (let B of Object.keys(Ze)) {
                                let H = Ze[B]
                                  , q = y.find(Q=>Q.name === H);
                                q && N(z.counters, H, q.startTime)
                            }
                        return N(z.counters, "visibilityHidden", f.visibilityHidden),
                        N(z.attributes, "style", function(B) {
                            if (B)
                                for (let H of B) {
                                    let q = H.name.split("?")[0];
                                    if (fr(q)) {
                                        let Q = q.split("/").slice(-2);
                                        if (Q.length === 2)
                                            return `mapbox://styles/${Q[0]}/${Q[1]}`
                                    }
                                }
                        }(g)),
                        N(z.attributes, "terrainEnabled", f.terrainEnabled ? "true" : "false"),
                        N(z.attributes, "fogEnabled", f.fogEnabled ? "true" : "false"),
                        N(z.attributes, "projection", f.projection),
                        N(z.attributes, "zoom", f.zoom),
                        N(z.metadata, "devicePixelRatio", S),
                        N(z.metadata, "connectionEffectiveType", M ? M.effectiveType : void 0),
                        N(z.metadata, "navigatorUserAgent", v.navigator.userAgent),
                        N(z.metadata, "screenWidth", v.screen.width),
                        N(z.metadata, "screenHeight", v.screen.height),
                        N(z.metadata, "windowWidth", v.innerWidth),
                        N(z.metadata, "windowHeight", v.innerHeight),
                        N(z.metadata, "mapWidth", f.width / S),
                        N(z.metadata, "mapHeight", f.height / S),
                        N(z.metadata, "webglRenderer", f.renderer),
                        N(z.metadata, "webglVendor", f.vendor),
                        N(z.metadata, "sdkVersion", x),
                        N(z.metadata, "sdkIdentifier", "mapbox-gl-js"),
                        z
                    }(a);
                    for (let f of u.metadata)
                        ;
                    for (let f of u.counters)
                        ;
                    for (let f of u.attributes)
                        ;
                    this.postEvent(n, u, ()=>{}
                    , s)
                }
            }
              , ue = ie.postPerformanceEvent.bind(ie)
              , Ee = new class extends ds {
                constructor() {
                    super("map.auth"),
                    this.success = {},
                    this.skuToken = ""
                }
                getSession(s, n, a, u) {
                    if (!A.API_URL || !A.SESSION_PATH)
                        return;
                    let f = Vr(A.API_URL + A.SESSION_PATH);
                    f.params.push(`sku=${n || ""}`),
                    f.params.push(`access_token=${u || A.ACCESS_TOKEN || ""}`);
                    let g = {
                        url: Gr(f),
                        headers: {
                            "Content-Type": "text/plain"
                        }
                    };
                    this.pendingRequest = function(y, w) {
                        return Ge(Ke(y, {
                            method: "GET"
                        }), w)
                    }(g, y=>{
                        this.pendingRequest = null,
                        a(y),
                        this.saveEventData(),
                        this.processRequests(u)
                    }
                    )
                }
                getSessionAPI(s, n, a, u) {
                    this.skuToken = n,
                    this.errorCb = u,
                    A.SESSION_PATH && A.API_URL && (a || A.ACCESS_TOKEN ? this.queueRequest({
                        id: s,
                        timestamp: Date.now()
                    }, a) : this.errorCb(new Error(Ln)))
                }
                processRequests(s) {
                    if (this.pendingRequest || this.queue.length === 0)
                        return;
                    let {id: n, timestamp: a} = this.queue.shift();
                    n && this.success[n] || this.getSession(a, this.skuToken, u=>{
                        u ? this.errorCb(u) : n && (this.success[n] = !0)
                    }
                    , s)
                }
            }
              , He = Ee.getSessionAPI.bind(Ee)
              , Re = new Set
              , Ze = {
                create: "create",
                load: "load",
                fullLoad: "fullLoad"
            }
              , ye = {
                mark(s) {
                    v.performance.mark(s)
                },
                measure(s, n, a) {
                    v.performance.measure(s, n, a)
                }
            };
            function et(s) {
                let n = s.name.split("?")[0];
                return Tr(n) && n.includes("mapbox-gl.js") ? "javascript" : Tr(n) && n.includes("mapbox-gl.css") ? "css" : function(a) {
                    return A.API_FONTS_REGEX.test(a)
                }(n) ? "fontRange" : Rs(n) ? "sprite" : fr(n) ? "style" : function(a) {
                    return A.API_TILEJSON_REGEX.test(a)
                }(n) ? "tilejson" : "other"
            }
            let We = v.performance;
            function ze(s) {
                let n = s ? s.url.toString() : void 0;
                return We.getEntriesByName(n)
            }
            let Rt, wt, fn, Mn, Nn = {
                now: ()=>fn !== void 0 ? fn : v.performance.now(),
                setNow(s) {
                    fn = s
                },
                restoreNow() {
                    fn = void 0
                },
                frame(s) {
                    let n = v.requestAnimationFrame(s);
                    return {
                        cancel: ()=>v.cancelAnimationFrame(n)
                    }
                },
                getImageData(s, n=0) {
                    let {width: a, height: u} = s;
                    Mn || (Mn = v.document.createElement("canvas"));
                    let f = Mn.getContext("2d", {
                        willReadFrequently: !0
                    });
                    if (!f)
                        throw new Error("failed to create canvas 2d context");
                    return (a > Mn.width || u > Mn.height) && (Mn.width = a,
                    Mn.height = u),
                    f.clearRect(-n, -n, a + 2 * n, u + 2 * n),
                    f.drawImage(s, 0, 0, a, u),
                    f.getImageData(-n, -n, a + 2 * n, u + 2 * n)
                },
                resolveURL: s=>(Rt || (Rt = v.document.createElement("a")),
                Rt.href = s,
                Rt.href),
                get devicePixelRatio() {
                    return v.devicePixelRatio
                },
                get prefersReducedMotion() {
                    return !!v.matchMedia && (wt == null && (wt = v.matchMedia("(prefers-reduced-motion: reduce)")),
                    wt.matches)
                }
            };
            function jt(s, n, a) {
                a[s] && a[s].indexOf(n) !== -1 || (a[s] = a[s] || [],
                a[s].push(n))
            }
            function qn(s, n, a) {
                if (a && a[s]) {
                    let u = a[s].indexOf(n);
                    u !== -1 && a[s].splice(u, 1)
                }
            }
            class On {
                constructor(n, a={}) {
                    Ke(this, a),
                    this.type = n
                }
            }
            class ar extends On {
                constructor(n, a={}) {
                    super("error", Ke({
                        error: n
                    }, a))
                }
            }
            class pr {
                on(n, a) {
                    return this._listeners = this._listeners || {},
                    jt(n, a, this._listeners),
                    this
                }
                off(n, a) {
                    return qn(n, a, this._listeners),
                    qn(n, a, this._oneTimeListeners),
                    this
                }
                once(n, a) {
                    return a ? (this._oneTimeListeners = this._oneTimeListeners || {},
                    jt(n, a, this._oneTimeListeners),
                    this) : new Promise(u=>this.once(n, u))
                }
                fire(n, a) {
                    typeof n == "string" && (n = new On(n,a || {}));
                    let u = n.type;
                    if (this.listens(u)) {
                        n.target = this;
                        let f = this._listeners && this._listeners[u] ? this._listeners[u].slice() : [];
                        for (let w of f)
                            w.call(this, n);
                        let g = this._oneTimeListeners && this._oneTimeListeners[u] ? this._oneTimeListeners[u].slice() : [];
                        for (let w of g)
                            qn(u, w, this._oneTimeListeners),
                            w.call(this, n);
                        let y = this._eventedParent;
                        y && (Ke(n, typeof this._eventedParentData == "function" ? this._eventedParentData() : this._eventedParentData),
                        y.fire(n))
                    } else
                        n instanceof ar && console.error(n.error);
                    return this
                }
                listens(n) {
                    return !!(this._listeners && this._listeners[n] && this._listeners[n].length > 0 || this._oneTimeListeners && this._oneTimeListeners[n] && this._oneTimeListeners[n].length > 0 || this._eventedParent && this._eventedParent.listens(n))
                }
                setEventedParent(n, a) {
                    return this._eventedParent = n,
                    this._eventedParentData = a,
                    this
                }
            }
            var ht = JSON.parse('{"$version":8,"$root":{"version":{"required":true,"type":"enum","values":[8]},"name":{"type":"string"},"metadata":{"type":"*"},"center":{"type":"array","value":"number"},"zoom":{"type":"number"},"bearing":{"type":"number","default":0,"period":360,"units":"degrees"},"pitch":{"type":"number","default":0,"units":"degrees"},"light":{"type":"light"},"terrain":{"type":"terrain"},"fog":{"type":"fog"},"sources":{"required":true,"type":"sources"},"sprite":{"type":"string"},"glyphs":{"type":"string"},"transition":{"type":"transition"},"projection":{"type":"projection"},"layers":{"required":true,"type":"array","value":"layer"}},"sources":{"*":{"type":"source"}},"source":["source_vector","source_raster","source_raster_dem","source_geojson","source_video","source_image"],"source_vector":{"type":{"required":true,"type":"enum","values":{"vector":{}}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"scheme":{"type":"enum","values":{"xyz":{},"tms":{}},"default":"xyz"},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"attribution":{"type":"string"},"promoteId":{"type":"promoteId"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster":{"type":{"required":true,"type":"enum","values":{"raster":{}}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512,"units":"pixels"},"scheme":{"type":"enum","values":{"xyz":{},"tms":{}},"default":"xyz"},"attribution":{"type":"string"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster_dem":{"type":{"required":true,"type":"enum","values":{"raster-dem":{}}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512,"units":"pixels"},"attribution":{"type":"string"},"encoding":{"type":"enum","values":{"terrarium":{},"mapbox":{}},"default":"mapbox"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_geojson":{"type":{"required":true,"type":"enum","values":{"geojson":{}}},"data":{"type":"*"},"maxzoom":{"type":"number","default":18},"attribution":{"type":"string"},"buffer":{"type":"number","default":128,"maximum":512,"minimum":0},"filter":{"type":"*"},"tolerance":{"type":"number","default":0.375},"cluster":{"type":"boolean","default":false},"clusterRadius":{"type":"number","default":50,"minimum":0},"clusterMaxZoom":{"type":"number"},"clusterMinPoints":{"type":"number"},"clusterProperties":{"type":"*"},"lineMetrics":{"type":"boolean","default":false},"generateId":{"type":"boolean","default":false},"promoteId":{"type":"promoteId"}},"source_video":{"type":{"required":true,"type":"enum","values":{"video":{}}},"urls":{"required":true,"type":"array","value":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"source_image":{"type":{"required":true,"type":"enum","values":{"image":{}}},"url":{"required":true,"type":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"layer":{"id":{"type":"string","required":true},"type":{"type":"enum","values":{"fill":{},"line":{},"symbol":{},"circle":{},"heatmap":{},"fill-extrusion":{},"raster":{},"hillshade":{},"background":{},"sky":{}},"required":true},"metadata":{"type":"*"},"source":{"type":"string"},"source-layer":{"type":"string"},"minzoom":{"type":"number","minimum":0,"maximum":24},"maxzoom":{"type":"number","minimum":0,"maximum":24},"filter":{"type":"filter"},"layout":{"type":"layout"},"paint":{"type":"paint"}},"layout":["layout_fill","layout_line","layout_circle","layout_heatmap","layout_fill-extrusion","layout_symbol","layout_raster","layout_hillshade","layout_background","layout_sky"],"layout_background":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_sky":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_fill":{"fill-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_circle":{"circle-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_heatmap":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_fill-extrusion":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"},"fill-extrusion-edge-radius":{"type":"number","private":true,"default":0,"minimum":0,"maximum":1,"property-type":"constant"}},"layout_line":{"line-cap":{"type":"enum","values":{"butt":{},"round":{},"square":{}},"default":"butt","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-join":{"type":"enum","values":{"bevel":{},"round":{},"miter":{}},"default":"miter","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-miter-limit":{"type":"number","default":2,"requires":[{"line-join":"miter"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-round-limit":{"type":"number","default":1.05,"requires":[{"line-join":"round"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_symbol":{"symbol-placement":{"type":"enum","values":{"point":{},"line":{},"line-center":{}},"default":"point","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-spacing":{"type":"number","default":250,"minimum":1,"units":"pixels","requires":[{"symbol-placement":"line"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-avoid-edges":{"type":"boolean","default":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"symbol-z-order":{"type":"enum","values":{"auto":{},"viewport-y":{},"source":{}},"default":"auto","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-allow-overlap":{"type":"boolean","default":false,"requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-ignore-placement":{"type":"boolean","default":false,"requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-optional":{"type":"boolean","default":false,"requires":["icon-image","text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-rotation-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-size":{"type":"number","default":1,"minimum":0,"units":"factor of the original icon size","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-text-fit":{"type":"enum","values":{"none":{},"width":{},"height":{},"both":{}},"default":"none","requires":["icon-image","text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-text-fit-padding":{"type":"array","value":"number","length":4,"default":[0,0,0,0],"units":"pixels","requires":["icon-image","text-field",{"icon-text-fit":["both","width","height"]}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-image":{"type":"resolvedImage","tokens":true,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-rotate":{"type":"number","default":0,"period":360,"units":"degrees","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-padding":{"type":"number","default":2,"minimum":0,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-keep-upright":{"type":"boolean","default":false,"requires":["icon-image",{"icon-rotation-alignment":"map"},{"symbol-placement":["line","line-center"]}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-offset":{"type":"array","value":"number","length":2,"default":[0,0],"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-anchor":{"type":"enum","values":{"center":{},"left":{},"right":{},"top":{},"bottom":{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},"default":"center","requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-pitch-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-pitch-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-rotation-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-field":{"type":"formatted","default":"","tokens":true,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-font":{"type":"array","value":"string","default":["Open Sans Regular","Arial Unicode MS Regular"],"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-size":{"type":"number","default":16,"minimum":0,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-width":{"type":"number","default":10,"minimum":0,"units":"ems","requires":["text-field",{"symbol-placement":["point"]}],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-line-height":{"type":"number","default":1.2,"units":"ems","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-letter-spacing":{"type":"number","default":0,"units":"ems","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-justify":{"type":"enum","values":{"auto":{},"left":{},"center":{},"right":{}},"default":"center","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-radial-offset":{"type":"number","units":"ems","default":0,"requires":["text-field"],"property-type":"data-driven","expression":{"interpolated":true,"parameters":["zoom","feature"]}},"text-variable-anchor":{"type":"array","value":"enum","values":{"center":{},"left":{},"right":{},"top":{},"bottom":{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},"requires":["text-field",{"symbol-placement":["point"]}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-anchor":{"type":"enum","values":{"center":{},"left":{},"right":{},"top":{},"bottom":{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},"default":"center","requires":["text-field",{"!":"text-variable-anchor"}],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-angle":{"type":"number","default":45,"units":"degrees","requires":["text-field",{"symbol-placement":["line","line-center"]}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-writing-mode":{"type":"array","value":"enum","values":{"horizontal":{},"vertical":{}},"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-rotate":{"type":"number","default":0,"period":360,"units":"degrees","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-padding":{"type":"number","default":2,"minimum":0,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-keep-upright":{"type":"boolean","default":true,"requires":["text-field",{"text-rotation-alignment":"map"},{"symbol-placement":["line","line-center"]}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-transform":{"type":"enum","values":{"none":{},"uppercase":{},"lowercase":{}},"default":"none","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-offset":{"type":"array","value":"number","units":"ems","length":2,"default":[0,0],"requires":["text-field",{"!":"text-radial-offset"}],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-allow-overlap":{"type":"boolean","default":false,"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-ignore-placement":{"type":"boolean","default":false,"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-optional":{"type":"boolean","default":false,"requires":["text-field","icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_raster":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_hillshade":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"filter":{"type":"array","value":"*"},"filter_symbol":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature","pitch","distance-from-center"]}},"filter_fill":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_line":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_circle":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_fill-extrusion":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_heatmap":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_operator":{"type":"enum","values":{"==":{},"!=":{},">":{},">=":{},"<":{},"<=":{},"in":{},"!in":{},"all":{},"any":{},"none":{},"has":{},"!has":{},"within":{}}},"geometry_type":{"type":"enum","values":{"Point":{},"LineString":{},"Polygon":{}}},"function":{"expression":{"type":"expression"},"stops":{"type":"array","value":"function_stop"},"base":{"type":"number","default":1,"minimum":0},"property":{"type":"string","default":"$zoom"},"type":{"type":"enum","values":{"identity":{},"exponential":{},"interval":{},"categorical":{}},"default":"exponential"},"colorSpace":{"type":"enum","values":{"rgb":{},"lab":{},"hcl":{}},"default":"rgb"},"default":{"type":"*","required":false}},"function_stop":{"type":"array","minimum":0,"maximum":24,"value":["number","color"],"length":2},"expression":{"type":"array","value":"*","minimum":1},"fog":{"range":{"type":"array","default":[0.5,10],"minimum":-20,"maximum":20,"length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"high-color":{"type":"color","property-type":"data-constant","default":"#245cdf","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"space-color":{"type":"color","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],4,"#010b19",7,"#367ab9"],"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"horizon-blend":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],4,0.2,7,0.1],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"star-intensity":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],5,0.35,6,0],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"light":{"anchor":{"type":"enum","default":"viewport","values":{"map":{},"viewport":{}},"property-type":"data-constant","transition":false,"expression":{"interpolated":false,"parameters":["zoom"]}},"position":{"type":"array","default":[1.15,210,30],"length":3,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"projection":{"name":{"type":"enum","values":{"albers":{},"equalEarth":{},"equirectangular":{},"lambertConformalConic":{},"mercator":{},"naturalEarth":{},"winkelTripel":{},"globe":{}},"default":"mercator","required":true},"center":{"type":"array","length":2,"value":"number","property-type":"data-constant","minimum":[-180,-90],"maximum":[180,90],"transition":false,"requires":[{"name":["albers","lambertConformalConic"]}]},"parallels":{"type":"array","length":2,"value":"number","property-type":"data-constant","minimum":[-90,-90],"maximum":[90,90],"transition":false,"requires":[{"name":["albers","lambertConformalConic"]}]}},"terrain":{"source":{"type":"string","required":true},"exaggeration":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1000,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true,"requires":["source"]}},"paint":["paint_fill","paint_line","paint_circle","paint_heatmap","paint_fill-extrusion","paint_symbol","paint_raster","paint_hillshade","paint_background","paint_sky"],"paint_fill":{"fill-antialias":{"type":"boolean","default":true,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"fill-pattern"}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-outline-color":{"type":"color","transition":true,"requires":[{"!":"fill-pattern"},{"fill-antialias":true}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["fill-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"}},"paint_fill-extrusion":{"fill-extrusion-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"fill-extrusion-pattern"}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["fill-extrusion-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"fill-extrusion-height":{"type":"number","default":0,"minimum":0,"units":"meters","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-base":{"type":"number","default":0,"minimum":0,"units":"meters","transition":true,"requires":["fill-extrusion-height"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-vertical-gradient":{"type":"boolean","default":true,"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-ambient-occlusion-intensity":{"property-type":"data-constant","type":"number","private":true,"default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-radius":{"property-type":"data-constant","type":"number","private":true,"default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true,"requires":["fill-extrusion-edge-radius"]}},"paint_line":{"line-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"line-pattern"}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["line-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"line-width":{"type":"number","default":1,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-gap-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-offset":{"type":"number","default":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-blur":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-dasharray":{"type":"array","value":"number","minimum":0,"transition":false,"units":"line widths","requires":[{"!":"line-pattern"}],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-gradient":{"type":"color","transition":false,"requires":[{"!":"line-pattern"},{"source":"geojson","has":{"lineMetrics":true}}],"expression":{"interpolated":true,"parameters":["line-progress"]},"property-type":"color-ramp"},"line-trim-offset":{"type":"array","value":"number","length":2,"default":[0,0],"minimum":[0,0],"maximum":[1,1],"transition":false,"requires":[{"source":"geojson","has":{"lineMetrics":true}}],"property-type":"constant"}},"paint_circle":{"circle-radius":{"type":"number","default":5,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-blur":{"type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"circle-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["circle-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-scale":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-alignment":{"type":"enum","values":{"map":{},"viewport":{}},"default":"viewport","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"circle-stroke-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-stroke-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-stroke-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"}},"paint_heatmap":{"heatmap-radius":{"type":"number","default":30,"minimum":1,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"heatmap-weight":{"type":"number","default":1,"minimum":0,"transition":false,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"heatmap-intensity":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"heatmap-color":{"type":"color","default":["interpolate",["linear"],["heatmap-density"],0,"rgba(0, 0, 255, 0)",0.1,"royalblue",0.3,"cyan",0.5,"lime",0.7,"yellow",1,"red"],"transition":false,"expression":{"interpolated":true,"parameters":["heatmap-density"]},"property-type":"color-ramp"},"heatmap-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_symbol":{"icon-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-color":{"type":"color","default":"#000000","transition":true,"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["icon-image","icon-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-color":{"type":"color","default":"#000000","transition":true,"overridable":true,"requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["text-field","text-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_raster":{"raster-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-hue-rotate":{"type":"number","default":0,"period":360,"transition":true,"units":"degrees","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-min":{"type":"number","default":0,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-max":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-saturation":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-contrast":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-resampling":{"type":"enum","values":{"linear":{},"nearest":{}},"default":"linear","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"raster-fade-duration":{"type":"number","default":300,"minimum":0,"transition":false,"units":"milliseconds","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_hillshade":{"hillshade-illumination-direction":{"type":"number","default":335,"minimum":0,"maximum":359,"transition":false,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-illumination-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"viewport","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-exaggeration":{"type":"number","default":0.5,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-shadow-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-highlight-color":{"type":"color","default":"#FFFFFF","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-accent-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_background":{"background-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"background-pattern"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"background-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"background-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_sky":{"sky-type":{"type":"enum","values":{"gradient":{},"atmosphere":{}},"default":"atmosphere","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun":{"type":"array","value":"number","length":2,"units":"degrees","minimum":[0,0],"maximum":[360,180],"transition":false,"requires":[{"sky-type":"atmosphere"}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun-intensity":{"type":"number","requires":[{"sky-type":"atmosphere"}],"default":10,"minimum":0,"maximum":100,"transition":false,"property-type":"data-constant"},"sky-gradient-center":{"type":"array","requires":[{"sky-type":"gradient"}],"value":"number","default":[0,0],"length":2,"units":"degrees","minimum":[0,0],"maximum":[360,180],"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient-radius":{"type":"number","requires":[{"sky-type":"gradient"}],"default":90,"minimum":0,"maximum":180,"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient":{"type":"color","default":["interpolate",["linear"],["sky-radial-progress"],0.8,"#87ceeb",1,"white"],"transition":false,"requires":[{"sky-type":"gradient"}],"expression":{"interpolated":true,"parameters":["sky-radial-progress"]},"property-type":"color-ramp"},"sky-atmosphere-halo-color":{"type":"color","default":"white","transition":false,"requires":[{"sky-type":"atmosphere"}],"property-type":"data-constant"},"sky-atmosphere-color":{"type":"color","default":"white","transition":false,"requires":[{"sky-type":"atmosphere"}],"property-type":"data-constant"},"sky-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"transition":{"duration":{"type":"number","default":300,"minimum":0,"units":"milliseconds"},"delay":{"type":"number","default":0,"minimum":0,"units":"milliseconds"}},"property-type":{"data-driven":{"type":"property-type"},"color-ramp":{"type":"property-type"},"data-constant":{"type":"property-type"},"constant":{"type":"property-type"}},"promoteId":{"*":{"type":"string"}}}');
            function mr(s, ...n) {
                for (let a of n)
                    for (let u in a)
                        s[u] = a[u];
                return s
            }
            function jn(s) {
                return s instanceof Number || s instanceof String || s instanceof Boolean ? s.valueOf() : s
            }
            function vr(s) {
                if (Array.isArray(s))
                    return s.map(vr);
                if (s instanceof Object && !(s instanceof Number || s instanceof String || s instanceof Boolean)) {
                    let n = {};
                    for (let a in s)
                        n[a] = vr(s[a]);
                    return n
                }
                return jn(s)
            }
            class ao extends Error {
                constructor(n, a) {
                    super(a),
                    this.message = a,
                    this.key = n
                }
            }
            var Zi = ao;
            class Xo {
                constructor(n, a=[]) {
                    this.parent = n,
                    this.bindings = {};
                    for (let[u,f] of a)
                        this.bindings[u] = f
                }
                concat(n) {
                    return new Xo(this,n)
                }
                get(n) {
                    if (this.bindings[n])
                        return this.bindings[n];
                    if (this.parent)
                        return this.parent.get(n);
                    throw new Error(`${n} not found in scope.`)
                }
                has(n) {
                    return !!this.bindings[n] || !!this.parent && this.parent.has(n)
                }
            }
            var hh = Xo;
            let Zo = {
                kind: "null"
            }
              , Xt = {
                kind: "number"
            }
              , ni = {
                kind: "string"
            }
              , $n = {
                kind: "boolean"
            }
              , lo = {
                kind: "color"
            }
              , Aa = {
                kind: "object"
            }
              , Yn = {
                kind: "value"
            }
              , Cc = {
                kind: "collator"
            }
              , pl = {
                kind: "formatted"
            }
              , ml = {
                kind: "resolvedImage"
            };
            function as(s, n) {
                return {
                    kind: "array",
                    itemType: s,
                    N: n
                }
            }
            function Li(s) {
                if (s.kind === "array") {
                    let n = Li(s.itemType);
                    return typeof s.N == "number" ? `array<${n}, ${s.N}>` : s.itemType.kind === "value" ? "array" : `array<${n}>`
                }
                return s.kind
            }
            let cg = [Zo, Xt, ni, $n, lo, pl, Aa, as(Yn), ml];
            function fs(s, n) {
                if (n.kind === "error")
                    return null;
                if (s.kind === "array") {
                    if (n.kind === "array" && (n.N === 0 && n.itemType.kind === "value" || !fs(s.itemType, n.itemType)) && (typeof s.N != "number" || s.N === n.N))
                        return null
                } else {
                    if (s.kind === n.kind)
                        return null;
                    if (s.kind === "value") {
                        for (let a of cg)
                            if (!fs(a, n))
                                return null
                    }
                }
                return `Expected ${Li(s)} but found ${Li(n)} instead.`
            }
            function mf(s, n) {
                return n.some(a=>a.kind === s.kind)
            }
            function Ma(s, n) {
                return n.some(a=>a === "null" ? s === null : a === "array" ? Array.isArray(s) : a === "object" ? s && !Array.isArray(s) && typeof s == "object" : a === typeof s)
            }
            var gf, dh = {
                transparent: [0, 0, 0, 0],
                aliceblue: [240, 248, 255, 1],
                antiquewhite: [250, 235, 215, 1],
                aqua: [0, 255, 255, 1],
                aquamarine: [127, 255, 212, 1],
                azure: [240, 255, 255, 1],
                beige: [245, 245, 220, 1],
                bisque: [255, 228, 196, 1],
                black: [0, 0, 0, 1],
                blanchedalmond: [255, 235, 205, 1],
                blue: [0, 0, 255, 1],
                blueviolet: [138, 43, 226, 1],
                brown: [165, 42, 42, 1],
                burlywood: [222, 184, 135, 1],
                cadetblue: [95, 158, 160, 1],
                chartreuse: [127, 255, 0, 1],
                chocolate: [210, 105, 30, 1],
                coral: [255, 127, 80, 1],
                cornflowerblue: [100, 149, 237, 1],
                cornsilk: [255, 248, 220, 1],
                crimson: [220, 20, 60, 1],
                cyan: [0, 255, 255, 1],
                darkblue: [0, 0, 139, 1],
                darkcyan: [0, 139, 139, 1],
                darkgoldenrod: [184, 134, 11, 1],
                darkgray: [169, 169, 169, 1],
                darkgreen: [0, 100, 0, 1],
                darkgrey: [169, 169, 169, 1],
                darkkhaki: [189, 183, 107, 1],
                darkmagenta: [139, 0, 139, 1],
                darkolivegreen: [85, 107, 47, 1],
                darkorange: [255, 140, 0, 1],
                darkorchid: [153, 50, 204, 1],
                darkred: [139, 0, 0, 1],
                darksalmon: [233, 150, 122, 1],
                darkseagreen: [143, 188, 143, 1],
                darkslateblue: [72, 61, 139, 1],
                darkslategray: [47, 79, 79, 1],
                darkslategrey: [47, 79, 79, 1],
                darkturquoise: [0, 206, 209, 1],
                darkviolet: [148, 0, 211, 1],
                deeppink: [255, 20, 147, 1],
                deepskyblue: [0, 191, 255, 1],
                dimgray: [105, 105, 105, 1],
                dimgrey: [105, 105, 105, 1],
                dodgerblue: [30, 144, 255, 1],
                firebrick: [178, 34, 34, 1],
                floralwhite: [255, 250, 240, 1],
                forestgreen: [34, 139, 34, 1],
                fuchsia: [255, 0, 255, 1],
                gainsboro: [220, 220, 220, 1],
                ghostwhite: [248, 248, 255, 1],
                gold: [255, 215, 0, 1],
                goldenrod: [218, 165, 32, 1],
                gray: [128, 128, 128, 1],
                green: [0, 128, 0, 1],
                greenyellow: [173, 255, 47, 1],
                grey: [128, 128, 128, 1],
                honeydew: [240, 255, 240, 1],
                hotpink: [255, 105, 180, 1],
                indianred: [205, 92, 92, 1],
                indigo: [75, 0, 130, 1],
                ivory: [255, 255, 240, 1],
                khaki: [240, 230, 140, 1],
                lavender: [230, 230, 250, 1],
                lavenderblush: [255, 240, 245, 1],
                lawngreen: [124, 252, 0, 1],
                lemonchiffon: [255, 250, 205, 1],
                lightblue: [173, 216, 230, 1],
                lightcoral: [240, 128, 128, 1],
                lightcyan: [224, 255, 255, 1],
                lightgoldenrodyellow: [250, 250, 210, 1],
                lightgray: [211, 211, 211, 1],
                lightgreen: [144, 238, 144, 1],
                lightgrey: [211, 211, 211, 1],
                lightpink: [255, 182, 193, 1],
                lightsalmon: [255, 160, 122, 1],
                lightseagreen: [32, 178, 170, 1],
                lightskyblue: [135, 206, 250, 1],
                lightslategray: [119, 136, 153, 1],
                lightslategrey: [119, 136, 153, 1],
                lightsteelblue: [176, 196, 222, 1],
                lightyellow: [255, 255, 224, 1],
                lime: [0, 255, 0, 1],
                limegreen: [50, 205, 50, 1],
                linen: [250, 240, 230, 1],
                magenta: [255, 0, 255, 1],
                maroon: [128, 0, 0, 1],
                mediumaquamarine: [102, 205, 170, 1],
                mediumblue: [0, 0, 205, 1],
                mediumorchid: [186, 85, 211, 1],
                mediumpurple: [147, 112, 219, 1],
                mediumseagreen: [60, 179, 113, 1],
                mediumslateblue: [123, 104, 238, 1],
                mediumspringgreen: [0, 250, 154, 1],
                mediumturquoise: [72, 209, 204, 1],
                mediumvioletred: [199, 21, 133, 1],
                midnightblue: [25, 25, 112, 1],
                mintcream: [245, 255, 250, 1],
                mistyrose: [255, 228, 225, 1],
                moccasin: [255, 228, 181, 1],
                navajowhite: [255, 222, 173, 1],
                navy: [0, 0, 128, 1],
                oldlace: [253, 245, 230, 1],
                olive: [128, 128, 0, 1],
                olivedrab: [107, 142, 35, 1],
                orange: [255, 165, 0, 1],
                orangered: [255, 69, 0, 1],
                orchid: [218, 112, 214, 1],
                palegoldenrod: [238, 232, 170, 1],
                palegreen: [152, 251, 152, 1],
                paleturquoise: [175, 238, 238, 1],
                palevioletred: [219, 112, 147, 1],
                papayawhip: [255, 239, 213, 1],
                peachpuff: [255, 218, 185, 1],
                peru: [205, 133, 63, 1],
                pink: [255, 192, 203, 1],
                plum: [221, 160, 221, 1],
                powderblue: [176, 224, 230, 1],
                purple: [128, 0, 128, 1],
                rebeccapurple: [102, 51, 153, 1],
                red: [255, 0, 0, 1],
                rosybrown: [188, 143, 143, 1],
                royalblue: [65, 105, 225, 1],
                saddlebrown: [139, 69, 19, 1],
                salmon: [250, 128, 114, 1],
                sandybrown: [244, 164, 96, 1],
                seagreen: [46, 139, 87, 1],
                seashell: [255, 245, 238, 1],
                sienna: [160, 82, 45, 1],
                silver: [192, 192, 192, 1],
                skyblue: [135, 206, 235, 1],
                slateblue: [106, 90, 205, 1],
                slategray: [112, 128, 144, 1],
                slategrey: [112, 128, 144, 1],
                snow: [255, 250, 250, 1],
                springgreen: [0, 255, 127, 1],
                steelblue: [70, 130, 180, 1],
                tan: [210, 180, 140, 1],
                teal: [0, 128, 128, 1],
                thistle: [216, 191, 216, 1],
                tomato: [255, 99, 71, 1],
                turquoise: [64, 224, 208, 1],
                violet: [238, 130, 238, 1],
                wheat: [245, 222, 179, 1],
                white: [255, 255, 255, 1],
                whitesmoke: [245, 245, 245, 1],
                yellow: [255, 255, 0, 1],
                yellowgreen: [154, 205, 50, 1]
            };
            function Dc(s) {
                return (s = Math.round(s)) < 0 ? 0 : s > 255 ? 255 : s
            }
            function Ia(s) {
                return Dc(s[s.length - 1] === "%" ? parseFloat(s) / 100 * 255 : parseInt(s))
            }
            function gl(s) {
                return (n = s[s.length - 1] === "%" ? parseFloat(s) / 100 : parseFloat(s)) < 0 ? 0 : n > 1 ? 1 : n;
                var n
            }
            function _f(s, n, a) {
                return a < 0 ? a += 1 : a > 1 && (a -= 1),
                6 * a < 1 ? s + (n - s) * a * 6 : 2 * a < 1 ? n : 3 * a < 2 ? s + (n - s) * (2 / 3 - a) * 6 : s
            }
            try {
                gf = {}.parseCSSColor = function(s) {
                    var n, a = s.replace(/ /g, "").toLowerCase();
                    if (a in dh)
                        return dh[a].slice();
                    if (a[0] === "#")
                        return a.length === 4 ? (n = parseInt(a.substr(1), 16)) >= 0 && n <= 4095 ? [(3840 & n) >> 4 | (3840 & n) >> 8, 240 & n | (240 & n) >> 4, 15 & n | (15 & n) << 4, 1] : null : a.length === 7 && (n = parseInt(a.substr(1), 16)) >= 0 && n <= 16777215 ? [(16711680 & n) >> 16, (65280 & n) >> 8, 255 & n, 1] : null;
                    var u = a.indexOf("(")
                      , f = a.indexOf(")");
                    if (u !== -1 && f + 1 === a.length) {
                        var g = a.substr(0, u)
                          , y = a.substr(u + 1, f - (u + 1)).split(",")
                          , w = 1;
                        switch (g) {
                        case "rgba":
                            if (y.length !== 4)
                                return null;
                            w = gl(y.pop());
                        case "rgb":
                            return y.length !== 3 ? null : [Ia(y[0]), Ia(y[1]), Ia(y[2]), w];
                        case "hsla":
                            if (y.length !== 4)
                                return null;
                            w = gl(y.pop());
                        case "hsl":
                            if (y.length !== 3)
                                return null;
                            var S = (parseFloat(y[0]) % 360 + 360) % 360 / 360
                              , M = gl(y[1])
                              , z = gl(y[2])
                              , N = z <= .5 ? z * (M + 1) : z + M - z * M
                              , B = 2 * z - N;
                            return [Dc(255 * _f(B, N, S + 1 / 3)), Dc(255 * _f(B, N, S)), Dc(255 * _f(B, N, S - 1 / 3)), w];
                        default:
                            return null
                        }
                    }
                    return null
                }
            } catch (s) {}
            class ps {
                constructor(n, a, u, f=1) {
                    this.r = n,
                    this.g = a,
                    this.b = u,
                    this.a = f
                }
                static parse(n) {
                    if (!n)
                        return;
                    if (n instanceof ps)
                        return n;
                    if (typeof n != "string")
                        return;
                    let a = gf(n);
                    return a ? new ps(a[0] / 255 * a[3],a[1] / 255 * a[3],a[2] / 255 * a[3],a[3]) : void 0
                }
                toString() {
                    let[n,a,u,f] = this.toArray();
                    return `rgba(${Math.round(n)},${Math.round(a)},${Math.round(u)},${f})`
                }
                toArray() {
                    let {r: n, g: a, b: u, a: f} = this;
                    return f === 0 ? [0, 0, 0, 0] : [255 * n / f, 255 * a / f, 255 * u / f, f]
                }
                toArray01() {
                    let {r: n, g: a, b: u, a: f} = this;
                    return f === 0 ? [0, 0, 0, 0] : [n / f, a / f, u / f, f]
                }
                toArray01PremultipliedAlpha() {
                    let {r: n, g: a, b: u, a: f} = this;
                    return [n, a, u, f]
                }
            }
            ps.black = new ps(0,0,0,1),
            ps.white = new ps(1,1,1,1),
            ps.transparent = new ps(0,0,0,0),
            ps.red = new ps(1,0,0,1),
            ps.blue = new ps(0,0,1,1);
            var nr = ps;
            class fh {
                constructor(n, a, u) {
                    this.sensitivity = n ? a ? "variant" : "case" : a ? "accent" : "base",
                    this.locale = u,
                    this.collator = new Intl.Collator(this.locale ? this.locale : [],{
                        sensitivity: this.sensitivity,
                        usage: "search"
                    })
                }
                compare(n, a) {
                    return this.collator.compare(n, a)
                }
                resolvedLocale() {
                    return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale
                }
            }
            class Lc {
                constructor(n, a, u, f, g) {
                    this.text = n.normalize ? n.normalize() : n,
                    this.image = a,
                    this.scale = u,
                    this.fontStack = f,
                    this.textColor = g
                }
            }
            class ms {
                constructor(n) {
                    this.sections = n
                }
                static fromString(n) {
                    return new ms([new Lc(n,null,null,null,null)])
                }
                isEmpty() {
                    return this.sections.length === 0 || !this.sections.some(n=>n.text.length !== 0 || n.image && n.image.name.length !== 0)
                }
                static factory(n) {
                    return n instanceof ms ? n : ms.fromString(n)
                }
                toString() {
                    return this.sections.length === 0 ? "" : this.sections.map(n=>n.text).join("")
                }
                serialize() {
                    let n = ["format"];
                    for (let a of this.sections) {
                        if (a.image) {
                            n.push(["image", a.image.name]);
                            continue
                        }
                        n.push(a.text);
                        let u = {};
                        a.fontStack && (u["text-font"] = ["literal", a.fontStack.split(",")]),
                        a.scale && (u["font-scale"] = a.scale),
                        a.textColor && (u["text-color"] = ["rgba"].concat(a.textColor.toArray())),
                        n.push(u)
                    }
                    return n
                }
            }
            class ls {
                constructor(n) {
                    this.name = n.name,
                    this.available = n.available
                }
                toString() {
                    return this.name
                }
                static fromString(n) {
                    return n ? new ls({
                        name: n,
                        available: !1
                    }) : null
                }
                serialize() {
                    return ["image", this.name]
                }
            }
            function ug(s, n, a, u) {
                return typeof s == "number" && s >= 0 && s <= 255 && typeof n == "number" && n >= 0 && n <= 255 && typeof a == "number" && a >= 0 && a <= 255 ? u === void 0 || typeof u == "number" && u >= 0 && u <= 1 ? null : `Invalid rgba value [${[s, n, a, u].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof u == "number" ? [s, n, a, u] : [s, n, a]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`
            }
            function ph(s) {
                if (s === null || typeof s == "string" || typeof s == "boolean" || typeof s == "number" || s instanceof nr || s instanceof fh || s instanceof ms || s instanceof ls)
                    return !0;
                if (Array.isArray(s)) {
                    for (let n of s)
                        if (!ph(n))
                            return !1;
                    return !0
                }
                if (typeof s == "object") {
                    for (let n in s)
                        if (!ph(s[n]))
                            return !1;
                    return !0
                }
                return !1
            }
            function gr(s) {
                if (s === null)
                    return Zo;
                if (typeof s == "string")
                    return ni;
                if (typeof s == "boolean")
                    return $n;
                if (typeof s == "number")
                    return Xt;
                if (s instanceof nr)
                    return lo;
                if (s instanceof fh)
                    return Cc;
                if (s instanceof ms)
                    return pl;
                if (s instanceof ls)
                    return ml;
                if (Array.isArray(s)) {
                    let n = s.length, a;
                    for (let u of s) {
                        let f = gr(u);
                        if (a) {
                            if (a === f)
                                continue;
                            a = Yn;
                            break
                        }
                        a = f
                    }
                    return as(a || Yn, n)
                }
                return Aa
            }
            function Rc(s) {
                let n = typeof s;
                return s === null ? "" : n === "string" || n === "number" || n === "boolean" ? String(s) : s instanceof nr || s instanceof ms || s instanceof ls ? s.toString() : JSON.stringify(s)
            }
            class yf {
                constructor(n, a) {
                    this.type = n,
                    this.value = a
                }
                static parse(n, a) {
                    if (n.length !== 2)
                        return a.error(`'literal' expression requires exactly one argument, but found ${n.length - 1} instead.`);
                    if (!ph(n[1]))
                        return a.error("invalid value");
                    let u = n[1]
                      , f = gr(u)
                      , g = a.expectedType;
                    return f.kind !== "array" || f.N !== 0 || !g || g.kind !== "array" || typeof g.N == "number" && g.N !== 0 || (f = g),
                    new yf(f,u)
                }
                evaluate() {
                    return this.value
                }
                eachChild() {}
                outputDefined() {
                    return !0
                }
                serialize() {
                    return this.type.kind === "array" || this.type.kind === "object" ? ["literal", this.value] : this.value instanceof nr ? ["rgba"].concat(this.value.toArray()) : this.value instanceof ms ? this.value.serialize() : this.value
                }
            }
            var Pc = yf
              , Dr = class {
                constructor(s) {
                    this.name = "ExpressionEvaluationError",
                    this.message = s
                }
                toJSON() {
                    return this.message
                }
            }
            ;
            let mh = {
                string: ni,
                number: Xt,
                boolean: $n,
                object: Aa
            };
            class _l {
                constructor(n, a) {
                    this.type = n,
                    this.args = a
                }
                static parse(n, a) {
                    if (n.length < 2)
                        return a.error("Expected at least one argument.");
                    let u, f = 1, g = n[0];
                    if (g === "array") {
                        let w, S;
                        if (n.length > 2) {
                            let M = n[1];
                            if (typeof M != "string" || !(M in mh) || M === "object")
                                return a.error('The item type argument of "array" must be one of string, number, boolean', 1);
                            w = mh[M],
                            f++
                        } else
                            w = Yn;
                        if (n.length > 3) {
                            if (n[2] !== null && (typeof n[2] != "number" || n[2] < 0 || n[2] !== Math.floor(n[2])))
                                return a.error('The length argument to "array" must be a positive integer literal', 2);
                            S = n[2],
                            f++
                        }
                        u = as(w, S)
                    } else
                        u = mh[g];
                    let y = [];
                    for (; f < n.length; f++) {
                        let w = a.parse(n[f], f, Yn);
                        if (!w)
                            return null;
                        y.push(w)
                    }
                    return new _l(u,y)
                }
                evaluate(n) {
                    for (let a = 0; a < this.args.length; a++) {
                        let u = this.args[a].evaluate(n);
                        if (!fs(this.type, gr(u)))
                            return u;
                        if (a === this.args.length - 1)
                            throw new Dr(`Expected value to be of type ${Li(this.type)}, but found ${Li(gr(u))} instead.`)
                    }
                    return null
                }
                eachChild(n) {
                    this.args.forEach(n)
                }
                outputDefined() {
                    return this.args.every(n=>n.outputDefined())
                }
                serialize() {
                    let n = this.type
                      , a = [n.kind];
                    if (n.kind === "array") {
                        let u = n.itemType;
                        if (u.kind === "string" || u.kind === "number" || u.kind === "boolean") {
                            a.push(u.kind);
                            let f = n.N;
                            (typeof f == "number" || this.args.length > 1) && a.push(f)
                        }
                    }
                    return a.concat(this.args.map(u=>u.serialize()))
                }
            }
            var Ao = _l;
            class kc {
                constructor(n) {
                    this.type = pl,
                    this.sections = n
                }
                static parse(n, a) {
                    if (n.length < 2)
                        return a.error("Expected at least one argument.");
                    let u = n[1];
                    if (!Array.isArray(u) && typeof u == "object")
                        return a.error("First argument must be an image or text section.");
                    let f = []
                      , g = !1;
                    for (let y = 1; y <= n.length - 1; ++y) {
                        let w = n[y];
                        if (g && typeof w == "object" && !Array.isArray(w)) {
                            g = !1;
                            let S = null;
                            if (w["font-scale"] && (S = a.parse(w["font-scale"], 1, Xt),
                            !S))
                                return null;
                            let M = null;
                            if (w["text-font"] && (M = a.parse(w["text-font"], 1, as(ni)),
                            !M))
                                return null;
                            let z = null;
                            if (w["text-color"] && (z = a.parse(w["text-color"], 1, lo),
                            !z))
                                return null;
                            let N = f[f.length - 1];
                            N.scale = S,
                            N.font = M,
                            N.textColor = z
                        } else {
                            let S = a.parse(n[y], 1, Yn);
                            if (!S)
                                return null;
                            let M = S.type.kind;
                            if (M !== "string" && M !== "value" && M !== "null" && M !== "resolvedImage")
                                return a.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                            g = !0,
                            f.push({
                                content: S,
                                scale: null,
                                font: null,
                                textColor: null
                            })
                        }
                    }
                    return new kc(f)
                }
                evaluate(n) {
                    return new ms(this.sections.map(a=>{
                        let u = a.content.evaluate(n);
                        return gr(u) === ml ? new Lc("",u,null,null,null) : new Lc(Rc(u),null,a.scale ? a.scale.evaluate(n) : null,a.font ? a.font.evaluate(n).join(",") : null,a.textColor ? a.textColor.evaluate(n) : null)
                    }
                    ))
                }
                eachChild(n) {
                    for (let a of this.sections)
                        n(a.content),
                        a.scale && n(a.scale),
                        a.font && n(a.font),
                        a.textColor && n(a.textColor)
                }
                outputDefined() {
                    return !1
                }
                serialize() {
                    let n = ["format"];
                    for (let a of this.sections) {
                        n.push(a.content.serialize());
                        let u = {};
                        a.scale && (u["font-scale"] = a.scale.serialize()),
                        a.font && (u["text-font"] = a.font.serialize()),
                        a.textColor && (u["text-color"] = a.textColor.serialize()),
                        n.push(u)
                    }
                    return n
                }
            }
            class gh {
                constructor(n) {
                    this.type = ml,
                    this.input = n
                }
                static parse(n, a) {
                    if (n.length !== 2)
                        return a.error("Expected two arguments.");
                    let u = a.parse(n[1], 1, ni);
                    return u ? new gh(u) : a.error("No image name provided.")
                }
                evaluate(n) {
                    let a = this.input.evaluate(n)
                      , u = ls.fromString(a);
                    return u && n.availableImages && (u.available = n.availableImages.indexOf(a) > -1),
                    u
                }
                eachChild(n) {
                    n(this.input)
                }
                outputDefined() {
                    return !1
                }
                serialize() {
                    return ["image", this.input.serialize()]
                }
            }
            let $0 = {
                "to-boolean": $n,
                "to-color": lo,
                "to-number": Xt,
                "to-string": ni
            };
            class xf {
                constructor(n, a) {
                    this.type = n,
                    this.args = a
                }
                static parse(n, a) {
                    if (n.length < 2)
                        return a.error("Expected at least one argument.");
                    let u = n[0];
                    if ((u === "to-boolean" || u === "to-string") && n.length !== 2)
                        return a.error("Expected one argument.");
                    let f = $0[u]
                      , g = [];
                    for (let y = 1; y < n.length; y++) {
                        let w = a.parse(n[y], y, Yn);
                        if (!w)
                            return null;
                        g.push(w)
                    }
                    return new xf(f,g)
                }
                evaluate(n) {
                    if (this.type.kind === "boolean")
                        return Boolean(this.args[0].evaluate(n));
                    if (this.type.kind === "color") {
                        let a, u;
                        for (let f of this.args) {
                            if (a = f.evaluate(n),
                            u = null,
                            a instanceof nr)
                                return a;
                            if (typeof a == "string") {
                                let g = n.parseColor(a);
                                if (g)
                                    return g
                            } else if (Array.isArray(a) && (u = a.length < 3 || a.length > 4 ? `Invalid rbga value ${JSON.stringify(a)}: expected an array containing either three or four numeric values.` : ug(a[0], a[1], a[2], a[3]),
                            !u))
                                return new nr(a[0] / 255,a[1] / 255,a[2] / 255,a[3])
                        }
                        throw new Dr(u || `Could not parse color from value '${typeof a == "string" ? a : String(JSON.stringify(a))}'`)
                    }
                    if (this.type.kind === "number") {
                        let a = null;
                        for (let u of this.args) {
                            if (a = u.evaluate(n),
                            a === null)
                                return 0;
                            let f = Number(a);
                            if (!isNaN(f))
                                return f
                        }
                        throw new Dr(`Could not convert ${JSON.stringify(a)} to number.`)
                    }
                    return this.type.kind === "formatted" ? ms.fromString(Rc(this.args[0].evaluate(n))) : this.type.kind === "resolvedImage" ? ls.fromString(Rc(this.args[0].evaluate(n))) : Rc(this.args[0].evaluate(n))
                }
                eachChild(n) {
                    this.args.forEach(n)
                }
                outputDefined() {
                    return this.args.every(n=>n.outputDefined())
                }
                serialize() {
                    if (this.type.kind === "formatted")
                        return new kc([{
                            content: this.args[0],
                            scale: null,
                            font: null,
                            textColor: null
                        }]).serialize();
                    if (this.type.kind === "resolvedImage")
                        return new gh(this.args[0]).serialize();
                    let n = [`to-${this.type.kind}`];
                    return this.eachChild(a=>{
                        n.push(a.serialize())
                    }
                    ),
                    n
                }
            }
            var yl = xf;
            let hg = ["Unknown", "Point", "LineString", "Polygon"];
            var zc = class {
                constructor() {
                    this.globals = null,
                    this.feature = null,
                    this.featureState = null,
                    this.formattedSection = null,
                    this._parseColorCache = {},
                    this.availableImages = null,
                    this.canonical = null,
                    this.featureTileCoord = null,
                    this.featureDistanceData = null
                }
                id() {
                    return this.feature && this.feature.id !== void 0 ? this.feature.id : null
                }
                geometryType() {
                    return this.feature ? typeof this.feature.type == "number" ? hg[this.feature.type] : this.feature.type : null
                }
                geometry() {
                    return this.feature && "geometry"in this.feature ? this.feature.geometry : null
                }
                canonicalID() {
                    return this.canonical
                }
                properties() {
                    return this.feature && this.feature.properties || {}
                }
                distanceFromCenter() {
                    if (this.featureTileCoord && this.featureDistanceData) {
                        let s = this.featureDistanceData.center
                          , n = this.featureDistanceData.scale
                          , {x: a, y: u} = this.featureTileCoord;
                        return this.featureDistanceData.bearing[0] * (a * n - s[0]) + this.featureDistanceData.bearing[1] * (u * n - s[1])
                    }
                    return 0
                }
                parseColor(s) {
                    let n = this._parseColorCache[s];
                    return n || (n = this._parseColorCache[s] = nr.parse(s)),
                    n
                }
            }
            ;
            class xl {
                constructor(n, a, u, f) {
                    this.name = n,
                    this.type = a,
                    this._evaluate = u,
                    this.args = f
                }
                evaluate(n) {
                    return this._evaluate(n, this.args)
                }
                eachChild(n) {
                    this.args.forEach(n)
                }
                outputDefined() {
                    return !1
                }
                serialize() {
                    return [this.name].concat(this.args.map(n=>n.serialize()))
                }
                static parse(n, a) {
                    let u = n[0]
                      , f = xl.definitions[u];
                    if (!f)
                        return a.error(`Unknown expression "${u}". If you wanted a literal array, use ["literal", [...]].`, 0);
                    let g = Array.isArray(f) ? f[0] : f.type
                      , y = Array.isArray(f) ? [[f[1], f[2]]] : f.overloads
                      , w = y.filter(([M])=>!Array.isArray(M) || M.length === n.length - 1)
                      , S = null;
                    for (let[M,z] of w) {
                        S = new Sf(a.registry,a.path,null,a.scope);
                        let N = []
                          , B = !1;
                        for (let H = 1; H < n.length; H++) {
                            let q = n[H]
                              , Q = Array.isArray(M) ? M[H - 1] : M.type
                              , de = S.parse(q, 1 + N.length, Q);
                            if (!de) {
                                B = !0;
                                break
                            }
                            N.push(de)
                        }
                        if (!B)
                            if (Array.isArray(M) && M.length !== N.length)
                                S.error(`Expected ${M.length} arguments, but found ${N.length} instead.`);
                            else {
                                for (let H = 0; H < N.length; H++) {
                                    let q = Array.isArray(M) ? M[H] : M.type
                                      , Q = N[H];
                                    S.concat(H + 1).checkSubtype(q, Q.type)
                                }
                                if (S.errors.length === 0)
                                    return new xl(u,g,z,N)
                            }
                    }
                    if (w.length === 1)
                        a.errors.push(...S.errors);
                    else {
                        let M = (w.length ? w : y).map(([N])=>{
                            return B = N,
                            Array.isArray(B) ? `(${B.map(Li).join(", ")})` : `(${Li(B.type)}...)`;
                            var B
                        }
                        ).join(" | ")
                          , z = [];
                        for (let N = 1; N < n.length; N++) {
                            let B = a.parse(n[N], 1 + z.length);
                            if (!B)
                                return null;
                            z.push(Li(B.type))
                        }
                        a.error(`Expected arguments of type ${M}, but found (${z.join(", ")}) instead.`)
                    }
                    return null
                }
                static register(n, a) {
                    xl.definitions = a;
                    for (let u in a)
                        n[u] = xl
                }
            }
            var qo = xl;
            class _h {
                constructor(n, a, u) {
                    this.type = Cc,
                    this.locale = u,
                    this.caseSensitive = n,
                    this.diacriticSensitive = a
                }
                static parse(n, a) {
                    if (n.length !== 2)
                        return a.error("Expected one argument.");
                    let u = n[1];
                    if (typeof u != "object" || Array.isArray(u))
                        return a.error("Collator options argument must be an object.");
                    let f = a.parse(u["case-sensitive"] !== void 0 && u["case-sensitive"], 1, $n);
                    if (!f)
                        return null;
                    let g = a.parse(u["diacritic-sensitive"] !== void 0 && u["diacritic-sensitive"], 1, $n);
                    if (!g)
                        return null;
                    let y = null;
                    return u.locale && (y = a.parse(u.locale, 1, ni),
                    !y) ? null : new _h(f,g,y)
                }
                evaluate(n) {
                    return new fh(this.caseSensitive.evaluate(n),this.diacriticSensitive.evaluate(n),this.locale ? this.locale.evaluate(n) : null)
                }
                eachChild(n) {
                    n(this.caseSensitive),
                    n(this.diacriticSensitive),
                    this.locale && n(this.locale)
                }
                outputDefined() {
                    return !1
                }
                serialize() {
                    let n = {};
                    return n["case-sensitive"] = this.caseSensitive.serialize(),
                    n["diacritic-sensitive"] = this.diacriticSensitive.serialize(),
                    this.locale && (n.locale = this.locale.serialize()),
                    ["collator", n]
                }
            }
            let Ko = 8192;
            function ks(s, n) {
                s[0] = Math.min(s[0], n[0]),
                s[1] = Math.min(s[1], n[1]),
                s[2] = Math.max(s[2], n[0]),
                s[3] = Math.max(s[3], n[1])
            }
            function Oc(s, n) {
                return !(s[0] <= n[0] || s[2] >= n[2] || s[1] <= n[1] || s[3] >= n[3])
            }
            function dg(s, n) {
                let a = (180 + s[0]) / 360
                  , u = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + s[1] * Math.PI / 360))) / 360
                  , f = Math.pow(2, n.z);
                return [Math.round(a * f * Ko), Math.round(u * f * Ko)]
            }
            function fg(s, n, a) {
                let u = s[0] - n[0]
                  , f = s[1] - n[1]
                  , g = s[0] - a[0]
                  , y = s[1] - a[1];
                return u * y - g * f == 0 && u * g <= 0 && f * y <= 0
            }
            function yh(s, n) {
                let a = !1;
                for (let y = 0, w = n.length; y < w; y++) {
                    let S = n[y];
                    for (let M = 0, z = S.length; M < z - 1; M++) {
                        if (fg(s, S[M], S[M + 1]))
                            return !1;
                        (f = S[M])[1] > (u = s)[1] != (g = S[M + 1])[1] > u[1] && u[0] < (g[0] - f[0]) * (u[1] - f[1]) / (g[1] - f[1]) + f[0] && (a = !a)
                    }
                }
                var u, f, g;
                return a
            }
            function pg(s, n) {
                for (let a = 0; a < n.length; a++)
                    if (yh(s, n[a]))
                        return !0;
                return !1
            }
            function vf(s, n, a, u) {
                let f = u[0] - a[0]
                  , g = u[1] - a[1]
                  , y = (s[0] - a[0]) * g - f * (s[1] - a[1])
                  , w = (n[0] - a[0]) * g - f * (n[1] - a[1]);
                return y > 0 && w < 0 || y < 0 && w > 0
            }
            function bf(s, n, a) {
                for (let M of a)
                    for (let z = 0; z < M.length - 1; ++z)
                        if ((w = [(y = M[z + 1])[0] - (g = M[z])[0], y[1] - g[1]])[0] * (S = [(f = n)[0] - (u = s)[0], f[1] - u[1]])[1] - w[1] * S[0] != 0 && vf(u, f, g, y) && vf(g, y, u, f))
                            return !0;
                var u, f, g, y, w, S;
                return !1
            }
            function vl(s, n) {
                for (let a = 0; a < s.length; ++a)
                    if (!yh(s[a], n))
                        return !1;
                for (let a = 0; a < s.length - 1; ++a)
                    if (bf(s[a], s[a + 1], n))
                        return !1;
                return !0
            }
            function mg(s, n) {
                for (let a = 0; a < n.length; a++)
                    if (vl(s, n[a]))
                        return !0;
                return !1
            }
            function xh(s, n, a) {
                let u = [];
                for (let f = 0; f < s.length; f++) {
                    let g = [];
                    for (let y = 0; y < s[f].length; y++) {
                        let w = dg(s[f][y], a);
                        ks(n, w),
                        g.push(w)
                    }
                    u.push(g)
                }
                return u
            }
            function vh(s, n, a) {
                let u = [];
                for (let f = 0; f < s.length; f++) {
                    let g = xh(s[f], n, a);
                    u.push(g)
                }
                return u
            }
            function wf(s, n, a, u) {
                if (s[0] < a[0] || s[0] > a[2]) {
                    let f = .5 * u
                      , g = s[0] - a[0] > f ? -u : a[0] - s[0] > f ? u : 0;
                    g === 0 && (g = s[0] - a[2] > f ? -u : a[2] - s[0] > f ? u : 0),
                    s[0] += g
                }
                ks(n, s)
            }
            function Ca(s, n, a, u) {
                let f = Math.pow(2, u.z) * Ko
                  , g = [u.x * Ko, u.y * Ko]
                  , y = [];
                if (!s)
                    return y;
                for (let w of s)
                    for (let S of w) {
                        let M = [S.x + g[0], S.y + g[1]];
                        wf(M, n, a, f),
                        y.push(M)
                    }
                return y
            }
            function fi(s, n, a, u) {
                let f = Math.pow(2, u.z) * Ko
                  , g = [u.x * Ko, u.y * Ko]
                  , y = [];
                if (!s)
                    return y;
                for (let S of s) {
                    let M = [];
                    for (let z of S) {
                        let N = [z.x + g[0], z.y + g[1]];
                        ks(n, N),
                        M.push(N)
                    }
                    y.push(M)
                }
                if (n[2] - n[0] <= f / 2) {
                    (w = n)[0] = w[1] = 1 / 0,
                    w[2] = w[3] = -1 / 0;
                    for (let S of y)
                        for (let M of S)
                            wf(M, n, a, f)
                }
                var w;
                return y
            }
            class Nc {
                constructor(n, a) {
                    this.type = $n,
                    this.geojson = n,
                    this.geometries = a
                }
                static parse(n, a) {
                    if (n.length !== 2)
                        return a.error(`'within' expression requires exactly one argument, but found ${n.length - 1} instead.`);
                    if (ph(n[1])) {
                        let u = n[1];
                        if (u.type === "FeatureCollection")
                            for (let f = 0; f < u.features.length; ++f) {
                                let g = u.features[f].geometry.type;
                                if (g === "Polygon" || g === "MultiPolygon")
                                    return new Nc(u,u.features[f].geometry)
                            }
                        else if (u.type === "Feature") {
                            let f = u.geometry.type;
                            if (f === "Polygon" || f === "MultiPolygon")
                                return new Nc(u,u.geometry)
                        } else if (u.type === "Polygon" || u.type === "MultiPolygon")
                            return new Nc(u,u)
                    }
                    return a.error("'within' expression requires valid geojson object that contains polygon geometry type.")
                }
                evaluate(n) {
                    if (n.geometry() != null && n.canonicalID() != null) {
                        if (n.geometryType() === "Point")
                            return function(a, u) {
                                let f = [1 / 0, 1 / 0, -1 / 0, -1 / 0]
                                  , g = [1 / 0, 1 / 0, -1 / 0, -1 / 0]
                                  , y = a.canonicalID();
                                if (!y)
                                    return !1;
                                if (u.type === "Polygon") {
                                    let w = xh(u.coordinates, g, y)
                                      , S = Ca(a.geometry(), f, g, y);
                                    if (!Oc(f, g))
                                        return !1;
                                    for (let M of S)
                                        if (!yh(M, w))
                                            return !1
                                }
                                if (u.type === "MultiPolygon") {
                                    let w = vh(u.coordinates, g, y)
                                      , S = Ca(a.geometry(), f, g, y);
                                    if (!Oc(f, g))
                                        return !1;
                                    for (let M of S)
                                        if (!pg(M, w))
                                            return !1
                                }
                                return !0
                            }(n, this.geometries);
                        if (n.geometryType() === "LineString")
                            return function(a, u) {
                                let f = [1 / 0, 1 / 0, -1 / 0, -1 / 0]
                                  , g = [1 / 0, 1 / 0, -1 / 0, -1 / 0]
                                  , y = a.canonicalID();
                                if (!y)
                                    return !1;
                                if (u.type === "Polygon") {
                                    let w = xh(u.coordinates, g, y)
                                      , S = fi(a.geometry(), f, g, y);
                                    if (!Oc(f, g))
                                        return !1;
                                    for (let M of S)
                                        if (!vl(M, w))
                                            return !1
                                }
                                if (u.type === "MultiPolygon") {
                                    let w = vh(u.coordinates, g, y)
                                      , S = fi(a.geometry(), f, g, y);
                                    if (!Oc(f, g))
                                        return !1;
                                    for (let M of S)
                                        if (!mg(M, w))
                                            return !1
                                }
                                return !0
                            }(n, this.geometries)
                    }
                    return !1
                }
                eachChild() {}
                outputDefined() {
                    return !0
                }
                serialize() {
                    return ["within", this.geojson]
                }
            }
            var Tf = Nc;
            function Fc(s) {
                if (s instanceof qo && (s.name === "get" && s.args.length === 1 || s.name === "feature-state" || s.name === "has" && s.args.length === 1 || s.name === "properties" || s.name === "geometry-type" || s.name === "id" || /^filter-/.test(s.name)) || s instanceof Tf)
                    return !1;
                let n = !0;
                return s.eachChild(a=>{
                    n && !Fc(a) && (n = !1)
                }
                ),
                n
            }
            function Bc(s) {
                if (s instanceof qo && s.name === "feature-state")
                    return !1;
                let n = !0;
                return s.eachChild(a=>{
                    n && !Bc(a) && (n = !1)
                }
                ),
                n
            }
            function bh(s, n) {
                if (s instanceof qo && n.indexOf(s.name) >= 0)
                    return !1;
                let a = !0;
                return s.eachChild(u=>{
                    a && !bh(u, n) && (a = !1)
                }
                ),
                a
            }
            class wh {
                constructor(n, a) {
                    this.type = a.type,
                    this.name = n,
                    this.boundExpression = a
                }
                static parse(n, a) {
                    if (n.length !== 2 || typeof n[1] != "string")
                        return a.error("'var' expression requires exactly one string literal argument.");
                    let u = n[1];
                    return a.scope.has(u) ? new wh(u,a.scope.get(u)) : a.error(`Unknown variable "${u}". Make sure "${u}" has been bound in an enclosing "let" expression before using it.`, 1)
                }
                evaluate(n) {
                    return this.boundExpression.evaluate(n)
                }
                eachChild() {}
                outputDefined() {
                    return !1
                }
                serialize() {
                    return ["var", this.name]
                }
            }
            var Ef = wh;
            class Th {
                constructor(n, a=[], u, f=new hh, g=[]) {
                    this.registry = n,
                    this.path = a,
                    this.key = a.map(y=>`[${y}]`).join(""),
                    this.scope = f,
                    this.errors = g,
                    this.expectedType = u
                }
                parse(n, a, u, f, g={}) {
                    return a ? this.concat(a, u, f)._parse(n, g) : this._parse(n, g)
                }
                _parse(n, a) {
                    function u(f, g, y) {
                        return y === "assert" ? new Ao(g,[f]) : y === "coerce" ? new yl(g,[f]) : f
                    }
                    if (n !== null && typeof n != "string" && typeof n != "boolean" && typeof n != "number" || (n = ["literal", n]),
                    Array.isArray(n)) {
                        if (n.length === 0)
                            return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
                        let f = n[0];
                        if (typeof f != "string")
                            return this.error(`Expression name must be a string, but found ${typeof f} instead. If you wanted a literal array, use ["literal", [...]].`, 0),
                            null;
                        let g = this.registry[f];
                        if (g) {
                            let y = g.parse(n, this);
                            if (!y)
                                return null;
                            if (this.expectedType) {
                                let w = this.expectedType
                                  , S = y.type;
                                if (w.kind !== "string" && w.kind !== "number" && w.kind !== "boolean" && w.kind !== "object" && w.kind !== "array" || S.kind !== "value")
                                    if (w.kind !== "color" && w.kind !== "formatted" && w.kind !== "resolvedImage" || S.kind !== "value" && S.kind !== "string") {
                                        if (this.checkSubtype(w, S))
                                            return null
                                    } else
                                        y = u(y, w, a.typeAnnotation || "coerce");
                                else
                                    y = u(y, w, a.typeAnnotation || "assert")
                            }
                            if (!(y instanceof Pc) && y.type.kind !== "resolvedImage" && Yo(y)) {
                                let w = new zc;
                                try {
                                    y = new Pc(y.type,y.evaluate(w))
                                } catch (S) {
                                    return this.error(S.message),
                                    null
                                }
                            }
                            return y
                        }
                        return this.error(`Unknown expression "${f}". If you wanted a literal array, use ["literal", [...]].`, 0)
                    }
                    return this.error(n === void 0 ? "'undefined' value invalid. Use null instead." : typeof n == "object" ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof n} instead.`)
                }
                concat(n, a, u) {
                    let f = typeof n == "number" ? this.path.concat(n) : this.path
                      , g = u ? this.scope.concat(u) : this.scope;
                    return new Th(this.registry,f,a || null,g,this.errors)
                }
                error(n, ...a) {
                    let u = `${this.key}${a.map(f=>`[${f}]`).join("")}`;
                    this.errors.push(new Zi(u,n))
                }
                checkSubtype(n, a) {
                    let u = fs(n, a);
                    return u && this.error(u),
                    u
                }
            }
            var Sf = Th;
            function Yo(s) {
                if (s instanceof Ef)
                    return Yo(s.boundExpression);
                if (s instanceof qo && s.name === "error" || s instanceof _h || s instanceof Tf)
                    return !1;
                let n = s instanceof yl || s instanceof Ao
                  , a = !0;
                return s.eachChild(u=>{
                    a = n ? a && Yo(u) : a && u instanceof Pc
                }
                ),
                !!a && Fc(s) && bh(s, ["zoom", "heatmap-density", "line-progress", "sky-radial-progress", "accumulated", "is-supported-script", "pitch", "distance-from-center"])
            }
            function Da(s, n) {
                let a = s.length - 1, u, f, g = 0, y = a, w = 0;
                for (; g <= y; )
                    if (w = Math.floor((g + y) / 2),
                    u = s[w],
                    f = s[w + 1],
                    u <= n) {
                        if (w === a || n < f)
                            return w;
                        g = w + 1
                    } else {
                        if (!(u > n))
                            throw new Dr("Input is not a number.");
                        y = w - 1
                    }
                return 0
            }
            class Eh {
                constructor(n, a, u) {
                    this.type = n,
                    this.input = a,
                    this.labels = [],
                    this.outputs = [];
                    for (let[f,g] of u)
                        this.labels.push(f),
                        this.outputs.push(g)
                }
                static parse(n, a) {
                    if (n.length - 1 < 4)
                        return a.error(`Expected at least 4 arguments, but found only ${n.length - 1}.`);
                    if ((n.length - 1) % 2 != 0)
                        return a.error("Expected an even number of arguments.");
                    let u = a.parse(n[1], 1, Xt);
                    if (!u)
                        return null;
                    let f = []
                      , g = null;
                    a.expectedType && a.expectedType.kind !== "value" && (g = a.expectedType);
                    for (let y = 1; y < n.length; y += 2) {
                        let w = y === 1 ? -1 / 0 : n[y]
                          , S = n[y + 1]
                          , M = y
                          , z = y + 1;
                        if (typeof w != "number")
                            return a.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', M);
                        if (f.length && f[f.length - 1][0] >= w)
                            return a.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', M);
                        let N = a.parse(S, z, g);
                        if (!N)
                            return null;
                        g = g || N.type,
                        f.push([w, N])
                    }
                    return new Eh(g,u,f)
                }
                evaluate(n) {
                    let a = this.labels
                      , u = this.outputs;
                    if (a.length === 1)
                        return u[0].evaluate(n);
                    let f = this.input.evaluate(n);
                    if (f <= a[0])
                        return u[0].evaluate(n);
                    let g = a.length;
                    return f >= a[g - 1] ? u[g - 1].evaluate(n) : u[Da(a, f)].evaluate(n)
                }
                eachChild(n) {
                    n(this.input);
                    for (let a of this.outputs)
                        n(a)
                }
                outputDefined() {
                    return this.outputs.every(n=>n.outputDefined())
                }
                serialize() {
                    let n = ["step", this.input.serialize()];
                    for (let a = 0; a < this.labels.length; a++)
                        a > 0 && n.push(this.labels[a]),
                        n.push(this.outputs[a].serialize());
                    return n
                }
            }
            var Af = Eh;
            function si(s, n, a) {
                return s * (1 - a) + n * a
            }
            var Uc = Object.freeze({
                __proto__: null,
                number: si,
                color: function(s, n, a) {
                    return new nr(si(s.r, n.r, a),si(s.g, n.g, a),si(s.b, n.b, a),si(s.a, n.a, a))
                },
                array: function(s, n, a) {
                    return s.map((u,f)=>si(u, n[f], a))
                }
            });
            let gg = .95047
              , _g = 1.08883
              , Mf = 4 / 29
              , If = 6 / 29
              , Cf = 3 * If * If
              , yg = Math.PI / 180
              , Q0 = 180 / Math.PI;
            function Sh(s) {
                return s > .008856451679035631 ? Math.pow(s, 1 / 3) : s / Cf + Mf
            }
            function Df(s) {
                return s > If ? s * s * s : Cf * (s - Mf)
            }
            function Ah(s) {
                return 255 * (s <= .0031308 ? 12.92 * s : 1.055 * Math.pow(s, 1 / 2.4) - .055)
            }
            function Mh(s) {
                return (s /= 255) <= .04045 ? s / 12.92 : Math.pow((s + .055) / 1.055, 2.4)
            }
            function xg(s) {
                let n = Mh(s.r)
                  , a = Mh(s.g)
                  , u = Mh(s.b)
                  , f = Sh((.4124564 * n + .3575761 * a + .1804375 * u) / gg)
                  , g = Sh((.2126729 * n + .7151522 * a + .072175 * u) / 1);
                return {
                    l: 116 * g - 16,
                    a: 500 * (f - g),
                    b: 200 * (g - Sh((.0193339 * n + .119192 * a + .9503041 * u) / _g)),
                    alpha: s.a
                }
            }
            function vg(s) {
                let n = (s.l + 16) / 116
                  , a = isNaN(s.a) ? n : n + s.a / 500
                  , u = isNaN(s.b) ? n : n - s.b / 200;
                return n = 1 * Df(n),
                a = gg * Df(a),
                u = _g * Df(u),
                new nr(Ah(3.2404542 * a - 1.5371385 * n - .4985314 * u),Ah(-.969266 * a + 1.8760108 * n + .041556 * u),Ah(.0556434 * a - .2040259 * n + 1.0572252 * u),s.alpha)
            }
            function ex(s, n, a) {
                let u = n - s;
                return s + a * (u > 180 || u < -180 ? u - 360 * Math.round(u / 360) : u)
            }
            let Vc = {
                forward: xg,
                reverse: vg,
                interpolate: function(s, n, a) {
                    return {
                        l: si(s.l, n.l, a),
                        a: si(s.a, n.a, a),
                        b: si(s.b, n.b, a),
                        alpha: si(s.alpha, n.alpha, a)
                    }
                }
            }
              , Gc = {
                forward: function(s) {
                    let {l: n, a, b: u} = xg(s)
                      , f = Math.atan2(u, a) * Q0;
                    return {
                        h: f < 0 ? f + 360 : f,
                        c: Math.sqrt(a * a + u * u),
                        l: n,
                        alpha: s.a
                    }
                },
                reverse: function(s) {
                    let n = s.h * yg
                      , a = s.c;
                    return vg({
                        l: s.l,
                        a: Math.cos(n) * a,
                        b: Math.sin(n) * a,
                        alpha: s.alpha
                    })
                },
                interpolate: function(s, n, a) {
                    return {
                        h: ex(s.h, n.h, a),
                        c: si(s.c, n.c, a),
                        l: si(s.l, n.l, a),
                        alpha: si(s.alpha, n.alpha, a)
                    }
                }
            };
            var bg = Object.freeze({
                __proto__: null,
                lab: Vc,
                hcl: Gc
            });
            class Hc {
                constructor(n, a, u, f, g) {
                    this.type = n,
                    this.operator = a,
                    this.interpolation = u,
                    this.input = f,
                    this.labels = [],
                    this.outputs = [];
                    for (let[y,w] of g)
                        this.labels.push(y),
                        this.outputs.push(w)
                }
                static interpolationFactor(n, a, u, f) {
                    let g = 0;
                    if (n.name === "exponential")
                        g = Lf(a, n.base, u, f);
                    else if (n.name === "linear")
                        g = Lf(a, 1, u, f);
                    else if (n.name === "cubic-bezier") {
                        let y = n.controlPoints;
                        g = new K(y[0],y[1],y[2],y[3]).solve(Lf(a, 1, u, f))
                    }
                    return g
                }
                static parse(n, a) {
                    let[u,f,g,...y] = n;
                    if (!Array.isArray(f) || f.length === 0)
                        return a.error("Expected an interpolation type expression.", 1);
                    if (f[0] === "linear")
                        f = {
                            name: "linear"
                        };
                    else if (f[0] === "exponential") {
                        let M = f[1];
                        if (typeof M != "number")
                            return a.error("Exponential interpolation requires a numeric base.", 1, 1);
                        f = {
                            name: "exponential",
                            base: M
                        }
                    } else {
                        if (f[0] !== "cubic-bezier")
                            return a.error(`Unknown interpolation type ${String(f[0])}`, 1, 0);
                        {
                            let M = f.slice(1);
                            if (M.length !== 4 || M.some(z=>typeof z != "number" || z < 0 || z > 1))
                                return a.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
                            f = {
                                name: "cubic-bezier",
                                controlPoints: M
                            }
                        }
                    }
                    if (n.length - 1 < 4)
                        return a.error(`Expected at least 4 arguments, but found only ${n.length - 1}.`);
                    if ((n.length - 1) % 2 != 0)
                        return a.error("Expected an even number of arguments.");
                    if (g = a.parse(g, 2, Xt),
                    !g)
                        return null;
                    let w = []
                      , S = null;
                    u === "interpolate-hcl" || u === "interpolate-lab" ? S = lo : a.expectedType && a.expectedType.kind !== "value" && (S = a.expectedType);
                    for (let M = 0; M < y.length; M += 2) {
                        let z = y[M]
                          , N = y[M + 1]
                          , B = M + 3
                          , H = M + 4;
                        if (typeof z != "number")
                            return a.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', B);
                        if (w.length && w[w.length - 1][0] >= z)
                            return a.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', B);
                        let q = a.parse(N, H, S);
                        if (!q)
                            return null;
                        S = S || q.type,
                        w.push([z, q])
                    }
                    return S.kind === "number" || S.kind === "color" || S.kind === "array" && S.itemType.kind === "number" && typeof S.N == "number" ? new Hc(S,u,f,g,w) : a.error(`Type ${Li(S)} is not interpolatable.`)
                }
                evaluate(n) {
                    let a = this.labels
                      , u = this.outputs;
                    if (a.length === 1)
                        return u[0].evaluate(n);
                    let f = this.input.evaluate(n);
                    if (f <= a[0])
                        return u[0].evaluate(n);
                    let g = a.length;
                    if (f >= a[g - 1])
                        return u[g - 1].evaluate(n);
                    let y = Da(a, f)
                      , w = Hc.interpolationFactor(this.interpolation, f, a[y], a[y + 1])
                      , S = u[y].evaluate(n)
                      , M = u[y + 1].evaluate(n);
                    return this.operator === "interpolate" ? Uc[this.type.kind.toLowerCase()](S, M, w) : this.operator === "interpolate-hcl" ? Gc.reverse(Gc.interpolate(Gc.forward(S), Gc.forward(M), w)) : Vc.reverse(Vc.interpolate(Vc.forward(S), Vc.forward(M), w))
                }
                eachChild(n) {
                    n(this.input);
                    for (let a of this.outputs)
                        n(a)
                }
                outputDefined() {
                    return this.outputs.every(n=>n.outputDefined())
                }
                serialize() {
                    let n;
                    n = this.interpolation.name === "linear" ? ["linear"] : this.interpolation.name === "exponential" ? this.interpolation.base === 1 ? ["linear"] : ["exponential", this.interpolation.base] : ["cubic-bezier"].concat(this.interpolation.controlPoints);
                    let a = [this.operator, n, this.input.serialize()];
                    for (let u = 0; u < this.labels.length; u++)
                        a.push(this.labels[u], this.outputs[u].serialize());
                    return a
                }
            }
            function Lf(s, n, a, u) {
                let f = u - a
                  , g = s - a;
                return f === 0 ? 0 : n === 1 ? g / f : (Math.pow(n, g) - 1) / (Math.pow(n, f) - 1)
            }
            var co = Hc;
            class Rf {
                constructor(n, a) {
                    this.type = n,
                    this.args = a
                }
                static parse(n, a) {
                    if (n.length < 2)
                        return a.error("Expectected at least one argument.");
                    let u = null
                      , f = a.expectedType;
                    f && f.kind !== "value" && (u = f);
                    let g = [];
                    for (let w of n.slice(1)) {
                        let S = a.parse(w, 1 + g.length, u, void 0, {
                            typeAnnotation: "omit"
                        });
                        if (!S)
                            return null;
                        u = u || S.type,
                        g.push(S)
                    }
                    let y = f && g.some(w=>fs(f, w.type));
                    return new Rf(y ? Yn : u,g)
                }
                evaluate(n) {
                    let a, u = null, f = 0;
                    for (let g of this.args) {
                        if (f++,
                        u = g.evaluate(n),
                        u && u instanceof ls && !u.available && (a || (a = u),
                        u = null,
                        f === this.args.length))
                            return a;
                        if (u !== null)
                            break
                    }
                    return u
                }
                eachChild(n) {
                    this.args.forEach(n)
                }
                outputDefined() {
                    return this.args.every(n=>n.outputDefined())
                }
                serialize() {
                    let n = ["coalesce"];
                    return this.eachChild(a=>{
                        n.push(a.serialize())
                    }
                    ),
                    n
                }
            }
            var wg = Rf;
            class Ih {
                constructor(n, a) {
                    this.type = a.type,
                    this.bindings = [].concat(n),
                    this.result = a
                }
                evaluate(n) {
                    return this.result.evaluate(n)
                }
                eachChild(n) {
                    for (let a of this.bindings)
                        n(a[1]);
                    n(this.result)
                }
                static parse(n, a) {
                    if (n.length < 4)
                        return a.error(`Expected at least 3 arguments, but found ${n.length - 1} instead.`);
                    let u = [];
                    for (let g = 1; g < n.length - 1; g += 2) {
                        let y = n[g];
                        if (typeof y != "string")
                            return a.error(`Expected string, but found ${typeof y} instead.`, g);
                        if (/[^a-zA-Z0-9_]/.test(y))
                            return a.error("Variable names must contain only alphanumeric characters or '_'.", g);
                        let w = a.parse(n[g + 1], g + 1);
                        if (!w)
                            return null;
                        u.push([y, w])
                    }
                    let f = a.parse(n[n.length - 1], n.length - 1, a.expectedType, u);
                    return f ? new Ih(u,f) : null
                }
                outputDefined() {
                    return this.result.outputDefined()
                }
                serialize() {
                    let n = ["let"];
                    for (let[a,u] of this.bindings)
                        n.push(a, u.serialize());
                    return n.push(this.result.serialize()),
                    n
                }
            }
            var Pf = Ih;
            class Ch {
                constructor(n, a, u) {
                    this.type = n,
                    this.index = a,
                    this.input = u
                }
                static parse(n, a) {
                    if (n.length !== 3)
                        return a.error(`Expected 2 arguments, but found ${n.length - 1} instead.`);
                    let u = a.parse(n[1], 1, Xt)
                      , f = a.parse(n[2], 2, as(a.expectedType || Yn));
                    return u && f ? new Ch(f.type.itemType,u,f) : null
                }
                evaluate(n) {
                    let a = this.index.evaluate(n)
                      , u = this.input.evaluate(n);
                    if (a < 0)
                        throw new Dr(`Array index out of bounds: ${a} < 0.`);
                    if (a >= u.length)
                        throw new Dr(`Array index out of bounds: ${a} > ${u.length - 1}.`);
                    if (a !== Math.floor(a))
                        throw new Dr(`Array index must be an integer, but found ${a} instead.`);
                    return u[a]
                }
                eachChild(n) {
                    n(this.index),
                    n(this.input)
                }
                outputDefined() {
                    return !1
                }
                serialize() {
                    return ["at", this.index.serialize(), this.input.serialize()]
                }
            }
            var tx = Ch;
            class kf {
                constructor(n, a) {
                    this.type = $n,
                    this.needle = n,
                    this.haystack = a
                }
                static parse(n, a) {
                    if (n.length !== 3)
                        return a.error(`Expected 2 arguments, but found ${n.length - 1} instead.`);
                    let u = a.parse(n[1], 1, Yn)
                      , f = a.parse(n[2], 2, Yn);
                    return u && f ? mf(u.type, [$n, ni, Xt, Zo, Yn]) ? new kf(u,f) : a.error(`Expected first argument to be of type boolean, string, number or null, but found ${Li(u.type)} instead`) : null
                }
                evaluate(n) {
                    let a = this.needle.evaluate(n)
                      , u = this.haystack.evaluate(n);
                    if (u == null)
                        return !1;
                    if (!Ma(a, ["boolean", "string", "number", "null"]))
                        throw new Dr(`Expected first argument to be of type boolean, string, number or null, but found ${Li(gr(a))} instead.`);
                    if (!Ma(u, ["string", "array"]))
                        throw new Dr(`Expected second argument to be of type array or string, but found ${Li(gr(u))} instead.`);
                    return u.indexOf(a) >= 0
                }
                eachChild(n) {
                    n(this.needle),
                    n(this.haystack)
                }
                outputDefined() {
                    return !0
                }
                serialize() {
                    return ["in", this.needle.serialize(), this.haystack.serialize()]
                }
            }
            var Tg = kf;
            class Wc {
                constructor(n, a, u) {
                    this.type = Xt,
                    this.needle = n,
                    this.haystack = a,
                    this.fromIndex = u
                }
                static parse(n, a) {
                    if (n.length <= 2 || n.length >= 5)
                        return a.error(`Expected 3 or 4 arguments, but found ${n.length - 1} instead.`);
                    let u = a.parse(n[1], 1, Yn)
                      , f = a.parse(n[2], 2, Yn);
                    if (!u || !f)
                        return null;
                    if (!mf(u.type, [$n, ni, Xt, Zo, Yn]))
                        return a.error(`Expected first argument to be of type boolean, string, number or null, but found ${Li(u.type)} instead`);
                    if (n.length === 4) {
                        let g = a.parse(n[3], 3, Xt);
                        return g ? new Wc(u,f,g) : null
                    }
                    return new Wc(u,f)
                }
                evaluate(n) {
                    let a = this.needle.evaluate(n)
                      , u = this.haystack.evaluate(n);
                    if (!Ma(a, ["boolean", "string", "number", "null"]))
                        throw new Dr(`Expected first argument to be of type boolean, string, number or null, but found ${Li(gr(a))} instead.`);
                    if (!Ma(u, ["string", "array"]))
                        throw new Dr(`Expected second argument to be of type array or string, but found ${Li(gr(u))} instead.`);
                    if (this.fromIndex) {
                        let f = this.fromIndex.evaluate(n);
                        return u.indexOf(a, f)
                    }
                    return u.indexOf(a)
                }
                eachChild(n) {
                    n(this.needle),
                    n(this.haystack),
                    this.fromIndex && n(this.fromIndex)
                }
                outputDefined() {
                    return !1
                }
                serialize() {
                    if (this.fromIndex != null && this.fromIndex !== void 0) {
                        let n = this.fromIndex.serialize();
                        return ["index-of", this.needle.serialize(), this.haystack.serialize(), n]
                    }
                    return ["index-of", this.needle.serialize(), this.haystack.serialize()]
                }
            }
            var Eg = Wc;
            class zf {
                constructor(n, a, u, f, g, y) {
                    this.inputType = n,
                    this.type = a,
                    this.input = u,
                    this.cases = f,
                    this.outputs = g,
                    this.otherwise = y
                }
                static parse(n, a) {
                    if (n.length < 5)
                        return a.error(`Expected at least 4 arguments, but found only ${n.length - 1}.`);
                    if (n.length % 2 != 1)
                        return a.error("Expected an even number of arguments.");
                    let u, f;
                    a.expectedType && a.expectedType.kind !== "value" && (f = a.expectedType);
                    let g = {}
                      , y = [];
                    for (let M = 2; M < n.length - 1; M += 2) {
                        let z = n[M]
                          , N = n[M + 1];
                        Array.isArray(z) || (z = [z]);
                        let B = a.concat(M);
                        if (z.length === 0)
                            return B.error("Expected at least one branch label.");
                        for (let q of z) {
                            if (typeof q != "number" && typeof q != "string")
                                return B.error("Branch labels must be numbers or strings.");
                            if (typeof q == "number" && Math.abs(q) > Number.MAX_SAFE_INTEGER)
                                return B.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
                            if (typeof q == "number" && Math.floor(q) !== q)
                                return B.error("Numeric branch labels must be integer values.");
                            if (u) {
                                if (B.checkSubtype(u, gr(q)))
                                    return null
                            } else
                                u = gr(q);
                            if (g[String(q)] !== void 0)
                                return B.error("Branch labels must be unique.");
                            g[String(q)] = y.length
                        }
                        let H = a.parse(N, M, f);
                        if (!H)
                            return null;
                        f = f || H.type,
                        y.push(H)
                    }
                    let w = a.parse(n[1], 1, Yn);
                    if (!w)
                        return null;
                    let S = a.parse(n[n.length - 1], n.length - 1, f);
                    return S ? w.type.kind !== "value" && a.concat(1).checkSubtype(u, w.type) ? null : new zf(u,f,w,g,y,S) : null
                }
                evaluate(n) {
                    let a = this.input.evaluate(n);
                    return (gr(a) === this.inputType && this.outputs[this.cases[a]] || this.otherwise).evaluate(n)
                }
                eachChild(n) {
                    n(this.input),
                    this.outputs.forEach(n),
                    n(this.otherwise)
                }
                outputDefined() {
                    return this.outputs.every(n=>n.outputDefined()) && this.otherwise.outputDefined()
                }
                serialize() {
                    let n = ["match", this.input.serialize()]
                      , a = Object.keys(this.cases).sort()
                      , u = []
                      , f = {};
                    for (let y of a) {
                        let w = f[this.cases[y]];
                        w === void 0 ? (f[this.cases[y]] = u.length,
                        u.push([this.cases[y], [y]])) : u[w][1].push(y)
                    }
                    let g = y=>this.inputType.kind === "number" ? Number(y) : y;
                    for (let[y,w] of u)
                        n.push(w.length === 1 ? g(w[0]) : w.map(g)),
                        n.push(this.outputs[y].serialize());
                    return n.push(this.otherwise.serialize()),
                    n
                }
            }
            var nx = zf;
            class Of {
                constructor(n, a, u) {
                    this.type = n,
                    this.branches = a,
                    this.otherwise = u
                }
                static parse(n, a) {
                    if (n.length < 4)
                        return a.error(`Expected at least 3 arguments, but found only ${n.length - 1}.`);
                    if (n.length % 2 != 0)
                        return a.error("Expected an odd number of arguments.");
                    let u;
                    a.expectedType && a.expectedType.kind !== "value" && (u = a.expectedType);
                    let f = [];
                    for (let y = 1; y < n.length - 1; y += 2) {
                        let w = a.parse(n[y], y, $n);
                        if (!w)
                            return null;
                        let S = a.parse(n[y + 1], y + 1, u);
                        if (!S)
                            return null;
                        f.push([w, S]),
                        u = u || S.type
                    }
                    let g = a.parse(n[n.length - 1], n.length - 1, u);
                    return g ? new Of(u,f,g) : null
                }
                evaluate(n) {
                    for (let[a,u] of this.branches)
                        if (a.evaluate(n))
                            return u.evaluate(n);
                    return this.otherwise.evaluate(n)
                }
                eachChild(n) {
                    for (let[a,u] of this.branches)
                        n(a),
                        n(u);
                    n(this.otherwise)
                }
                outputDefined() {
                    return this.branches.every(([n,a])=>a.outputDefined()) && this.otherwise.outputDefined()
                }
                serialize() {
                    let n = ["case"];
                    return this.eachChild(a=>{
                        n.push(a.serialize())
                    }
                    ),
                    n
                }
            }
            var ix = Of;
            class La {
                constructor(n, a, u, f) {
                    this.type = n,
                    this.input = a,
                    this.beginIndex = u,
                    this.endIndex = f
                }
                static parse(n, a) {
                    if (n.length <= 2 || n.length >= 5)
                        return a.error(`Expected 3 or 4 arguments, but found ${n.length - 1} instead.`);
                    let u = a.parse(n[1], 1, Yn)
                      , f = a.parse(n[2], 2, Xt);
                    if (!u || !f)
                        return null;
                    if (!mf(u.type, [as(Yn), ni, Yn]))
                        return a.error(`Expected first argument to be of type array or string, but found ${Li(u.type)} instead`);
                    if (n.length === 4) {
                        let g = a.parse(n[3], 3, Xt);
                        return g ? new La(u.type,u,f,g) : null
                    }
                    return new La(u.type,u,f)
                }
                evaluate(n) {
                    let a = this.input.evaluate(n)
                      , u = this.beginIndex.evaluate(n);
                    if (!Ma(a, ["string", "array"]))
                        throw new Dr(`Expected first argument to be of type array or string, but found ${Li(gr(a))} instead.`);
                    if (this.endIndex) {
                        let f = this.endIndex.evaluate(n);
                        return a.slice(u, f)
                    }
                    return a.slice(u)
                }
                eachChild(n) {
                    n(this.input),
                    n(this.beginIndex),
                    this.endIndex && n(this.endIndex)
                }
                outputDefined() {
                    return !1
                }
                serialize() {
                    if (this.endIndex != null && this.endIndex !== void 0) {
                        let n = this.endIndex.serialize();
                        return ["slice", this.input.serialize(), this.beginIndex.serialize(), n]
                    }
                    return ["slice", this.input.serialize(), this.beginIndex.serialize()]
                }
            }
            var Sg = La;
            function Nf(s, n) {
                return s === "==" || s === "!=" ? n.kind === "boolean" || n.kind === "string" || n.kind === "number" || n.kind === "null" || n.kind === "value" : n.kind === "string" || n.kind === "number" || n.kind === "value"
            }
            function Ag(s, n, a, u) {
                return u.compare(n, a) === 0
            }
            function bl(s, n, a) {
                let u = s !== "==" && s !== "!=";
                return class r3 {
                    constructor(g, y, w) {
                        this.type = $n,
                        this.lhs = g,
                        this.rhs = y,
                        this.collator = w,
                        this.hasUntypedArgument = g.type.kind === "value" || y.type.kind === "value"
                    }
                    static parse(g, y) {
                        if (g.length !== 3 && g.length !== 4)
                            return y.error("Expected two or three arguments.");
                        let w = g[0]
                          , S = y.parse(g[1], 1, Yn);
                        if (!S)
                            return null;
                        if (!Nf(w, S.type))
                            return y.concat(1).error(`"${w}" comparisons are not supported for type '${Li(S.type)}'.`);
                        let M = y.parse(g[2], 2, Yn);
                        if (!M)
                            return null;
                        if (!Nf(w, M.type))
                            return y.concat(2).error(`"${w}" comparisons are not supported for type '${Li(M.type)}'.`);
                        if (S.type.kind !== M.type.kind && S.type.kind !== "value" && M.type.kind !== "value")
                            return y.error(`Cannot compare types '${Li(S.type)}' and '${Li(M.type)}'.`);
                        u && (S.type.kind === "value" && M.type.kind !== "value" ? S = new Ao(M.type,[S]) : S.type.kind !== "value" && M.type.kind === "value" && (M = new Ao(S.type,[M])));
                        let z = null;
                        if (g.length === 4) {
                            if (S.type.kind !== "string" && M.type.kind !== "string" && S.type.kind !== "value" && M.type.kind !== "value")
                                return y.error("Cannot use collator to compare non-string types.");
                            if (z = y.parse(g[3], 3, Cc),
                            !z)
                                return null
                        }
                        return new r3(S,M,z)
                    }
                    evaluate(g) {
                        let y = this.lhs.evaluate(g)
                          , w = this.rhs.evaluate(g);
                        if (u && this.hasUntypedArgument) {
                            let S = gr(y)
                              , M = gr(w);
                            if (S.kind !== M.kind || S.kind !== "string" && S.kind !== "number")
                                throw new Dr(`Expected arguments for "${s}" to be (string, string) or (number, number), but found (${S.kind}, ${M.kind}) instead.`)
                        }
                        if (this.collator && !u && this.hasUntypedArgument) {
                            let S = gr(y)
                              , M = gr(w);
                            if (S.kind !== "string" || M.kind !== "string")
                                return n(g, y, w)
                        }
                        return this.collator ? a(g, y, w, this.collator.evaluate(g)) : n(g, y, w)
                    }
                    eachChild(g) {
                        g(this.lhs),
                        g(this.rhs),
                        this.collator && g(this.collator)
                    }
                    outputDefined() {
                        return !0
                    }
                    serialize() {
                        let g = [s];
                        return this.eachChild(y=>{
                            g.push(y.serialize())
                        }
                        ),
                        g
                    }
                }
            }
            let rx = bl("==", function(s, n, a) {
                return n === a
            }, Ag)
              , Mg = bl("!=", function(s, n, a) {
                return n !== a
            }, function(s, n, a, u) {
                return !Ag(0, n, a, u)
            })
              , Ig = bl("<", function(s, n, a) {
                return n < a
            }, function(s, n, a, u) {
                return u.compare(n, a) < 0
            })
              , Cg = bl(">", function(s, n, a) {
                return n > a
            }, function(s, n, a, u) {
                return u.compare(n, a) > 0
            })
              , Ff = bl("<=", function(s, n, a) {
                return n <= a
            }, function(s, n, a, u) {
                return u.compare(n, a) <= 0
            })
              , sx = bl(">=", function(s, n, a) {
                return n >= a
            }, function(s, n, a, u) {
                return u.compare(n, a) >= 0
            });
            class Bf {
                constructor(n, a, u, f, g, y) {
                    this.type = ni,
                    this.number = n,
                    this.locale = a,
                    this.currency = u,
                    this.unit = f,
                    this.minFractionDigits = g,
                    this.maxFractionDigits = y
                }
                static parse(n, a) {
                    if (n.length !== 3)
                        return a.error("Expected two arguments.");
                    let u = a.parse(n[1], 1, Xt);
                    if (!u)
                        return null;
                    let f = n[2];
                    if (typeof f != "object" || Array.isArray(f))
                        return a.error("NumberFormat options argument must be an object.");
                    let g = null;
                    if (f.locale && (g = a.parse(f.locale, 1, ni),
                    !g))
                        return null;
                    let y = null;
                    if (f.currency && (y = a.parse(f.currency, 1, ni),
                    !y))
                        return null;
                    let w = null;
                    if (f.unit && (w = a.parse(f.unit, 1, ni),
                    !w))
                        return null;
                    let S = null;
                    if (f["min-fraction-digits"] && (S = a.parse(f["min-fraction-digits"], 1, Xt),
                    !S))
                        return null;
                    let M = null;
                    return f["max-fraction-digits"] && (M = a.parse(f["max-fraction-digits"], 1, Xt),
                    !M) ? null : new Bf(u,g,y,w,S,M)
                }
                evaluate(n) {
                    return new Intl.NumberFormat(this.locale ? this.locale.evaluate(n) : [],{
                        style: (this.currency ? "currency" : this.unit && "unit") || "decimal",
                        currency: this.currency ? this.currency.evaluate(n) : void 0,
                        unit: this.unit ? this.unit.evaluate(n) : void 0,
                        minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(n) : void 0,
                        maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(n) : void 0
                    }).format(this.number.evaluate(n))
                }
                eachChild(n) {
                    n(this.number),
                    this.locale && n(this.locale),
                    this.currency && n(this.currency),
                    this.unit && n(this.unit),
                    this.minFractionDigits && n(this.minFractionDigits),
                    this.maxFractionDigits && n(this.maxFractionDigits)
                }
                outputDefined() {
                    return !1
                }
                serialize() {
                    let n = {};
                    return this.locale && (n.locale = this.locale.serialize()),
                    this.currency && (n.currency = this.currency.serialize()),
                    this.unit && (n.unit = this.unit.serialize()),
                    this.minFractionDigits && (n["min-fraction-digits"] = this.minFractionDigits.serialize()),
                    this.maxFractionDigits && (n["max-fraction-digits"] = this.maxFractionDigits.serialize()),
                    ["number-format", this.number.serialize(), n]
                }
            }
            class Uf {
                constructor(n) {
                    this.type = Xt,
                    this.input = n
                }
                static parse(n, a) {
                    if (n.length !== 2)
                        return a.error(`Expected 1 argument, but found ${n.length - 1} instead.`);
                    let u = a.parse(n[1], 1);
                    return u ? u.type.kind !== "array" && u.type.kind !== "string" && u.type.kind !== "value" ? a.error(`Expected argument of type string or array, but found ${Li(u.type)} instead.`) : new Uf(u) : null
                }
                evaluate(n) {
                    let a = this.input.evaluate(n);
                    if (typeof a == "string" || Array.isArray(a))
                        return a.length;
                    throw new Dr(`Expected value to be of type string or array, but found ${Li(gr(a))} instead.`)
                }
                eachChild(n) {
                    n(this.input)
                }
                outputDefined() {
                    return !1
                }
                serialize() {
                    let n = ["length"];
                    return this.eachChild(a=>{
                        n.push(a.serialize())
                    }
                    ),
                    n
                }
            }
            let Dg = {
                "==": rx,
                "!=": Mg,
                ">": Cg,
                "<": Ig,
                ">=": sx,
                "<=": Ff,
                array: Ao,
                at: tx,
                boolean: Ao,
                case: ix,
                coalesce: wg,
                collator: _h,
                format: kc,
                image: gh,
                in: Tg,
                "index-of": Eg,
                interpolate: co,
                "interpolate-hcl": co,
                "interpolate-lab": co,
                length: Uf,
                let: Pf,
                literal: Pc,
                match: nx,
                number: Ao,
                "number-format": Bf,
                object: Ao,
                slice: Sg,
                step: Af,
                string: Ao,
                "to-boolean": yl,
                "to-color": yl,
                "to-number": yl,
                "to-string": yl,
                var: Ef,
                within: Tf
            };
            function Lg(s, [n,a,u,f]) {
                n = n.evaluate(s),
                a = a.evaluate(s),
                u = u.evaluate(s);
                let g = f ? f.evaluate(s) : 1
                  , y = ug(n, a, u, g);
                if (y)
                    throw new Dr(y);
                return new nr(n / 255 * g,a / 255 * g,u / 255 * g,g)
            }
            function Rg(s, n) {
                return s in n
            }
            function Vf(s, n) {
                let a = n[s];
                return a === void 0 ? null : a
            }
            function Jo(s) {
                return {
                    type: s
                }
            }
            qo.register(Dg, {
                error: [{
                    kind: "error"
                }, [ni], (s,[n])=>{
                    throw new Dr(n.evaluate(s))
                }
                ],
                typeof: [ni, [Yn], (s,[n])=>Li(gr(n.evaluate(s)))],
                "to-rgba": [as(Xt, 4), [lo], (s,[n])=>n.evaluate(s).toArray()],
                rgb: [lo, [Xt, Xt, Xt], Lg],
                rgba: [lo, [Xt, Xt, Xt, Xt], Lg],
                has: {
                    type: $n,
                    overloads: [[[ni], (s,[n])=>Rg(n.evaluate(s), s.properties())], [[ni, Aa], (s,[n,a])=>Rg(n.evaluate(s), a.evaluate(s))]]
                },
                get: {
                    type: Yn,
                    overloads: [[[ni], (s,[n])=>Vf(n.evaluate(s), s.properties())], [[ni, Aa], (s,[n,a])=>Vf(n.evaluate(s), a.evaluate(s))]]
                },
                "feature-state": [Yn, [ni], (s,[n])=>Vf(n.evaluate(s), s.featureState || {})],
                properties: [Aa, [], s=>s.properties()],
                "geometry-type": [ni, [], s=>s.geometryType()],
                id: [Yn, [], s=>s.id()],
                zoom: [Xt, [], s=>s.globals.zoom],
                pitch: [Xt, [], s=>s.globals.pitch || 0],
                "distance-from-center": [Xt, [], s=>s.distanceFromCenter()],
                "heatmap-density": [Xt, [], s=>s.globals.heatmapDensity || 0],
                "line-progress": [Xt, [], s=>s.globals.lineProgress || 0],
                "sky-radial-progress": [Xt, [], s=>s.globals.skyRadialProgress || 0],
                accumulated: [Yn, [], s=>s.globals.accumulated === void 0 ? null : s.globals.accumulated],
                "+": [Xt, Jo(Xt), (s,n)=>{
                    let a = 0;
                    for (let u of n)
                        a += u.evaluate(s);
                    return a
                }
                ],
                "*": [Xt, Jo(Xt), (s,n)=>{
                    let a = 1;
                    for (let u of n)
                        a *= u.evaluate(s);
                    return a
                }
                ],
                "-": {
                    type: Xt,
                    overloads: [[[Xt, Xt], (s,[n,a])=>n.evaluate(s) - a.evaluate(s)], [[Xt], (s,[n])=>-n.evaluate(s)]]
                },
                "/": [Xt, [Xt, Xt], (s,[n,a])=>n.evaluate(s) / a.evaluate(s)],
                "%": [Xt, [Xt, Xt], (s,[n,a])=>n.evaluate(s) % a.evaluate(s)],
                ln2: [Xt, [], ()=>Math.LN2],
                pi: [Xt, [], ()=>Math.PI],
                e: [Xt, [], ()=>Math.E],
                "^": [Xt, [Xt, Xt], (s,[n,a])=>Math.pow(n.evaluate(s), a.evaluate(s))],
                sqrt: [Xt, [Xt], (s,[n])=>Math.sqrt(n.evaluate(s))],
                log10: [Xt, [Xt], (s,[n])=>Math.log(n.evaluate(s)) / Math.LN10],
                ln: [Xt, [Xt], (s,[n])=>Math.log(n.evaluate(s))],
                log2: [Xt, [Xt], (s,[n])=>Math.log(n.evaluate(s)) / Math.LN2],
                sin: [Xt, [Xt], (s,[n])=>Math.sin(n.evaluate(s))],
                cos: [Xt, [Xt], (s,[n])=>Math.cos(n.evaluate(s))],
                tan: [Xt, [Xt], (s,[n])=>Math.tan(n.evaluate(s))],
                asin: [Xt, [Xt], (s,[n])=>Math.asin(n.evaluate(s))],
                acos: [Xt, [Xt], (s,[n])=>Math.acos(n.evaluate(s))],
                atan: [Xt, [Xt], (s,[n])=>Math.atan(n.evaluate(s))],
                min: [Xt, Jo(Xt), (s,n)=>Math.min(...n.map(a=>a.evaluate(s)))],
                max: [Xt, Jo(Xt), (s,n)=>Math.max(...n.map(a=>a.evaluate(s)))],
                abs: [Xt, [Xt], (s,[n])=>Math.abs(n.evaluate(s))],
                round: [Xt, [Xt], (s,[n])=>{
                    let a = n.evaluate(s);
                    return a < 0 ? -Math.round(-a) : Math.round(a)
                }
                ],
                floor: [Xt, [Xt], (s,[n])=>Math.floor(n.evaluate(s))],
                ceil: [Xt, [Xt], (s,[n])=>Math.ceil(n.evaluate(s))],
                "filter-==": [$n, [ni, Yn], (s,[n,a])=>s.properties()[n.value] === a.value],
                "filter-id-==": [$n, [Yn], (s,[n])=>s.id() === n.value],
                "filter-type-==": [$n, [ni], (s,[n])=>s.geometryType() === n.value],
                "filter-<": [$n, [ni, Yn], (s,[n,a])=>{
                    let u = s.properties()[n.value]
                      , f = a.value;
                    return typeof u == typeof f && u < f
                }
                ],
                "filter-id-<": [$n, [Yn], (s,[n])=>{
                    let a = s.id()
                      , u = n.value;
                    return typeof a == typeof u && a < u
                }
                ],
                "filter->": [$n, [ni, Yn], (s,[n,a])=>{
                    let u = s.properties()[n.value]
                      , f = a.value;
                    return typeof u == typeof f && u > f
                }
                ],
                "filter-id->": [$n, [Yn], (s,[n])=>{
                    let a = s.id()
                      , u = n.value;
                    return typeof a == typeof u && a > u
                }
                ],
                "filter-<=": [$n, [ni, Yn], (s,[n,a])=>{
                    let u = s.properties()[n.value]
                      , f = a.value;
                    return typeof u == typeof f && u <= f
                }
                ],
                "filter-id-<=": [$n, [Yn], (s,[n])=>{
                    let a = s.id()
                      , u = n.value;
                    return typeof a == typeof u && a <= u
                }
                ],
                "filter->=": [$n, [ni, Yn], (s,[n,a])=>{
                    let u = s.properties()[n.value]
                      , f = a.value;
                    return typeof u == typeof f && u >= f
                }
                ],
                "filter-id->=": [$n, [Yn], (s,[n])=>{
                    let a = s.id()
                      , u = n.value;
                    return typeof a == typeof u && a >= u
                }
                ],
                "filter-has": [$n, [Yn], (s,[n])=>n.value in s.properties()],
                "filter-has-id": [$n, [], s=>s.id() !== null && s.id() !== void 0],
                "filter-type-in": [$n, [as(ni)], (s,[n])=>n.value.indexOf(s.geometryType()) >= 0],
                "filter-id-in": [$n, [as(Yn)], (s,[n])=>n.value.indexOf(s.id()) >= 0],
                "filter-in-small": [$n, [ni, as(Yn)], (s,[n,a])=>a.value.indexOf(s.properties()[n.value]) >= 0],
                "filter-in-large": [$n, [ni, as(Yn)], (s,[n,a])=>function(u, f, g, y) {
                    for (; g <= y; ) {
                        let w = g + y >> 1;
                        if (f[w] === u)
                            return !0;
                        f[w] > u ? y = w - 1 : g = w + 1
                    }
                    return !1
                }(s.properties()[n.value], a.value, 0, a.value.length - 1)],
                all: {
                    type: $n,
                    overloads: [[[$n, $n], (s,[n,a])=>n.evaluate(s) && a.evaluate(s)], [Jo($n), (s,n)=>{
                        for (let a of n)
                            if (!a.evaluate(s))
                                return !1;
                        return !0
                    }
                    ]]
                },
                any: {
                    type: $n,
                    overloads: [[[$n, $n], (s,[n,a])=>n.evaluate(s) || a.evaluate(s)], [Jo($n), (s,n)=>{
                        for (let a of n)
                            if (a.evaluate(s))
                                return !0;
                        return !1
                    }
                    ]]
                },
                "!": [$n, [$n], (s,[n])=>!n.evaluate(s)],
                "is-supported-script": [$n, [ni], (s,[n])=>{
                    let a = s.globals && s.globals.isSupportedScript;
                    return !a || a(n.evaluate(s))
                }
                ],
                upcase: [ni, [ni], (s,[n])=>n.evaluate(s).toUpperCase()],
                downcase: [ni, [ni], (s,[n])=>n.evaluate(s).toLowerCase()],
                concat: [ni, Jo(Yn), (s,n)=>n.map(a=>Rc(a.evaluate(s))).join("")],
                "resolved-locale": [ni, [Cc], (s,[n])=>n.evaluate(s).resolvedLocale()]
            });
            var wl = Dg;
            function jc(s) {
                return {
                    result: "success",
                    value: s
                }
            }
            function Tl(s) {
                return {
                    result: "error",
                    value: s
                }
            }
            function El(s) {
                return s["property-type"] === "data-driven"
            }
            function Mo(s) {
                return !!s.expression && s.expression.parameters.indexOf("zoom") > -1
            }
            function Dh(s) {
                return !!s.expression && s.expression.interpolated
            }
            function ii(s) {
                return s instanceof Number ? "number" : s instanceof String ? "string" : s instanceof Boolean ? "boolean" : Array.isArray(s) ? "array" : s === null ? "null" : typeof s
            }
            function Lh(s) {
                return typeof s == "object" && s !== null && !Array.isArray(s)
            }
            function ox(s) {
                return s
            }
            function Gf(s, n) {
                let a = n.type === "color"
                  , u = s.stops && typeof s.stops[0][0] == "object"
                  , f = u || !(u || s.property !== void 0)
                  , g = s.type || (Dh(n) ? "exponential" : "interval");
                if (a && ((s = mr({}, s)).stops && (s.stops = s.stops.map(M=>[M[0], nr.parse(M[1])])),
                s.default = nr.parse(s.default ? s.default : n.default)),
                s.colorSpace && s.colorSpace !== "rgb" && !bg[s.colorSpace])
                    throw new Error(`Unknown color space: ${s.colorSpace}`);
                let y, w, S;
                if (g === "exponential")
                    y = Rh;
                else if (g === "interval")
                    y = Pg;
                else if (g === "categorical") {
                    y = Hf,
                    w = Object.create(null);
                    for (let M of s.stops)
                        w[M[0]] = M[1];
                    S = typeof s.stops[0][0]
                } else {
                    if (g !== "identity")
                        throw new Error(`Unknown function type "${g}"`);
                    y = kg
                }
                if (u) {
                    let M = {}
                      , z = [];
                    for (let H = 0; H < s.stops.length; H++) {
                        let q = s.stops[H]
                          , Q = q[0].zoom;
                        M[Q] === void 0 && (M[Q] = {
                            zoom: Q,
                            type: s.type,
                            property: s.property,
                            default: s.default,
                            stops: []
                        },
                        z.push(Q)),
                        M[Q].stops.push([q[0].value, q[1]])
                    }
                    let N = [];
                    for (let H of z)
                        N.push([M[H].zoom, Gf(M[H], n)]);
                    let B = {
                        name: "linear"
                    };
                    return {
                        kind: "composite",
                        interpolationType: B,
                        interpolationFactor: co.interpolationFactor.bind(void 0, B),
                        zoomStops: N.map(H=>H[0]),
                        evaluate: ({zoom: H},q)=>Rh({
                            stops: N,
                            base: s.base
                        }, n, H).evaluate(H, q)
                    }
                }
                if (f) {
                    let M = g === "exponential" ? {
                        name: "exponential",
                        base: s.base !== void 0 ? s.base : 1
                    } : null;
                    return {
                        kind: "camera",
                        interpolationType: M,
                        interpolationFactor: co.interpolationFactor.bind(void 0, M),
                        zoomStops: s.stops.map(z=>z[0]),
                        evaluate: ({zoom: z})=>y(s, n, z, w, S)
                    }
                }
                return {
                    kind: "source",
                    evaluate(M, z) {
                        let N = z && z.properties ? z.properties[s.property] : void 0;
                        return N === void 0 ? Xc(s.default, n.default) : y(s, n, N, w, S)
                    }
                }
            }
            function Xc(s, n, a) {
                return s !== void 0 ? s : n !== void 0 ? n : a !== void 0 ? a : void 0
            }
            function Hf(s, n, a, u, f) {
                return Xc(typeof a === f ? u[a] : void 0, s.default, n.default)
            }
            function Pg(s, n, a) {
                if (ii(a) !== "number")
                    return Xc(s.default, n.default);
                let u = s.stops.length;
                if (u === 1 || a <= s.stops[0][0])
                    return s.stops[0][1];
                if (a >= s.stops[u - 1][0])
                    return s.stops[u - 1][1];
                let f = Da(s.stops.map(g=>g[0]), a);
                return s.stops[f][1]
            }
            function Rh(s, n, a) {
                let u = s.base !== void 0 ? s.base : 1;
                if (ii(a) !== "number")
                    return Xc(s.default, n.default);
                let f = s.stops.length;
                if (f === 1 || a <= s.stops[0][0])
                    return s.stops[0][1];
                if (a >= s.stops[f - 1][0])
                    return s.stops[f - 1][1];
                let g = Da(s.stops.map(z=>z[0]), a)
                  , y = function(z, N, B, H) {
                    let q = H - B
                      , Q = z - B;
                    return q === 0 ? 0 : N === 1 ? Q / q : (Math.pow(N, Q) - 1) / (Math.pow(N, q) - 1)
                }(a, u, s.stops[g][0], s.stops[g + 1][0])
                  , w = s.stops[g][1]
                  , S = s.stops[g + 1][1]
                  , M = Uc[n.type] || ox;
                if (s.colorSpace && s.colorSpace !== "rgb") {
                    let z = bg[s.colorSpace];
                    M = (N,B)=>z.reverse(z.interpolate(z.forward(N), z.forward(B), y))
                }
                return typeof w.evaluate == "function" ? {
                    evaluate(...z) {
                        let N = w.evaluate.apply(void 0, z)
                          , B = S.evaluate.apply(void 0, z);
                        if (N !== void 0 && B !== void 0)
                            return M(N, B, y)
                    }
                } : M(w, S, y)
            }
            function kg(s, n, a) {
                return n.type === "color" ? a = nr.parse(a) : n.type === "formatted" ? a = ms.fromString(a.toString()) : n.type === "resolvedImage" ? a = ls.fromString(a.toString()) : ii(a) === n.type || n.type === "enum" && n.values[a] || (a = void 0),
                Xc(a, s.default, n.default)
            }
            class Ph {
                constructor(n, a) {
                    this.expression = n,
                    this._warningHistory = {},
                    this._evaluator = new zc,
                    this._defaultValue = a ? function(u) {
                        return u.type === "color" && (Lh(u.default) || Array.isArray(u.default)) ? new nr(0,0,0,0) : u.type === "color" ? nr.parse(u.default) || null : u.default === void 0 ? null : u.default
                    }(a) : null,
                    this._enumValues = a && a.type === "enum" ? a.values : null
                }
                evaluateWithoutErrorHandling(n, a, u, f, g, y, w, S) {
                    return this._evaluator.globals = n,
                    this._evaluator.feature = a,
                    this._evaluator.featureState = u,
                    this._evaluator.canonical = f || null,
                    this._evaluator.availableImages = g || null,
                    this._evaluator.formattedSection = y,
                    this._evaluator.featureTileCoord = w || null,
                    this._evaluator.featureDistanceData = S || null,
                    this.expression.evaluate(this._evaluator)
                }
                evaluate(n, a, u, f, g, y, w, S) {
                    this._evaluator.globals = n,
                    this._evaluator.feature = a || null,
                    this._evaluator.featureState = u || null,
                    this._evaluator.canonical = f || null,
                    this._evaluator.availableImages = g || null,
                    this._evaluator.formattedSection = y || null,
                    this._evaluator.featureTileCoord = w || null,
                    this._evaluator.featureDistanceData = S || null;
                    try {
                        let M = this.expression.evaluate(this._evaluator);
                        if (M == null || typeof M == "number" && M != M)
                            return this._defaultValue;
                        if (this._enumValues && !(M in this._enumValues))
                            throw new Dr(`Expected value to be one of ${Object.keys(this._enumValues).map(z=>JSON.stringify(z)).join(", ")}, but found ${JSON.stringify(M)} instead.`);
                        return M
                    } catch (M) {
                        return this._warningHistory[M.message] || (this._warningHistory[M.message] = !0,
                        typeof console != "undefined" && console.warn(M.message)),
                        this._defaultValue
                    }
                }
            }
            function Sl(s) {
                return Array.isArray(s) && s.length > 0 && typeof s[0] == "string" && s[0]in wl
            }
            function Al(s, n) {
                let a = new Sf(wl,[],n ? function(f) {
                    let g = {
                        color: lo,
                        string: ni,
                        number: Xt,
                        enum: ni,
                        boolean: $n,
                        formatted: pl,
                        resolvedImage: ml
                    };
                    return f.type === "array" ? as(g[f.value] || Yn, f.length) : g[f.type]
                }(n) : void 0)
                  , u = a.parse(s, void 0, void 0, void 0, n && n.type === "string" ? {
                    typeAnnotation: "coerce"
                } : void 0);
                return u ? jc(new Ph(u,n)) : Tl(a.errors)
            }
            class kh {
                constructor(n, a) {
                    this.kind = n,
                    this._styleExpression = a,
                    this.isStateDependent = n !== "constant" && !Bc(a.expression)
                }
                evaluateWithoutErrorHandling(n, a, u, f, g, y) {
                    return this._styleExpression.evaluateWithoutErrorHandling(n, a, u, f, g, y)
                }
                evaluate(n, a, u, f, g, y) {
                    return this._styleExpression.evaluate(n, a, u, f, g, y)
                }
            }
            class Ra {
                constructor(n, a, u, f) {
                    this.kind = n,
                    this.zoomStops = u,
                    this._styleExpression = a,
                    this.isStateDependent = n !== "camera" && !Bc(a.expression),
                    this.interpolationType = f
                }
                evaluateWithoutErrorHandling(n, a, u, f, g, y) {
                    return this._styleExpression.evaluateWithoutErrorHandling(n, a, u, f, g, y)
                }
                evaluate(n, a, u, f, g, y) {
                    return this._styleExpression.evaluate(n, a, u, f, g, y)
                }
                interpolationFactor(n, a, u) {
                    return this.interpolationType ? co.interpolationFactor(this.interpolationType, n, a, u) : 0
                }
            }
            function Pa(s, n) {
                if ((s = Al(s, n)).result === "error")
                    return s;
                let a = s.value.expression
                  , u = Fc(a);
                if (!u && !El(n))
                    return Tl([new Zi("","data expressions not supported")]);
                let f = bh(a, ["zoom", "pitch", "distance-from-center"]);
                if (!f && !Mo(n))
                    return Tl([new Zi("","zoom expressions not supported")]);
                let g = qc(a);
                return g || f ? g instanceof Zi ? Tl([g]) : g instanceof co && !Dh(n) ? Tl([new Zi("",'"interpolate" expressions cannot be used with this property')]) : jc(g ? new Ra(u ? "camera" : "composite",s.value,g.labels,g instanceof co ? g.interpolation : void 0) : new kh(u ? "constant" : "source",s.value)) : Tl([new Zi("",'"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')])
            }
            class Zc {
                constructor(n, a) {
                    this._parameters = n,
                    this._specification = a,
                    mr(this, Gf(this._parameters, this._specification))
                }
                static deserialize(n) {
                    return new Zc(n._parameters,n._specification)
                }
                static serialize(n) {
                    return {
                        _parameters: n._parameters,
                        _specification: n._specification
                    }
                }
            }
            function qc(s) {
                let n = null;
                if (s instanceof Pf)
                    n = qc(s.result);
                else if (s instanceof wg) {
                    for (let a of s.args)
                        if (n = qc(a),
                        n)
                            break
                } else
                    (s instanceof Af || s instanceof co) && s.input instanceof qo && s.input.name === "zoom" && (n = s);
                return n instanceof Zi || s.eachChild(a=>{
                    let u = qc(a);
                    u instanceof Zi ? n = u : !n && u ? n = new Zi("",'"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : n && u && n !== u && (n = new Zi("",'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'))
                }
                ),
                n
            }
            class rn {
                constructor(n, a, u, f) {
                    this.message = (n ? `${n}: ` : "") + u,
                    f && (this.identifier = f),
                    a != null && a.__line__ && (this.line = a.__line__)
                }
            }
            function zs(s) {
                let n = s.key
                  , a = s.value
                  , u = s.valueSpec || {}
                  , f = s.objectElementValidators || {}
                  , g = s.style
                  , y = s.styleSpec
                  , w = []
                  , S = ii(a);
                if (S !== "object")
                    return [new rn(n,a,`object expected, ${S} found`)];
                for (let M in a) {
                    let z = M.split(".")[0], N = u[z] || u["*"], B;
                    f[z] ? B = f[z] : u[z] ? B = Hr : f["*"] ? B = f["*"] : u["*"] && (B = Hr),
                    B ? w = w.concat(B({
                        key: (n && `${n}.`) + M,
                        value: a[M],
                        valueSpec: N,
                        style: g,
                        styleSpec: y,
                        object: a,
                        objectKey: M
                    }, a)) : w.push(new rn(n,a[M],`unknown property "${M}"`))
                }
                for (let M in u)
                    f[M] || u[M].required && u[M].default === void 0 && a[M] === void 0 && w.push(new rn(n,a,`missing required property "${M}"`));
                return w
            }
            function zg(s) {
                let n = s.value
                  , a = s.valueSpec
                  , u = s.style
                  , f = s.styleSpec
                  , g = s.key
                  , y = s.arrayElementValidator || Hr;
                if (ii(n) !== "array")
                    return [new rn(g,n,`array expected, ${ii(n)} found`)];
                if (a.length && n.length !== a.length)
                    return [new rn(g,n,`array length ${a.length} expected, length ${n.length} found`)];
                if (a["min-length"] && n.length < a["min-length"])
                    return [new rn(g,n,`array length at least ${a["min-length"]} expected, length ${n.length} found`)];
                let w = {
                    type: a.value,
                    values: a.values,
                    minimum: a.minimum,
                    maximum: a.maximum,
                    function: void 0
                };
                f.$version < 7 && (w.function = a.function),
                ii(a.value) === "object" && (w = a.value);
                let S = [];
                for (let M = 0; M < n.length; M++)
                    S = S.concat(y({
                        array: n,
                        arrayIndex: M,
                        value: n[M],
                        valueSpec: w,
                        style: u,
                        styleSpec: f,
                        key: `${g}[${M}]`
                    }));
                return S
            }
            function Wf(s) {
                let n = s.key
                  , a = s.value
                  , u = s.valueSpec
                  , f = ii(a);
                if (f === "number" && a != a && (f = "NaN"),
                f !== "number")
                    return [new rn(n,a,`number expected, ${f} found`)];
                if ("minimum"in u) {
                    let g = u.minimum;
                    if (ii(u.minimum) === "array" && (g = u.minimum[s.arrayIndex]),
                    a < g)
                        return [new rn(n,a,`${a} is less than the minimum value ${g}`)]
                }
                if ("maximum"in u) {
                    let g = u.maximum;
                    if (ii(u.maximum) === "array" && (g = u.maximum[s.arrayIndex]),
                    a > g)
                        return [new rn(n,a,`${a} is greater than the maximum value ${g}`)]
                }
                return []
            }
            function Kc(s) {
                let n = s.valueSpec, a = jn(s.value.type), u, f, g, y = {}, w = a !== "categorical" && s.value.property === void 0, S = !w, M = ii(s.value.stops) === "array" && ii(s.value.stops[0]) === "array" && ii(s.value.stops[0][0]) === "object", z = zs({
                    key: s.key,
                    value: s.value,
                    valueSpec: s.styleSpec.function,
                    style: s.style,
                    styleSpec: s.styleSpec,
                    objectElementValidators: {
                        stops: function(H) {
                            if (a === "identity")
                                return [new rn(H.key,H.value,'identity function may not have a "stops" property')];
                            let q = []
                              , Q = H.value;
                            return q = q.concat(zg({
                                key: H.key,
                                value: Q,
                                valueSpec: H.valueSpec,
                                style: H.style,
                                styleSpec: H.styleSpec,
                                arrayElementValidator: N
                            })),
                            ii(Q) === "array" && Q.length === 0 && q.push(new rn(H.key,Q,"array must have at least one stop")),
                            q
                        },
                        default: function(H) {
                            return Hr({
                                key: H.key,
                                value: H.value,
                                valueSpec: n,
                                style: H.style,
                                styleSpec: H.styleSpec
                            })
                        }
                    }
                });
                return a === "identity" && w && z.push(new rn(s.key,s.value,'missing required property "property"')),
                a === "identity" || s.value.stops || z.push(new rn(s.key,s.value,'missing required property "stops"')),
                a === "exponential" && s.valueSpec.expression && !Dh(s.valueSpec) && z.push(new rn(s.key,s.value,"exponential functions not supported")),
                s.styleSpec.$version >= 8 && (S && !El(s.valueSpec) ? z.push(new rn(s.key,s.value,"property functions not supported")) : w && !Mo(s.valueSpec) && z.push(new rn(s.key,s.value,"zoom functions not supported"))),
                a !== "categorical" && !M || s.value.property !== void 0 || z.push(new rn(s.key,s.value,'"property" property is required')),
                z;
                function N(H) {
                    let q = []
                      , Q = H.value
                      , de = H.key;
                    if (ii(Q) !== "array")
                        return [new rn(de,Q,`array expected, ${ii(Q)} found`)];
                    if (Q.length !== 2)
                        return [new rn(de,Q,`array length 2 expected, length ${Q.length} found`)];
                    if (M) {
                        if (ii(Q[0]) !== "object")
                            return [new rn(de,Q,`object expected, ${ii(Q[0])} found`)];
                        if (Q[0].zoom === void 0)
                            return [new rn(de,Q,"object stop key must have zoom")];
                        if (Q[0].value === void 0)
                            return [new rn(de,Q,"object stop key must have value")];
                        let Me = jn(Q[0].zoom);
                        if (typeof Me != "number")
                            return [new rn(de,Q[0].zoom,"stop zoom values must be numbers")];
                        if (g && g > Me)
                            return [new rn(de,Q[0].zoom,"stop zoom values must appear in ascending order")];
                        Me !== g && (g = Me,
                        f = void 0,
                        y = {}),
                        q = q.concat(zs({
                            key: `${de}[0]`,
                            value: Q[0],
                            valueSpec: {
                                zoom: {}
                            },
                            style: H.style,
                            styleSpec: H.styleSpec,
                            objectElementValidators: {
                                zoom: Wf,
                                value: B
                            }
                        }))
                    } else
                        q = q.concat(B({
                            key: `${de}[0]`,
                            value: Q[0],
                            valueSpec: {},
                            style: H.style,
                            styleSpec: H.styleSpec
                        }, Q));
                    return Sl(vr(Q[1])) ? q.concat([new rn(`${de}[1]`,Q[1],"expressions are not allowed in function stops.")]) : q.concat(Hr({
                        key: `${de}[1]`,
                        value: Q[1],
                        valueSpec: n,
                        style: H.style,
                        styleSpec: H.styleSpec
                    }))
                }
                function B(H, q) {
                    let Q = ii(H.value)
                      , de = jn(H.value)
                      , Me = H.value !== null ? H.value : q;
                    if (u) {
                        if (Q !== u)
                            return [new rn(H.key,Me,`${Q} stop domain type must match previous stop domain type ${u}`)]
                    } else
                        u = Q;
                    if (Q !== "number" && Q !== "string" && Q !== "boolean" && typeof de != "number" && typeof de != "string" && typeof de != "boolean")
                        return [new rn(H.key,Me,"stop domain value must be a number, string, or boolean")];
                    if (Q !== "number" && a !== "categorical") {
                        let Pe = `number expected, ${Q} found`;
                        return El(n) && a === void 0 && (Pe += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'),
                        [new rn(H.key,Me,Pe)]
                    }
                    return a !== "categorical" || Q !== "number" || typeof de == "number" && isFinite(de) && Math.floor(de) === de ? a !== "categorical" && Q === "number" && typeof de == "number" && typeof f == "number" && f !== void 0 && de < f ? [new rn(H.key,Me,"stop domain values must appear in ascending order")] : (f = de,
                    a === "categorical" && de in y ? [new rn(H.key,Me,"stop domain values must be unique")] : (y[de] = !0,
                    [])) : [new rn(H.key,Me,`integer expected, found ${String(de)}`)]
                }
            }
            function Ml(s) {
                let n = (s.expressionContext === "property" ? Pa : Al)(vr(s.value), s.valueSpec);
                if (n.result === "error")
                    return n.value.map(u=>new rn(`${s.key}${u.key}`,s.value,u.message));
                let a = n.value.expression || n.value._styleExpression.expression;
                if (s.expressionContext === "property" && s.propertyKey === "text-font" && !a.outputDefined())
                    return [new rn(s.key,s.value,`Invalid data expression for "${s.propertyKey}". Output values must be contained as literals within the expression.`)];
                if (s.expressionContext === "property" && s.propertyType === "layout" && !Bc(a))
                    return [new rn(s.key,s.value,'"feature-state" data expressions are not supported with layout properties.')];
                if (s.expressionContext === "filter")
                    return Og(a, s);
                if (s.expressionContext && s.expressionContext.indexOf("cluster") === 0) {
                    if (!bh(a, ["zoom", "feature-state"]))
                        return [new rn(s.key,s.value,'"zoom" and "feature-state" expressions are not supported with cluster properties.')];
                    if (s.expressionContext === "cluster-initial" && !Fc(a))
                        return [new rn(s.key,s.value,"Feature data expressions are not supported with initial expression part of cluster properties.")]
                }
                return []
            }
            function Og(s, n) {
                let a = new Set(["zoom", "feature-state", "pitch", "distance-from-center"]);
                if (n.valueSpec && n.valueSpec.expression)
                    for (let f of n.valueSpec.expression.parameters)
                        a.delete(f);
                if (a.size === 0)
                    return [];
                let u = [];
                return s instanceof qo && a.has(s.name) ? [new rn(n.key,n.value,`["${s.name}"] expression is not supported in a filter for a ${n.object.type} layer with id: ${n.object.id}`)] : (s.eachChild(f=>{
                    u.push(...Og(f, n))
                }
                ),
                u)
            }
            function zh(s) {
                let n = s.key
                  , a = s.value
                  , u = s.valueSpec
                  , f = [];
                return Array.isArray(u.values) ? u.values.indexOf(jn(a)) === -1 && f.push(new rn(n,a,`expected one of [${u.values.join(", ")}], ${JSON.stringify(a)} found`)) : Object.keys(u.values).indexOf(jn(a)) === -1 && f.push(new rn(n,a,`expected one of [${Object.keys(u.values).join(", ")}], ${JSON.stringify(a)} found`)),
                f
            }
            function jf(s) {
                if (s === !0 || s === !1)
                    return !0;
                if (!Array.isArray(s) || s.length === 0)
                    return !1;
                switch (s[0]) {
                case "has":
                    return s.length >= 2 && s[1] !== "$id" && s[1] !== "$type";
                case "in":
                    return s.length >= 3 && (typeof s[1] != "string" || Array.isArray(s[2]));
                case "!in":
                case "!has":
                case "none":
                    return !1;
                case "==":
                case "!=":
                case ">":
                case ">=":
                case "<":
                case "<=":
                    return s.length !== 3 || Array.isArray(s[1]) || Array.isArray(s[2]);
                case "any":
                case "all":
                    for (let n of s.slice(1))
                        if (!jf(n) && typeof n != "boolean")
                            return !1;
                    return !0;
                default:
                    return !0
                }
            }
            function Oh(s, n="fill") {
                if (s == null)
                    return {
                        filter: ()=>!0,
                        needGeometry: !1,
                        needFeature: !1
                    };
                jf(s) || (s = Fh(s));
                let a = s
                  , u = !0;
                try {
                    u = function(M) {
                        if (!Er(M))
                            return M;
                        let z = vr(M);
                        return Jc(z),
                        z = Yc(z),
                        z
                    }(a)
                } catch (M) {
                    console.warn(`Failed to extract static filter. Filter will continue working, but at higher memory usage and slower framerate.
This is most likely a bug, please report this via https://github.com/mapbox/mapbox-gl-js/issues/new?assignees=&labels=&template=Bug_report.md
and paste the contents of this message in the report.
Thank you!
Filter Expression:
${JSON.stringify(a, null, 2)}
        `)
                }
                let f = ht[`filter_ ${n}`]
                  , g = Al(u, f)
                  , y = null;
                if (g.result === "error")
                    throw new Error(g.value.map(M=>`${M.key}: ${M.message}`).join(", "));
                y = (M,z,N)=>g.value.evaluate(M, z, {}, N);
                let w = null
                  , S = null;
                if (u !== a) {
                    let M = Al(a, f);
                    if (M.result === "error")
                        throw new Error(M.value.map(z=>`${z.key}: ${z.message}`).join(", "));
                    w = (z,N,B,H,q)=>M.value.evaluate(z, N, {}, B, void 0, void 0, H, q),
                    S = !Fc(M.value.expression)
                }
                return {
                    filter: y,
                    dynamicFilter: w || void 0,
                    needGeometry: Ng(u),
                    needFeature: !!S
                }
            }
            function Yc(s) {
                if (!Array.isArray(s))
                    return s;
                let n = function(a) {
                    if (Nh.has(a[0])) {
                        for (let u = 1; u < a.length; u++)
                            if (Er(a[u]))
                                return !0
                    }
                    return a
                }(s);
                return n === !0 ? n : n.map(a=>Yc(a))
            }
            function Jc(s) {
                let n = !1
                  , a = [];
                if (s[0] === "case") {
                    for (let u = 1; u < s.length - 1; u += 2)
                        n = n || Er(s[u]),
                        a.push(s[u + 1]);
                    a.push(s[s.length - 1])
                } else if (s[0] === "match") {
                    n = n || Er(s[1]);
                    for (let u = 2; u < s.length - 1; u += 2)
                        a.push(s[u + 1]);
                    a.push(s[s.length - 1])
                } else if (s[0] === "step") {
                    n = n || Er(s[1]);
                    for (let u = 1; u < s.length - 1; u += 2)
                        a.push(s[u + 1])
                }
                n && (s.length = 0,
                s.push("any", ...a));
                for (let u = 1; u < s.length; u++)
                    Jc(s[u])
            }
            function Er(s) {
                if (!Array.isArray(s))
                    return !1;
                if ((n = s[0]) === "pitch" || n === "distance-from-center")
                    return !0;
                var n;
                for (let a = 1; a < s.length; a++)
                    if (Er(s[a]))
                        return !0;
                return !1
            }
            let Nh = new Set(["in", "==", "!=", ">", ">=", "<", "<=", "to-boolean"]);
            function ax(s, n) {
                return s < n ? -1 : s > n ? 1 : 0
            }
            function Ng(s) {
                if (!Array.isArray(s))
                    return !1;
                if (s[0] === "within")
                    return !0;
                for (let n = 1; n < s.length; n++)
                    if (Ng(s[n]))
                        return !0;
                return !1
            }
            function Fh(s) {
                if (!s)
                    return !0;
                let n = s[0];
                return s.length <= 1 ? n !== "any" : n === "==" ? Xf(s[1], s[2], "==") : n === "!=" ? Il(Xf(s[1], s[2], "==")) : n === "<" || n === ">" || n === "<=" || n === ">=" ? Xf(s[1], s[2], n) : n === "any" ? (a = s.slice(1),
                ["any"].concat(a.map(Fh))) : n === "all" ? ["all"].concat(s.slice(1).map(Fh)) : n === "none" ? ["all"].concat(s.slice(1).map(Fh).map(Il)) : n === "in" ? Bh(s[1], s.slice(2)) : n === "!in" ? Il(Bh(s[1], s.slice(2))) : n === "has" ? Fg(s[1]) : n === "!has" ? Il(Fg(s[1])) : n !== "within" || s;
                var a
            }
            function Xf(s, n, a) {
                switch (s) {
                case "$type":
                    return [`filter-type-${a}`, n];
                case "$id":
                    return [`filter-id-${a}`, n];
                default:
                    return [`filter-${a}`, s, n]
                }
            }
            function Bh(s, n) {
                if (n.length === 0)
                    return !1;
                switch (s) {
                case "$type":
                    return ["filter-type-in", ["literal", n]];
                case "$id":
                    return ["filter-id-in", ["literal", n]];
                default:
                    return n.length > 200 && !n.some(a=>typeof a != typeof n[0]) ? ["filter-in-large", s, ["literal", n.sort(ax)]] : ["filter-in-small", s, ["literal", n]]
                }
            }
            function Fg(s) {
                switch (s) {
                case "$type":
                    return !0;
                case "$id":
                    return ["filter-has-id"];
                default:
                    return ["filter-has", s]
                }
            }
            function Il(s) {
                return ["!", s]
            }
            function Zf(s) {
                return jf(vr(s.value)) ? Ml(mr({}, s, {
                    expressionContext: "filter",
                    valueSpec: s.styleSpec[`filter_ ${s.layerType || "fill"}`]
                })) : Bg(s)
            }
            function Bg(s) {
                let n = s.value
                  , a = s.key;
                if (ii(n) !== "array")
                    return [new rn(a,n,`array expected, ${ii(n)} found`)];
                let u = s.styleSpec, f, g = [];
                if (n.length < 1)
                    return [new rn(a,n,"filter array must have at least 1 element")];
                switch (g = g.concat(zh({
                    key: `${a}[0]`,
                    value: n[0],
                    valueSpec: u.filter_operator,
                    style: s.style,
                    styleSpec: s.styleSpec
                })),
                jn(n[0])) {
                case "<":
                case "<=":
                case ">":
                case ">=":
                    n.length >= 2 && jn(n[1]) === "$type" && g.push(new rn(a,n,`"$type" cannot be use with operator "${n[0]}"`));
                case "==":
                case "!=":
                    n.length !== 3 && g.push(new rn(a,n,`filter array for operator "${n[0]}" must have 3 elements`));
                case "in":
                case "!in":
                    n.length >= 2 && (f = ii(n[1]),
                    f !== "string" && g.push(new rn(`${a}[1]`,n[1],`string expected, ${f} found`)));
                    for (let y = 2; y < n.length; y++)
                        f = ii(n[y]),
                        jn(n[1]) === "$type" ? g = g.concat(zh({
                            key: `${a}[${y}]`,
                            value: n[y],
                            valueSpec: u.geometry_type,
                            style: s.style,
                            styleSpec: s.styleSpec
                        })) : f !== "string" && f !== "number" && f !== "boolean" && g.push(new rn(`${a}[${y}]`,n[y],`string, number, or boolean expected, ${f} found`));
                    break;
                case "any":
                case "all":
                case "none":
                    for (let y = 1; y < n.length; y++)
                        g = g.concat(Bg({
                            key: `${a}[${y}]`,
                            value: n[y],
                            style: s.style,
                            styleSpec: s.styleSpec
                        }));
                    break;
                case "has":
                case "!has":
                    f = ii(n[1]),
                    n.length !== 2 ? g.push(new rn(a,n,`filter array for "${n[0]}" operator must have 2 elements`)) : f !== "string" && g.push(new rn(`${a}[1]`,n[1],`string expected, ${f} found`));
                    break;
                case "within":
                    f = ii(n[1]),
                    n.length !== 2 ? g.push(new rn(a,n,`filter array for "${n[0]}" operator must have 2 elements`)) : f !== "object" && g.push(new rn(`${a}[1]`,n[1],`object expected, ${f} found`))
                }
                return g
            }
            function Uh(s, n) {
                let a = s.key
                  , u = s.style
                  , f = s.styleSpec
                  , g = s.value
                  , y = s.objectKey
                  , w = f[`${n}_ ${s.layerType}`];
                if (!w)
                    return [];
                let S = y.match(/^(.*)-transition$/);
                if (n === "paint" && S && w[S[1]] && w[S[1]].transition)
                    return Hr({
                        key: a,
                        value: g,
                        valueSpec: f.transition,
                        style: u,
                        styleSpec: f
                    });
                let M = s.valueSpec || w[y];
                if (!M)
                    return [new rn(a,g,`unknown property "${y}"`)];
                let z;
                if (ii(g) === "string" && El(M) && !M.tokens && (z = /^{([^}]+)}$/.exec(g)))
                    return [new rn(a,g,`"${y}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(z[1])} }\`.`)];
                let N = [];
                return s.layerType === "symbol" && (y === "text-field" && u && !u.glyphs && N.push(new rn(a,g,'use of "text-field" requires a style "glyphs" property')),
                y === "text-font" && Lh(vr(g)) && jn(g.type) === "identity" && N.push(new rn(a,g,'"text-font" does not support identity functions'))),
                N.concat(Hr({
                    key: s.key,
                    value: g,
                    valueSpec: M,
                    style: u,
                    styleSpec: f,
                    expressionContext: "property",
                    propertyType: n,
                    propertyKey: y
                }))
            }
            function Ug(s) {
                return Uh(s, "paint")
            }
            function qf(s) {
                return Uh(s, "layout")
            }
            function Kf(s) {
                let n = []
                  , a = s.value
                  , u = s.key
                  , f = s.style
                  , g = s.styleSpec;
                a.type || a.ref || n.push(new rn(u,a,'either "type" or "ref" is required'));
                let y = jn(a.type)
                  , w = jn(a.ref);
                if (a.id) {
                    let S = jn(a.id);
                    for (let M = 0; M < s.arrayIndex; M++) {
                        let z = f.layers[M];
                        jn(z.id) === S && n.push(new rn(u,a.id,`duplicate layer id "${a.id}", previously used at line ${z.id.__line__}`))
                    }
                }
                if ("ref"in a) {
                    let S;
                    ["type", "source", "source-layer", "filter", "layout"].forEach(M=>{
                        M in a && n.push(new rn(u,a[M],`"${M}" is prohibited for ref layers`))
                    }
                    ),
                    f.layers.forEach(M=>{
                        jn(M.id) === w && (S = M)
                    }
                    ),
                    S ? S.ref ? n.push(new rn(u,a.ref,"ref cannot reference another ref layer")) : y = jn(S.type) : typeof w == "string" && n.push(new rn(u,a.ref,`ref layer "${w}" not found`))
                } else if (y !== "background" && y !== "sky")
                    if (a.source) {
                        let S = f.sources && f.sources[a.source]
                          , M = S && jn(S.type);
                        S ? M === "vector" && y === "raster" ? n.push(new rn(u,a.source,`layer "${a.id}" requires a raster source`)) : M === "raster" && y !== "raster" ? n.push(new rn(u,a.source,`layer "${a.id}" requires a vector source`)) : M !== "vector" || a["source-layer"] ? M === "raster-dem" && y !== "hillshade" ? n.push(new rn(u,a.source,"raster-dem source can only be used with layer type 'hillshade'.")) : y !== "line" || !a.paint || !a.paint["line-gradient"] && !a.paint["line-trim-offset"] || M === "geojson" && S.lineMetrics || n.push(new rn(u,a,`layer "${a.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : n.push(new rn(u,a,`layer "${a.id}" must specify a "source-layer"`)) : n.push(new rn(u,a.source,`source "${a.source}" not found`))
                    } else
                        n.push(new rn(u,a,'missing required property "source"'));
                return n = n.concat(zs({
                    key: u,
                    value: a,
                    valueSpec: g.layer,
                    style: s.style,
                    styleSpec: s.styleSpec,
                    objectElementValidators: {
                        "*": ()=>[],
                        type: ()=>Hr({
                            key: `${u}.type`,
                            value: a.type,
                            valueSpec: g.layer.type,
                            style: s.style,
                            styleSpec: s.styleSpec,
                            object: a,
                            objectKey: "type"
                        }),
                        filter: S=>Zf(mr({
                            layerType: y
                        }, S)),
                        layout: S=>zs({
                            layer: a,
                            key: S.key,
                            value: S.value,
                            valueSpec: {},
                            style: S.style,
                            styleSpec: S.styleSpec,
                            objectElementValidators: {
                                "*": M=>qf(mr({
                                    layerType: y
                                }, M))
                            }
                        }),
                        paint: S=>zs({
                            layer: a,
                            key: S.key,
                            value: S.value,
                            valueSpec: {},
                            style: S.style,
                            styleSpec: S.styleSpec,
                            objectElementValidators: {
                                "*": M=>Ug(mr({
                                    layerType: y
                                }, M))
                            }
                        })
                    }
                })),
                n
            }
            function Cl(s) {
                let n = s.value
                  , a = s.key
                  , u = ii(n);
                return u !== "string" ? [new rn(a,n,`string expected, ${u} found`)] : []
            }
            let Vh = {
                promoteId: function({key: s, value: n}) {
                    if (ii(n) === "string")
                        return Cl({
                            key: s,
                            value: n
                        });
                    {
                        let a = [];
                        for (let u in n)
                            a.push(...Cl({
                                key: `${s}.${u}`,
                                value: n[u]
                            }));
                        return a
                    }
                }
            };
            function $c(s) {
                let n = s.value
                  , a = s.key
                  , u = s.styleSpec
                  , f = s.style;
                if (!n.type)
                    return [new rn(a,n,'"type" is required')];
                let g = jn(n.type), y;
                switch (g) {
                case "vector":
                case "raster":
                case "raster-dem":
                    return y = zs({
                        key: a,
                        value: n,
                        valueSpec: u[`source_ ${g.replace("-", "_")}`],
                        style: s.style,
                        styleSpec: u,
                        objectElementValidators: Vh
                    }),
                    y;
                case "geojson":
                    if (y = zs({
                        key: a,
                        value: n,
                        valueSpec: u.source_geojson,
                        style: f,
                        styleSpec: u,
                        objectElementValidators: Vh
                    }),
                    n.cluster)
                        for (let w in n.clusterProperties) {
                            let[S,M] = n.clusterProperties[w]
                              , z = typeof S == "string" ? [S, ["accumulated"], ["get", w]] : S;
                            y.push(...Ml({
                                key: `${a}.${w}.map`,
                                value: M,
                                expressionContext: "cluster-map"
                            })),
                            y.push(...Ml({
                                key: `${a}.${w}.reduce`,
                                value: z,
                                expressionContext: "cluster-reduce"
                            }))
                        }
                    return y;
                case "video":
                    return zs({
                        key: a,
                        value: n,
                        valueSpec: u.source_video,
                        style: f,
                        styleSpec: u
                    });
                case "image":
                    return zs({
                        key: a,
                        value: n,
                        valueSpec: u.source_image,
                        style: f,
                        styleSpec: u
                    });
                case "canvas":
                    return [new rn(a,null,"Please use runtime APIs to add canvas sources, rather than including them in stylesheets.","source.canvas")];
                default:
                    return zh({
                        key: `${a}.type`,
                        value: n.type,
                        valueSpec: {
                            values: Vg(u)
                        },
                        style: f,
                        styleSpec: u
                    })
                }
            }
            function Vg(s) {
                return s.source.reduce((n,a)=>{
                    let u = s[a];
                    return u.type.type === "enum" && (n = n.concat(Object.keys(u.type.values))),
                    n
                }
                , [])
            }
            function Gg(s) {
                let n = s.value
                  , a = s.styleSpec
                  , u = a.light
                  , f = s.style
                  , g = []
                  , y = ii(n);
                if (n === void 0)
                    return g;
                if (y !== "object")
                    return g = g.concat([new rn("light",n,`object expected, ${y} found`)]),
                    g;
                for (let w in n) {
                    let S = w.match(/^(.*)-transition$/);
                    g = g.concat(S && u[S[1]] && u[S[1]].transition ? Hr({
                        key: w,
                        value: n[w],
                        valueSpec: a.transition,
                        style: f,
                        styleSpec: a
                    }) : u[w] ? Hr({
                        key: w,
                        value: n[w],
                        valueSpec: u[w],
                        style: f,
                        styleSpec: a
                    }) : [new rn(w,n[w],`unknown property "${w}"`)])
                }
                return g
            }
            function Yf(s) {
                let n = s.value
                  , a = s.key
                  , u = s.style
                  , f = s.styleSpec
                  , g = f.terrain
                  , y = []
                  , w = ii(n);
                if (n === void 0)
                    return y;
                if (w !== "object")
                    return y = y.concat([new rn("terrain",n,`object expected, ${w} found`)]),
                    y;
                for (let S in n) {
                    let M = S.match(/^(.*)-transition$/);
                    y = y.concat(M && g[M[1]] && g[M[1]].transition ? Hr({
                        key: S,
                        value: n[S],
                        valueSpec: f.transition,
                        style: u,
                        styleSpec: f
                    }) : g[S] ? Hr({
                        key: S,
                        value: n[S],
                        valueSpec: g[S],
                        style: u,
                        styleSpec: f
                    }) : [new rn(S,n[S],`unknown property "${S}"`)])
                }
                if (n.source) {
                    let S = u.sources && u.sources[n.source]
                      , M = S && jn(S.type);
                    S ? M !== "raster-dem" && y.push(new rn(a,n.source,`terrain cannot be used with a source of type ${String(M)}, it only be used with a "raster-dem" source type`)) : y.push(new rn(a,n.source,`source "${n.source}" not found`))
                } else
                    y.push(new rn(a,n,'terrain is missing required property "source"'));
                return y
            }
            function Hg(s) {
                let n = s.value
                  , a = s.style
                  , u = s.styleSpec
                  , f = u.fog
                  , g = []
                  , y = ii(n);
                if (n === void 0)
                    return g;
                if (y !== "object")
                    return g = g.concat([new rn("fog",n,`object expected, ${y} found`)]),
                    g;
                for (let w in n) {
                    let S = w.match(/^(.*)-transition$/);
                    g = g.concat(S && f[S[1]] && f[S[1]].transition ? Hr({
                        key: w,
                        value: n[w],
                        valueSpec: u.transition,
                        style: a,
                        styleSpec: u
                    }) : f[w] ? Hr({
                        key: w,
                        value: n[w],
                        valueSpec: f[w],
                        style: a,
                        styleSpec: u
                    }) : [new rn(w,n[w],`unknown property "${w}"`)])
                }
                return g
            }
            let Gh = {
                "*": ()=>[],
                array: zg,
                boolean: function(s) {
                    let n = s.value
                      , a = s.key
                      , u = ii(n);
                    return u !== "boolean" ? [new rn(a,n,`boolean expected, ${u} found`)] : []
                },
                number: Wf,
                color: function(s) {
                    let n = s.key
                      , a = s.value
                      , u = ii(a);
                    return u !== "string" ? [new rn(n,a,`color expected, ${u} found`)] : gf(a) === null ? [new rn(n,a,`color expected, "${a}" found`)] : []
                },
                enum: zh,
                filter: Zf,
                function: Kc,
                layer: Kf,
                object: zs,
                source: $c,
                light: Gg,
                terrain: Yf,
                fog: Hg,
                string: Cl,
                formatted: function(s) {
                    return Cl(s).length === 0 ? [] : Ml(s)
                },
                resolvedImage: function(s) {
                    return Cl(s).length === 0 ? [] : Ml(s)
                },
                projection: function(s) {
                    let n = s.value
                      , a = s.styleSpec
                      , u = a.projection
                      , f = s.style
                      , g = []
                      , y = ii(n);
                    if (y === "object")
                        for (let w in n)
                            g = g.concat(Hr({
                                key: w,
                                value: n[w],
                                valueSpec: u[w],
                                style: f,
                                styleSpec: a
                            }));
                    else
                        y !== "string" && (g = g.concat([new rn("projection",n,`object or string expected, ${y} found`)]));
                    return g
                }
            };
            function Hr(s) {
                let n = s.value
                  , a = s.valueSpec
                  , u = s.styleSpec;
                return a.expression && Lh(jn(n)) ? Kc(s) : a.expression && Sl(vr(n)) ? Ml(s) : a.type && Gh[a.type] ? Gh[a.type](s) : zs(mr({}, s, {
                    valueSpec: a.type ? u[a.type] : a
                }))
            }
            function lx(s) {
                let n = s.value
                  , a = s.key
                  , u = Cl(s);
                return u.length || (n.indexOf("{fontstack}") === -1 && u.push(new rn(a,n,'"glyphs" url must include a "{fontstack}" token')),
                n.indexOf("{range}") === -1 && u.push(new rn(a,n,'"glyphs" url must include a "{range}" token'))),
                u
            }
            function Wg(s, n=ht) {
                return Io(Hr({
                    key: "",
                    value: s,
                    valueSpec: n.$root,
                    styleSpec: n,
                    style: s,
                    objectElementValidators: {
                        glyphs: lx,
                        "*": ()=>[]
                    }
                }))
            }
            let cx = s=>Io(Ug(s))
              , jg = s=>Io(qf(s));
            function Io(s) {
                return s.slice().sort((n,a)=>n.line && a.line ? n.line - a.line : 0)
            }
            function Xg(s, n) {
                let a = !1;
                if (n && n.length)
                    for (let u of n)
                        s.fire(new ar(new Error(u.message))),
                        a = !0;
                return a
            }
            var Dl = uo;
            function uo(s, n, a) {
                var u = this.cells = [];
                if (s instanceof ArrayBuffer) {
                    this.arrayBuffer = s;
                    var f = new Int32Array(this.arrayBuffer);
                    s = f[0],
                    this.d = (n = f[1]) + 2 * (a = f[2]);
                    for (var g = 0; g < this.d * this.d; g++) {
                        var y = f[3 + g]
                          , w = f[3 + g + 1];
                        u.push(y === w ? null : f.subarray(y, w))
                    }
                    var S = f[3 + u.length + 1];
                    this.keys = f.subarray(f[3 + u.length], S),
                    this.bboxes = f.subarray(S),
                    this.insert = this._insertReadonly
                } else {
                    this.d = n + 2 * a;
                    for (var M = 0; M < this.d * this.d; M++)
                        u.push([]);
                    this.keys = [],
                    this.bboxes = []
                }
                this.n = n,
                this.extent = s,
                this.padding = a,
                this.scale = n / s,
                this.uid = 0;
                var z = a / n * s;
                this.min = -z,
                this.max = s + z
            }
            uo.prototype.insert = function(s, n, a, u, f) {
                this._forEachCell(n, a, u, f, this._insertCell, this.uid++),
                this.keys.push(s),
                this.bboxes.push(n),
                this.bboxes.push(a),
                this.bboxes.push(u),
                this.bboxes.push(f)
            }
            ,
            uo.prototype._insertReadonly = function() {
                throw "Cannot insert into a GridIndex created from an ArrayBuffer."
            }
            ,
            uo.prototype._insertCell = function(s, n, a, u, f, g) {
                this.cells[f].push(g)
            }
            ,
            uo.prototype.query = function(s, n, a, u, f) {
                var g = this.min
                  , y = this.max;
                if (s <= g && n <= g && y <= a && y <= u && !f)
                    return Array.prototype.slice.call(this.keys);
                var w = [];
                return this._forEachCell(s, n, a, u, this._queryCell, w, {}, f),
                w
            }
            ,
            uo.prototype._queryCell = function(s, n, a, u, f, g, y, w) {
                var S = this.cells[f];
                if (S !== null)
                    for (var M = this.keys, z = this.bboxes, N = 0; N < S.length; N++) {
                        var B = S[N];
                        if (y[B] === void 0) {
                            var H = 4 * B;
                            (w ? w(z[H + 0], z[H + 1], z[H + 2], z[H + 3]) : s <= z[H + 2] && n <= z[H + 3] && a >= z[H + 0] && u >= z[H + 1]) ? (y[B] = !0,
                            g.push(M[B])) : y[B] = !1
                        }
                    }
            }
            ,
            uo.prototype._forEachCell = function(s, n, a, u, f, g, y, w) {
                for (var S = this._convertToCellCoord(s), M = this._convertToCellCoord(n), z = this._convertToCellCoord(a), N = this._convertToCellCoord(u), B = S; B <= z; B++)
                    for (var H = M; H <= N; H++) {
                        var q = this.d * H + B;
                        if ((!w || w(this._convertFromCellCoord(B), this._convertFromCellCoord(H), this._convertFromCellCoord(B + 1), this._convertFromCellCoord(H + 1))) && f.call(this, s, n, a, u, q, g, y, w))
                            return
                    }
            }
            ,
            uo.prototype._convertFromCellCoord = function(s) {
                return (s - this.padding) / this.scale
            }
            ,
            uo.prototype._convertToCellCoord = function(s) {
                return Math.max(0, Math.min(this.d - 1, Math.floor(s * this.scale) + this.padding))
            }
            ,
            uo.prototype.toArrayBuffer = function() {
                if (this.arrayBuffer)
                    return this.arrayBuffer;
                for (var s = this.cells, n = 3 + this.cells.length + 1 + 1, a = 0, u = 0; u < this.cells.length; u++)
                    a += this.cells[u].length;
                var f = new Int32Array(n + a + this.keys.length + this.bboxes.length);
                f[0] = this.extent,
                f[1] = this.n,
                f[2] = this.padding;
                for (var g = n, y = 0; y < s.length; y++) {
                    var w = s[y];
                    f[3 + y] = g,
                    f.set(w, g),
                    g += w.length
                }
                return f[3 + s.length] = g,
                f.set(this.keys, g),
                f[3 + s.length + 1] = g += this.keys.length,
                f.set(this.bboxes, g),
                g += this.bboxes.length,
                f.buffer
            }
            ;
            let Hh = {};
            function cn(s, n, a={}) {
                Object.defineProperty(s, "_classRegistryKey", {
                    value: n,
                    writeable: !1
                }),
                Hh[n] = {
                    klass: s,
                    omit: a.omit || []
                }
            }
            cn(Object, "Object"),
            Dl.serialize = function(s, n) {
                let a = s.toArrayBuffer();
                return n && n.push(a),
                {
                    buffer: a
                }
            }
            ,
            Dl.deserialize = function(s) {
                return new Dl(s.buffer)
            }
            ,
            Object.defineProperty(Dl, "name", {
                value: "Grid"
            }),
            cn(Dl, "Grid"),
            cn(nr, "Color"),
            cn(Error, "Error"),
            cn(ln, "AJAXError"),
            cn(ls, "ResolvedImage"),
            cn(Zc, "StylePropertyFunction"),
            cn(Ph, "StyleExpression", {
                omit: ["_evaluator"]
            }),
            cn(Ra, "ZoomDependentExpression"),
            cn(kh, "ZoomConstantExpression"),
            cn(qo, "CompoundExpression", {
                omit: ["_evaluate"]
            });
            for (let s in wl)
                Hh[wl[s]._classRegistryKey] || cn(wl[s], `Expression ${s}`);
            function Zg(s) {
                return s && typeof ArrayBuffer != "undefined" && (s instanceof ArrayBuffer || s.constructor && s.constructor.name === "ArrayBuffer")
            }
            function Qc(s) {
                return v.ImageBitmap && s instanceof v.ImageBitmap
            }
            function eu(s, n) {
                if (s == null || typeof s == "boolean" || typeof s == "number" || typeof s == "string" || s instanceof Boolean || s instanceof Number || s instanceof String || s instanceof Date || s instanceof RegExp)
                    return s;
                if (Zg(s) || Qc(s))
                    return n && n.push(s),
                    s;
                if (ArrayBuffer.isView(s)) {
                    let a = s;
                    return n && n.push(a.buffer),
                    a
                }
                if (s instanceof v.ImageData)
                    return n && n.push(s.data.buffer),
                    s;
                if (Array.isArray(s)) {
                    let a = [];
                    for (let u of s)
                        a.push(eu(u, n));
                    return a
                }
                if (typeof s == "object") {
                    let a = s.constructor
                      , u = a._classRegistryKey;
                    if (!u)
                        throw new Error(`can't serialize object of unregistered class ${u}`);
                    let f = a.serialize ? a.serialize(s, n) : {};
                    if (!a.serialize) {
                        for (let g in s)
                            s.hasOwnProperty(g) && (Hh[u].omit.indexOf(g) >= 0 || (f[g] = eu(s[g], n)));
                        s instanceof Error && (f.message = s.message)
                    }
                    if (f.$name)
                        throw new Error("$name property is reserved for worker serialization logic.");
                    return u !== "Object" && (f.$name = u),
                    f
                }
                throw new Error("can't serialize object of type " + typeof s)
            }
            function tu(s) {
                if (s == null || typeof s == "boolean" || typeof s == "number" || typeof s == "string" || s instanceof Boolean || s instanceof Number || s instanceof String || s instanceof Date || s instanceof RegExp || Zg(s) || Qc(s) || ArrayBuffer.isView(s) || s instanceof v.ImageData)
                    return s;
                if (Array.isArray(s))
                    return s.map(tu);
                if (typeof s == "object") {
                    let n = s.$name || "Object"
                      , {klass: a} = Hh[n];
                    if (!a)
                        throw new Error(`can't deserialize unregistered class ${n}`);
                    if (a.deserialize)
                        return a.deserialize(s);
                    let u = Object.create(a.prototype);
                    for (let f of Object.keys(s))
                        f !== "$name" && (u[f] = tu(s[f]));
                    return u
                }
                throw new Error("can't deserialize object of type " + typeof s)
            }
            let nu = s=>s >= 1536 && s <= 1791
              , qg = s=>s >= 1872 && s <= 1919
              , Jf = s=>s >= 2208 && s <= 2303
              , Kg = s=>s >= 11904 && s <= 12031
              , $f = s=>s >= 12032 && s <= 12255
              , Qf = s=>s >= 12272 && s <= 12287
              , iu = s=>s >= 12288 && s <= 12351
              , Wh = s=>s >= 12352 && s <= 12447
              , Ll = s=>s >= 12448 && s <= 12543
              , jh = s=>s >= 12544 && s <= 12591
              , Yg = s=>s >= 12704 && s <= 12735
              , Jg = s=>s >= 12736 && s <= 12783
              , ep = s=>s >= 12784 && s <= 12799
              , $g = s=>s >= 12800 && s <= 13055
              , Qg = s=>s >= 13056 && s <= 13311
              , e_ = s=>s >= 13312 && s <= 19903
              , tp = s=>s >= 19968 && s <= 40959
              , t_ = s=>s >= 40960 && s <= 42127
              , n_ = s=>s >= 42128 && s <= 42191
              , i_ = s=>s >= 44032 && s <= 55215
              , r_ = s=>s >= 63744 && s <= 64255
              , Xh = s=>s >= 64336 && s <= 65023
              , ru = s=>s >= 65040 && s <= 65055
              , m = s=>s >= 65072 && s <= 65103
              , l = s=>s >= 65104 && s <= 65135
              , h = s=>s >= 65136 && s <= 65279
              , _ = s=>s >= 65280 && s <= 65519;
            function b(s) {
                for (let n of s)
                    if (R(n.charCodeAt(0)))
                        return !0;
                return !1
            }
            function T(s) {
                for (let n of s)
                    if (!L(n.charCodeAt(0)))
                        return !1;
                return !0
            }
            function L(s) {
                return !(nu(s) || qg(s) || Jf(s) || Xh(s) || h(s))
            }
            function R(s) {
                return !(s !== 746 && s !== 747 && (s < 4352 || !(Yg(s) || jh(s) || m(s) && !(s >= 65097 && s <= 65103) || r_(s) || Qg(s) || Kg(s) || Jg(s) || !(!iu(s) || s >= 12296 && s <= 12305 || s >= 12308 && s <= 12319 || s === 12336) || e_(s) || tp(s) || $g(s) || (n=>n >= 12592 && n <= 12687)(s) || (n=>n >= 43360 && n <= 43391)(s) || (n=>n >= 55216 && n <= 55295)(s) || (n=>n >= 4352 && n <= 4607)(s) || i_(s) || Wh(s) || Qf(s) || (n=>n >= 12688 && n <= 12703)(s) || $f(s) || ep(s) || Ll(s) && s !== 12540 || !(!_(s) || s === 65288 || s === 65289 || s === 65293 || s >= 65306 && s <= 65310 || s === 65339 || s === 65341 || s === 65343 || s >= 65371 && s <= 65503 || s === 65507 || s >= 65512 && s <= 65519) || !(!l(s) || s >= 65112 && s <= 65118 || s >= 65123 && s <= 65126) || (n=>n >= 5120 && n <= 5759)(s) || (n=>n >= 6320 && n <= 6399)(s) || ru(s) || (n=>n >= 19904 && n <= 19967)(s) || t_(s) || n_(s))))
            }
            function O(s) {
                return !(R(s) || function(n) {
                    return !!((a=>a >= 128 && a <= 255)(n) && (n === 167 || n === 169 || n === 174 || n === 177 || n === 188 || n === 189 || n === 190 || n === 215 || n === 247) || (a=>a >= 8192 && a <= 8303)(n) && (n === 8214 || n === 8224 || n === 8225 || n === 8240 || n === 8241 || n === 8251 || n === 8252 || n === 8258 || n === 8263 || n === 8264 || n === 8265 || n === 8273) || (a=>a >= 8448 && a <= 8527)(n) || (a=>a >= 8528 && a <= 8591)(n) || (a=>a >= 8960 && a <= 9215)(n) && (n >= 8960 && n <= 8967 || n >= 8972 && n <= 8991 || n >= 8996 && n <= 9e3 || n === 9003 || n >= 9085 && n <= 9114 || n >= 9150 && n <= 9165 || n === 9167 || n >= 9169 && n <= 9179 || n >= 9186 && n <= 9215) || (a=>a >= 9216 && a <= 9279)(n) && n !== 9251 || (a=>a >= 9280 && a <= 9311)(n) || (a=>a >= 9312 && a <= 9471)(n) || (a=>a >= 9632 && a <= 9727)(n) || (a=>a >= 9728 && a <= 9983)(n) && !(n >= 9754 && n <= 9759) || (a=>a >= 11008 && a <= 11263)(n) && (n >= 11026 && n <= 11055 || n >= 11088 && n <= 11097 || n >= 11192 && n <= 11243) || iu(n) || Ll(n) || (a=>a >= 57344 && a <= 63743)(n) || m(n) || l(n) || _(n) || n === 8734 || n === 8756 || n === 8757 || n >= 9984 && n <= 10087 || n >= 10102 && n <= 10131 || n === 65532 || n === 65533)
                }(s))
            }
            function V(s) {
                return s >= 1424 && s <= 2303 || Xh(s) || h(s)
            }
            function G(s, n) {
                return !(!n && V(s) || s >= 2304 && s <= 3583 || s >= 3840 && s <= 4255 || (a=>a >= 6016 && a <= 6143)(s))
            }
            function J(s) {
                for (let n of s)
                    if (V(n.charCodeAt(0)))
                        return !0;
                return !1
            }
            let le = "deferred"
              , me = "loading"
              , pe = "loaded"
              , ge = null
              , ve = "unavailable"
              , re = null
              , Ce = function(s) {
                s && typeof s == "string" && s.indexOf("NetworkError") > -1 && (ve = "error"),
                ge && ge(s)
            };
            function Ae() {
                De.fire(new On("pluginStateChange",{
                    pluginStatus: ve,
                    pluginURL: re
                }))
            }
            let De = new pr
              , Ve = function() {
                return ve
            }
              , Fe = function() {
                if (ve !== le || !re)
                    throw new Error("rtl-text-plugin cannot be downloaded unless a pluginURL is specified");
                ve = me,
                Ae(),
                re && Wt({
                    url: re
                }, s=>{
                    s ? Ce(s) : (ve = pe,
                    Ae())
                }
                )
            }
              , Xe = {
                applyArabicShaping: null,
                processBidirectionalText: null,
                processStyledBidirectionalText: null,
                isLoaded: ()=>ve === pe || Xe.applyArabicShaping != null,
                isLoading: ()=>ve === me,
                setState(s) {
                    ve = s.pluginStatus,
                    re = s.pluginURL
                },
                isParsed: ()=>Xe.applyArabicShaping != null && Xe.processBidirectionalText != null && Xe.processStyledBidirectionalText != null,
                getPluginURL: ()=>re
            };
            class $e {
                constructor(n, a) {
                    this.zoom = n,
                    a ? (this.now = a.now,
                    this.fadeDuration = a.fadeDuration,
                    this.transition = a.transition,
                    this.pitch = a.pitch) : (this.now = 0,
                    this.fadeDuration = 0,
                    this.transition = {},
                    this.pitch = 0)
                }
                isSupportedScript(n) {
                    return function(a, u) {
                        for (let f of a)
                            if (!G(f.charCodeAt(0), u))
                                return !1;
                        return !0
                    }(n, Xe.isLoaded())
                }
            }
            class rt {
                constructor(n, a) {
                    this.property = n,
                    this.value = a,
                    this.expression = function(u, f) {
                        if (Lh(u))
                            return new Zc(u,f);
                        if (Sl(u)) {
                            let g = Pa(u, f);
                            if (g.result === "error")
                                throw new Error(g.value.map(y=>`${y.key}: ${y.message}`).join(", "));
                            return g.value
                        }
                        {
                            let g = u;
                            return typeof u == "string" && f.type === "color" && (g = nr.parse(u)),
                            {
                                kind: "constant",
                                evaluate: ()=>g
                            }
                        }
                    }(a === void 0 ? n.specification.default : a, n.specification)
                }
                isDataDriven() {
                    return this.expression.kind === "source" || this.expression.kind === "composite"
                }
                possiblyEvaluate(n, a, u) {
                    return this.property.possiblyEvaluate(this, n, a, u)
                }
            }
            class lt {
                constructor(n) {
                    this.property = n,
                    this.value = new rt(n,void 0)
                }
                transitioned(n, a) {
                    return new nt(this.property,this.value,a,Ke({}, n.transition, this.transition),n.now)
                }
                untransitioned() {
                    return new nt(this.property,this.value,null,{},0)
                }
            }
            class Vt {
                constructor(n) {
                    this._properties = n,
                    this._values = Object.create(n.defaultTransitionablePropertyValues)
                }
                getValue(n) {
                    return Bt(this._values[n].value.value)
                }
                setValue(n, a) {
                    this._values.hasOwnProperty(n) || (this._values[n] = new lt(this._values[n].property)),
                    this._values[n].value = new rt(this._values[n].property,a === null ? void 0 : Bt(a))
                }
                getTransition(n) {
                    return Bt(this._values[n].transition)
                }
                setTransition(n, a) {
                    this._values.hasOwnProperty(n) || (this._values[n] = new lt(this._values[n].property)),
                    this._values[n].transition = Bt(a) || void 0
                }
                serialize() {
                    let n = {};
                    for (let a of Object.keys(this._values)) {
                        let u = this.getValue(a);
                        u !== void 0 && (n[a] = u);
                        let f = this.getTransition(a);
                        f !== void 0 && (n[`${a}-transition`] = f)
                    }
                    return n
                }
                transitioned(n, a) {
                    let u = new vt(this._properties);
                    for (let f of Object.keys(this._values))
                        u._values[f] = this._values[f].transitioned(n, a._values[f]);
                    return u
                }
                untransitioned() {
                    let n = new vt(this._properties);
                    for (let a of Object.keys(this._values))
                        n._values[a] = this._values[a].untransitioned();
                    return n
                }
            }
            class nt {
                constructor(n, a, u, f, g) {
                    let y = f.delay || 0
                      , w = f.duration || 0;
                    g = g || 0,
                    this.property = n,
                    this.value = a,
                    this.begin = g + y,
                    this.end = this.begin + w,
                    n.specification.transition && (f.delay || f.duration) && (this.prior = u)
                }
                possiblyEvaluate(n, a, u) {
                    let f = n.now || 0
                      , g = this.value.possiblyEvaluate(n, a, u)
                      , y = this.prior;
                    if (y) {
                        if (f > this.end)
                            return this.prior = null,
                            g;
                        if (this.value.isDataDriven())
                            return this.prior = null,
                            g;
                        if (f < this.begin)
                            return y.possiblyEvaluate(n, a, u);
                        {
                            let w = (f - this.begin) / (this.end - this.begin);
                            return this.property.interpolate(y.possiblyEvaluate(n, a, u), g, ne(w))
                        }
                    }
                    return g
                }
            }
            class vt {
                constructor(n) {
                    this._properties = n,
                    this._values = Object.create(n.defaultTransitioningPropertyValues)
                }
                possiblyEvaluate(n, a, u) {
                    let f = new st(this._properties);
                    for (let g of Object.keys(this._values))
                        f._values[g] = this._values[g].possiblyEvaluate(n, a, u);
                    return f
                }
                hasTransition() {
                    for (let n of Object.keys(this._values))
                        if (this._values[n].prior)
                            return !0;
                    return !1
                }
            }
            class pt {
                constructor(n) {
                    this._properties = n,
                    this._values = Object.create(n.defaultPropertyValues)
                }
                getValue(n) {
                    return Bt(this._values[n].value)
                }
                setValue(n, a) {
                    this._values[n] = new rt(this._values[n].property,a === null ? void 0 : Bt(a))
                }
                serialize() {
                    let n = {};
                    for (let a of Object.keys(this._values)) {
                        let u = this.getValue(a);
                        u !== void 0 && (n[a] = u)
                    }
                    return n
                }
                possiblyEvaluate(n, a, u) {
                    let f = new st(this._properties);
                    for (let g of Object.keys(this._values))
                        f._values[g] = this._values[g].possiblyEvaluate(n, a, u);
                    return f
                }
            }
            class Dt {
                constructor(n, a, u) {
                    this.property = n,
                    this.value = a,
                    this.parameters = u
                }
                isConstant() {
                    return this.value.kind === "constant"
                }
                constantOr(n) {
                    return this.value.kind === "constant" ? this.value.value : n
                }
                evaluate(n, a, u, f) {
                    return this.property.evaluate(this.value, this.parameters, n, a, u, f)
                }
            }
            class st {
                constructor(n) {
                    this._properties = n,
                    this._values = Object.create(n.defaultPossiblyEvaluatedValues)
                }
                get(n) {
                    return this._values[n]
                }
            }
            class Je {
                constructor(n) {
                    this.specification = n
                }
                possiblyEvaluate(n, a) {
                    return n.expression.evaluate(a)
                }
                interpolate(n, a, u) {
                    let f = Uc[this.specification.type];
                    return f ? f(n, a, u) : n
                }
            }
            class ct {
                constructor(n, a) {
                    this.specification = n,
                    this.overrides = a
                }
                possiblyEvaluate(n, a, u, f) {
                    return new Dt(this,n.expression.kind === "constant" || n.expression.kind === "camera" ? {
                        kind: "constant",
                        value: n.expression.evaluate(a, null, {}, u, f)
                    } : n.expression,a)
                }
                interpolate(n, a, u) {
                    if (n.value.kind !== "constant" || a.value.kind !== "constant")
                        return n;
                    if (n.value.value === void 0 || a.value.value === void 0)
                        return new Dt(this,{
                            kind: "constant",
                            value: void 0
                        },n.parameters);
                    let f = Uc[this.specification.type];
                    return f ? new Dt(this,{
                        kind: "constant",
                        value: f(n.value.value, a.value.value, u)
                    },n.parameters) : n
                }
                evaluate(n, a, u, f, g, y) {
                    return n.kind === "constant" ? n.value : n.evaluate(a, u, f, g, y)
                }
            }
            class At {
                constructor(n) {
                    this.specification = n
                }
                possiblyEvaluate(n, a, u, f) {
                    return !!n.expression.evaluate(a, null, {}, u, f)
                }
                interpolate() {
                    return !1
                }
            }
            class Pt {
                constructor(n) {
                    this.properties = n,
                    this.defaultPropertyValues = {},
                    this.defaultTransitionablePropertyValues = {},
                    this.defaultTransitioningPropertyValues = {},
                    this.defaultPossiblyEvaluatedValues = {},
                    this.overridableProperties = [];
                    let a = new $e(0,{});
                    for (let u in n) {
                        let f = n[u];
                        f.specification.overridable && this.overridableProperties.push(u);
                        let g = this.defaultPropertyValues[u] = new rt(f,void 0)
                          , y = this.defaultTransitionablePropertyValues[u] = new lt(f);
                        this.defaultTransitioningPropertyValues[u] = y.untransitioned(),
                        this.defaultPossiblyEvaluatedValues[u] = g.possiblyEvaluate(a)
                    }
                }
            }
            function pn(s, n) {
                return 256 * (s = ae(Math.floor(s), 0, 255)) + ae(Math.floor(n), 0, 255)
            }
            cn(ct, "DataDrivenProperty"),
            cn(Je, "DataConstantProperty"),
            cn(At, "ColorRampProperty");
            let Xn = {
                Int8: Int8Array,
                Uint8: Uint8Array,
                Int16: Int16Array,
                Uint16: Uint16Array,
                Int32: Int32Array,
                Uint32: Uint32Array,
                Float32: Float32Array
            };
            class un {
                constructor(n, a) {
                    this._structArray = n,
                    this._pos1 = a * this.size,
                    this._pos2 = this._pos1 / 2,
                    this._pos4 = this._pos1 / 4,
                    this._pos8 = this._pos1 / 8
                }
            }
            class sn {
                constructor() {
                    this.isTransferred = !1,
                    this.capacity = -1,
                    this.resize(0)
                }
                static serialize(n, a) {
                    return n._trim(),
                    a && (n.isTransferred = !0,
                    a.push(n.arrayBuffer)),
                    {
                        length: n.length,
                        arrayBuffer: n.arrayBuffer
                    }
                }
                static deserialize(n) {
                    let a = Object.create(this.prototype);
                    return a.arrayBuffer = n.arrayBuffer,
                    a.length = n.length,
                    a.capacity = n.arrayBuffer.byteLength / a.bytesPerElement,
                    a._refreshViews(),
                    a
                }
                _trim() {
                    this.length !== this.capacity && (this.capacity = this.length,
                    this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement),
                    this._refreshViews())
                }
                clear() {
                    this.length = 0
                }
                resize(n) {
                    this.reserve(n),
                    this.length = n
                }
                reserve(n) {
                    if (n > this.capacity) {
                        this.capacity = Math.max(n, Math.floor(5 * this.capacity), 128),
                        this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
                        let a = this.uint8;
                        this._refreshViews(),
                        a && this.uint8.set(a)
                    }
                }
                _refreshViews() {
                    throw new Error("_refreshViews() must be implemented by each concrete StructArray layout")
                }
                destroy() {
                    this.int8 = this.uint8 = this.int16 = this.uint16 = this.int32 = this.uint32 = this.float32 = null,
                    this.arrayBuffer = null
                }
            }
            function vn(s, n=1) {
                let a = 0
                  , u = 0;
                return {
                    members: s.map(f=>{
                        let g = Xn[f.type].BYTES_PER_ELEMENT
                          , y = a = Qn(a, Math.max(n, g))
                          , w = f.components || 1;
                        return u = Math.max(u, g),
                        a += g * w,
                        {
                            name: f.name,
                            type: f.type,
                            components: w,
                            offset: y
                        }
                    }
                    ),
                    size: Qn(a, Math.max(u, n)),
                    alignment: n
                }
            }
            function Qn(s, n) {
                return Math.ceil(s / n) * n
            }
            class En extends sn {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer),
                    this.int16 = new Int16Array(this.arrayBuffer)
                }
                emplaceBack(n, a) {
                    let u = this.length;
                    return this.resize(u + 1),
                    this.emplace(u, n, a)
                }
                emplace(n, a, u) {
                    let f = 2 * n;
                    return this.int16[f + 0] = a,
                    this.int16[f + 1] = u,
                    n
                }
            }
            En.prototype.bytesPerElement = 4,
            cn(En, "StructArrayLayout2i4");
            class pi extends sn {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer),
                    this.int16 = new Int16Array(this.arrayBuffer)
                }
                emplaceBack(n, a, u) {
                    let f = this.length;
                    return this.resize(f + 1),
                    this.emplace(f, n, a, u)
                }
                emplace(n, a, u, f) {
                    let g = 3 * n;
                    return this.int16[g + 0] = a,
                    this.int16[g + 1] = u,
                    this.int16[g + 2] = f,
                    n
                }
            }
            pi.prototype.bytesPerElement = 6,
            cn(pi, "StructArrayLayout3i6");
            class Ti extends sn {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer),
                    this.int16 = new Int16Array(this.arrayBuffer)
                }
                emplaceBack(n, a, u, f) {
                    let g = this.length;
                    return this.resize(g + 1),
                    this.emplace(g, n, a, u, f)
                }
                emplace(n, a, u, f, g) {
                    let y = 4 * n;
                    return this.int16[y + 0] = a,
                    this.int16[y + 1] = u,
                    this.int16[y + 2] = f,
                    this.int16[y + 3] = g,
                    n
                }
            }
            Ti.prototype.bytesPerElement = 8,
            cn(Ti, "StructArrayLayout4i8");
            class Ri extends sn {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer),
                    this.int16 = new Int16Array(this.arrayBuffer),
                    this.float32 = new Float32Array(this.arrayBuffer)
                }
                emplaceBack(n, a, u, f, g, y, w) {
                    let S = this.length;
                    return this.resize(S + 1),
                    this.emplace(S, n, a, u, f, g, y, w)
                }
                emplace(n, a, u, f, g, y, w, S) {
                    let M = 6 * n
                      , z = 12 * n
                      , N = 3 * n;
                    return this.int16[M + 0] = a,
                    this.int16[M + 1] = u,
                    this.uint8[z + 4] = f,
                    this.uint8[z + 5] = g,
                    this.uint8[z + 6] = y,
                    this.uint8[z + 7] = w,
                    this.float32[N + 2] = S,
                    n
                }
            }
            Ri.prototype.bytesPerElement = 12,
            cn(Ri, "StructArrayLayout2i4ub1f12");
            class Mi extends sn {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer),
                    this.float32 = new Float32Array(this.arrayBuffer)
                }
                emplaceBack(n, a, u, f) {
                    let g = this.length;
                    return this.resize(g + 1),
                    this.emplace(g, n, a, u, f)
                }
                emplace(n, a, u, f, g) {
                    let y = 4 * n;
                    return this.float32[y + 0] = a,
                    this.float32[y + 1] = u,
                    this.float32[y + 2] = f,
                    this.float32[y + 3] = g,
                    n
                }
            }
            Mi.prototype.bytesPerElement = 16,
            cn(Mi, "StructArrayLayout4f16");
            class lr extends sn {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer),
                    this.uint16 = new Uint16Array(this.arrayBuffer),
                    this.float32 = new Float32Array(this.arrayBuffer)
                }
                emplaceBack(n, a, u, f, g) {
                    let y = this.length;
                    return this.resize(y + 1),
                    this.emplace(y, n, a, u, f, g)
                }
                emplace(n, a, u, f, g, y) {
                    let w = 6 * n
                      , S = 3 * n;
                    return this.uint16[w + 0] = a,
                    this.uint16[w + 1] = u,
                    this.uint16[w + 2] = f,
                    this.uint16[w + 3] = g,
                    this.float32[S + 2] = y,
                    n
                }
            }
            lr.prototype.bytesPerElement = 12,
            cn(lr, "StructArrayLayout4ui1f12");
            class gs extends sn {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer),
                    this.uint16 = new Uint16Array(this.arrayBuffer)
                }
                emplaceBack(n, a, u, f) {
                    let g = this.length;
                    return this.resize(g + 1),
                    this.emplace(g, n, a, u, f)
                }
                emplace(n, a, u, f, g) {
                    let y = 4 * n;
                    return this.uint16[y + 0] = a,
                    this.uint16[y + 1] = u,
                    this.uint16[y + 2] = f,
                    this.uint16[y + 3] = g,
                    n
                }
            }
            gs.prototype.bytesPerElement = 8,
            cn(gs, "StructArrayLayout4ui8");
            class Ks extends sn {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer),
                    this.int16 = new Int16Array(this.arrayBuffer)
                }
                emplaceBack(n, a, u, f, g, y) {
                    let w = this.length;
                    return this.resize(w + 1),
                    this.emplace(w, n, a, u, f, g, y)
                }
                emplace(n, a, u, f, g, y, w) {
                    let S = 6 * n;
                    return this.int16[S + 0] = a,
                    this.int16[S + 1] = u,
                    this.int16[S + 2] = f,
                    this.int16[S + 3] = g,
                    this.int16[S + 4] = y,
                    this.int16[S + 5] = w,
                    n
                }
            }
            Ks.prototype.bytesPerElement = 12,
            cn(Ks, "StructArrayLayout6i12");
            class Co extends sn {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer),
                    this.int16 = new Int16Array(this.arrayBuffer),
                    this.uint16 = new Uint16Array(this.arrayBuffer)
                }
                emplaceBack(n, a, u, f, g, y, w, S, M, z, N, B) {
                    let H = this.length;
                    return this.resize(H + 1),
                    this.emplace(H, n, a, u, f, g, y, w, S, M, z, N, B)
                }
                emplace(n, a, u, f, g, y, w, S, M, z, N, B, H) {
                    let q = 12 * n;
                    return this.int16[q + 0] = a,
                    this.int16[q + 1] = u,
                    this.int16[q + 2] = f,
                    this.int16[q + 3] = g,
                    this.uint16[q + 4] = y,
                    this.uint16[q + 5] = w,
                    this.uint16[q + 6] = S,
                    this.uint16[q + 7] = M,
                    this.int16[q + 8] = z,
                    this.int16[q + 9] = N,
                    this.int16[q + 10] = B,
                    this.int16[q + 11] = H,
                    n
                }
            }
            Co.prototype.bytesPerElement = 24,
            cn(Co, "StructArrayLayout4i4ui4i24");
            class Gi extends sn {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer),
                    this.int16 = new Int16Array(this.arrayBuffer),
                    this.float32 = new Float32Array(this.arrayBuffer)
                }
                emplaceBack(n, a, u, f, g, y) {
                    let w = this.length;
                    return this.resize(w + 1),
                    this.emplace(w, n, a, u, f, g, y)
                }
                emplace(n, a, u, f, g, y, w) {
                    let S = 10 * n
                      , M = 5 * n;
                    return this.int16[S + 0] = a,
                    this.int16[S + 1] = u,
                    this.int16[S + 2] = f,
                    this.float32[M + 2] = g,
                    this.float32[M + 3] = y,
                    this.float32[M + 4] = w,
                    n
                }
            }
            Gi.prototype.bytesPerElement = 20,
            cn(Gi, "StructArrayLayout3i3f20");
            class Ii extends sn {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer),
                    this.uint32 = new Uint32Array(this.arrayBuffer)
                }
                emplaceBack(n) {
                    let a = this.length;
                    return this.resize(a + 1),
                    this.emplace(a, n)
                }
                emplace(n, a) {
                    return this.uint32[1 * n + 0] = a,
                    n
                }
            }
            Ii.prototype.bytesPerElement = 4,
            cn(Ii, "StructArrayLayout1ul4");
            class li extends sn {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer),
                    this.int16 = new Int16Array(this.arrayBuffer),
                    this.float32 = new Float32Array(this.arrayBuffer),
                    this.uint32 = new Uint32Array(this.arrayBuffer),
                    this.uint16 = new Uint16Array(this.arrayBuffer)
                }
                emplaceBack(n, a, u, f, g, y, w, S, M, z, N, B, H) {
                    let q = this.length;
                    return this.resize(q + 1),
                    this.emplace(q, n, a, u, f, g, y, w, S, M, z, N, B, H)
                }
                emplace(n, a, u, f, g, y, w, S, M, z, N, B, H, q) {
                    let Q = 20 * n
                      , de = 10 * n;
                    return this.int16[Q + 0] = a,
                    this.int16[Q + 1] = u,
                    this.int16[Q + 2] = f,
                    this.int16[Q + 3] = g,
                    this.int16[Q + 4] = y,
                    this.float32[de + 3] = w,
                    this.float32[de + 4] = S,
                    this.float32[de + 5] = M,
                    this.float32[de + 6] = z,
                    this.int16[Q + 14] = N,
                    this.uint32[de + 8] = B,
                    this.uint16[Q + 18] = H,
                    this.uint16[Q + 19] = q,
                    n
                }
            }
            li.prototype.bytesPerElement = 40,
            cn(li, "StructArrayLayout5i4f1i1ul2ui40");
            class Ji extends sn {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer),
                    this.int16 = new Int16Array(this.arrayBuffer)
                }
                emplaceBack(n, a, u, f, g, y, w) {
                    let S = this.length;
                    return this.resize(S + 1),
                    this.emplace(S, n, a, u, f, g, y, w)
                }
                emplace(n, a, u, f, g, y, w, S) {
                    let M = 8 * n;
                    return this.int16[M + 0] = a,
                    this.int16[M + 1] = u,
                    this.int16[M + 2] = f,
                    this.int16[M + 4] = g,
                    this.int16[M + 5] = y,
                    this.int16[M + 6] = w,
                    this.int16[M + 7] = S,
                    n
                }
            }
            Ji.prototype.bytesPerElement = 16,
            cn(Ji, "StructArrayLayout3i2i2i16");
            class Wr extends sn {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer),
                    this.float32 = new Float32Array(this.arrayBuffer),
                    this.int16 = new Int16Array(this.arrayBuffer)
                }
                emplaceBack(n, a, u, f, g) {
                    let y = this.length;
                    return this.resize(y + 1),
                    this.emplace(y, n, a, u, f, g)
                }
                emplace(n, a, u, f, g, y) {
                    let w = 4 * n
                      , S = 8 * n;
                    return this.float32[w + 0] = a,
                    this.float32[w + 1] = u,
                    this.float32[w + 2] = f,
                    this.int16[S + 6] = g,
                    this.int16[S + 7] = y,
                    n
                }
            }
            Wr.prototype.bytesPerElement = 16,
            cn(Wr, "StructArrayLayout2f1f2i16");
            class Oi extends sn {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer),
                    this.float32 = new Float32Array(this.arrayBuffer)
                }
                emplaceBack(n, a, u, f) {
                    let g = this.length;
                    return this.resize(g + 1),
                    this.emplace(g, n, a, u, f)
                }
                emplace(n, a, u, f, g) {
                    let y = 12 * n
                      , w = 3 * n;
                    return this.uint8[y + 0] = a,
                    this.uint8[y + 1] = u,
                    this.float32[w + 1] = f,
                    this.float32[w + 2] = g,
                    n
                }
            }
            Oi.prototype.bytesPerElement = 12,
            cn(Oi, "StructArrayLayout2ub2f12");
            class jr extends sn {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer),
                    this.float32 = new Float32Array(this.arrayBuffer)
                }
                emplaceBack(n, a, u) {
                    let f = this.length;
                    return this.resize(f + 1),
                    this.emplace(f, n, a, u)
                }
                emplace(n, a, u, f) {
                    let g = 3 * n;
                    return this.float32[g + 0] = a,
                    this.float32[g + 1] = u,
                    this.float32[g + 2] = f,
                    n
                }
            }
            jr.prototype.bytesPerElement = 12,
            cn(jr, "StructArrayLayout3f12");
            class Xr extends sn {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer),
                    this.uint16 = new Uint16Array(this.arrayBuffer)
                }
                emplaceBack(n, a, u) {
                    let f = this.length;
                    return this.resize(f + 1),
                    this.emplace(f, n, a, u)
                }
                emplace(n, a, u, f) {
                    let g = 3 * n;
                    return this.uint16[g + 0] = a,
                    this.uint16[g + 1] = u,
                    this.uint16[g + 2] = f,
                    n
                }
            }
            Xr.prototype.bytesPerElement = 6,
            cn(Xr, "StructArrayLayout3ui6");
            class $o extends sn {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer),
                    this.int16 = new Int16Array(this.arrayBuffer),
                    this.float32 = new Float32Array(this.arrayBuffer),
                    this.uint16 = new Uint16Array(this.arrayBuffer),
                    this.uint32 = new Uint32Array(this.arrayBuffer)
                }
                emplaceBack(n, a, u, f, g, y, w, S, M, z, N, B, H, q, Q, de, Me, Pe, we, Le, Ue) {
                    let Ne = this.length;
                    return this.resize(Ne + 1),
                    this.emplace(Ne, n, a, u, f, g, y, w, S, M, z, N, B, H, q, Q, de, Me, Pe, we, Le, Ue)
                }
                emplace(n, a, u, f, g, y, w, S, M, z, N, B, H, q, Q, de, Me, Pe, we, Le, Ue, Ne) {
                    let at = 30 * n
                      , it = 15 * n
                      , _t = 60 * n;
                    return this.int16[at + 0] = a,
                    this.int16[at + 1] = u,
                    this.int16[at + 2] = f,
                    this.float32[it + 2] = g,
                    this.float32[it + 3] = y,
                    this.uint16[at + 8] = w,
                    this.uint16[at + 9] = S,
                    this.uint32[it + 5] = M,
                    this.uint32[it + 6] = z,
                    this.uint32[it + 7] = N,
                    this.uint16[at + 16] = B,
                    this.uint16[at + 17] = H,
                    this.uint16[at + 18] = q,
                    this.float32[it + 10] = Q,
                    this.float32[it + 11] = de,
                    this.uint8[_t + 48] = Me,
                    this.uint8[_t + 49] = Pe,
                    this.uint8[_t + 50] = we,
                    this.uint32[it + 13] = Le,
                    this.int16[at + 28] = Ue,
                    this.uint8[_t + 58] = Ne,
                    n
                }
            }
            $o.prototype.bytesPerElement = 60,
            cn($o, "StructArrayLayout3i2f2ui3ul3ui2f3ub1ul1i1ub60");
            class Rl extends sn {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer),
                    this.int16 = new Int16Array(this.arrayBuffer),
                    this.float32 = new Float32Array(this.arrayBuffer),
                    this.uint16 = new Uint16Array(this.arrayBuffer),
                    this.uint32 = new Uint32Array(this.arrayBuffer)
                }
                emplaceBack(n, a, u, f, g, y, w, S, M, z, N, B, H, q, Q, de, Me, Pe, we, Le, Ue, Ne, at, it, _t, Ot, dt, yt, Tt, Lt) {
                    let Nt = this.length;
                    return this.resize(Nt + 1),
                    this.emplace(Nt, n, a, u, f, g, y, w, S, M, z, N, B, H, q, Q, de, Me, Pe, we, Le, Ue, Ne, at, it, _t, Ot, dt, yt, Tt, Lt)
                }
                emplace(n, a, u, f, g, y, w, S, M, z, N, B, H, q, Q, de, Me, Pe, we, Le, Ue, Ne, at, it, _t, Ot, dt, yt, Tt, Lt, Nt) {
                    let mt = 38 * n
                      , qt = 19 * n;
                    return this.int16[mt + 0] = a,
                    this.int16[mt + 1] = u,
                    this.int16[mt + 2] = f,
                    this.float32[qt + 2] = g,
                    this.float32[qt + 3] = y,
                    this.int16[mt + 8] = w,
                    this.int16[mt + 9] = S,
                    this.int16[mt + 10] = M,
                    this.int16[mt + 11] = z,
                    this.int16[mt + 12] = N,
                    this.int16[mt + 13] = B,
                    this.uint16[mt + 14] = H,
                    this.uint16[mt + 15] = q,
                    this.uint16[mt + 16] = Q,
                    this.uint16[mt + 17] = de,
                    this.uint16[mt + 18] = Me,
                    this.uint16[mt + 19] = Pe,
                    this.uint16[mt + 20] = we,
                    this.uint16[mt + 21] = Le,
                    this.uint16[mt + 22] = Ue,
                    this.uint16[mt + 23] = Ne,
                    this.uint16[mt + 24] = at,
                    this.uint16[mt + 25] = it,
                    this.uint16[mt + 26] = _t,
                    this.uint16[mt + 27] = Ot,
                    this.uint16[mt + 28] = dt,
                    this.uint32[qt + 15] = yt,
                    this.float32[qt + 16] = Tt,
                    this.float32[qt + 17] = Lt,
                    this.float32[qt + 18] = Nt,
                    n
                }
            }
            Rl.prototype.bytesPerElement = 76,
            cn(Rl, "StructArrayLayout3i2f6i15ui1ul3f76");
            class Ss extends sn {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer),
                    this.float32 = new Float32Array(this.arrayBuffer)
                }
                emplaceBack(n) {
                    let a = this.length;
                    return this.resize(a + 1),
                    this.emplace(a, n)
                }
                emplace(n, a) {
                    return this.float32[1 * n + 0] = a,
                    n
                }
            }
            Ss.prototype.bytesPerElement = 4,
            cn(Ss, "StructArrayLayout1f4");
            class Os extends sn {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer),
                    this.float32 = new Float32Array(this.arrayBuffer)
                }
                emplaceBack(n, a, u, f, g) {
                    let y = this.length;
                    return this.resize(y + 1),
                    this.emplace(y, n, a, u, f, g)
                }
                emplace(n, a, u, f, g, y) {
                    let w = 5 * n;
                    return this.float32[w + 0] = a,
                    this.float32[w + 1] = u,
                    this.float32[w + 2] = f,
                    this.float32[w + 3] = g,
                    this.float32[w + 4] = y,
                    n
                }
            }
            Os.prototype.bytesPerElement = 20,
            cn(Os, "StructArrayLayout5f20");
            class Do extends sn {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer),
                    this.uint32 = new Uint32Array(this.arrayBuffer),
                    this.uint16 = new Uint16Array(this.arrayBuffer)
                }
                emplaceBack(n, a, u, f) {
                    let g = this.length;
                    return this.resize(g + 1),
                    this.emplace(g, n, a, u, f)
                }
                emplace(n, a, u, f, g) {
                    let y = 6 * n;
                    return this.uint32[3 * n + 0] = a,
                    this.uint16[y + 2] = u,
                    this.uint16[y + 3] = f,
                    this.uint16[y + 4] = g,
                    n
                }
            }
            Do.prototype.bytesPerElement = 12,
            cn(Do, "StructArrayLayout1ul3ui12");
            class Qo extends sn {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer),
                    this.uint16 = new Uint16Array(this.arrayBuffer)
                }
                emplaceBack(n, a) {
                    let u = this.length;
                    return this.resize(u + 1),
                    this.emplace(u, n, a)
                }
                emplace(n, a, u) {
                    let f = 2 * n;
                    return this.uint16[f + 0] = a,
                    this.uint16[f + 1] = u,
                    n
                }
            }
            Qo.prototype.bytesPerElement = 4,
            cn(Qo, "StructArrayLayout2ui4");
            class ea extends sn {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer),
                    this.uint16 = new Uint16Array(this.arrayBuffer)
                }
                emplaceBack(n) {
                    let a = this.length;
                    return this.resize(a + 1),
                    this.emplace(a, n)
                }
                emplace(n, a) {
                    return this.uint16[1 * n + 0] = a,
                    n
                }
            }
            ea.prototype.bytesPerElement = 2,
            cn(ea, "StructArrayLayout1ui2");
            class Pl extends sn {
                _refreshViews() {
                    this.uint8 = new Uint8Array(this.arrayBuffer),
                    this.float32 = new Float32Array(this.arrayBuffer)
                }
                emplaceBack(n, a) {
                    let u = this.length;
                    return this.resize(u + 1),
                    this.emplace(u, n, a)
                }
                emplace(n, a, u) {
                    let f = 2 * n;
                    return this.float32[f + 0] = a,
                    this.float32[f + 1] = u,
                    n
                }
            }
            Pl.prototype.bytesPerElement = 8,
            cn(Pl, "StructArrayLayout2f8");
            class kw extends un {
                get projectedAnchorX() {
                    return this._structArray.int16[this._pos2 + 0]
                }
                get projectedAnchorY() {
                    return this._structArray.int16[this._pos2 + 1]
                }
                get projectedAnchorZ() {
                    return this._structArray.int16[this._pos2 + 2]
                }
                get tileAnchorX() {
                    return this._structArray.int16[this._pos2 + 3]
                }
                get tileAnchorY() {
                    return this._structArray.int16[this._pos2 + 4]
                }
                get x1() {
                    return this._structArray.float32[this._pos4 + 3]
                }
                get y1() {
                    return this._structArray.float32[this._pos4 + 4]
                }
                get x2() {
                    return this._structArray.float32[this._pos4 + 5]
                }
                get y2() {
                    return this._structArray.float32[this._pos4 + 6]
                }
                get padding() {
                    return this._structArray.int16[this._pos2 + 14]
                }
                get featureIndex() {
                    return this._structArray.uint32[this._pos4 + 8]
                }
                get sourceLayerIndex() {
                    return this._structArray.uint16[this._pos2 + 18]
                }
                get bucketIndex() {
                    return this._structArray.uint16[this._pos2 + 19]
                }
            }
            kw.prototype.size = 40;
            class ux extends li {
                get(n) {
                    return new kw(this,n)
                }
            }
            cn(ux, "CollisionBoxArray");
            class zw extends un {
                get projectedAnchorX() {
                    return this._structArray.int16[this._pos2 + 0]
                }
                get projectedAnchorY() {
                    return this._structArray.int16[this._pos2 + 1]
                }
                get projectedAnchorZ() {
                    return this._structArray.int16[this._pos2 + 2]
                }
                get tileAnchorX() {
                    return this._structArray.float32[this._pos4 + 2]
                }
                get tileAnchorY() {
                    return this._structArray.float32[this._pos4 + 3]
                }
                get glyphStartIndex() {
                    return this._structArray.uint16[this._pos2 + 8]
                }
                get numGlyphs() {
                    return this._structArray.uint16[this._pos2 + 9]
                }
                get vertexStartIndex() {
                    return this._structArray.uint32[this._pos4 + 5]
                }
                get lineStartIndex() {
                    return this._structArray.uint32[this._pos4 + 6]
                }
                get lineLength() {
                    return this._structArray.uint32[this._pos4 + 7]
                }
                get segment() {
                    return this._structArray.uint16[this._pos2 + 16]
                }
                get lowerSize() {
                    return this._structArray.uint16[this._pos2 + 17]
                }
                get upperSize() {
                    return this._structArray.uint16[this._pos2 + 18]
                }
                get lineOffsetX() {
                    return this._structArray.float32[this._pos4 + 10]
                }
                get lineOffsetY() {
                    return this._structArray.float32[this._pos4 + 11]
                }
                get writingMode() {
                    return this._structArray.uint8[this._pos1 + 48]
                }
                get placedOrientation() {
                    return this._structArray.uint8[this._pos1 + 49]
                }
                set placedOrientation(n) {
                    this._structArray.uint8[this._pos1 + 49] = n
                }
                get hidden() {
                    return this._structArray.uint8[this._pos1 + 50]
                }
                set hidden(n) {
                    this._structArray.uint8[this._pos1 + 50] = n
                }
                get crossTileID() {
                    return this._structArray.uint32[this._pos4 + 13]
                }
                set crossTileID(n) {
                    this._structArray.uint32[this._pos4 + 13] = n
                }
                get associatedIconIndex() {
                    return this._structArray.int16[this._pos2 + 28]
                }
                get flipState() {
                    return this._structArray.uint8[this._pos1 + 58]
                }
                set flipState(n) {
                    this._structArray.uint8[this._pos1 + 58] = n
                }
            }
            zw.prototype.size = 60;
            class Ow extends $o {
                get(n) {
                    return new zw(this,n)
                }
            }
            cn(Ow, "PlacedSymbolArray");
            class Nw extends un {
                get projectedAnchorX() {
                    return this._structArray.int16[this._pos2 + 0]
                }
                get projectedAnchorY() {
                    return this._structArray.int16[this._pos2 + 1]
                }
                get projectedAnchorZ() {
                    return this._structArray.int16[this._pos2 + 2]
                }
                get tileAnchorX() {
                    return this._structArray.float32[this._pos4 + 2]
                }
                get tileAnchorY() {
                    return this._structArray.float32[this._pos4 + 3]
                }
                get rightJustifiedTextSymbolIndex() {
                    return this._structArray.int16[this._pos2 + 8]
                }
                get centerJustifiedTextSymbolIndex() {
                    return this._structArray.int16[this._pos2 + 9]
                }
                get leftJustifiedTextSymbolIndex() {
                    return this._structArray.int16[this._pos2 + 10]
                }
                get verticalPlacedTextSymbolIndex() {
                    return this._structArray.int16[this._pos2 + 11]
                }
                get placedIconSymbolIndex() {
                    return this._structArray.int16[this._pos2 + 12]
                }
                get verticalPlacedIconSymbolIndex() {
                    return this._structArray.int16[this._pos2 + 13]
                }
                get key() {
                    return this._structArray.uint16[this._pos2 + 14]
                }
                get textBoxStartIndex() {
                    return this._structArray.uint16[this._pos2 + 15]
                }
                get textBoxEndIndex() {
                    return this._structArray.uint16[this._pos2 + 16]
                }
                get verticalTextBoxStartIndex() {
                    return this._structArray.uint16[this._pos2 + 17]
                }
                get verticalTextBoxEndIndex() {
                    return this._structArray.uint16[this._pos2 + 18]
                }
                get iconBoxStartIndex() {
                    return this._structArray.uint16[this._pos2 + 19]
                }
                get iconBoxEndIndex() {
                    return this._structArray.uint16[this._pos2 + 20]
                }
                get verticalIconBoxStartIndex() {
                    return this._structArray.uint16[this._pos2 + 21]
                }
                get verticalIconBoxEndIndex() {
                    return this._structArray.uint16[this._pos2 + 22]
                }
                get featureIndex() {
                    return this._structArray.uint16[this._pos2 + 23]
                }
                get numHorizontalGlyphVertices() {
                    return this._structArray.uint16[this._pos2 + 24]
                }
                get numVerticalGlyphVertices() {
                    return this._structArray.uint16[this._pos2 + 25]
                }
                get numIconVertices() {
                    return this._structArray.uint16[this._pos2 + 26]
                }
                get numVerticalIconVertices() {
                    return this._structArray.uint16[this._pos2 + 27]
                }
                get useRuntimeCollisionCircles() {
                    return this._structArray.uint16[this._pos2 + 28]
                }
                get crossTileID() {
                    return this._structArray.uint32[this._pos4 + 15]
                }
                set crossTileID(n) {
                    this._structArray.uint32[this._pos4 + 15] = n
                }
                get textOffset0() {
                    return this._structArray.float32[this._pos4 + 16]
                }
                get textOffset1() {
                    return this._structArray.float32[this._pos4 + 17]
                }
                get collisionCircleDiameter() {
                    return this._structArray.float32[this._pos4 + 18]
                }
            }
            Nw.prototype.size = 76;
            class Fw extends Rl {
                get(n) {
                    return new Nw(this,n)
                }
            }
            cn(Fw, "SymbolInstanceArray");
            class Bw extends Ss {
                getoffsetX(n) {
                    return this.float32[1 * n + 0]
                }
            }
            cn(Bw, "GlyphOffsetArray");
            class Uw extends En {
                getx(n) {
                    return this.int16[2 * n + 0]
                }
                gety(n) {
                    return this.int16[2 * n + 1]
                }
            }
            cn(Uw, "SymbolLineVertexArray");
            class Vw extends un {
                get featureIndex() {
                    return this._structArray.uint32[this._pos4 + 0]
                }
                get sourceLayerIndex() {
                    return this._structArray.uint16[this._pos2 + 2]
                }
                get bucketIndex() {
                    return this._structArray.uint16[this._pos2 + 3]
                }
                get layoutVertexArrayOffset() {
                    return this._structArray.uint16[this._pos2 + 4]
                }
            }
            Vw.prototype.size = 12;
            class Gw extends Do {
                get(n) {
                    return new Vw(this,n)
                }
            }
            cn(Gw, "FeatureIndexArray");
            class Hw extends Qo {
                geta_centroid_pos0(n) {
                    return this.uint16[2 * n + 0]
                }
                geta_centroid_pos1(n) {
                    return this.uint16[2 * n + 1]
                }
            }
            cn(Hw, "FillExtrusionCentroidArray");
            let H3 = vn([{
                name: "a_pattern",
                components: 4,
                type: "Uint16"
            }, {
                name: "a_pixel_ratio",
                components: 1,
                type: "Float32"
            }])
              , W3 = vn([{
                name: "a_dash",
                components: 4,
                type: "Uint16"
            }]);
            var su = {}
              , j3 = {
                get exports() {
                    return su
                },
                set exports(s) {
                    su = s
                }
            }
              , hx = {};
            ({
                get exports() {
                    return hx
                },
                set exports(s) {
                    hx = s
                }
            }).exports = function(s, n) {
                var a, u, f, g, y, w, S, M;
                for (u = s.length - (a = 3 & s.length),
                f = n,
                y = 3432918353,
                w = 461845907,
                M = 0; M < u; )
                    S = 255 & s.charCodeAt(M) | (255 & s.charCodeAt(++M)) << 8 | (255 & s.charCodeAt(++M)) << 16 | (255 & s.charCodeAt(++M)) << 24,
                    ++M,
                    f = 27492 + (65535 & (g = 5 * (65535 & (f = (f ^= S = (65535 & (S = (S = (65535 & S) * y + (((S >>> 16) * y & 65535) << 16) & 4294967295) << 15 | S >>> 17)) * w + (((S >>> 16) * w & 65535) << 16) & 4294967295) << 13 | f >>> 19)) + ((5 * (f >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (g >>> 16) & 65535) << 16);
                switch (S = 0,
                a) {
                case 3:
                    S ^= (255 & s.charCodeAt(M + 2)) << 16;
                case 2:
                    S ^= (255 & s.charCodeAt(M + 1)) << 8;
                case 1:
                    f ^= S = (65535 & (S = (S = (65535 & (S ^= 255 & s.charCodeAt(M))) * y + (((S >>> 16) * y & 65535) << 16) & 4294967295) << 15 | S >>> 17)) * w + (((S >>> 16) * w & 65535) << 16) & 4294967295
                }
                return f ^= s.length,
                f = 2246822507 * (65535 & (f ^= f >>> 16)) + ((2246822507 * (f >>> 16) & 65535) << 16) & 4294967295,
                f = 3266489909 * (65535 & (f ^= f >>> 13)) + ((3266489909 * (f >>> 16) & 65535) << 16) & 4294967295,
                (f ^= f >>> 16) >>> 0
            }
            ;
            var dx = {};
            ({
                get exports() {
                    return dx
                },
                set exports(s) {
                    dx = s
                }
            }).exports = function(s, n) {
                for (var a, u = s.length, f = n ^ u, g = 0; u >= 4; )
                    a = 1540483477 * (65535 & (a = 255 & s.charCodeAt(g) | (255 & s.charCodeAt(++g)) << 8 | (255 & s.charCodeAt(++g)) << 16 | (255 & s.charCodeAt(++g)) << 24)) + ((1540483477 * (a >>> 16) & 65535) << 16),
                    f = 1540483477 * (65535 & f) + ((1540483477 * (f >>> 16) & 65535) << 16) ^ (a = 1540483477 * (65535 & (a ^= a >>> 24)) + ((1540483477 * (a >>> 16) & 65535) << 16)),
                    u -= 4,
                    ++g;
                switch (u) {
                case 3:
                    f ^= (255 & s.charCodeAt(g + 2)) << 16;
                case 2:
                    f ^= (255 & s.charCodeAt(g + 1)) << 8;
                case 1:
                    f = 1540483477 * (65535 & (f ^= 255 & s.charCodeAt(g))) + ((1540483477 * (f >>> 16) & 65535) << 16)
                }
                return f = 1540483477 * (65535 & (f ^= f >>> 13)) + ((1540483477 * (f >>> 16) & 65535) << 16),
                (f ^= f >>> 15) >>> 0
            }
            ;
            var Ww = hx
              , X3 = dx;
            j3.exports = Ww,
            su.murmur3 = Ww,
            su.murmur2 = X3;
            class s_ {
                constructor() {
                    this.ids = [],
                    this.positions = [],
                    this.indexed = !1
                }
                add(n, a, u, f) {
                    this.ids.push(jw(n)),
                    this.positions.push(a, u, f)
                }
                getPositions(n) {
                    let a = jw(n)
                      , u = 0
                      , f = this.ids.length - 1;
                    for (; u < f; ) {
                        let y = u + f >> 1;
                        this.ids[y] >= a ? f = y : u = y + 1
                    }
                    let g = [];
                    for (; this.ids[u] === a; )
                        g.push({
                            index: this.positions[3 * u],
                            start: this.positions[3 * u + 1],
                            end: this.positions[3 * u + 2]
                        }),
                        u++;
                    return g
                }
                static serialize(n, a) {
                    let u = new Float64Array(n.ids)
                      , f = new Uint32Array(n.positions);
                    return fx(u, f, 0, u.length - 1),
                    a && a.push(u.buffer, f.buffer),
                    {
                        ids: u,
                        positions: f
                    }
                }
                static deserialize(n) {
                    let a = new s_;
                    return a.ids = n.ids,
                    a.positions = n.positions,
                    a.indexed = !0,
                    a
                }
            }
            function jw(s) {
                let n = +s;
                return !isNaN(n) && Number.MIN_SAFE_INTEGER <= n && n <= Number.MAX_SAFE_INTEGER ? n : su(String(s))
            }
            function fx(s, n, a, u) {
                for (; a < u; ) {
                    let f = s[a + u >> 1]
                      , g = a - 1
                      , y = u + 1;
                    for (; ; ) {
                        do
                            g++;
                        while (s[g] < f);
                        do
                            y--;
                        while (s[y] > f);
                        if (g >= y)
                            break;
                        o_(s, g, y),
                        o_(n, 3 * g, 3 * y),
                        o_(n, 3 * g + 1, 3 * y + 1),
                        o_(n, 3 * g + 2, 3 * y + 2)
                    }
                    y - a < u - y ? (fx(s, n, a, y),
                    a = y + 1) : (fx(s, n, y + 1, u),
                    u = y)
                }
            }
            function o_(s, n, a) {
                let u = s[n];
                s[n] = s[a],
                s[a] = u
            }
            cn(s_, "FeaturePositionMap");
            class ka {
                constructor(n) {
                    this.gl = n.gl,
                    this.initialized = !1
                }
                fetchUniformLocation(n, a) {
                    return this.location || this.initialized || (this.location = this.gl.getUniformLocation(n, a),
                    this.initialized = !0),
                    !!this.location
                }
            }
            class a_ extends ka {
                constructor(n) {
                    super(n),
                    this.current = 0
                }
                set(n, a, u) {
                    this.fetchUniformLocation(n, a) && this.current !== u && (this.current = u,
                    this.gl.uniform1f(this.location, u))
                }
            }
            class Xw extends ka {
                constructor(n) {
                    super(n),
                    this.current = [0, 0, 0, 0]
                }
                set(n, a, u) {
                    this.fetchUniformLocation(n, a) && (u[0] === this.current[0] && u[1] === this.current[1] && u[2] === this.current[2] && u[3] === this.current[3] || (this.current = u,
                    this.gl.uniform4f(this.location, u[0], u[1], u[2], u[3])))
                }
            }
            class Zw extends ka {
                constructor(n) {
                    super(n),
                    this.current = nr.transparent
                }
                set(n, a, u) {
                    this.fetchUniformLocation(n, a) && (u.r === this.current.r && u.g === this.current.g && u.b === this.current.b && u.a === this.current.a || (this.current = u,
                    this.gl.uniform4f(this.location, u.r, u.g, u.b, u.a)))
                }
            }
            let Z3 = new Float32Array(16)
              , q3 = new Float32Array(9)
              , K3 = new Float32Array(4);
            function px(s) {
                return [pn(255 * s.r, 255 * s.g), pn(255 * s.b, 255 * s.a)]
            }
            class np {
                constructor(n, a, u) {
                    this.value = n,
                    this.uniformNames = a.map(f=>`u_ ${f}`),
                    this.type = u
                }
                setUniform(n, a, u, f, g) {
                    a.set(n, g, f.constantOr(this.value))
                }
                getBinding(n, a) {
                    return this.type === "color" ? new Zw(n) : new a_(n)
                }
            }
            class Zh {
                constructor(n, a) {
                    this.uniformNames = a.map(u=>`u_ ${u}`),
                    this.pattern = null,
                    this.pixelRatio = 1
                }
                setConstantPatternPositions(n) {
                    this.pixelRatio = n.pixelRatio || 1,
                    this.pattern = n.tl.concat(n.br)
                }
                setUniform(n, a, u, f, g) {
                    let y = g === "u_pattern" || g === "u_dash" ? this.pattern : g === "u_pixel_ratio" ? this.pixelRatio : null;
                    y && a.set(n, g, y)
                }
                getBinding(n, a) {
                    return a === "u_pattern" || a === "u_dash" ? new Xw(n) : new a_(n)
                }
            }
            class za {
                constructor(n, a, u, f) {
                    this.expression = n,
                    this.type = u,
                    this.maxValue = 0,
                    this.paintVertexAttributes = a.map(g=>({
                        name: `a_ ${g}`,
                        type: "Float32",
                        components: u === "color" ? 2 : 1,
                        offset: 0
                    })),
                    this.paintVertexArray = new f
                }
                populatePaintArray(n, a, u, f, g, y) {
                    let w = this.paintVertexArray.length
                      , S = this.expression.evaluate(new $e(0), a, {}, g, f, y);
                    this.paintVertexArray.resize(n),
                    this._setPaintValue(w, n, S)
                }
                updatePaintArray(n, a, u, f, g) {
                    let y = this.expression.evaluate({
                        zoom: 0
                    }, u, f, void 0, g);
                    this._setPaintValue(n, a, y)
                }
                _setPaintValue(n, a, u) {
                    if (this.type === "color") {
                        let f = px(u);
                        for (let g = n; g < a; g++)
                            this.paintVertexArray.emplace(g, f[0], f[1])
                    } else {
                        for (let f = n; f < a; f++)
                            this.paintVertexArray.emplace(f, u);
                        this.maxValue = Math.max(this.maxValue, Math.abs(u))
                    }
                }
                upload(n) {
                    this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = n.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent))
                }
                destroy() {
                    this.paintVertexBuffer && this.paintVertexBuffer.destroy()
                }
            }
            class Lo {
                constructor(n, a, u, f, g, y) {
                    this.expression = n,
                    this.uniformNames = a.map(w=>`u_ ${w}_t`),
                    this.type = u,
                    this.useIntegerZoom = f,
                    this.zoom = g,
                    this.maxValue = 0,
                    this.paintVertexAttributes = a.map(w=>({
                        name: `a_ ${w}`,
                        type: "Float32",
                        components: u === "color" ? 4 : 2,
                        offset: 0
                    })),
                    this.paintVertexArray = new y
                }
                populatePaintArray(n, a, u, f, g, y) {
                    let w = this.expression.evaluate(new $e(this.zoom), a, {}, g, f, y)
                      , S = this.expression.evaluate(new $e(this.zoom + 1), a, {}, g, f, y)
                      , M = this.paintVertexArray.length;
                    this.paintVertexArray.resize(n),
                    this._setPaintValue(M, n, w, S)
                }
                updatePaintArray(n, a, u, f, g) {
                    let y = this.expression.evaluate({
                        zoom: this.zoom
                    }, u, f, void 0, g)
                      , w = this.expression.evaluate({
                        zoom: this.zoom + 1
                    }, u, f, void 0, g);
                    this._setPaintValue(n, a, y, w)
                }
                _setPaintValue(n, a, u, f) {
                    if (this.type === "color") {
                        let g = px(u)
                          , y = px(f);
                        for (let w = n; w < a; w++)
                            this.paintVertexArray.emplace(w, g[0], g[1], y[0], y[1])
                    } else {
                        for (let g = n; g < a; g++)
                            this.paintVertexArray.emplace(g, u, f);
                        this.maxValue = Math.max(this.maxValue, Math.abs(u), Math.abs(f))
                    }
                }
                upload(n) {
                    this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = n.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent))
                }
                destroy() {
                    this.paintVertexBuffer && this.paintVertexBuffer.destroy()
                }
                setUniform(n, a, u, f, g) {
                    let y = this.useIntegerZoom ? Math.floor(u.zoom) : u.zoom
                      , w = ae(this.expression.interpolationFactor(y, this.zoom, this.zoom + 1), 0, 1);
                    a.set(n, g, w)
                }
                getBinding(n, a) {
                    return new a_(n)
                }
            }
            class kl {
                constructor(n, a, u, f, g) {
                    this.expression = n,
                    this.layerId = g,
                    this.paintVertexAttributes = (u === "array" ? W3 : H3).members;
                    for (let y = 0; y < a.length; ++y)
                        ;
                    this.paintVertexArray = new f
                }
                populatePaintArray(n, a, u) {
                    let f = this.paintVertexArray.length;
                    this.paintVertexArray.resize(n),
                    this._setPaintValues(f, n, a.patterns && a.patterns[this.layerId], u)
                }
                updatePaintArray(n, a, u, f, g, y) {
                    this._setPaintValues(n, a, u.patterns && u.patterns[this.layerId], y)
                }
                _setPaintValues(n, a, u, f) {
                    if (!f || !u)
                        return;
                    let g = f[u];
                    if (!g)
                        return;
                    let {tl: y, br: w, pixelRatio: S} = g;
                    for (let M = n; M < a; M++)
                        this.paintVertexArray.emplace(M, y[0], y[1], w[0], w[1], S)
                }
                upload(n) {
                    this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer = n.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent))
                }
                destroy() {
                    this.paintVertexBuffer && this.paintVertexBuffer.destroy()
                }
            }
            class zl {
                constructor(n, a, u=()=>!0) {
                    this.binders = {},
                    this._buffers = [];
                    let f = [];
                    for (let g in n.paint._values) {
                        if (!u(g))
                            continue;
                        let y = n.paint.get(g);
                        if (!(y instanceof Dt && El(y.property.specification)))
                            continue;
                        let w = J3(g, n.type)
                          , S = y.value
                          , M = y.property.specification.type
                          , z = y.property.useIntegerZoom
                          , N = g === "line-dasharray" || g.endsWith("pattern")
                          , B = g === "line-dasharray" && n.layout.get("line-cap").value.kind !== "constant";
                        if (S.kind !== "constant" || B)
                            if (S.kind === "source" || B || N) {
                                let H = qw(g, M, "source");
                                this.binders[g] = N ? new kl(S,w,M,H,n.id) : new za(S,w,M,H),
                                f.push(`/a_ ${g}`)
                            } else {
                                let H = qw(g, M, "composite");
                                this.binders[g] = new Lo(S,w,M,z,a,H),
                                f.push(`/z_ ${g}`)
                            }
                        else
                            this.binders[g] = N ? new Zh(S.value,w) : new np(S.value,w,M),
                            f.push(`/u_ ${g}`)
                    }
                    this.cacheKey = f.sort().join("")
                }
                getMaxValue(n) {
                    let a = this.binders[n];
                    return a instanceof za || a instanceof Lo ? a.maxValue : 0
                }
                populatePaintArrays(n, a, u, f, g, y) {
                    for (let w in this.binders) {
                        let S = this.binders[w];
                        (S instanceof za || S instanceof Lo || S instanceof kl) && S.populatePaintArray(n, a, u, f, g, y)
                    }
                }
                setConstantPatternPositions(n) {
                    for (let a in this.binders) {
                        let u = this.binders[a];
                        u instanceof Zh && u.setConstantPatternPositions(n)
                    }
                }
                updatePaintArrays(n, a, u, f, g, y) {
                    let w = !1;
                    for (let S in n) {
                        let M = a.getPositions(S);
                        for (let z of M) {
                            let N = u.feature(z.index);
                            for (let B in this.binders) {
                                let H = this.binders[B];
                                if ((H instanceof za || H instanceof Lo || H instanceof kl) && H.expression.isStateDependent === !0) {
                                    let q = f.paint.get(B);
                                    H.expression = q.value,
                                    H.updatePaintArray(z.start, z.end, N, n[S], g, y),
                                    w = !0
                                }
                            }
                        }
                    }
                    return w
                }
                defines() {
                    let n = [];
                    for (let a in this.binders) {
                        let u = this.binders[a];
                        (u instanceof np || u instanceof Zh) && n.push(...u.uniformNames.map(f=>`#define HAS_UNIFORM_ ${f}`))
                    }
                    return n
                }
                getBinderAttributes() {
                    let n = [];
                    for (let a in this.binders) {
                        let u = this.binders[a];
                        if (u instanceof za || u instanceof Lo || u instanceof kl)
                            for (let f = 0; f < u.paintVertexAttributes.length; f++)
                                n.push(u.paintVertexAttributes[f].name)
                    }
                    return n
                }
                getBinderUniforms() {
                    let n = [];
                    for (let a in this.binders) {
                        let u = this.binders[a];
                        if (u instanceof np || u instanceof Zh || u instanceof Lo)
                            for (let f of u.uniformNames)
                                n.push(f)
                    }
                    return n
                }
                getPaintVertexBuffers() {
                    return this._buffers
                }
                getUniforms(n) {
                    let a = [];
                    for (let u in this.binders) {
                        let f = this.binders[u];
                        if (f instanceof np || f instanceof Zh || f instanceof Lo)
                            for (let g of f.uniformNames)
                                a.push({
                                    name: g,
                                    property: u,
                                    binding: f.getBinding(n, g)
                                })
                    }
                    return a
                }
                setUniforms(n, a, u, f, g) {
                    for (let {name: y, property: w, binding: S} of u)
                        this.binders[w].setUniform(n, S, g, f.get(w), y)
                }
                updatePaintBuffers() {
                    this._buffers = [];
                    for (let n in this.binders) {
                        let a = this.binders[n];
                        (a instanceof za || a instanceof Lo || a instanceof kl) && a.paintVertexBuffer && this._buffers.push(a.paintVertexBuffer)
                    }
                }
                upload(n) {
                    for (let a in this.binders) {
                        let u = this.binders[a];
                        (u instanceof za || u instanceof Lo || u instanceof kl) && u.upload(n)
                    }
                    this.updatePaintBuffers()
                }
                destroy() {
                    for (let n in this.binders) {
                        let a = this.binders[n];
                        (a instanceof za || a instanceof Lo || a instanceof kl) && a.destroy()
                    }
                }
            }
            class ou {
                constructor(n, a, u=()=>!0) {
                    this.programConfigurations = {};
                    for (let f of n)
                        this.programConfigurations[f.id] = new zl(f,a,u);
                    this.needsUpload = !1,
                    this._featureMap = new s_,
                    this._bufferOffset = 0
                }
                populatePaintArrays(n, a, u, f, g, y, w) {
                    for (let S in this.programConfigurations)
                        this.programConfigurations[S].populatePaintArrays(n, a, f, g, y, w);
                    a.id !== void 0 && this._featureMap.add(a.id, u, this._bufferOffset, n),
                    this._bufferOffset = n,
                    this.needsUpload = !0
                }
                updatePaintArrays(n, a, u, f, g) {
                    for (let y of u)
                        this.needsUpload = this.programConfigurations[y.id].updatePaintArrays(n, this._featureMap, a, y, f, g) || this.needsUpload
                }
                get(n) {
                    return this.programConfigurations[n]
                }
                upload(n) {
                    if (this.needsUpload) {
                        for (let a in this.programConfigurations)
                            this.programConfigurations[a].upload(n);
                        this.needsUpload = !1
                    }
                }
                destroy() {
                    for (let n in this.programConfigurations)
                        this.programConfigurations[n].destroy()
                }
            }
            let Y3 = {
                "text-opacity": ["opacity"],
                "icon-opacity": ["opacity"],
                "text-color": ["fill_color"],
                "icon-color": ["fill_color"],
                "text-halo-color": ["halo_color"],
                "icon-halo-color": ["halo_color"],
                "text-halo-blur": ["halo_blur"],
                "icon-halo-blur": ["halo_blur"],
                "text-halo-width": ["halo_width"],
                "icon-halo-width": ["halo_width"],
                "line-gap-width": ["gapwidth"],
                "line-pattern": ["pattern", "pixel_ratio"],
                "fill-pattern": ["pattern", "pixel_ratio"],
                "fill-extrusion-pattern": ["pattern", "pixel_ratio"],
                "line-dasharray": ["dash"]
            };
            function J3(s, n) {
                return Y3[s] || [s.replace(`${n}-`, "").replace(/-/g, "_")]
            }
            let $3 = {
                "line-pattern": {
                    source: lr,
                    composite: lr
                },
                "fill-pattern": {
                    source: lr,
                    composite: lr
                },
                "fill-extrusion-pattern": {
                    source: lr,
                    composite: lr
                },
                "line-dasharray": {
                    source: gs,
                    composite: gs
                }
            }
              , Q3 = {
                color: {
                    source: Pl,
                    composite: Mi
                },
                number: {
                    source: Ss,
                    composite: Pl
                }
            };
            function qw(s, n, a) {
                let u = $3[s];
                return u && u[a] || Q3[n][a]
            }
            cn(np, "ConstantBinder"),
            cn(Zh, "PatternConstantBinder"),
            cn(za, "SourceExpressionBinder"),
            cn(kl, "PatternCompositeBinder"),
            cn(Lo, "CompositeExpressionBinder"),
            cn(zl, "ProgramConfiguration", {
                omit: ["_buffers"]
            }),
            cn(ou, "ProgramConfigurationSet");
            let l_ = "-transition";
            class Ro extends pr {
                constructor(n, a) {
                    if (super(),
                    this.id = n.id,
                    this.type = n.type,
                    this._featureFilter = {
                        filter: ()=>!0,
                        needGeometry: !1,
                        needFeature: !1
                    },
                    this._filterCompiled = !1,
                    n.type !== "custom" && (this.metadata = n.metadata,
                    this.minzoom = n.minzoom,
                    this.maxzoom = n.maxzoom,
                    n.type !== "background" && n.type !== "sky" && (this.source = n.source,
                    this.sourceLayer = n["source-layer"],
                    this.filter = n.filter),
                    a.layout && (this._unevaluatedLayout = new pt(a.layout)),
                    a.paint)) {
                        this._transitionablePaint = new Vt(a.paint);
                        for (let u in n.paint)
                            this.setPaintProperty(u, n.paint[u], {
                                validate: !1
                            });
                        for (let u in n.layout)
                            this.setLayoutProperty(u, n.layout[u], {
                                validate: !1
                            });
                        this._transitioningPaint = this._transitionablePaint.untransitioned(),
                        this.paint = new st(a.paint)
                    }
                }
                getLayoutProperty(n) {
                    return n === "visibility" ? this.visibility : this._unevaluatedLayout.getValue(n)
                }
                setLayoutProperty(n, a, u={}) {
                    a != null && this._validate(jg, `layers.${this.id}.layout.${n}`, n, a, u) || (n !== "visibility" ? this._unevaluatedLayout.setValue(n, a) : this.visibility = a)
                }
                getPaintProperty(n) {
                    return Tn(n, l_) ? this._transitionablePaint.getTransition(n.slice(0, -l_.length)) : this._transitionablePaint.getValue(n)
                }
                setPaintProperty(n, a, u={}) {
                    if (a != null && this._validate(cx, `layers.${this.id}.paint.${n}`, n, a, u))
                        return !1;
                    if (Tn(n, l_))
                        return this._transitionablePaint.setTransition(n.slice(0, -l_.length), a || void 0),
                        !1;
                    {
                        let f = this._transitionablePaint._values[n]
                          , g = f.value.isDataDriven()
                          , y = f.value;
                        this._transitionablePaint.setValue(n, a),
                        this._handleSpecialPaintPropertyUpdate(n);
                        let w = this._transitionablePaint._values[n].value
                          , S = w.isDataDriven()
                          , M = Tn(n, "pattern") || n === "line-dasharray";
                        return S || g || M || this._handleOverridablePaintPropertyUpdate(n, y, w)
                    }
                }
                _handleSpecialPaintPropertyUpdate(n) {}
                getProgramIds() {
                    return null
                }
                getProgramConfiguration(n) {
                    return null
                }
                _handleOverridablePaintPropertyUpdate(n, a, u) {
                    return !1
                }
                isHidden(n) {
                    return !!(this.minzoom && n < this.minzoom) || !!(this.maxzoom && n >= this.maxzoom) || this.visibility === "none"
                }
                updateTransitions(n) {
                    this._transitioningPaint = this._transitionablePaint.transitioned(n, this._transitioningPaint)
                }
                hasTransition() {
                    return this._transitioningPaint.hasTransition()
                }
                recalculate(n, a) {
                    this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(n, void 0, a)),
                    this.paint = this._transitioningPaint.possiblyEvaluate(n, void 0, a)
                }
                serialize() {
                    let n = {
                        id: this.id,
                        type: this.type,
                        source: this.source,
                        "source-layer": this.sourceLayer,
                        metadata: this.metadata,
                        minzoom: this.minzoom,
                        maxzoom: this.maxzoom,
                        filter: this.filter,
                        layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(),
                        paint: this._transitionablePaint && this._transitionablePaint.serialize()
                    };
                    return this.visibility && (n.layout = n.layout || {},
                    n.layout.visibility = this.visibility),
                    Dn(n, (a,u)=>!(a === void 0 || u === "layout" && !Object.keys(a).length || u === "paint" && !Object.keys(a).length))
                }
                _validate(n, a, u, f, g={}) {
                    return (!g || g.validate !== !1) && Xg(this, n.call(Wg, {
                        key: a,
                        layerType: this.type,
                        objectKey: u,
                        value: f,
                        styleSpec: ht,
                        style: {
                            glyphs: !0,
                            sprite: !0
                        }
                    }))
                }
                is3D() {
                    return !1
                }
                isSky() {
                    return !1
                }
                isTileClipped() {
                    return !1
                }
                hasOffscreenPass() {
                    return !1
                }
                resize() {}
                isStateDependent() {
                    for (let n in this.paint._values) {
                        let a = this.paint.get(n);
                        if (a instanceof Dt && El(a.property.specification) && (a.value.kind === "source" || a.value.kind === "composite") && a.value.isStateDependent)
                            return !0
                    }
                    return !1
                }
                compileFilter() {
                    this._filterCompiled || (this._featureFilter = Oh(this.filter),
                    this._filterCompiled = !0)
                }
                invalidateCompiledFilter() {
                    this._filterCompiled = !1
                }
                dynamicFilter() {
                    return this._featureFilter.dynamicFilter
                }
                dynamicFilterNeedsFeature() {
                    return this._featureFilter.needFeature
                }
            }
            let eD = vn([{
                name: "a_pos",
                components: 2,
                type: "Int16"
            }], 4)
              , tD = vn([{
                name: "a_pos_3",
                components: 3,
                type: "Int16"
            }, {
                name: "a_pos_normal_3",
                components: 3,
                type: "Int16"
            }]);
            class cr {
                constructor(n=[]) {
                    this.segments = n
                }
                prepareSegment(n, a, u, f) {
                    let g = this.segments[this.segments.length - 1];
                    return n > cr.MAX_VERTEX_ARRAY_LENGTH && ut(`Max vertices per segment is ${cr.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${n}`),
                    (!g || g.vertexLength + n > cr.MAX_VERTEX_ARRAY_LENGTH || g.sortKey !== f) && (g = {
                        vertexOffset: a.length,
                        primitiveOffset: u.length,
                        vertexLength: 0,
                        primitiveLength: 0
                    },
                    f !== void 0 && (g.sortKey = f),
                    this.segments.push(g)),
                    g
                }
                get() {
                    return this.segments
                }
                destroy() {
                    for (let n of this.segments)
                        for (let a in n.vaos)
                            n.vaos[a].destroy()
                }
                static simpleSegment(n, a, u, f) {
                    return new cr([{
                        vertexOffset: n,
                        primitiveOffset: a,
                        vertexLength: u,
                        primitiveLength: f,
                        vaos: {},
                        sortKey: 0
                    }])
                }
            }
            cr.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1,
            cn(cr, "SegmentVector");
            var kn = 8192;
            class Ol {
                constructor(n, a) {
                    n && (a ? this.setSouthWest(n).setNorthEast(a) : n.length === 4 ? this.setSouthWest([n[0], n[1]]).setNorthEast([n[2], n[3]]) : this.setSouthWest(n[0]).setNorthEast(n[1]))
                }
                setNorthEast(n) {
                    return this._ne = n instanceof oi ? new oi(n.lng,n.lat) : oi.convert(n),
                    this
                }
                setSouthWest(n) {
                    return this._sw = n instanceof oi ? new oi(n.lng,n.lat) : oi.convert(n),
                    this
                }
                extend(n) {
                    let a = this._sw, u = this._ne, f, g;
                    if (n instanceof oi)
                        f = n,
                        g = n;
                    else {
                        if (!(n instanceof Ol))
                            return Array.isArray(n) ? n.length === 4 || n.every(Array.isArray) ? this.extend(Ol.convert(n)) : this.extend(oi.convert(n)) : typeof n == "object" && n !== null && n.hasOwnProperty("lat") && n.hasOwnProperty("lon") ? this.extend(oi.convert(n)) : this;
                        if (f = n._sw,
                        g = n._ne,
                        !f || !g)
                            return this
                    }
                    return a || u ? (a.lng = Math.min(f.lng, a.lng),
                    a.lat = Math.min(f.lat, a.lat),
                    u.lng = Math.max(g.lng, u.lng),
                    u.lat = Math.max(g.lat, u.lat)) : (this._sw = new oi(f.lng,f.lat),
                    this._ne = new oi(g.lng,g.lat)),
                    this
                }
                getCenter() {
                    return new oi((this._sw.lng + this._ne.lng) / 2,(this._sw.lat + this._ne.lat) / 2)
                }
                getSouthWest() {
                    return this._sw
                }
                getNorthEast() {
                    return this._ne
                }
                getNorthWest() {
                    return new oi(this.getWest(),this.getNorth())
                }
                getSouthEast() {
                    return new oi(this.getEast(),this.getSouth())
                }
                getWest() {
                    return this._sw.lng
                }
                getSouth() {
                    return this._sw.lat
                }
                getEast() {
                    return this._ne.lng
                }
                getNorth() {
                    return this._ne.lat
                }
                toArray() {
                    return [this._sw.toArray(), this._ne.toArray()]
                }
                toString() {
                    return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`
                }
                isEmpty() {
                    return !(this._sw && this._ne)
                }
                contains(n) {
                    let {lng: a, lat: u} = oi.convert(n)
                      , f = this._sw.lng <= a && a <= this._ne.lng;
                    return this._sw.lng > this._ne.lng && (f = this._sw.lng >= a && a >= this._ne.lng),
                    this._sw.lat <= u && u <= this._ne.lat && f
                }
                static convert(n) {
                    return !n || n instanceof Ol ? n : new Ol(n)
                }
            }
            var c_ = 1e-6
              , Ns = typeof Float32Array != "undefined" ? Float32Array : Array;
            function Kw() {
                var s = new Ns(9);
                return Ns != Float32Array && (s[1] = 0,
                s[2] = 0,
                s[3] = 0,
                s[5] = 0,
                s[6] = 0,
                s[7] = 0),
                s[0] = 1,
                s[4] = 1,
                s[8] = 1,
                s
            }
            function Yw(s, n, a) {
                var u = n[0]
                  , f = n[1]
                  , g = n[2]
                  , y = n[3]
                  , w = n[4]
                  , S = n[5]
                  , M = n[6]
                  , z = n[7]
                  , N = n[8]
                  , B = a[0]
                  , H = a[1]
                  , q = a[2]
                  , Q = a[3]
                  , de = a[4]
                  , Me = a[5]
                  , Pe = a[6]
                  , we = a[7]
                  , Le = a[8];
                return s[0] = B * u + H * y + q * M,
                s[1] = B * f + H * w + q * z,
                s[2] = B * g + H * S + q * N,
                s[3] = Q * u + de * y + Me * M,
                s[4] = Q * f + de * w + Me * z,
                s[5] = Q * g + de * S + Me * N,
                s[6] = Pe * u + we * y + Le * M,
                s[7] = Pe * f + we * w + Le * z,
                s[8] = Pe * g + we * S + Le * N,
                s
            }
            function Po(s) {
                return s[0] = 1,
                s[1] = 0,
                s[2] = 0,
                s[3] = 0,
                s[4] = 0,
                s[5] = 1,
                s[6] = 0,
                s[7] = 0,
                s[8] = 0,
                s[9] = 0,
                s[10] = 1,
                s[11] = 0,
                s[12] = 0,
                s[13] = 0,
                s[14] = 0,
                s[15] = 1,
                s
            }
            function mx(s, n) {
                var a = n[0]
                  , u = n[1]
                  , f = n[2]
                  , g = n[3]
                  , y = n[4]
                  , w = n[5]
                  , S = n[6]
                  , M = n[7]
                  , z = n[8]
                  , N = n[9]
                  , B = n[10]
                  , H = n[11]
                  , q = n[12]
                  , Q = n[13]
                  , de = n[14]
                  , Me = n[15]
                  , Pe = a * w - u * y
                  , we = a * S - f * y
                  , Le = a * M - g * y
                  , Ue = u * S - f * w
                  , Ne = u * M - g * w
                  , at = f * M - g * S
                  , it = z * Q - N * q
                  , _t = z * de - B * q
                  , Ot = z * Me - H * q
                  , dt = N * de - B * Q
                  , yt = N * Me - H * Q
                  , Tt = B * Me - H * de
                  , Lt = Pe * Tt - we * yt + Le * dt + Ue * Ot - Ne * _t + at * it;
                return Lt ? (s[0] = (w * Tt - S * yt + M * dt) * (Lt = 1 / Lt),
                s[1] = (f * yt - u * Tt - g * dt) * Lt,
                s[2] = (Q * at - de * Ne + Me * Ue) * Lt,
                s[3] = (B * Ne - N * at - H * Ue) * Lt,
                s[4] = (S * Ot - y * Tt - M * _t) * Lt,
                s[5] = (a * Tt - f * Ot + g * _t) * Lt,
                s[6] = (de * Le - q * at - Me * we) * Lt,
                s[7] = (z * at - B * Le + H * we) * Lt,
                s[8] = (y * yt - w * Ot + M * it) * Lt,
                s[9] = (u * Ot - a * yt - g * it) * Lt,
                s[10] = (q * Ne - Q * Le + Me * Pe) * Lt,
                s[11] = (N * Le - z * Ne - H * Pe) * Lt,
                s[12] = (w * _t - y * dt - S * it) * Lt,
                s[13] = (a * dt - u * _t + f * it) * Lt,
                s[14] = (Q * we - q * Ue - de * Pe) * Lt,
                s[15] = (z * Ue - N * we + B * Pe) * Lt,
                s) : null
            }
            function au(s, n, a) {
                var u = n[0]
                  , f = n[1]
                  , g = n[2]
                  , y = n[3]
                  , w = n[4]
                  , S = n[5]
                  , M = n[6]
                  , z = n[7]
                  , N = n[8]
                  , B = n[9]
                  , H = n[10]
                  , q = n[11]
                  , Q = n[12]
                  , de = n[13]
                  , Me = n[14]
                  , Pe = n[15]
                  , we = a[0]
                  , Le = a[1]
                  , Ue = a[2]
                  , Ne = a[3];
                return s[0] = we * u + Le * w + Ue * N + Ne * Q,
                s[1] = we * f + Le * S + Ue * B + Ne * de,
                s[2] = we * g + Le * M + Ue * H + Ne * Me,
                s[3] = we * y + Le * z + Ue * q + Ne * Pe,
                s[4] = (we = a[4]) * u + (Le = a[5]) * w + (Ue = a[6]) * N + (Ne = a[7]) * Q,
                s[5] = we * f + Le * S + Ue * B + Ne * de,
                s[6] = we * g + Le * M + Ue * H + Ne * Me,
                s[7] = we * y + Le * z + Ue * q + Ne * Pe,
                s[8] = (we = a[8]) * u + (Le = a[9]) * w + (Ue = a[10]) * N + (Ne = a[11]) * Q,
                s[9] = we * f + Le * S + Ue * B + Ne * de,
                s[10] = we * g + Le * M + Ue * H + Ne * Me,
                s[11] = we * y + Le * z + Ue * q + Ne * Pe,
                s[12] = (we = a[12]) * u + (Le = a[13]) * w + (Ue = a[14]) * N + (Ne = a[15]) * Q,
                s[13] = we * f + Le * S + Ue * B + Ne * de,
                s[14] = we * g + Le * M + Ue * H + Ne * Me,
                s[15] = we * y + Le * z + Ue * q + Ne * Pe,
                s
            }
            function ip(s, n, a) {
                var u, f, g, y, w, S, M, z, N, B, H, q, Q = a[0], de = a[1], Me = a[2];
                return n === s ? (s[12] = n[0] * Q + n[4] * de + n[8] * Me + n[12],
                s[13] = n[1] * Q + n[5] * de + n[9] * Me + n[13],
                s[14] = n[2] * Q + n[6] * de + n[10] * Me + n[14],
                s[15] = n[3] * Q + n[7] * de + n[11] * Me + n[15]) : (f = n[1],
                g = n[2],
                y = n[3],
                w = n[4],
                S = n[5],
                M = n[6],
                z = n[7],
                N = n[8],
                B = n[9],
                H = n[10],
                q = n[11],
                s[0] = u = n[0],
                s[1] = f,
                s[2] = g,
                s[3] = y,
                s[4] = w,
                s[5] = S,
                s[6] = M,
                s[7] = z,
                s[8] = N,
                s[9] = B,
                s[10] = H,
                s[11] = q,
                s[12] = u * Q + w * de + N * Me + n[12],
                s[13] = f * Q + S * de + B * Me + n[13],
                s[14] = g * Q + M * de + H * Me + n[14],
                s[15] = y * Q + z * de + q * Me + n[15]),
                s
            }
            function lu(s, n, a) {
                var u = a[0]
                  , f = a[1]
                  , g = a[2];
                return s[0] = n[0] * u,
                s[1] = n[1] * u,
                s[2] = n[2] * u,
                s[3] = n[3] * u,
                s[4] = n[4] * f,
                s[5] = n[5] * f,
                s[6] = n[6] * f,
                s[7] = n[7] * f,
                s[8] = n[8] * g,
                s[9] = n[9] * g,
                s[10] = n[10] * g,
                s[11] = n[11] * g,
                s[12] = n[12],
                s[13] = n[13],
                s[14] = n[14],
                s[15] = n[15],
                s
            }
            function gx(s, n, a) {
                var u = Math.sin(a)
                  , f = Math.cos(a)
                  , g = n[4]
                  , y = n[5]
                  , w = n[6]
                  , S = n[7]
                  , M = n[8]
                  , z = n[9]
                  , N = n[10]
                  , B = n[11];
                return n !== s && (s[0] = n[0],
                s[1] = n[1],
                s[2] = n[2],
                s[3] = n[3],
                s[12] = n[12],
                s[13] = n[13],
                s[14] = n[14],
                s[15] = n[15]),
                s[4] = g * f + M * u,
                s[5] = y * f + z * u,
                s[6] = w * f + N * u,
                s[7] = S * f + B * u,
                s[8] = M * f - g * u,
                s[9] = z * f - y * u,
                s[10] = N * f - w * u,
                s[11] = B * f - S * u,
                s
            }
            function u_(s, n, a) {
                var u = Math.sin(a)
                  , f = Math.cos(a)
                  , g = n[0]
                  , y = n[1]
                  , w = n[2]
                  , S = n[3]
                  , M = n[8]
                  , z = n[9]
                  , N = n[10]
                  , B = n[11];
                return n !== s && (s[4] = n[4],
                s[5] = n[5],
                s[6] = n[6],
                s[7] = n[7],
                s[12] = n[12],
                s[13] = n[13],
                s[14] = n[14],
                s[15] = n[15]),
                s[0] = g * f - M * u,
                s[1] = y * f - z * u,
                s[2] = w * f - N * u,
                s[3] = S * f - B * u,
                s[8] = g * u + M * f,
                s[9] = y * u + z * f,
                s[10] = w * u + N * f,
                s[11] = S * u + B * f,
                s
            }
            function Jw(s, n) {
                return s[0] = n[0],
                s[1] = 0,
                s[2] = 0,
                s[3] = 0,
                s[4] = 0,
                s[5] = n[1],
                s[6] = 0,
                s[7] = 0,
                s[8] = 0,
                s[9] = 0,
                s[10] = n[2],
                s[11] = 0,
                s[12] = 0,
                s[13] = 0,
                s[14] = 0,
                s[15] = 1,
                s
            }
            function $w(s, n, a) {
                var u, f, g, y = a[0], w = a[1], S = a[2], M = Math.hypot(y, w, S);
                return M < c_ ? null : (y *= M = 1 / M,
                w *= M,
                S *= M,
                u = Math.sin(n),
                f = Math.cos(n),
                s[0] = y * y * (g = 1 - f) + f,
                s[1] = w * y * g + S * u,
                s[2] = S * y * g - w * u,
                s[3] = 0,
                s[4] = y * w * g - S * u,
                s[5] = w * w * g + f,
                s[6] = S * w * g + y * u,
                s[7] = 0,
                s[8] = y * S * g + w * u,
                s[9] = w * S * g - y * u,
                s[10] = S * S * g + f,
                s[11] = 0,
                s[12] = 0,
                s[13] = 0,
                s[14] = 0,
                s[15] = 1,
                s)
            }
            Math.hypot || (Math.hypot = function() {
                for (var s = 0, n = arguments.length; n--; )
                    s += arguments[n] * arguments[n];
                return Math.sqrt(s)
            }
            );
            var nD = au;
            function _x() {
                var s = new Ns(3);
                return Ns != Float32Array && (s[0] = 0,
                s[1] = 0,
                s[2] = 0),
                s
            }
            function Qw(s) {
                var n = new Ns(3);
                return n[0] = s[0],
                n[1] = s[1],
                n[2] = s[2],
                n
            }
            function rp(s) {
                return Math.hypot(s[0], s[1], s[2])
            }
            function qh(s, n, a) {
                var u = new Ns(3);
                return u[0] = s,
                u[1] = n,
                u[2] = a,
                u
            }
            function Oa(s, n, a) {
                return s[0] = n[0] + a[0],
                s[1] = n[1] + a[1],
                s[2] = n[2] + a[2],
                s
            }
            function yx(s, n, a) {
                return s[0] = n[0] - a[0],
                s[1] = n[1] - a[1],
                s[2] = n[2] - a[2],
                s
            }
            function eT(s, n, a) {
                return s[0] = n[0] * a[0],
                s[1] = n[1] * a[1],
                s[2] = n[2] * a[2],
                s
            }
            function sp(s, n, a) {
                return s[0] = Math.min(n[0], a[0]),
                s[1] = Math.min(n[1], a[1]),
                s[2] = Math.min(n[2], a[2]),
                s
            }
            function op(s, n, a) {
                return s[0] = Math.max(n[0], a[0]),
                s[1] = Math.max(n[1], a[1]),
                s[2] = Math.max(n[2], a[2]),
                s
            }
            function Ys(s, n, a) {
                return s[0] = n[0] * a,
                s[1] = n[1] * a,
                s[2] = n[2] * a,
                s
            }
            function ap(s, n, a, u) {
                return s[0] = n[0] + a[0] * u,
                s[1] = n[1] + a[1] * u,
                s[2] = n[2] + a[2] * u,
                s
            }
            function _s(s, n) {
                var a = n[0]
                  , u = n[1]
                  , f = n[2]
                  , g = a * a + u * u + f * f;
                return g > 0 && (g = 1 / Math.sqrt(g)),
                s[0] = n[0] * g,
                s[1] = n[1] * g,
                s[2] = n[2] * g,
                s
            }
            function ho(s, n) {
                return s[0] * n[0] + s[1] * n[1] + s[2] * n[2]
            }
            function xx(s, n, a) {
                var u = n[0]
                  , f = n[1]
                  , g = n[2]
                  , y = a[0]
                  , w = a[1]
                  , S = a[2];
                return s[0] = f * S - g * w,
                s[1] = g * y - u * S,
                s[2] = u * w - f * y,
                s
            }
            function ir(s, n, a) {
                var u = n[0]
                  , f = n[1]
                  , g = n[2]
                  , y = a[3] * u + a[7] * f + a[11] * g + a[15];
                return s[0] = (a[0] * u + a[4] * f + a[8] * g + a[12]) / (y = y || 1),
                s[1] = (a[1] * u + a[5] * f + a[9] * g + a[13]) / y,
                s[2] = (a[2] * u + a[6] * f + a[10] * g + a[14]) / y,
                s
            }
            function tT(s, n, a) {
                var u = a[0]
                  , f = a[1]
                  , g = a[2]
                  , y = n[0]
                  , w = n[1]
                  , S = n[2]
                  , M = f * S - g * w
                  , z = g * y - u * S
                  , N = u * w - f * y
                  , B = f * N - g * z
                  , H = g * M - u * N
                  , q = u * z - f * M
                  , Q = 2 * a[3];
                return z *= Q,
                N *= Q,
                H *= 2,
                q *= 2,
                s[0] = y + (M *= Q) + (B *= 2),
                s[1] = w + z + H,
                s[2] = S + N + q,
                s
            }
            var lp, ko = yx, iD = eT, rD = rp;
            function nT(s, n, a) {
                return s[0] = n[0] * a,
                s[1] = n[1] * a,
                s[2] = n[2] * a,
                s[3] = n[3] * a,
                s
            }
            function iT(s, n) {
                var a = n[0]
                  , u = n[1]
                  , f = n[2]
                  , g = n[3]
                  , y = a * a + u * u + f * f + g * g;
                return y > 0 && (y = 1 / Math.sqrt(y)),
                s[0] = a * y,
                s[1] = u * y,
                s[2] = f * y,
                s[3] = g * y,
                s
            }
            function cu(s, n, a) {
                var u = n[0]
                  , f = n[1]
                  , g = n[2]
                  , y = n[3];
                return s[0] = a[0] * u + a[4] * f + a[8] * g + a[12] * y,
                s[1] = a[1] * u + a[5] * f + a[9] * g + a[13] * y,
                s[2] = a[2] * u + a[6] * f + a[10] * g + a[14] * y,
                s[3] = a[3] * u + a[7] * f + a[11] * g + a[15] * y,
                s
            }
            function rT() {
                var s = new Ns(4);
                return Ns != Float32Array && (s[0] = 0,
                s[1] = 0,
                s[2] = 0),
                s[3] = 1,
                s
            }
            function sT(s) {
                return s[0] = 0,
                s[1] = 0,
                s[2] = 0,
                s[3] = 1,
                s
            }
            function oT(s, n, a) {
                a *= .5;
                var u = n[0]
                  , f = n[1]
                  , g = n[2]
                  , y = n[3]
                  , w = Math.sin(a)
                  , S = Math.cos(a);
                return s[0] = u * S + y * w,
                s[1] = f * S + g * w,
                s[2] = g * S - f * w,
                s[3] = y * S - u * w,
                s
            }
            function aT(s, n, a) {
                a *= .5;
                var u = n[0]
                  , f = n[1]
                  , g = n[2]
                  , y = n[3]
                  , w = Math.sin(a)
                  , S = Math.cos(a);
                return s[0] = u * S - g * w,
                s[1] = f * S + y * w,
                s[2] = g * S + u * w,
                s[3] = y * S - f * w,
                s
            }
            _x(),
            lp = new Ns(4),
            Ns != Float32Array && (lp[0] = 0,
            lp[1] = 0,
            lp[2] = 0,
            lp[3] = 0);
            var sD = iT;
            _x(),
            qh(1, 0, 0),
            qh(0, 1, 0),
            rT(),
            rT(),
            Kw();
            let oD = vn([{
                type: "Float32",
                name: "a_globe_pos",
                components: 3
            }, {
                type: "Float32",
                name: "a_uv",
                components: 2
            }])
              , {members: lT} = oD
              , cT = vn([{
                name: "a_pos_3",
                components: 3,
                type: "Int16"
            }]);
            var cp = vn([{
                name: "a_pos",
                type: "Int16",
                components: 2
            }]);
            class vx {
                constructor(n, a) {
                    this.pos = n,
                    this.dir = a
                }
                intersectsPlane(n, a, u) {
                    let f = ho(a, this.dir);
                    if (Math.abs(f) < 1e-6)
                        return !1;
                    let g = ((n[0] - this.pos[0]) * a[0] + (n[1] - this.pos[1]) * a[1] + (n[2] - this.pos[2]) * a[2]) / f;
                    return u[0] = this.pos[0] + this.dir[0] * g,
                    u[1] = this.pos[1] + this.dir[1] * g,
                    u[2] = this.pos[2] + this.dir[2] * g,
                    !0
                }
                closestPointOnSphere(n, a, u) {
                    if (function(H, q) {
                        var Q = H[0]
                          , de = H[1]
                          , Me = H[2]
                          , Pe = q[0]
                          , we = q[1]
                          , Le = q[2];
                        return Math.abs(Q - Pe) <= c_ * Math.max(1, Math.abs(Q), Math.abs(Pe)) && Math.abs(de - we) <= c_ * Math.max(1, Math.abs(de), Math.abs(we)) && Math.abs(Me - Le) <= c_ * Math.max(1, Math.abs(Me), Math.abs(Le))
                    }(this.pos, n) || a === 0)
                        return u[0] = u[1] = u[2] = 0,
                        !1;
                    let[f,g,y] = this.dir
                      , w = this.pos[0] - n[0]
                      , S = this.pos[1] - n[1]
                      , M = this.pos[2] - n[2]
                      , z = f * f + g * g + y * y
                      , N = 2 * (w * f + S * g + M * y)
                      , B = N * N - 4 * z * (w * w + S * S + M * M - a * a);
                    if (B < 0) {
                        let H = Math.max(-N / 2, 0)
                          , q = w + f * H
                          , Q = S + g * H
                          , de = M + y * H
                          , Me = Math.hypot(q, Q, de);
                        return u[0] = q * a / Me,
                        u[1] = Q * a / Me,
                        u[2] = de * a / Me,
                        !1
                    }
                    {
                        let H = (-N - Math.sqrt(B)) / (2 * z);
                        if (H < 0) {
                            let q = Math.hypot(w, S, M);
                            return u[0] = w * a / q,
                            u[1] = S * a / q,
                            u[2] = M * a / q,
                            !1
                        }
                        return u[0] = w + f * H,
                        u[1] = S + g * H,
                        u[2] = M + y * H,
                        !0
                    }
                }
            }
            class bx {
                constructor(n, a, u, f, g) {
                    this.TL = n,
                    this.TR = a,
                    this.BR = u,
                    this.BL = f,
                    this.horizon = g
                }
                static fromInvProjectionMatrix(n, a, u) {
                    let f = [-1, 1, 1]
                      , g = [1, 1, 1]
                      , y = [1, -1, 1]
                      , w = [-1, -1, 1]
                      , S = ir(f, f, n)
                      , M = ir(g, g, n)
                      , z = ir(y, y, n)
                      , N = ir(w, w, n);
                    return new bx(S,M,z,N,a / u)
                }
            }
            class wx {
                constructor(n, a) {
                    this.points = n,
                    this.planes = a
                }
                static fromInvProjectionMatrix(n, a, u, f) {
                    let g = Math.pow(2, u)
                      , y = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map(S=>{
                        let M = cu([], S, n)
                          , z = 1 / M[3] / a * g;
                        return function(N, B, H) {
                            return N[0] = B[0] * H[0],
                            N[1] = B[1] * H[1],
                            N[2] = B[2] * H[2],
                            N[3] = B[3] * H[3],
                            N
                        }(M, M, [z, z, f ? 1 / M[3] : z, z])
                    }
                    )
                      , w = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map(S=>{
                        let M = _s([], xx([], ko([], y[S[0]], y[S[1]]), ko([], y[S[2]], y[S[1]])))
                          , z = -ho(M, y[S[1]]);
                        return M.concat(z)
                    }
                    );
                    return new wx(y,w)
                }
            }
            class ys {
                static fromPoints(n) {
                    let a = [1 / 0, 1 / 0, 1 / 0]
                      , u = [-1 / 0, -1 / 0, -1 / 0];
                    for (let f of n)
                        sp(a, a, f),
                        op(u, u, f);
                    return new ys(a,u)
                }
                static applyTransform(n, a) {
                    let u = n.getCorners();
                    for (let f = 0; f < u.length; ++f)
                        ir(u[f], u[f], a);
                    return ys.fromPoints(u)
                }
                constructor(n, a) {
                    this.min = n,
                    this.max = a,
                    this.center = Ys([], Oa([], this.min, this.max), .5)
                }
                quadrant(n) {
                    let a = [n % 2 == 0, n < 2]
                      , u = Qw(this.min)
                      , f = Qw(this.max);
                    for (let g = 0; g < a.length; g++)
                        u[g] = a[g] ? this.min[g] : this.center[g],
                        f[g] = a[g] ? this.center[g] : this.max[g];
                    return f[2] = this.max[2],
                    new ys(u,f)
                }
                distanceX(n) {
                    return Math.max(Math.min(this.max[0], n[0]), this.min[0]) - n[0]
                }
                distanceY(n) {
                    return Math.max(Math.min(this.max[1], n[1]), this.min[1]) - n[1]
                }
                distanceZ(n) {
                    return Math.max(Math.min(this.max[2], n[2]), this.min[2]) - n[2]
                }
                getCorners() {
                    let n = this.min
                      , a = this.max;
                    return [[n[0], n[1], n[2]], [a[0], n[1], n[2]], [a[0], a[1], n[2]], [n[0], a[1], n[2]], [n[0], n[1], a[2]], [a[0], n[1], a[2]], [a[0], a[1], a[2]], [n[0], a[1], a[2]]]
                }
                intersects(n) {
                    let a = this.getCorners()
                      , u = !0;
                    for (let f = 0; f < n.planes.length; f++) {
                        let g = n.planes[f]
                          , y = 0;
                        for (let w = 0; w < a.length; w++)
                            y += ho(g, a[w]) + g[3] >= 0;
                        if (y === 0)
                            return 0;
                        y !== a.length && (u = !1)
                    }
                    if (u)
                        return 2;
                    for (let f = 0; f < 3; f++) {
                        let g = Number.MAX_VALUE
                          , y = -Number.MAX_VALUE;
                        for (let w = 0; w < n.points.length; w++) {
                            let S = n.points[w][f] - this.min[f];
                            g = Math.min(g, S),
                            y = Math.max(y, S)
                        }
                        if (y < 0 || g > this.max[f] - this.min[f])
                            return 0
                    }
                    return 1
                }
            }
            let ta = kn / Math.PI / 2
              , uu = 64
              , up = [uu, 32, 16]
              , fo = -ta
              , po = ta
              , aD = [new ys([fo, fo, fo],[po, po, po]), new ys([fo, fo, fo],[0, 0, po]), new ys([0, fo, fo],[po, 0, po]), new ys([fo, 0, fo],[0, po, po]), new ys([0, 0, fo],[po, po, po])];
            function h_(s) {
                return s * ta / fp
            }
            function uT(s, n, a, u=!0) {
                let f = Ys([], s._camera.position, s.worldSize)
                  , g = [n, a, 1, 1];
                cu(g, g, s.pixelMatrixInverse),
                nT(g, g, 1 / g[3]);
                let y = _s([], ko([], g, f))
                  , w = s.globeMatrix
                  , S = [w[12], w[13], w[14]]
                  , M = ko([], S, f)
                  , z = rp(M)
                  , N = _s([], M)
                  , B = s.worldSize / (2 * Math.PI)
                  , H = ho(N, y)
                  , q = Math.asin(B / z);
                if (q < Math.acos(H)) {
                    if (!u)
                        return null;
                    let Ot = []
                      , dt = [];
                    Ys(Ot, y, z / H),
                    _s(dt, ko(dt, Ot, M)),
                    _s(y, Oa(y, M, Ys(y, dt, Math.tan(q) * z)))
                }
                let Q = [];
                new vx(f,y).closestPointOnSphere(S, B, Q);
                let de = _s([], zn(w, 0))
                  , Me = _s([], zn(w, 1))
                  , Pe = _s([], zn(w, 2))
                  , we = ho(de, Q)
                  , Le = ho(Me, Q)
                  , Ue = ho(Pe, Q)
                  , Ne = ee(Math.asin(-Le / B))
                  , at = ee(Math.atan2(we, Ue));
                at = s.center.lng + function(Ot, dt) {
                    let yt = (dt - Ot + 180) % 360 - 180;
                    return yt < -180 ? yt + 360 : yt
                }(s.center.lng, at);
                let it = ia(at)
                  , _t = ae(ra(Ne), 0, 1);
                return new $h(it,_t)
            }
            class lD {
                constructor(n, a, u) {
                    this.a = ko([], n, u),
                    this.b = ko([], a, u),
                    this.center = u;
                    let f = _s([], this.a)
                      , g = _s([], this.b);
                    this.angle = Math.acos(ho(f, g))
                }
            }
            function Tx(s, n) {
                if (s.angle === 0)
                    return null;
                let a;
                return a = s.a[n] === 0 ? 1 / s.angle * .5 * Math.PI : 1 / s.angle * Math.atan(s.b[n] / s.a[n] / Math.sin(s.angle) - 1 / Math.tan(s.angle)),
                a < 0 || a > 1 ? null : function(u, f, g, y) {
                    let w = Math.sin(g);
                    return u * (Math.sin((1 - y) * g) / w) + f * (Math.sin(y * g) / w)
                }(s.a[n], s.b[n], s.angle, ae(a, 0, 1)) + s.center[n]
            }
            function na(s) {
                if (s.z <= 1)
                    return aD[s.z + 2 * s.y + s.x];
                let n = Ex(d_(s));
                return ys.fromPoints(n)
            }
            function hu(s, n, a) {
                return Ys(s, s, 1 - a),
                ap(s, s, n, a)
            }
            function hT(s, n) {
                let a = Jh(n.zoom);
                if (a === 0)
                    return na(s);
                let u = d_(s)
                  , f = Ex(u)
                  , g = ia(u.getWest()) * n.worldSize
                  , y = ia(u.getEast()) * n.worldSize
                  , w = ra(u.getNorth()) * n.worldSize
                  , S = ra(u.getSouth()) * n.worldSize
                  , M = [g, w, 0]
                  , z = [y, w, 0]
                  , N = [g, S, 0]
                  , B = [y, S, 0]
                  , H = mx([], n.globeMatrix);
                return ir(M, M, H),
                ir(z, z, H),
                ir(N, N, H),
                ir(B, B, H),
                f[0] = hu(f[0], N, a),
                f[1] = hu(f[1], B, a),
                f[2] = hu(f[2], z, a),
                f[3] = hu(f[3], M, a),
                ys.fromPoints(f)
            }
            function dT(s, n, a) {
                for (let u of s)
                    ir(u, u, n),
                    Ys(u, u, a)
            }
            function cD(s, n, a) {
                let u = n / s.worldSize
                  , f = s.globeMatrix;
                if (a.z <= 1) {
                    let it = na(a).getCorners();
                    return dT(it, f, u),
                    ys.fromPoints(it)
                }
                let g = d_(a)
                  , y = Ex(g);
                dT(y, f, u);
                let w = Number.MAX_VALUE
                  , S = [-w, -w, -w]
                  , M = [w, w, w];
                if (g.contains(s.center)) {
                    for (let Ot of y)
                        sp(M, M, Ot),
                        op(S, S, Ot);
                    S[2] = 0;
                    let it = s.point
                      , _t = [it.x * u, it.y * u, 0];
                    return sp(M, M, _t),
                    op(S, S, _t),
                    new ys(M,S)
                }
                let z = [f[12] * u, f[13] * u, f[14] * u]
                  , N = g.getCenter()
                  , B = ae(s.center.lat, -qr, qr)
                  , H = ae(N.lat, -qr, qr)
                  , q = ia(s.center.lng)
                  , Q = ra(B)
                  , de = q - ia(N.lng)
                  , Me = Q - ra(H);
                de > .5 ? de -= 1 : de < -.5 && (de += 1);
                let Pe = 0;
                Math.abs(de) > Math.abs(Me) ? Pe = de >= 0 ? 1 : 3 : (Pe = Me >= 0 ? 0 : 2,
                ap(z, z, [f[4] * u, f[5] * u, f[6] * u], -Math.sin(oe(Me >= 0 ? g.getSouth() : g.getNorth())) * ta));
                let we = y[Pe]
                  , Le = y[(Pe + 1) % 4]
                  , Ue = new lD(we,Le,z)
                  , Ne = [Tx(Ue, 0) || we[0], Tx(Ue, 1) || we[1], Tx(Ue, 2) || we[2]]
                  , at = Jh(s.zoom);
                if (at > 0) {
                    let it = function({x: Ot, y: dt, z: yt}, Tt, Lt, Nt, mt) {
                        let qt = 1 / (1 << yt)
                          , Sn = Ot * qt
                          , en = Sn + qt
                          , hn = dt * qt
                          , Yt = hn + qt
                          , Cn = 0
                          , ei = (Sn + en) / 2 - Nt;
                        return ei > .5 ? Cn = -1 : ei < -.5 && (Cn = 1),
                        Sn = ((Sn + Cn) * Tt - (Nt *= Tt)) * Lt + Nt,
                        en = ((en + Cn) * Tt - Nt) * Lt + Nt,
                        hn = (hn * Tt - (mt *= Tt)) * Lt + mt,
                        Yt = (Yt * Tt - mt) * Lt + mt,
                        [[Sn, Yt, 0], [en, Yt, 0], [en, hn, 0], [Sn, hn, 0]]
                    }(a, n, s._pixelsPerMercatorPixel, q, Q);
                    for (let Ot = 0; Ot < y.length; Ot++)
                        hu(y[Ot], it[Ot], at);
                    let _t = Oa([], it[Pe], it[(Pe + 1) % 4]);
                    Ys(_t, _t, .5),
                    hu(Ne, _t, at)
                }
                for (let it of y)
                    sp(M, M, it),
                    op(S, S, it);
                return M[2] = Math.min(we[2], Le[2]),
                sp(M, M, Ne),
                op(S, S, Ne),
                new ys(M,S)
            }
            function d_({x: s, y: n, z: a}) {
                let u = 1 / (1 << a)
                  , f = new oi(Js(s * u),Zr((n + 1) * u))
                  , g = new oi(Js((s + 1) * u),Zr(n * u));
                return new Ol(f,g)
            }
            function Ex(s) {
                let n = oe(s.getNorth())
                  , a = oe(s.getSouth())
                  , u = Math.cos(n)
                  , f = Math.cos(a)
                  , g = Math.sin(n)
                  , y = Math.sin(a)
                  , w = s.getWest()
                  , S = s.getEast();
                return [Kh(f, y, w), Kh(f, y, S), Kh(u, g, S), Kh(u, g, w)]
            }
            function Kh(s, n, a, u=ta) {
                return a = oe(a),
                [s * Math.sin(a) * u, -n * u, s * Math.cos(a) * u]
            }
            function Yh(s, n, a) {
                return Kh(Math.cos(oe(s)), Math.sin(oe(s)), n, a)
            }
            function hp(s, n, a, u) {
                let f = 1 << a.z
                  , g = (s / kn + a.x) / f;
                return Yh(Zr((n / kn + a.y) / f), Js(g), u)
            }
            function f_({min: s, max: n}) {
                return 16383 / Math.max(n[0] - s[0], n[1] - s[1], n[2] - s[2])
            }
            let fT = new Float64Array(16);
            function dp(s) {
                let n = f_(s)
                  , a = Jw(fT, [n, n, n]);
                return ip(a, a, ((u = [])[0] = -(f = s.min)[0],
                u[1] = -f[1],
                u[2] = -f[2],
                u));
                var u, f
            }
            function Sx(s) {
                let n = (u = s.min,
                (a = fT)[0] = 1,
                a[1] = 0,
                a[2] = 0,
                a[3] = 0,
                a[4] = 0,
                a[5] = 1,
                a[6] = 0,
                a[7] = 0,
                a[8] = 0,
                a[9] = 0,
                a[10] = 1,
                a[11] = 0,
                a[12] = u[0],
                a[13] = u[1],
                a[14] = u[2],
                a[15] = 1,
                a);
                var a, u;
                let f = 1 / f_(s);
                return lu(n, n, [f, f, f])
            }
            function pT(s, n, a, u, f) {
                let g = function(S) {
                    let M = kn / (2 * Math.PI);
                    return S / (2 * Math.PI) / M
                }(a)
                  , y = [s, n, -a / (2 * Math.PI)]
                  , w = Po(new Float64Array(16));
                return ip(w, w, y),
                lu(w, w, [g, g, g]),
                gx(w, w, oe(-f)),
                u_(w, w, oe(-u)),
                w
            }
            function Jh(s) {
                return se(5, 6, s)
            }
            function mT(s, n) {
                let a = Yh(n.lat, n.lng)
                  , u = function(q) {
                    let Q = Yh(q._center.lat, q._center.lng)
                      , de = xx([], qh(0, 1, 0), Q)
                      , Me = $w([], -q.angle, Q);
                    de = ir(de, de, Me),
                    $w(Me, -q._pitch, de);
                    let Pe = _s([], Q);
                    return Ys(Pe, Pe, h_(q.cameraToCenterDistance / q.pixelsPerMeter)),
                    ir(Pe, Pe, Me),
                    Oa([], Q, Pe)
                }(s);
                return y = (f = yx([], u, a))[0],
                w = f[1],
                S = f[2],
                M = (g = a)[0],
                z = g[1],
                N = g[2],
                H = (B = Math.sqrt(y * y + w * w + S * S) * Math.sqrt(M * M + z * z + N * N)) && ho(f, g) / B,
                Math.acos(Math.min(Math.max(H, -1), 1));
                var f, g, y, w, S, M, z, N, B, H
            }
            function Ax(s, n) {
                return mT(s, n) > Math.PI / 2 * 1.01
            }
            let gT = oe(85)
              , uD = Math.cos(gT)
              , hD = Math.sin(gT)
              , fp = 63710088e-1
              , _T = 2 * Math.PI * fp;
            class oi {
                constructor(n, a) {
                    if (isNaN(n) || isNaN(a))
                        throw new Error(`Invalid LngLat object: (${n}, ${a})`);
                    if (this.lng = +n,
                    this.lat = +a,
                    this.lat > 90 || this.lat < -90)
                        throw new Error("Invalid LngLat latitude value: must be between -90 and 90")
                }
                wrap() {
                    return new oi(ke(this.lng, -180, 180),this.lat)
                }
                toArray() {
                    return [this.lng, this.lat]
                }
                toString() {
                    return `LngLat(${this.lng}, ${this.lat})`
                }
                distanceTo(n) {
                    let a = Math.PI / 180
                      , u = this.lat * a
                      , f = n.lat * a
                      , g = Math.sin(u) * Math.sin(f) + Math.cos(u) * Math.cos(f) * Math.cos((n.lng - this.lng) * a);
                    return fp * Math.acos(Math.min(g, 1))
                }
                toBounds(n=0) {
                    let a = 360 * n / 40075017
                      , u = a / Math.cos(Math.PI / 180 * this.lat);
                    return new Ol(new oi(this.lng - u,this.lat - a),new oi(this.lng + u,this.lat + a))
                }
                toEcef(n) {
                    let a = h_(n);
                    return Yh(this.lat, this.lng, ta + a)
                }
                static convert(n) {
                    if (n instanceof oi)
                        return n;
                    if (Array.isArray(n) && (n.length === 2 || n.length === 3))
                        return new oi(Number(n[0]),Number(n[1]));
                    if (!Array.isArray(n) && typeof n == "object" && n !== null)
                        return new oi(Number("lng"in n ? n.lng : n.lon),Number(n.lat));
                    throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]")
                }
            }
            function Mx(s) {
                return _T * Math.cos(s * Math.PI / 180)
            }
            function ia(s) {
                return (180 + s) / 360
            }
            function ra(s) {
                return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + s * Math.PI / 360))) / 360
            }
            function zo(s, n) {
                return s / Mx(n)
            }
            function Js(s) {
                return 360 * s - 180
            }
            function Zr(s) {
                return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * s) * Math.PI / 180)) - 90
            }
            function yT(s, n) {
                return s * Mx(Zr(n))
            }
            let qr = 85.051129;
            function xT(s) {
                return 1 / Math.cos(s * Math.PI / 180)
            }
            class $h {
                constructor(n, a, u=0) {
                    this.x = +n,
                    this.y = +a,
                    this.z = +u
                }
                static fromLngLat(n, a=0) {
                    let u = oi.convert(n);
                    return new $h(ia(u.lng),ra(u.lat),zo(a, u.lat))
                }
                toLngLat() {
                    return new oi(Js(this.x),Zr(this.y))
                }
                toAltitude() {
                    return yT(this.z, this.y)
                }
                meterInMercatorCoordinateUnits() {
                    return 1 / _T * xT(Zr(this.y))
                }
            }
            function Ix(s, n, a, u, f, g, y, w, S) {
                let M = (n + u) / 2
                  , z = (a + f) / 2
                  , N = new W(M,z);
                w(N),
                function(B, H, q, Q, de, Me) {
                    let Pe = q - de
                      , we = Q - Me;
                    return Math.abs((Q - H) * Pe - (q - B) * we) / Math.hypot(Pe, we)
                }(N.x, N.y, g.x, g.y, y.x, y.y) >= S ? (Ix(s, n, a, M, z, g, N, w, S),
                Ix(s, M, z, u, f, N, y, w, S)) : s.push(y)
            }
            function vT(s, n, a) {
                let u = s[0]
                  , f = u.x
                  , g = u.y;
                n(u);
                let y = [u];
                for (let w = 1; w < s.length; w++) {
                    let S = s[w]
                      , {x: M, y: z} = S;
                    n(S),
                    Ix(y, f, g, M, z, u, S, n, a),
                    f = M,
                    g = z,
                    u = S
                }
                return y
            }
            function Cx(s, n, a, u) {
                if (u(n, a)) {
                    let f = n.add(a)._mult(.5);
                    Cx(s, n, f, u),
                    Cx(s, f, a, u)
                } else
                    s.push(a)
            }
            function dD(s, n) {
                let a = s[0]
                  , u = [a];
                for (let f = 1; f < s.length; f++) {
                    let g = s[f];
                    Cx(u, a, g, n),
                    a = g
                }
                return u
            }
            let Dx = Math.pow(2, 14) - 1
              , bT = -Dx - 1;
            function fD(s, n) {
                let a = Math.round(s.x * n)
                  , u = Math.round(s.y * n);
                return s.x = ae(a, bT, Dx),
                s.y = ae(u, bT, Dx),
                (a < s.x || a > s.x + 1 || u < s.y || u > s.y + 1) && ut("Geometry exceeds allowed extent, reduce your vector tile buffer size"),
                s
            }
            function Na(s, n, a) {
                let u = s.loadGeometry()
                  , f = s.extent
                  , g = kn / f;
                if (n && a && a.projection.isReprojectedInTileSpace) {
                    let y = 1 << n.z
                      , {scale: w, x: S, y: M, projection: z} = a
                      , N = B=>{
                        let H = Js((n.x + B.x / f) / y)
                          , q = Zr((n.y + B.y / f) / y)
                          , Q = z.project(H, q);
                        B.x = (Q.x * w - S) * f,
                        B.y = (Q.y * w - M) * f
                    }
                    ;
                    for (let B = 0; B < u.length; B++)
                        if (s.type !== 1)
                            u[B] = vT(u[B], N, 1);
                        else {
                            let H = [];
                            for (let q of u[B])
                                q.x < 0 || q.x >= f || q.y < 0 || q.y >= f || (N(q),
                                H.push(q));
                            u[B] = H
                        }
                }
                for (let y of u)
                    for (let w of y)
                        fD(w, g);
                return u
            }
            function du(s, n) {
                return {
                    type: s.type,
                    id: s.id,
                    properties: s.properties,
                    geometry: n ? Na(s) : []
                }
            }
            function p_(s, n, a, u, f) {
                s.emplaceBack(2 * n + (u + 1) / 2, 2 * a + (f + 1) / 2)
            }
            function m_(s, n, a) {
                let u = 16384;
                s.emplaceBack(n.x, n.y, n.z, a[0] * u, a[1] * u, a[2] * u)
            }
            class Lx {
                constructor(n) {
                    this.zoom = n.zoom,
                    this.overscaling = n.overscaling,
                    this.layers = n.layers,
                    this.layerIds = this.layers.map(a=>a.id),
                    this.index = n.index,
                    this.hasPattern = !1,
                    this.projection = n.projection,
                    this.layoutVertexArray = new En,
                    this.indexArray = new Xr,
                    this.segments = new cr,
                    this.programConfigurations = new ou(n.layers,n.zoom),
                    this.stateDependentLayerIds = this.layers.filter(a=>a.isStateDependent()).map(a=>a.id)
                }
                populate(n, a, u, f) {
                    let g = this.layers[0]
                      , y = []
                      , w = null;
                    g.type === "circle" && (w = g.layout.get("circle-sort-key"));
                    for (let {feature: M, id: z, index: N, sourceLayerIndex: B} of n) {
                        let H = this.layers[0]._featureFilter.needGeometry
                          , q = du(M, H);
                        if (!this.layers[0]._featureFilter.filter(new $e(this.zoom), q, u))
                            continue;
                        let Q = w ? w.evaluate(q, {}, u) : void 0
                          , de = {
                            id: z,
                            properties: M.properties,
                            type: M.type,
                            sourceLayerIndex: B,
                            index: N,
                            geometry: H ? q.geometry : Na(M, u, f),
                            patterns: {},
                            sortKey: Q
                        };
                        y.push(de)
                    }
                    w && y.sort((M,z)=>M.sortKey - z.sortKey);
                    let S = null;
                    f.projection.name === "globe" && (this.globeExtVertexArray = new Ks,
                    S = f.projection);
                    for (let M of y) {
                        let {geometry: z, index: N, sourceLayerIndex: B} = M
                          , H = n[N].feature;
                        this.addFeature(M, z, N, a.availableImages, u, S),
                        a.featureIndex.insert(H, z, N, B, this.index)
                    }
                }
                update(n, a, u, f) {
                    this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(n, a, this.stateDependentLayers, u, f)
                }
                isEmpty() {
                    return this.layoutVertexArray.length === 0
                }
                uploadPending() {
                    return !this.uploaded || this.programConfigurations.needsUpload
                }
                upload(n) {
                    this.uploaded || (this.layoutVertexBuffer = n.createVertexBuffer(this.layoutVertexArray, eD.members),
                    this.indexBuffer = n.createIndexBuffer(this.indexArray),
                    this.globeExtVertexArray && (this.globeExtVertexBuffer = n.createVertexBuffer(this.globeExtVertexArray, tD.members))),
                    this.programConfigurations.upload(n),
                    this.uploaded = !0
                }
                destroy() {
                    this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(),
                    this.indexBuffer.destroy(),
                    this.programConfigurations.destroy(),
                    this.segments.destroy(),
                    this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy())
                }
                addFeature(n, a, u, f, g, y) {
                    for (let w of a)
                        for (let S of w) {
                            let M = S.x
                              , z = S.y;
                            if (M < 0 || M >= kn || z < 0 || z >= kn)
                                continue;
                            if (y) {
                                let H = y.projectTilePoint(M, z, g)
                                  , q = y.upVector(g, M, z)
                                  , Q = this.globeExtVertexArray;
                                m_(Q, H, q),
                                m_(Q, H, q),
                                m_(Q, H, q),
                                m_(Q, H, q)
                            }
                            let N = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, n.sortKey)
                              , B = N.vertexLength;
                            p_(this.layoutVertexArray, M, z, -1, -1),
                            p_(this.layoutVertexArray, M, z, 1, -1),
                            p_(this.layoutVertexArray, M, z, 1, 1),
                            p_(this.layoutVertexArray, M, z, -1, 1),
                            this.indexArray.emplaceBack(B, B + 1, B + 2),
                            this.indexArray.emplaceBack(B, B + 2, B + 3),
                            N.vertexLength += 4,
                            N.primitiveLength += 2
                        }
                    this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, n, u, {}, f, g)
                }
            }
            function wT(s, n) {
                for (let a = 0; a < s.length; a++)
                    if (fu(n, s[a]))
                        return !0;
                for (let a = 0; a < n.length; a++)
                    if (fu(s, n[a]))
                        return !0;
                return !!Rx(s, n)
            }
            function pD(s, n, a) {
                return !!fu(s, n) || !!Px(n, s, a)
            }
            function TT(s, n) {
                if (s.length === 1)
                    return ST(n, s[0]);
                for (let a = 0; a < n.length; a++) {
                    let u = n[a];
                    for (let f = 0; f < u.length; f++)
                        if (fu(s, u[f]))
                            return !0
                }
                for (let a = 0; a < s.length; a++)
                    if (ST(n, s[a]))
                        return !0;
                for (let a = 0; a < n.length; a++)
                    if (Rx(s, n[a]))
                        return !0;
                return !1
            }
            function mD(s, n, a) {
                if (s.length > 1) {
                    if (Rx(s, n))
                        return !0;
                    for (let u = 0; u < n.length; u++)
                        if (Px(n[u], s, a))
                            return !0
                }
                for (let u = 0; u < s.length; u++)
                    if (Px(s[u], n, a))
                        return !0;
                return !1
            }
            function Rx(s, n) {
                if (s.length === 0 || n.length === 0)
                    return !1;
                for (let a = 0; a < s.length - 1; a++) {
                    let u = s[a]
                      , f = s[a + 1];
                    for (let g = 0; g < n.length - 1; g++)
                        if (gD(u, f, n[g], n[g + 1]))
                            return !0
                }
                return !1
            }
            function gD(s, n, a, u) {
                return ot(s, a, u) !== ot(n, a, u) && ot(s, n, a) !== ot(s, n, u)
            }
            function Px(s, n, a) {
                let u = a * a;
                if (n.length === 1)
                    return s.distSqr(n[0]) < u;
                for (let f = 1; f < n.length; f++)
                    if (ET(s, n[f - 1], n[f]) < u)
                        return !0;
                return !1
            }
            function ET(s, n, a) {
                let u = n.distSqr(a);
                if (u === 0)
                    return s.distSqr(n);
                let f = ((s.x - n.x) * (a.x - n.x) + (s.y - n.y) * (a.y - n.y)) / u;
                return s.distSqr(f < 0 ? n : f > 1 ? a : a.sub(n)._mult(f)._add(n))
            }
            function ST(s, n) {
                let a, u, f, g = !1;
                for (let y = 0; y < s.length; y++) {
                    a = s[y];
                    for (let w = 0, S = a.length - 1; w < a.length; S = w++)
                        u = a[w],
                        f = a[S],
                        u.y > n.y != f.y > n.y && n.x < (f.x - u.x) * (n.y - u.y) / (f.y - u.y) + u.x && (g = !g)
                }
                return g
            }
            function fu(s, n) {
                let a = !1;
                for (let u = 0, f = s.length - 1; u < s.length; f = u++) {
                    let g = s[u]
                      , y = s[f];
                    g.y > n.y != y.y > n.y && n.x < (y.x - g.x) * (n.y - g.y) / (y.y - g.y) + g.x && (a = !a)
                }
                return a
            }
            function AT(s, n, a, u, f) {
                for (let y of s)
                    if (n <= y.x && a <= y.y && u >= y.x && f >= y.y)
                        return !0;
                let g = [new W(n,a), new W(n,f), new W(u,f), new W(u,a)];
                if (s.length > 2) {
                    for (let y of g)
                        if (fu(s, y))
                            return !0
                }
                for (let y = 0; y < s.length - 1; y++)
                    if (_D(s[y], s[y + 1], g))
                        return !0;
                return !1
            }
            function _D(s, n, a) {
                let u = a[0]
                  , f = a[2];
                if (s.x < u.x && n.x < u.x || s.x > f.x && n.x > f.x || s.y < u.y && n.y < u.y || s.y > f.y && n.y > f.y)
                    return !1;
                let g = ot(s, n, a[0]);
                return g !== ot(s, n, a[1]) || g !== ot(s, n, a[2]) || g !== ot(s, n, a[3])
            }
            function Qh(s, n, a) {
                let u = n.paint.get(s).value;
                return u.kind === "constant" ? u.value : a.programConfigurations.get(n.id).getMaxValue(s)
            }
            function g_(s) {
                return Math.sqrt(s[0] * s[0] + s[1] * s[1])
            }
            function MT(s, n, a, u, f) {
                if (!n[0] && !n[1])
                    return s;
                let g = W.convert(n)._mult(f);
                a === "viewport" && g._rotate(-u);
                let y = [];
                for (let w = 0; w < s.length; w++)
                    y.push(s[w].sub(g));
                return y
            }
            function IT(s, n, a, u) {
                let f = W.convert(s)._mult(u);
                return n === "viewport" && f._rotate(-a),
                f
            }
            cn(Lx, "CircleBucket", {
                omit: ["layers"]
            });
            let yD = new Pt({
                "circle-sort-key": new ct(ht.layout_circle["circle-sort-key"])
            });
            var xD = {
                paint: new Pt({
                    "circle-radius": new ct(ht.paint_circle["circle-radius"]),
                    "circle-color": new ct(ht.paint_circle["circle-color"]),
                    "circle-blur": new ct(ht.paint_circle["circle-blur"]),
                    "circle-opacity": new ct(ht.paint_circle["circle-opacity"]),
                    "circle-translate": new Je(ht.paint_circle["circle-translate"]),
                    "circle-translate-anchor": new Je(ht.paint_circle["circle-translate-anchor"]),
                    "circle-pitch-scale": new Je(ht.paint_circle["circle-pitch-scale"]),
                    "circle-pitch-alignment": new Je(ht.paint_circle["circle-pitch-alignment"]),
                    "circle-stroke-width": new ct(ht.paint_circle["circle-stroke-width"]),
                    "circle-stroke-color": new ct(ht.paint_circle["circle-stroke-color"]),
                    "circle-stroke-opacity": new ct(ht.paint_circle["circle-stroke-opacity"])
                }),
                layout: yD
            };
            function CT(s, n, a, u, f, g, y, w, S) {
                if (g && s.queryGeometry.isAboveHorizon)
                    return !1;
                g && (S *= s.pixelToTileUnitsFactor);
                let M = s.tileID.canonical
                  , z = a.projection.upVectorScale(M, a.center.lat, a.worldSize).metersToTile;
                for (let N of n)
                    for (let B of N) {
                        let H = B.add(w)
                          , q = f && a.elevation ? a.elevation.exaggeration() * f.getElevationAt(H.x, H.y, !0) : 0
                          , Q = a.projection.projectTilePoint(H.x, H.y, M);
                        if (q > 0) {
                            let we = a.projection.upVector(M, H.x, H.y);
                            Q.x += we[0] * z * q,
                            Q.y += we[1] * z * q,
                            Q.z += we[2] * z * q
                        }
                        let de = g ? H : vD(Q.x, Q.y, Q.z, u)
                          , Me = g ? s.tilespaceRays.map(we=>wD(we, q)) : s.queryGeometry.screenGeometry
                          , Pe = cu([], [Q.x, Q.y, Q.z, 1], u);
                        if (!y && g ? S *= Pe[3] / a.cameraToCenterDistance : y && !g && (S *= a.cameraToCenterDistance / Pe[3]),
                        g) {
                            let we = Zr((B.y / kn + M.y) / (1 << M.z));
                            S /= a.projection.pixelsPerMeter(we, 1) / zo(1, we)
                        }
                        if (pD(Me, de, S))
                            return !0
                    }
                return !1
            }
            function vD(s, n, a, u) {
                let f = cu([], [s, n, a, 1], u);
                return new W(f[0] / f[3],f[1] / f[3])
            }
            let DT = qh(0, 0, 0)
              , bD = qh(0, 0, 1);
            function wD(s, n) {
                let a = _x();
                return DT[2] = n,
                s.intersectsPlane(DT, bD, a),
                new W(a[0],a[1])
            }
            class LT extends Lx {
            }
            function RT(s, {width: n, height: a}, u, f) {
                if (f) {
                    if (f instanceof Uint8ClampedArray)
                        f = new Uint8Array(f.buffer);
                    else if (f.length !== n * a * u)
                        throw new RangeError("mismatched image size")
                } else
                    f = new Uint8Array(n * a * u);
                return s.width = n,
                s.height = a,
                s.data = f,
                s
            }
            function PT(s, n, a) {
                let {width: u, height: f} = n;
                u === s.width && f === s.height || (kx(s, n, {
                    x: 0,
                    y: 0
                }, {
                    x: 0,
                    y: 0
                }, {
                    width: Math.min(s.width, u),
                    height: Math.min(s.height, f)
                }, a),
                s.width = u,
                s.height = f,
                s.data = n.data)
            }
            function kx(s, n, a, u, f, g) {
                if (f.width === 0 || f.height === 0)
                    return n;
                if (f.width > s.width || f.height > s.height || a.x > s.width - f.width || a.y > s.height - f.height)
                    throw new RangeError("out of range source coordinates for image copy");
                if (f.width > n.width || f.height > n.height || u.x > n.width - f.width || u.y > n.height - f.height)
                    throw new RangeError("out of range destination coordinates for image copy");
                let y = s.data
                  , w = n.data;
                for (let S = 0; S < f.height; S++) {
                    let M = ((a.y + S) * s.width + a.x) * g
                      , z = ((u.y + S) * n.width + u.x) * g;
                    for (let N = 0; N < f.width * g; N++)
                        w[z + N] = y[M + N]
                }
                return n
            }
            cn(LT, "HeatmapBucket", {
                omit: ["layers"]
            });
            class Fa {
                constructor(n, a) {
                    RT(this, n, 1, a)
                }
                resize(n) {
                    PT(this, new Fa(n), 1)
                }
                clone() {
                    return new Fa({
                        width: this.width,
                        height: this.height
                    },new Uint8Array(this.data))
                }
                static copy(n, a, u, f, g) {
                    kx(n, a, u, f, g, 1)
                }
            }
            class Fs {
                constructor(n, a) {
                    RT(this, n, 4, a)
                }
                resize(n) {
                    PT(this, new Fs(n), 4)
                }
                replace(n, a) {
                    a ? this.data.set(n) : this.data = n instanceof Uint8ClampedArray ? new Uint8Array(n.buffer) : n
                }
                clone() {
                    return new Fs({
                        width: this.width,
                        height: this.height
                    },new Uint8Array(this.data))
                }
                static copy(n, a, u, f, g) {
                    kx(n, a, u, f, g, 4)
                }
            }
            cn(Fa, "AlphaImage"),
            cn(Fs, "RGBAImage");
            var TD = {
                paint: new Pt({
                    "heatmap-radius": new ct(ht.paint_heatmap["heatmap-radius"]),
                    "heatmap-weight": new ct(ht.paint_heatmap["heatmap-weight"]),
                    "heatmap-intensity": new Je(ht.paint_heatmap["heatmap-intensity"]),
                    "heatmap-color": new At(ht.paint_heatmap["heatmap-color"]),
                    "heatmap-opacity": new Je(ht.paint_heatmap["heatmap-opacity"])
                })
            };
            function zx(s) {
                let n = {}
                  , a = s.resolution || 256
                  , u = s.clips ? s.clips.length : 1
                  , f = s.image || new Fs({
                    width: a,
                    height: u
                })
                  , g = (y,w,S)=>{
                    n[s.evaluationKey] = S;
                    let M = s.expression.evaluate(n);
                    f.data[y + w + 0] = Math.floor(255 * M.r / M.a),
                    f.data[y + w + 1] = Math.floor(255 * M.g / M.a),
                    f.data[y + w + 2] = Math.floor(255 * M.b / M.a),
                    f.data[y + w + 3] = Math.floor(255 * M.a)
                }
                ;
                if (s.clips)
                    for (let y = 0, w = 0; y < u; ++y,
                    w += 4 * a)
                        for (let S = 0, M = 0; S < a; S++,
                        M += 4) {
                            let z = S / (a - 1)
                              , {start: N, end: B} = s.clips[y];
                            g(w, M, N * (1 - z) + B * z)
                        }
                else
                    for (let y = 0, w = 0; y < a; y++,
                    w += 4)
                        g(0, w, y / (a - 1));
                return f
            }
            var ED = {
                paint: new Pt({
                    "hillshade-illumination-direction": new Je(ht.paint_hillshade["hillshade-illumination-direction"]),
                    "hillshade-illumination-anchor": new Je(ht.paint_hillshade["hillshade-illumination-anchor"]),
                    "hillshade-exaggeration": new Je(ht.paint_hillshade["hillshade-exaggeration"]),
                    "hillshade-shadow-color": new Je(ht.paint_hillshade["hillshade-shadow-color"]),
                    "hillshade-highlight-color": new Je(ht.paint_hillshade["hillshade-highlight-color"]),
                    "hillshade-accent-color": new Je(ht.paint_hillshade["hillshade-accent-color"])
                })
            };
            let SD = vn([{
                name: "a_pos",
                components: 2,
                type: "Int16"
            }], 4)
              , {members: AD} = SD;
            var ed = {};
            function __(s, n, a) {
                a = a || 2;
                var u, f, g, y, w, S, M, z = n && n.length, N = z ? n[0] * a : s.length, B = kT(s, 0, N, a, !0), H = [];
                if (!B || B.next === B.prev)
                    return H;
                if (z && (B = function(Q, de, Me, Pe) {
                    var we, Le, Ue, Ne = [];
                    for (we = 0,
                    Le = de.length; we < Le; we++)
                        (Ue = kT(Q, de[we] * Pe, we < Le - 1 ? de[we + 1] * Pe : Q.length, Pe, !1)) === Ue.next && (Ue.steiner = !0),
                        Ne.push(kD(Ue));
                    for (Ne.sort(LD),
                    we = 0; we < Ne.length; we++)
                        Me = RD(Ne[we], Me);
                    return Me
                }(s, n, B, a)),
                s.length > 80 * a) {
                    u = g = s[0],
                    f = y = s[1];
                    for (var q = a; q < N; q += a)
                        (w = s[q]) < u && (u = w),
                        (S = s[q + 1]) < f && (f = S),
                        w > g && (g = w),
                        S > y && (y = S);
                    M = (M = Math.max(g - u, y - f)) !== 0 ? 32767 / M : 0
                }
                return pp(B, H, a, u, f, M, 0),
                H
            }
            function kT(s, n, a, u, f) {
                var g, y;
                if (f === Fx(s, n, a, u) > 0)
                    for (g = n; g < a; g += u)
                        y = NT(g, s[g], s[g + 1], y);
                else
                    for (g = a - u; g >= n; g -= u)
                        y = NT(g, s[g], s[g + 1], y);
                return y && y_(y, y.next) && (gp(y),
                y = y.next),
                y
            }
            function pu(s, n) {
                if (!s)
                    return s;
                n || (n = s);
                var a, u = s;
                do
                    if (a = !1,
                    u.steiner || !y_(u, u.next) && ur(u.prev, u, u.next) !== 0)
                        u = u.next;
                    else {
                        if (gp(u),
                        (u = n = u.prev) === u.next)
                            break;
                        a = !0
                    }
                while (a || u !== n);
                return n
            }
            function pp(s, n, a, u, f, g, y) {
                if (s) {
                    !y && g && function(z, N, B, H) {
                        var q = z;
                        do
                            q.z === 0 && (q.z = Ox(q.x, q.y, N, B, H)),
                            q.prevZ = q.prev,
                            q.nextZ = q.next,
                            q = q.next;
                        while (q !== z);
                        q.prevZ.nextZ = null,
                        q.prevZ = null,
                        function(Q) {
                            var de, Me, Pe, we, Le, Ue, Ne, at, it = 1;
                            do {
                                for (Me = Q,
                                Q = null,
                                Le = null,
                                Ue = 0; Me; ) {
                                    for (Ue++,
                                    Pe = Me,
                                    Ne = 0,
                                    de = 0; de < it && (Ne++,
                                    Pe = Pe.nextZ); de++)
                                        ;
                                    for (at = it; Ne > 0 || at > 0 && Pe; )
                                        Ne !== 0 && (at === 0 || !Pe || Me.z <= Pe.z) ? (we = Me,
                                        Me = Me.nextZ,
                                        Ne--) : (we = Pe,
                                        Pe = Pe.nextZ,
                                        at--),
                                        Le ? Le.nextZ = we : Q = we,
                                        we.prevZ = Le,
                                        Le = we;
                                    Me = Pe
                                }
                                Le.nextZ = null,
                                it *= 2
                            } while (Ue > 1)
                        }(q)
                    }(s, u, f, g);
                    for (var w, S, M = s; s.prev !== s.next; )
                        if (w = s.prev,
                        S = s.next,
                        g ? ID(s, u, f, g) : MD(s))
                            n.push(w.i / a | 0),
                            n.push(s.i / a | 0),
                            n.push(S.i / a | 0),
                            gp(s),
                            s = S.next,
                            M = S.next;
                        else if ((s = S) === M) {
                            y ? y === 1 ? pp(s = CD(pu(s), n, a), n, a, u, f, g, 2) : y === 2 && DD(s, n, a, u, f, g) : pp(pu(s), n, a, u, f, g, 1);
                            break
                        }
                }
            }
            function MD(s) {
                var n = s.prev
                  , a = s
                  , u = s.next;
                if (ur(n, a, u) >= 0)
                    return !1;
                for (var f = n.x, g = a.x, y = u.x, w = n.y, S = a.y, M = u.y, z = f < g ? f < y ? f : y : g < y ? g : y, N = w < S ? w < M ? w : M : S < M ? S : M, B = f > g ? f > y ? f : y : g > y ? g : y, H = w > S ? w > M ? w : M : S > M ? S : M, q = u.next; q !== n; ) {
                    if (q.x >= z && q.x <= B && q.y >= N && q.y <= H && td(f, w, g, S, y, M, q.x, q.y) && ur(q.prev, q, q.next) >= 0)
                        return !1;
                    q = q.next
                }
                return !0
            }
            function ID(s, n, a, u) {
                var f = s.prev
                  , g = s
                  , y = s.next;
                if (ur(f, g, y) >= 0)
                    return !1;
                for (var w = f.x, S = g.x, M = y.x, z = f.y, N = g.y, B = y.y, H = w < S ? w < M ? w : M : S < M ? S : M, q = z < N ? z < B ? z : B : N < B ? N : B, Q = w > S ? w > M ? w : M : S > M ? S : M, de = z > N ? z > B ? z : B : N > B ? N : B, Me = Ox(H, q, n, a, u), Pe = Ox(Q, de, n, a, u), we = s.prevZ, Le = s.nextZ; we && we.z >= Me && Le && Le.z <= Pe; ) {
                    if (we.x >= H && we.x <= Q && we.y >= q && we.y <= de && we !== f && we !== y && td(w, z, S, N, M, B, we.x, we.y) && ur(we.prev, we, we.next) >= 0 || (we = we.prevZ,
                    Le.x >= H && Le.x <= Q && Le.y >= q && Le.y <= de && Le !== f && Le !== y && td(w, z, S, N, M, B, Le.x, Le.y) && ur(Le.prev, Le, Le.next) >= 0))
                        return !1;
                    Le = Le.nextZ
                }
                for (; we && we.z >= Me; ) {
                    if (we.x >= H && we.x <= Q && we.y >= q && we.y <= de && we !== f && we !== y && td(w, z, S, N, M, B, we.x, we.y) && ur(we.prev, we, we.next) >= 0)
                        return !1;
                    we = we.prevZ
                }
                for (; Le && Le.z <= Pe; ) {
                    if (Le.x >= H && Le.x <= Q && Le.y >= q && Le.y <= de && Le !== f && Le !== y && td(w, z, S, N, M, B, Le.x, Le.y) && ur(Le.prev, Le, Le.next) >= 0)
                        return !1;
                    Le = Le.nextZ
                }
                return !0
            }
            function CD(s, n, a) {
                var u = s;
                do {
                    var f = u.prev
                      , g = u.next.next;
                    !y_(f, g) && zT(f, u, u.next, g) && mp(f, g) && mp(g, f) && (n.push(f.i / a | 0),
                    n.push(u.i / a | 0),
                    n.push(g.i / a | 0),
                    gp(u),
                    gp(u.next),
                    u = s = g),
                    u = u.next
                } while (u !== s);
                return pu(u)
            }
            function DD(s, n, a, u, f, g) {
                var y = s;
                do {
                    for (var w = y.next.next; w !== y.prev; ) {
                        if (y.i !== w.i && zD(y, w)) {
                            var S = OT(y, w);
                            return y = pu(y, y.next),
                            S = pu(S, S.next),
                            pp(y, n, a, u, f, g, 0),
                            void pp(S, n, a, u, f, g, 0)
                        }
                        w = w.next
                    }
                    y = y.next
                } while (y !== s)
            }
            function LD(s, n) {
                return s.x - n.x
            }
            function RD(s, n) {
                var a = function(f, g) {
                    var y, w = g, S = f.x, M = f.y, z = -1 / 0;
                    do {
                        if (M <= w.y && M >= w.next.y && w.next.y !== w.y) {
                            var N = w.x + (M - w.y) * (w.next.x - w.x) / (w.next.y - w.y);
                            if (N <= S && N > z && (z = N,
                            y = w.x < w.next.x ? w : w.next,
                            N === S))
                                return y
                        }
                        w = w.next
                    } while (w !== g);
                    if (!y)
                        return null;
                    var B, H = y, q = y.x, Q = y.y, de = 1 / 0;
                    w = y;
                    do
                        S >= w.x && w.x >= q && S !== w.x && td(M < Q ? S : z, M, q, Q, M < Q ? z : S, M, w.x, w.y) && (B = Math.abs(M - w.y) / (S - w.x),
                        mp(w, f) && (B < de || B === de && (w.x > y.x || w.x === y.x && PD(y, w))) && (y = w,
                        de = B)),
                        w = w.next;
                    while (w !== H);
                    return y
                }(s, n);
                if (!a)
                    return n;
                var u = OT(a, s);
                return pu(u, u.next),
                pu(a, a.next)
            }
            function PD(s, n) {
                return ur(s.prev, s, n.prev) < 0 && ur(n.next, s, s.next) < 0
            }
            function Ox(s, n, a, u, f) {
                return (s = 1431655765 & ((s = 858993459 & ((s = 252645135 & ((s = 16711935 & ((s = (s - a) * f | 0) | s << 8)) | s << 4)) | s << 2)) | s << 1)) | (n = 1431655765 & ((n = 858993459 & ((n = 252645135 & ((n = 16711935 & ((n = (n - u) * f | 0) | n << 8)) | n << 4)) | n << 2)) | n << 1)) << 1
            }
            function kD(s) {
                var n = s
                  , a = s;
                do
                    (n.x < a.x || n.x === a.x && n.y < a.y) && (a = n),
                    n = n.next;
                while (n !== s);
                return a
            }
            function td(s, n, a, u, f, g, y, w) {
                return (f - y) * (n - w) >= (s - y) * (g - w) && (s - y) * (u - w) >= (a - y) * (n - w) && (a - y) * (g - w) >= (f - y) * (u - w)
            }
            function zD(s, n) {
                return s.next.i !== n.i && s.prev.i !== n.i && !function(a, u) {
                    var f = a;
                    do {
                        if (f.i !== a.i && f.next.i !== a.i && f.i !== u.i && f.next.i !== u.i && zT(f, f.next, a, u))
                            return !0;
                        f = f.next
                    } while (f !== a);
                    return !1
                }(s, n) && (mp(s, n) && mp(n, s) && function(a, u) {
                    var f = a
                      , g = !1
                      , y = (a.x + u.x) / 2
                      , w = (a.y + u.y) / 2;
                    do
                        f.y > w != f.next.y > w && f.next.y !== f.y && y < (f.next.x - f.x) * (w - f.y) / (f.next.y - f.y) + f.x && (g = !g),
                        f = f.next;
                    while (f !== a);
                    return g
                }(s, n) && (ur(s.prev, s, n.prev) || ur(s, n.prev, n)) || y_(s, n) && ur(s.prev, s, s.next) > 0 && ur(n.prev, n, n.next) > 0)
            }
            function ur(s, n, a) {
                return (n.y - s.y) * (a.x - n.x) - (n.x - s.x) * (a.y - n.y)
            }
            function y_(s, n) {
                return s.x === n.x && s.y === n.y
            }
            function zT(s, n, a, u) {
                var f = v_(ur(s, n, a))
                  , g = v_(ur(s, n, u))
                  , y = v_(ur(a, u, s))
                  , w = v_(ur(a, u, n));
                return f !== g && y !== w || !(f !== 0 || !x_(s, a, n)) || !(g !== 0 || !x_(s, u, n)) || !(y !== 0 || !x_(a, s, u)) || !(w !== 0 || !x_(a, n, u))
            }
            function x_(s, n, a) {
                return n.x <= Math.max(s.x, a.x) && n.x >= Math.min(s.x, a.x) && n.y <= Math.max(s.y, a.y) && n.y >= Math.min(s.y, a.y)
            }
            function v_(s) {
                return s > 0 ? 1 : s < 0 ? -1 : 0
            }
            function mp(s, n) {
                return ur(s.prev, s, s.next) < 0 ? ur(s, n, s.next) >= 0 && ur(s, s.prev, n) >= 0 : ur(s, n, s.prev) < 0 || ur(s, s.next, n) < 0
            }
            function OT(s, n) {
                var a = new Nx(s.i,s.x,s.y)
                  , u = new Nx(n.i,n.x,n.y)
                  , f = s.next
                  , g = n.prev;
                return s.next = n,
                n.prev = s,
                a.next = f,
                f.prev = a,
                u.next = a,
                a.prev = u,
                g.next = u,
                u.prev = g,
                u
            }
            function NT(s, n, a, u) {
                var f = new Nx(s,n,a);
                return u ? (f.next = u.next,
                f.prev = u,
                u.next.prev = f,
                u.next = f) : (f.prev = f,
                f.next = f),
                f
            }
            function gp(s) {
                s.next.prev = s.prev,
                s.prev.next = s.next,
                s.prevZ && (s.prevZ.nextZ = s.nextZ),
                s.nextZ && (s.nextZ.prevZ = s.prevZ)
            }
            function Nx(s, n, a) {
                this.i = s,
                this.x = n,
                this.y = a,
                this.prev = null,
                this.next = null,
                this.z = 0,
                this.prevZ = null,
                this.nextZ = null,
                this.steiner = !1
            }
            function Fx(s, n, a, u) {
                for (var f = 0, g = n, y = a - u; g < a; g += u)
                    f += (s[y] - s[g]) * (s[g + 1] + s[y + 1]),
                    y = g;
                return f
            }
            function OD(s, n, a, u, f) {
                FT(s, n, a || 0, u || s.length - 1, f || ND)
            }
            function FT(s, n, a, u, f) {
                for (; u > a; ) {
                    if (u - a > 600) {
                        var g = u - a + 1
                          , y = n - a + 1
                          , w = Math.log(g)
                          , S = .5 * Math.exp(2 * w / 3)
                          , M = .5 * Math.sqrt(w * S * (g - S) / g) * (y - g / 2 < 0 ? -1 : 1);
                        FT(s, n, Math.max(a, Math.floor(n - y * S / g + M)), Math.min(u, Math.floor(n + (g - y) * S / g + M)), f)
                    }
                    var z = s[n]
                      , N = a
                      , B = u;
                    for (_p(s, a, n),
                    f(s[u], z) > 0 && _p(s, a, u); N < B; ) {
                        for (_p(s, N, B),
                        N++,
                        B--; f(s[N], z) < 0; )
                            N++;
                        for (; f(s[B], z) > 0; )
                            B--
                    }
                    f(s[a], z) === 0 ? _p(s, a, B) : _p(s, ++B, u),
                    B <= n && (a = B + 1),
                    n <= B && (u = B - 1)
                }
            }
            function _p(s, n, a) {
                var u = s[n];
                s[n] = s[a],
                s[a] = u
            }
            function ND(s, n) {
                return s < n ? -1 : s > n ? 1 : 0
            }
            function Bx(s, n) {
                let a = s.length;
                if (a <= 1)
                    return [s];
                let u = [], f, g;
                for (let y = 0; y < a; y++) {
                    let w = xt(s[y]);
                    w !== 0 && (s[y].area = Math.abs(w),
                    g === void 0 && (g = w < 0),
                    g === w < 0 ? (f && u.push(f),
                    f = [s[y]]) : f.push(s[y]))
                }
                if (f && u.push(f),
                n > 1)
                    for (let y = 0; y < u.length; y++)
                        u[y].length <= n || (OD(u[y], n, 1, u[y].length - 1, FD),
                        u[y] = u[y].slice(0, n));
                return u
            }
            function FD(s, n) {
                return n.area - s.area
            }
            function Ux(s, n, a) {
                let u = a.patternDependencies
                  , f = !1;
                for (let g of n) {
                    let y = g.paint.get(`${s}-pattern`);
                    y.isConstant() || (f = !0);
                    let w = y.constantOr(null);
                    w && (f = !0,
                    u[w] = !0)
                }
                return f
            }
            function Vx(s, n, a, u, f) {
                let g = f.patternDependencies;
                for (let y of n) {
                    let w = y.paint.get(`${s}-pattern`).value;
                    if (w.kind !== "constant") {
                        let S = w.evaluate({
                            zoom: u
                        }, a, {}, f.availableImages);
                        S = S && S.name ? S.name : S,
                        g[S] = !0,
                        a.patterns[y.id] = S
                    }
                }
                return a
            }
            ({
                get exports() {
                    return ed
                },
                set exports(s) {
                    ed = s
                }
            }).exports = __,
            ed.default = __,
            __.deviation = function(s, n, a, u) {
                var f = n && n.length
                  , g = Math.abs(Fx(s, 0, f ? n[0] * a : s.length, a));
                if (f)
                    for (var y = 0, w = n.length; y < w; y++)
                        g -= Math.abs(Fx(s, n[y] * a, y < w - 1 ? n[y + 1] * a : s.length, a));
                var S = 0;
                for (y = 0; y < u.length; y += 3) {
                    var M = u[y] * a
                      , z = u[y + 1] * a
                      , N = u[y + 2] * a;
                    S += Math.abs((s[M] - s[N]) * (s[z + 1] - s[M + 1]) - (s[M] - s[z]) * (s[N + 1] - s[M + 1]))
                }
                return g === 0 && S === 0 ? 0 : Math.abs((S - g) / g)
            }
            ,
            __.flatten = function(s) {
                for (var n = s[0][0].length, a = {
                    vertices: [],
                    holes: [],
                    dimensions: n
                }, u = 0, f = 0; f < s.length; f++) {
                    for (var g = 0; g < s[f].length; g++)
                        for (var y = 0; y < n; y++)
                            a.vertices.push(s[f][g][y]);
                    f > 0 && a.holes.push(u += s[f - 1].length)
                }
                return a
            }
            ;
            class b_ {
                constructor(n) {
                    this.zoom = n.zoom,
                    this.overscaling = n.overscaling,
                    this.layers = n.layers,
                    this.layerIds = this.layers.map(a=>a.id),
                    this.index = n.index,
                    this.hasPattern = !1,
                    this.patternFeatures = [],
                    this.layoutVertexArray = new En,
                    this.indexArray = new Xr,
                    this.indexArray2 = new Qo,
                    this.programConfigurations = new ou(n.layers,n.zoom),
                    this.segments = new cr,
                    this.segments2 = new cr,
                    this.stateDependentLayerIds = this.layers.filter(a=>a.isStateDependent()).map(a=>a.id),
                    this.projection = n.projection
                }
                populate(n, a, u, f) {
                    this.hasPattern = Ux("fill", this.layers, a);
                    let g = this.layers[0].layout.get("fill-sort-key")
                      , y = [];
                    for (let {feature: w, id: S, index: M, sourceLayerIndex: z} of n) {
                        let N = this.layers[0]._featureFilter.needGeometry
                          , B = du(w, N);
                        if (!this.layers[0]._featureFilter.filter(new $e(this.zoom), B, u))
                            continue;
                        let H = g ? g.evaluate(B, {}, u, a.availableImages) : void 0
                          , q = {
                            id: S,
                            properties: w.properties,
                            type: w.type,
                            sourceLayerIndex: z,
                            index: M,
                            geometry: N ? B.geometry : Na(w, u, f),
                            patterns: {},
                            sortKey: H
                        };
                        y.push(q)
                    }
                    g && y.sort((w,S)=>w.sortKey - S.sortKey);
                    for (let w of y) {
                        let {geometry: S, index: M, sourceLayerIndex: z} = w;
                        if (this.hasPattern) {
                            let N = Vx("fill", this.layers, w, this.zoom, a);
                            this.patternFeatures.push(N)
                        } else
                            this.addFeature(w, S, M, u, {}, a.availableImages);
                        a.featureIndex.insert(n[M].feature, S, M, z, this.index)
                    }
                }
                update(n, a, u, f) {
                    this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(n, a, this.stateDependentLayers, u, f)
                }
                addFeatures(n, a, u, f, g) {
                    for (let y of this.patternFeatures)
                        this.addFeature(y, y.geometry, y.index, a, u, f)
                }
                isEmpty() {
                    return this.layoutVertexArray.length === 0
                }
                uploadPending() {
                    return !this.uploaded || this.programConfigurations.needsUpload
                }
                upload(n) {
                    this.uploaded || (this.layoutVertexBuffer = n.createVertexBuffer(this.layoutVertexArray, AD),
                    this.indexBuffer = n.createIndexBuffer(this.indexArray),
                    this.indexBuffer2 = n.createIndexBuffer(this.indexArray2)),
                    this.programConfigurations.upload(n),
                    this.uploaded = !0
                }
                destroy() {
                    this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(),
                    this.indexBuffer.destroy(),
                    this.indexBuffer2.destroy(),
                    this.programConfigurations.destroy(),
                    this.segments.destroy(),
                    this.segments2.destroy())
                }
                addFeature(n, a, u, f, g, y=[]) {
                    for (let w of Bx(a, 500)) {
                        let S = 0;
                        for (let q of w)
                            S += q.length;
                        let M = this.segments.prepareSegment(S, this.layoutVertexArray, this.indexArray)
                          , z = M.vertexLength
                          , N = []
                          , B = [];
                        for (let q of w) {
                            if (q.length === 0)
                                continue;
                            q !== w[0] && B.push(N.length / 2);
                            let Q = this.segments2.prepareSegment(q.length, this.layoutVertexArray, this.indexArray2)
                              , de = Q.vertexLength;
                            this.layoutVertexArray.emplaceBack(q[0].x, q[0].y),
                            this.indexArray2.emplaceBack(de + q.length - 1, de),
                            N.push(q[0].x),
                            N.push(q[0].y);
                            for (let Me = 1; Me < q.length; Me++)
                                this.layoutVertexArray.emplaceBack(q[Me].x, q[Me].y),
                                this.indexArray2.emplaceBack(de + Me - 1, de + Me),
                                N.push(q[Me].x),
                                N.push(q[Me].y);
                            Q.vertexLength += q.length,
                            Q.primitiveLength += q.length
                        }
                        let H = ed(N, B);
                        for (let q = 0; q < H.length; q += 3)
                            this.indexArray.emplaceBack(z + H[q], z + H[q + 1], z + H[q + 2]);
                        M.vertexLength += S,
                        M.primitiveLength += H.length / 3
                    }
                    this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, n, u, g, y, f)
                }
            }
            cn(b_, "FillBucket", {
                omit: ["layers", "patternFeatures"]
            });
            let BD = new Pt({
                "fill-sort-key": new ct(ht.layout_fill["fill-sort-key"])
            });
            var UD = {
                paint: new Pt({
                    "fill-antialias": new Je(ht.paint_fill["fill-antialias"]),
                    "fill-opacity": new ct(ht.paint_fill["fill-opacity"]),
                    "fill-color": new ct(ht.paint_fill["fill-color"]),
                    "fill-outline-color": new ct(ht.paint_fill["fill-outline-color"]),
                    "fill-translate": new Je(ht.paint_fill["fill-translate"]),
                    "fill-translate-anchor": new Je(ht.paint_fill["fill-translate-anchor"]),
                    "fill-pattern": new ct(ht.paint_fill["fill-pattern"])
                }),
                layout: BD
            };
            let VD = vn([{
                name: "a_pos_normal_ed",
                components: 4,
                type: "Int16"
            }])
              , GD = vn([{
                name: "a_centroid_pos",
                components: 2,
                type: "Uint16"
            }])
              , HD = vn([{
                name: "a_pos_3",
                components: 3,
                type: "Int16"
            }, {
                name: "a_pos_normal_3",
                components: 3,
                type: "Int16"
            }])
              , {members: WD} = VD;
            var w_ = {}
              , jD = W
              , BT = nd;
            function nd(s, n, a, u, f) {
                this.properties = {},
                this.extent = a,
                this.type = 0,
                this._pbf = s,
                this._geometry = -1,
                this._keys = u,
                this._values = f,
                s.readFields(XD, this, n)
            }
            function XD(s, n, a) {
                s == 1 ? n.id = a.readVarint() : s == 2 ? function(u, f) {
                    for (var g = u.readVarint() + u.pos; u.pos < g; ) {
                        var y = f._keys[u.readVarint()]
                          , w = f._values[u.readVarint()];
                        f.properties[y] = w
                    }
                }(a, n) : s == 3 ? n.type = a.readVarint() : s == 4 && (n._geometry = a.pos)
            }
            function ZD(s) {
                for (var n, a, u = 0, f = 0, g = s.length, y = g - 1; f < g; y = f++)
                    u += ((a = s[y]).x - (n = s[f]).x) * (n.y + a.y);
                return u
            }
            nd.types = ["Unknown", "Point", "LineString", "Polygon"],
            nd.prototype.loadGeometry = function() {
                var s = this._pbf;
                s.pos = this._geometry;
                for (var n, a = s.readVarint() + s.pos, u = 1, f = 0, g = 0, y = 0, w = []; s.pos < a; ) {
                    if (f <= 0) {
                        var S = s.readVarint();
                        u = 7 & S,
                        f = S >> 3
                    }
                    if (f--,
                    u === 1 || u === 2)
                        g += s.readSVarint(),
                        y += s.readSVarint(),
                        u === 1 && (n && w.push(n),
                        n = []),
                        n.push(new jD(g,y));
                    else {
                        if (u !== 7)
                            throw new Error("unknown command " + u);
                        n && n.push(n[0].clone())
                    }
                }
                return n && w.push(n),
                w
            }
            ,
            nd.prototype.bbox = function() {
                var s = this._pbf;
                s.pos = this._geometry;
                for (var n = s.readVarint() + s.pos, a = 1, u = 0, f = 0, g = 0, y = 1 / 0, w = -1 / 0, S = 1 / 0, M = -1 / 0; s.pos < n; ) {
                    if (u <= 0) {
                        var z = s.readVarint();
                        a = 7 & z,
                        u = z >> 3
                    }
                    if (u--,
                    a === 1 || a === 2)
                        (f += s.readSVarint()) < y && (y = f),
                        f > w && (w = f),
                        (g += s.readSVarint()) < S && (S = g),
                        g > M && (M = g);
                    else if (a !== 7)
                        throw new Error("unknown command " + a)
                }
                return [y, S, w, M]
            }
            ,
            nd.prototype.toGeoJSON = function(s, n, a) {
                var u, f, g = this.extent * Math.pow(2, a), y = this.extent * s, w = this.extent * n, S = this.loadGeometry(), M = nd.types[this.type];
                function z(H) {
                    for (var q = 0; q < H.length; q++) {
                        var Q = H[q];
                        H[q] = [360 * (Q.x + y) / g - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (Q.y + w) / g) * Math.PI / 180)) - 90]
                    }
                }
                switch (this.type) {
                case 1:
                    var N = [];
                    for (u = 0; u < S.length; u++)
                        N[u] = S[u][0];
                    z(S = N);
                    break;
                case 2:
                    for (u = 0; u < S.length; u++)
                        z(S[u]);
                    break;
                case 3:
                    for (S = function(H) {
                        var q = H.length;
                        if (q <= 1)
                            return [H];
                        for (var Q, de, Me = [], Pe = 0; Pe < q; Pe++) {
                            var we = ZD(H[Pe]);
                            we !== 0 && (de === void 0 && (de = we < 0),
                            de === we < 0 ? (Q && Me.push(Q),
                            Q = [H[Pe]]) : Q.push(H[Pe]))
                        }
                        return Q && Me.push(Q),
                        Me
                    }(S),
                    u = 0; u < S.length; u++)
                        for (f = 0; f < S[u].length; f++)
                            z(S[u][f])
                }
                S.length === 1 ? S = S[0] : M = "Multi" + M;
                var B = {
                    type: "Feature",
                    geometry: {
                        type: M,
                        coordinates: S
                    },
                    properties: this.properties
                };
                return "id"in this && (B.id = this.id),
                B
            }
            ;
            var qD = BT
              , UT = VT;
            function VT(s, n) {
                this.version = 1,
                this.name = null,
                this.extent = 4096,
                this.length = 0,
                this._pbf = s,
                this._keys = [],
                this._values = [],
                this._features = [],
                s.readFields(KD, this, n),
                this.length = this._features.length
            }
            function KD(s, n, a) {
                s === 15 ? n.version = a.readVarint() : s === 1 ? n.name = a.readString() : s === 5 ? n.extent = a.readVarint() : s === 2 ? n._features.push(a.pos) : s === 3 ? n._keys.push(a.readString()) : s === 4 && n._values.push(function(u) {
                    for (var f = null, g = u.readVarint() + u.pos; u.pos < g; ) {
                        var y = u.readVarint() >> 3;
                        f = y === 1 ? u.readString() : y === 2 ? u.readFloat() : y === 3 ? u.readDouble() : y === 4 ? u.readVarint64() : y === 5 ? u.readVarint() : y === 6 ? u.readSVarint() : y === 7 ? u.readBoolean() : null
                    }
                    return f
                }(a))
            }
            VT.prototype.feature = function(s) {
                if (s < 0 || s >= this._features.length)
                    throw new Error("feature index out of bounds");
                this._pbf.pos = this._features[s];
                var n = this._pbf.readVarint() + this._pbf.pos;
                return new qD(this._pbf,n,this.extent,this._keys,this._values)
            }
            ;
            var YD = UT;
            function JD(s, n, a) {
                if (s === 3) {
                    var u = new YD(a,a.readVarint() + a.pos);
                    u.length && (n[u.name] = u)
                }
            }
            var Gx = w_.VectorTile = function(s, n) {
                this.layers = s.readFields(JD, {}, n)
            }
              , T_ = w_.VectorTileFeature = BT;
            function E_(s, n, a, u) {
                let f = []
                  , g = u === 0 ? (y,w,S,M,z,N)=>{
                    y.push(new W(N,S + (N - w) / (M - w) * (z - S)))
                }
                : (y,w,S,M,z,N)=>{
                    y.push(new W(w + (N - S) / (z - S) * (M - w),N))
                }
                ;
                for (let y of s) {
                    let w = [];
                    for (let S of y) {
                        if (S.length <= 2)
                            continue;
                        let M = [];
                        for (let B = 0; B < S.length - 1; B++) {
                            let H = S[B].x
                              , q = S[B].y
                              , Q = S[B + 1].x
                              , de = S[B + 1].y
                              , Me = u === 0 ? H : q
                              , Pe = u === 0 ? Q : de;
                            Me < n ? Pe > n && g(M, H, q, Q, de, n) : Me > a ? Pe < a && g(M, H, q, Q, de, a) : M.push(S[B]),
                            Pe < n && Me >= n && g(M, H, q, Q, de, n),
                            Pe > a && Me <= a && g(M, H, q, Q, de, a)
                        }
                        let z = S[S.length - 1]
                          , N = u === 0 ? z.x : z.y;
                        N >= n && N <= a && M.push(z),
                        M.length && (z = M[M.length - 1],
                        M[0].x === z.x && M[0].y === z.y || M.push(M[0]),
                        w.push(M))
                    }
                    w.length && f.push(w)
                }
                return f
            }
            w_.VectorTileLayer = UT;
            let $D = T_.types
              , QD = Math.pow(2, 13);
            function yp(s, n, a, u, f, g, y, w) {
                s.emplaceBack((n << 1) + y, (a << 1) + g, (Math.floor(u * QD) << 1) + f, Math.round(w))
            }
            function xp(s, n, a) {
                let u = 16384;
                s.emplaceBack(n.x, n.y, n.z, a[0] * u, a[1] * u, a[2] * u)
            }
            class GT {
                constructor() {
                    this.acc = new W(0,0),
                    this.polyCount = []
                }
                startRing(n) {
                    this.currentPolyCount = {
                        edges: 0,
                        top: 0
                    },
                    this.polyCount.push(this.currentPolyCount),
                    this.min || (this.min = new W(n.x,n.y),
                    this.max = new W(n.x,n.y))
                }
                append(n, a) {
                    this.currentPolyCount.edges++,
                    this.acc._add(n);
                    let u = this.min
                      , f = this.max;
                    n.x < u.x ? u.x = n.x : n.x > f.x && (f.x = n.x),
                    n.y < u.y ? u.y = n.y : n.y > f.y && (f.y = n.y),
                    ((n.x === 0 || n.x === kn) && n.x === a.x) != ((n.y === 0 || n.y === kn) && n.y === a.y) && this.processBorderOverlap(n, a),
                    a.x < 0 != n.x < 0 && this.addBorderIntersection(0, si(a.y, n.y, (0 - a.x) / (n.x - a.x))),
                    a.x > kn != n.x > kn && this.addBorderIntersection(1, si(a.y, n.y, (kn - a.x) / (n.x - a.x))),
                    a.y < 0 != n.y < 0 && this.addBorderIntersection(2, si(a.x, n.x, (0 - a.y) / (n.y - a.y))),
                    a.y > kn != n.y > kn && this.addBorderIntersection(3, si(a.x, n.x, (kn - a.y) / (n.y - a.y)))
                }
                addBorderIntersection(n, a) {
                    this.borders || (this.borders = [[Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE]]);
                    let u = this.borders[n];
                    a < u[0] && (u[0] = a),
                    a > u[1] && (u[1] = a)
                }
                processBorderOverlap(n, a) {
                    if (n.x === a.x) {
                        if (n.y === a.y)
                            return;
                        let u = n.x === 0 ? 0 : 1;
                        this.addBorderIntersection(u, a.y),
                        this.addBorderIntersection(u, n.y)
                    } else {
                        let u = n.y === 0 ? 2 : 3;
                        this.addBorderIntersection(u, a.x),
                        this.addBorderIntersection(u, n.x)
                    }
                }
                centroid() {
                    let n = this.polyCount.reduce((a,u)=>a + u.edges, 0);
                    return n !== 0 ? this.acc.div(n)._round() : new W(0,0)
                }
                span() {
                    return new W(this.max.x - this.min.x,this.max.y - this.min.y)
                }
                intersectsCount() {
                    return this.borders.reduce((n,a)=>n + +(a[0] !== Number.MAX_VALUE), 0)
                }
            }
            class vp {
                constructor(n) {
                    this.zoom = n.zoom,
                    this.canonical = n.canonical,
                    this.overscaling = n.overscaling,
                    this.layers = n.layers,
                    this.layerIds = this.layers.map(a=>a.id),
                    this.index = n.index,
                    this.hasPattern = !1,
                    this.edgeRadius = 0,
                    this.projection = n.projection,
                    this.layoutVertexArray = new Ti,
                    this.centroidVertexArray = new Hw,
                    this.indexArray = new Xr,
                    this.programConfigurations = new ou(n.layers,n.zoom),
                    this.segments = new cr,
                    this.stateDependentLayerIds = this.layers.filter(a=>a.isStateDependent()).map(a=>a.id),
                    this.enableTerrain = n.enableTerrain
                }
                populate(n, a, u, f) {
                    this.features = [],
                    this.hasPattern = Ux("fill-extrusion", this.layers, a),
                    this.featuresOnBorder = [],
                    this.borders = [[], [], [], []],
                    this.borderDoneWithNeighborZ = [-1, -1, -1, -1],
                    this.tileToMeter = function(g) {
                        let y = Math.exp(Math.PI * (1 - g.y / (1 << g.z) * 2));
                        return 80150034 * y / (y * y + 1) / kn / (1 << g.z)
                    }(u),
                    this.edgeRadius = this.layers[0].layout.get("fill-extrusion-edge-radius") / this.tileToMeter;
                    for (let {feature: g, id: y, index: w, sourceLayerIndex: S} of n) {
                        let M = this.layers[0]._featureFilter.needGeometry
                          , z = du(g, M);
                        if (!this.layers[0]._featureFilter.filter(new $e(this.zoom), z, u))
                            continue;
                        let N = {
                            id: y,
                            sourceLayerIndex: S,
                            index: w,
                            geometry: M ? z.geometry : Na(g, u, f),
                            properties: g.properties,
                            type: g.type,
                            patterns: {}
                        }
                          , B = this.layoutVertexArray.length;
                        this.hasPattern ? this.features.push(Vx("fill-extrusion", this.layers, N, this.zoom, a)) : this.addFeature(N, N.geometry, w, u, {}, a.availableImages, f),
                        a.featureIndex.insert(g, N.geometry, w, S, this.index, B)
                    }
                    this.sortBorders()
                }
                addFeatures(n, a, u, f, g) {
                    for (let y of this.features) {
                        let {geometry: w} = y;
                        this.addFeature(y, w, y.index, a, u, f, g)
                    }
                    this.sortBorders()
                }
                update(n, a, u, f) {
                    this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(n, a, this.stateDependentLayers, u, f)
                }
                isEmpty() {
                    return this.layoutVertexArray.length === 0
                }
                uploadPending() {
                    return !this.uploaded || this.programConfigurations.needsUpload
                }
                upload(n) {
                    this.uploaded || (this.layoutVertexBuffer = n.createVertexBuffer(this.layoutVertexArray, WD),
                    this.indexBuffer = n.createIndexBuffer(this.indexArray),
                    this.layoutVertexExtArray && (this.layoutVertexExtBuffer = n.createVertexBuffer(this.layoutVertexExtArray, HD.members, !0))),
                    this.programConfigurations.upload(n),
                    this.uploaded = !0
                }
                uploadCentroid(n) {
                    this.centroidVertexArray.length !== 0 && (this.centroidVertexBuffer ? this.needsCentroidUpdate && this.centroidVertexBuffer.updateData(this.centroidVertexArray) : this.centroidVertexBuffer = n.createVertexBuffer(this.centroidVertexArray, GD.members, !0),
                    this.needsCentroidUpdate = !1)
                }
                destroy() {
                    this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(),
                    this.centroidVertexBuffer && this.centroidVertexBuffer.destroy(),
                    this.layoutVertexExtBuffer && this.layoutVertexExtBuffer.destroy(),
                    this.indexBuffer.destroy(),
                    this.programConfigurations.destroy(),
                    this.segments.destroy())
                }
                addFeature(n, a, u, f, g, y, w) {
                    let S = [new W(0,0), new W(kn,kn)]
                      , M = w.projection
                      , z = M.name === "globe"
                      , N = this.enableTerrain && !z ? new GT : null
                      , B = $D[n.type] === "Polygon";
                    z && !this.layoutVertexExtArray && (this.layoutVertexExtArray = new Ks);
                    let H = Bx(a, 500);
                    for (let Me = H.length - 1; Me >= 0; Me--) {
                        let Pe = H[Me];
                        (Pe.length === 0 || (q = Pe[0]).every(we=>we.x <= 0) || q.every(we=>we.x >= kn) || q.every(we=>we.y <= 0) || q.every(we=>we.y >= kn)) && H.splice(Me, 1)
                    }
                    var q;
                    let Q;
                    if (z)
                        Q = KT(H, S, f);
                    else {
                        Q = [];
                        for (let Me of H)
                            Q.push({
                                polygon: Me,
                                bounds: S
                            })
                    }
                    let de = B ? this.edgeRadius : 0;
                    for (let {polygon: Me, bounds: Pe} of Q) {
                        let we = 0
                          , Le = 0;
                        for (let Ne of Me)
                            B && !Ne[0].equals(Ne[Ne.length - 1]) && Ne.push(Ne[0]),
                            Le += B ? Ne.length - 1 : Ne.length;
                        let Ue = this.segments.prepareSegment((B ? 5 : 4) * Le, this.layoutVertexArray, this.indexArray);
                        if (B) {
                            let Ne = []
                              , at = [];
                            we = Ue.vertexLength;
                            for (let _t of Me) {
                                let Ot, dt;
                                _t.length && _t !== Me[0] && at.push(Ne.length / 2),
                                Ot = _t[1].sub(_t[0])._perp()._unit();
                                for (let yt = 1; yt < _t.length; yt++) {
                                    let Tt = _t[yt]
                                      , Lt = _t[yt === _t.length - 1 ? 1 : yt + 1]
                                      , {x: Nt, y: mt} = Tt;
                                    if (de) {
                                        dt = Lt.sub(Tt)._perp()._unit();
                                        let qt = Ot.add(dt)._unit()
                                          , Sn = de * Math.min(4, 1 / (Ot.x * qt.x + Ot.y * qt.y));
                                        Nt += Sn * qt.x,
                                        mt += Sn * qt.y,
                                        Ot = dt
                                    }
                                    yp(this.layoutVertexArray, Nt, mt, 0, 0, 1, 1, 0),
                                    Ue.vertexLength++,
                                    Ne.push(Tt.x, Tt.y),
                                    z && xp(this.layoutVertexExtArray, M.projectTilePoint(Nt, mt, f), M.upVector(f, Nt, mt))
                                }
                            }
                            let it = ed(Ne, at);
                            for (let _t = 0; _t < it.length; _t += 3)
                                this.indexArray.emplaceBack(we + it[_t], we + it[_t + 2], we + it[_t + 1]),
                                Ue.primitiveLength++
                        }
                        for (let Ne of Me) {
                            N && Ne.length && N.startRing(Ne[0]);
                            let at, it, _t, Ot = Ne.length > 4 && XT(Ne[Ne.length - 2], Ne[0], Ne[1]), dt = de ? eL(Ne[Ne.length - 2], Ne[0], Ne[1], de) : 0;
                            it = Ne[1].sub(Ne[0])._perp()._unit();
                            let yt = !0;
                            for (let Tt = 1, Lt = 0; Tt < Ne.length; Tt++) {
                                let Nt = Ne[Tt - 1]
                                  , mt = Ne[Tt]
                                  , qt = Ne[Tt === Ne.length - 1 ? 1 : Tt + 1];
                                if (N && B && N.currentPolyCount.top++,
                                jT(mt, Nt, Pe)) {
                                    de && (it = qt.sub(mt)._perp()._unit(),
                                    yt = !yt);
                                    continue
                                }
                                N && N.append(mt, Nt);
                                let Sn = mt.sub(Nt)._perp()
                                  , en = Sn.x / (Math.abs(Sn.x) + Math.abs(Sn.y))
                                  , hn = Sn.y > 0 ? 1 : 0
                                  , Yt = Nt.dist(mt);
                                if (Lt + Yt > 32768 && (Lt = 0),
                                de) {
                                    _t = qt.sub(mt)._perp()._unit();
                                    let Kn = WT(Nt, mt, qt, HT(it, _t), de);
                                    isNaN(Kn) && (Kn = 0);
                                    let Rn = mt.sub(Nt)._unit();
                                    Nt = Nt.add(Rn.mult(dt))._round(),
                                    mt = mt.add(Rn.mult(-Kn))._round(),
                                    dt = Kn,
                                    it = _t
                                }
                                let Cn = Ue.vertexLength
                                  , ei = Ne.length > 4 && XT(Nt, mt, qt)
                                  , Jn = ZT(Lt, Ot, yt);
                                if (yp(this.layoutVertexArray, Nt.x, Nt.y, en, hn, 0, 0, Jn),
                                yp(this.layoutVertexArray, Nt.x, Nt.y, en, hn, 0, 1, Jn),
                                Lt += Yt,
                                Jn = ZT(Lt, ei, !yt),
                                Ot = ei,
                                yp(this.layoutVertexArray, mt.x, mt.y, en, hn, 0, 0, Jn),
                                yp(this.layoutVertexArray, mt.x, mt.y, en, hn, 0, 1, Jn),
                                Ue.vertexLength += 4,
                                this.indexArray.emplaceBack(Cn + 0, Cn + 1, Cn + 2),
                                this.indexArray.emplaceBack(Cn + 1, Cn + 3, Cn + 2),
                                Ue.primitiveLength += 2,
                                de) {
                                    let Kn = we + (Tt === 1 ? Ne.length - 2 : Tt - 2)
                                      , Rn = Tt === 1 ? we : Kn + 1;
                                    if (this.indexArray.emplaceBack(Cn + 1, Kn, Cn + 3),
                                    this.indexArray.emplaceBack(Kn, Rn, Cn + 3),
                                    Ue.primitiveLength += 2,
                                    at === void 0 && (at = Cn),
                                    !jT(qt, Ne[Tt], Pe)) {
                                        let vi = Tt === Ne.length - 1 ? at : Ue.vertexLength;
                                        this.indexArray.emplaceBack(Cn + 2, Cn + 3, vi),
                                        this.indexArray.emplaceBack(Cn + 3, vi + 1, vi),
                                        this.indexArray.emplaceBack(Cn + 3, Rn, vi + 1),
                                        Ue.primitiveLength += 3
                                    }
                                    yt = !yt
                                }
                                if (z) {
                                    let Kn = this.layoutVertexExtArray
                                      , Rn = M.projectTilePoint(Nt.x, Nt.y, f)
                                      , vi = M.projectTilePoint(mt.x, mt.y, f)
                                      , Bn = M.upVector(f, Nt.x, Nt.y)
                                      , ti = M.upVector(f, mt.x, mt.y);
                                    xp(Kn, Rn, Bn),
                                    xp(Kn, Rn, Bn),
                                    xp(Kn, vi, ti),
                                    xp(Kn, vi, ti)
                                }
                            }
                            B && (we += Ne.length - 1)
                        }
                    }
                    if (N && N.polyCount.length > 0) {
                        if (N.borders) {
                            N.vertexArrayOffset = this.centroidVertexArray.length;
                            let Me = N.borders
                              , Pe = this.featuresOnBorder.push(N) - 1;
                            for (let we = 0; we < 4; we++)
                                Me[we][0] !== Number.MAX_VALUE && this.borders[we].push(Pe)
                        }
                        this.encodeCentroid(N.borders ? void 0 : N.centroid(), N)
                    }
                    this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, n, u, g, y, f)
                }
                sortBorders() {
                    for (let n = 0; n < 4; n++)
                        this.borders[n].sort((a,u)=>this.featuresOnBorder[a].borders[n][0] - this.featuresOnBorder[u].borders[n][0])
                }
                encodeCentroid(n, a, u=!0) {
                    let f, g;
                    if (n)
                        if (n.y !== 0) {
                            let w = a.span()._mult(this.tileToMeter);
                            f = (Math.max(n.x, 1) << 3) + Math.min(7, Math.round(w.x / 10)),
                            g = (Math.max(n.y, 1) << 3) + Math.min(7, Math.round(w.y / 10))
                        } else
                            f = Math.ceil(7 * (n.x + 450)),
                            g = 0;
                    else
                        f = 0,
                        g = +u;
                    let y = u ? this.centroidVertexArray.length : a.vertexArrayOffset;
                    for (let w of a.polyCount) {
                        u && this.centroidVertexArray.resize(this.centroidVertexArray.length + 4 * w.edges + w.top);
                        for (let S = 0; S < w.top; S++)
                            this.centroidVertexArray.emplace(y++, f, g);
                        for (let S = 0; S < 2 * w.edges; S++)
                            this.centroidVertexArray.emplace(y++, 0, g),
                            this.centroidVertexArray.emplace(y++, f, g)
                    }
                }
            }
            function HT(s, n) {
                let a = s.add(n)._unit();
                return s.x * a.x + s.y * a.y
            }
            function eL(s, n, a, u) {
                let f = n.sub(s)._perp()._unit()
                  , g = a.sub(n)._perp()._unit();
                return WT(s, n, a, HT(f, g), u)
            }
            function WT(s, n, a, u, f) {
                let g = Math.sqrt(1 - u * u);
                return Math.min(s.dist(n) / 3, n.dist(a) / 3, f * g / u)
            }
            function jT(s, n, a) {
                return s.x < a[0].x && n.x < a[0].x || s.x > a[1].x && n.x > a[1].x || s.y < a[0].y && n.y < a[0].y || s.y > a[1].y && n.y > a[1].y
            }
            function XT(s, n, a) {
                if (s.x < 0 || s.x >= kn || n.x < 0 || n.x >= kn || a.x < 0 || a.x >= kn)
                    return !1;
                let u = a.sub(n)
                  , f = u.perp()
                  , g = s.sub(n);
                return (u.x * g.x + u.y * g.y) / Math.sqrt((u.x * u.x + u.y * u.y) * (g.x * g.x + g.y * g.y)) > -.866 && f.x * g.x + f.y * g.y < 0
            }
            function ZT(s, n, a) {
                let u = n ? 2 | s : -3 & s;
                return a ? 1 | u : -2 & u
            }
            function qT() {
                let s = Math.PI / 32
                  , n = Math.tan(s)
                  , a = fp;
                return a * Math.sqrt(1 + 2 * n * n) - a
            }
            function KT(s, n, a) {
                let u = 1 << a.z
                  , f = Js(a.x / u)
                  , g = Js((a.x + 1) / u)
                  , y = Zr(a.y / u)
                  , w = Zr((a.y + 1) / u);
                return function(S, M, z, N, B=0, H) {
                    let q = [];
                    if (!S.length || !z || !N)
                        return q;
                    let Q = (Ne,at)=>{
                        for (let it of Ne)
                            q.push({
                                polygon: it,
                                bounds: at
                            })
                    }
                      , de = Math.ceil(Math.log2(z))
                      , Me = Math.ceil(Math.log2(N))
                      , Pe = de - Me
                      , we = [];
                    for (let Ne = 0; Ne < Math.abs(Pe); Ne++)
                        we.push(Pe > 0 ? 0 : 1);
                    for (let Ne = 0; Ne < Math.min(de, Me); Ne++)
                        we.push(0),
                        we.push(1);
                    let Le = S;
                    if (Le = E_(Le, M[0].y - B, M[1].y + B, 1),
                    Le = E_(Le, M[0].x - B, M[1].x + B, 0),
                    !Le.length)
                        return q;
                    let Ue = [];
                    for (we.length ? Ue.push({
                        polygons: Le,
                        bounds: M,
                        depth: 0
                    }) : Q(Le, M); Ue.length; ) {
                        let Ne = Ue.pop()
                          , at = Ne.depth
                          , it = we[at]
                          , _t = Ne.bounds[0]
                          , Ot = Ne.bounds[1]
                          , dt = it === 0 ? _t.x : _t.y
                          , yt = it === 0 ? Ot.x : Ot.y
                          , Tt = H ? H(it, dt, yt) : .5 * (dt + yt)
                          , Lt = E_(Ne.polygons, dt - B, Tt + B, it)
                          , Nt = E_(Ne.polygons, Tt - B, yt + B, it);
                        if (Lt.length) {
                            let mt = [_t, new W(it === 0 ? Tt : Ot.x,it === 1 ? Tt : Ot.y)];
                            we.length > at + 1 ? Ue.push({
                                polygons: Lt,
                                bounds: mt,
                                depth: at + 1
                            }) : Q(Lt, mt)
                        }
                        if (Nt.length) {
                            let mt = [new W(it === 0 ? Tt : _t.x,it === 1 ? Tt : _t.y), Ot];
                            we.length > at + 1 ? Ue.push({
                                polygons: Nt,
                                bounds: mt,
                                depth: at + 1
                            }) : Q(Nt, mt)
                        }
                    }
                    return q
                }(s, n, Math.ceil((g - f) / 11.25), Math.ceil((y - w) / 11.25), 1, (S,M,z)=>{
                    if (S === 0)
                        return .5 * (M + z);
                    {
                        let N = Zr((a.y + M / kn) / u);
                        return (ra(.5 * (Zr((a.y + z / kn) / u) + N)) * u - a.y) * kn
                    }
                }
                )
            }
            cn(vp, "FillExtrusionBucket", {
                omit: ["layers", "features"]
            }),
            cn(GT, "PartMetadata");
            let tL = new Pt({
                "fill-extrusion-edge-radius": new Je(ht["layout_fill-extrusion"]["fill-extrusion-edge-radius"])
            });
            var nL = {
                paint: new Pt({
                    "fill-extrusion-opacity": new Je(ht["paint_fill-extrusion"]["fill-extrusion-opacity"]),
                    "fill-extrusion-color": new ct(ht["paint_fill-extrusion"]["fill-extrusion-color"]),
                    "fill-extrusion-translate": new Je(ht["paint_fill-extrusion"]["fill-extrusion-translate"]),
                    "fill-extrusion-translate-anchor": new Je(ht["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]),
                    "fill-extrusion-pattern": new ct(ht["paint_fill-extrusion"]["fill-extrusion-pattern"]),
                    "fill-extrusion-height": new ct(ht["paint_fill-extrusion"]["fill-extrusion-height"]),
                    "fill-extrusion-base": new ct(ht["paint_fill-extrusion"]["fill-extrusion-base"]),
                    "fill-extrusion-vertical-gradient": new Je(ht["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]),
                    "fill-extrusion-ambient-occlusion-intensity": new Je(ht["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-intensity"]),
                    "fill-extrusion-ambient-occlusion-radius": new Je(ht["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-radius"])
                }),
                layout: tL
            };
            function YT(s, n, a) {
                var u = 2 * Math.PI * 6378137 / 256 / Math.pow(2, a);
                return [s * u - 2 * Math.PI * 6378137 / 2, n * u - 2 * Math.PI * 6378137 / 2]
            }
            class S_ {
                constructor(n, a, u) {
                    this.z = n,
                    this.x = a,
                    this.y = u,
                    this.key = bp(0, n, n, a, u)
                }
                equals(n) {
                    return this.z === n.z && this.x === n.x && this.y === n.y
                }
                url(n, a) {
                    let u = function(g, y, w) {
                        var S = YT(256 * g, 256 * (y = Math.pow(2, w) - y - 1), w)
                          , M = YT(256 * (g + 1), 256 * (y + 1), w);
                        return S[0] + "," + S[1] + "," + M[0] + "," + M[1]
                    }(this.x, this.y, this.z)
                      , f = function(g, y, w) {
                        let S, M = "";
                        for (let z = g; z > 0; z--)
                            S = 1 << z - 1,
                            M += (y & S ? 1 : 0) + (w & S ? 2 : 0);
                        return M
                    }(this.z, this.x, this.y);
                    return n[(this.x + this.y) % n.length].replace("{prefix}", (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String(a === "tms" ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace("{quadkey}", f).replace("{bbox-epsg-3857}", u)
                }
                toString() {
                    return `${this.z}/${this.x}/${this.y}`
                }
            }
            class JT {
                constructor(n, a) {
                    this.wrap = n,
                    this.canonical = a,
                    this.key = bp(n, a.z, a.z, a.x, a.y)
                }
            }
            class xs {
                constructor(n, a, u, f, g) {
                    this.overscaledZ = n,
                    this.wrap = a,
                    this.canonical = new S_(u,+f,+g),
                    this.key = a === 0 && n === u ? this.canonical.key : bp(a, n, u, f, g)
                }
                equals(n) {
                    return this.overscaledZ === n.overscaledZ && this.wrap === n.wrap && this.canonical.equals(n.canonical)
                }
                scaledTo(n) {
                    let a = this.canonical.z - n;
                    return n > this.canonical.z ? new xs(n,this.wrap,this.canonical.z,this.canonical.x,this.canonical.y) : new xs(n,this.wrap,n,this.canonical.x >> a,this.canonical.y >> a)
                }
                calculateScaledKey(n, a=!0) {
                    if (this.overscaledZ === n && a)
                        return this.key;
                    if (n > this.canonical.z)
                        return bp(this.wrap * +a, n, this.canonical.z, this.canonical.x, this.canonical.y);
                    {
                        let u = this.canonical.z - n;
                        return bp(this.wrap * +a, n, n, this.canonical.x >> u, this.canonical.y >> u)
                    }
                }
                isChildOf(n) {
                    if (n.wrap !== this.wrap)
                        return !1;
                    let a = this.canonical.z - n.canonical.z;
                    return n.overscaledZ === 0 || n.overscaledZ < this.overscaledZ && n.canonical.x === this.canonical.x >> a && n.canonical.y === this.canonical.y >> a
                }
                children(n) {
                    if (this.overscaledZ >= n)
                        return [new xs(this.overscaledZ + 1,this.wrap,this.canonical.z,this.canonical.x,this.canonical.y)];
                    let a = this.canonical.z + 1
                      , u = 2 * this.canonical.x
                      , f = 2 * this.canonical.y;
                    return [new xs(a,this.wrap,a,u,f), new xs(a,this.wrap,a,u + 1,f), new xs(a,this.wrap,a,u,f + 1), new xs(a,this.wrap,a,u + 1,f + 1)]
                }
                isLessThan(n) {
                    return this.wrap < n.wrap || !(this.wrap > n.wrap) && (this.overscaledZ < n.overscaledZ || !(this.overscaledZ > n.overscaledZ) && (this.canonical.x < n.canonical.x || !(this.canonical.x > n.canonical.x) && this.canonical.y < n.canonical.y))
                }
                wrapped() {
                    return new xs(this.overscaledZ,0,this.canonical.z,this.canonical.x,this.canonical.y)
                }
                unwrapTo(n) {
                    return new xs(this.overscaledZ,n,this.canonical.z,this.canonical.x,this.canonical.y)
                }
                overscaleFactor() {
                    return Math.pow(2, this.overscaledZ - this.canonical.z)
                }
                toUnwrapped() {
                    return new JT(this.wrap,this.canonical)
                }
                toString() {
                    return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`
                }
            }
            function bp(s, n, a, u, f) {
                let g = 1 << Math.min(a, 22)
                  , y = g * (f % g) + u % g;
                return s && a < 22 && (y += g * g * ((s < 0 ? -2 * s - 1 : 2 * s) % (1 << 2 * (22 - a)))),
                16 * (32 * y + a) + (n - a)
            }
            cn(S_, "CanonicalTileID"),
            cn(xs, "OverscaledTileID", {
                omit: ["projMatrix"]
            });
            class id extends W {
                constructor(n, a, u) {
                    super(n, a),
                    this.z = u
                }
            }
            function wp(s, n) {
                return s.x * n.x + s.y * n.y
            }
            function $T(s, n) {
                if (s.length === 1) {
                    let a = 0, u = n[a++], f;
                    for (; !f || u.equals(f); )
                        if (f = n[a++],
                        !f)
                            return 1 / 0;
                    for (; a < n.length; a++) {
                        let g = n[a]
                          , y = s[0]
                          , w = f.sub(u)
                          , S = g.sub(u)
                          , M = y.sub(u)
                          , z = wp(w, w)
                          , N = wp(w, S)
                          , B = wp(S, S)
                          , H = wp(M, w)
                          , q = wp(M, S)
                          , Q = z * B - N * N
                          , de = (B * H - N * q) / Q
                          , Me = (z * q - N * H) / Q
                          , Pe = u.z * (1 - de - Me) + f.z * de + g.z * Me;
                        if (isFinite(Pe))
                            return Pe
                    }
                    return 1 / 0
                }
                {
                    let a = 1 / 0;
                    for (let u of n)
                        a = Math.min(a, u.z);
                    return a
                }
            }
            function QT(s, n, a, u, f, g, y, w) {
                let S = y * f.getElevationAt(s, n, !0, !0)
                  , M = g[0] !== 0
                  , z = M ? g[1] === 0 ? y * (g[0] / 7 - 450) : y * function(N, B, H) {
                    let q = Math.floor(B[0] / 8)
                      , Q = Math.floor(B[1] / 8)
                      , de = 10 * (B[0] - 8 * q)
                      , Me = 10 * (B[1] - 8 * Q)
                      , Pe = N.getElevationAt(q, Q, !0, !0)
                      , we = N.getMeterToDEM(H)
                      , Le = Math.floor(.5 * (de * we - 1))
                      , Ue = Math.floor(.5 * (Me * we - 1))
                      , Ne = N.tileCoordToPixel(q, Q)
                      , at = 2 * Le + 1
                      , it = 2 * Ue + 1
                      , _t = function(Nt, mt, qt, Sn, en) {
                        return [Nt.getElevationAtPixel(mt, qt, !0), Nt.getElevationAtPixel(mt + en, qt, !0), Nt.getElevationAtPixel(mt, qt + en, !0), Nt.getElevationAtPixel(mt + Sn, qt + en, !0)]
                    }(N, Ne.x - Le, Ne.y - Ue, at, it)
                      , Ot = Math.abs(_t[0] - _t[1])
                      , dt = Math.abs(_t[2] - _t[3])
                      , yt = Math.abs(_t[0] - _t[2]) + Math.abs(_t[1] - _t[3])
                      , Tt = Math.min(.25, .5 * we * (Ot + dt) / at)
                      , Lt = Math.min(.25, .5 * we * yt / it);
                    return Pe + Math.max(Tt * de, Lt * Me)
                }(f, g, w) : S;
                return {
                    base: S + (a === 0) ? -1 : a,
                    top: M ? Math.max(z + u, S + a + 2) : S + u
                }
            }
            let iL = vn([{
                name: "a_pos_normal",
                components: 2,
                type: "Int16"
            }, {
                name: "a_data",
                components: 4,
                type: "Uint8"
            }, {
                name: "a_linesofar",
                components: 1,
                type: "Float32"
            }], 4)
              , {members: rL} = iL
              , sL = vn([{
                name: "a_packed",
                components: 4,
                type: "Float32"
            }])
              , {members: oL} = sL
              , aL = T_.types
              , lL = Math.cos(Math.PI / 180 * 37.5);
            class A_ {
                constructor(n) {
                    this.zoom = n.zoom,
                    this.overscaling = n.overscaling,
                    this.layers = n.layers,
                    this.layerIds = this.layers.map(a=>a.id),
                    this.index = n.index,
                    this.projection = n.projection,
                    this.hasPattern = !1,
                    this.patternFeatures = [],
                    this.lineClipsArray = [],
                    this.gradients = {},
                    this.layers.forEach(a=>{
                        this.gradients[a.id] = {}
                    }
                    ),
                    this.layoutVertexArray = new Ri,
                    this.layoutVertexArray2 = new Mi,
                    this.indexArray = new Xr,
                    this.programConfigurations = new ou(n.layers,n.zoom),
                    this.segments = new cr,
                    this.maxLineLength = 0,
                    this.stateDependentLayerIds = this.layers.filter(a=>a.isStateDependent()).map(a=>a.id)
                }
                populate(n, a, u, f) {
                    this.hasPattern = Ux("line", this.layers, a);
                    let g = this.layers[0].layout.get("line-sort-key")
                      , y = [];
                    for (let {feature: z, id: N, index: B, sourceLayerIndex: H} of n) {
                        let q = this.layers[0]._featureFilter.needGeometry
                          , Q = du(z, q);
                        if (!this.layers[0]._featureFilter.filter(new $e(this.zoom), Q, u))
                            continue;
                        let de = g ? g.evaluate(Q, {}, u) : void 0
                          , Me = {
                            id: N,
                            properties: z.properties,
                            type: z.type,
                            sourceLayerIndex: H,
                            index: B,
                            geometry: q ? Q.geometry : Na(z, u, f),
                            patterns: {},
                            sortKey: de
                        };
                        y.push(Me)
                    }
                    g && y.sort((z,N)=>z.sortKey - N.sortKey);
                    let {lineAtlas: w, featureIndex: S} = a
                      , M = this.addConstantDashes(w);
                    for (let z of y) {
                        let {geometry: N, index: B, sourceLayerIndex: H} = z;
                        if (M && this.addFeatureDashes(z, w),
                        this.hasPattern) {
                            let q = Vx("line", this.layers, z, this.zoom, a);
                            this.patternFeatures.push(q)
                        } else
                            this.addFeature(z, N, B, u, w.positions, a.availableImages);
                        S.insert(n[B].feature, N, B, H, this.index)
                    }
                }
                addConstantDashes(n) {
                    let a = !1;
                    for (let u of this.layers) {
                        let f = u.paint.get("line-dasharray").value
                          , g = u.layout.get("line-cap").value;
                        if (f.kind !== "constant" || g.kind !== "constant")
                            a = !0;
                        else {
                            let y = g.value
                              , w = f.value;
                            if (!w)
                                continue;
                            n.addDash(w, y)
                        }
                    }
                    return a
                }
                addFeatureDashes(n, a) {
                    let u = this.zoom;
                    for (let f of this.layers) {
                        let g = f.paint.get("line-dasharray").value
                          , y = f.layout.get("line-cap").value;
                        if (g.kind === "constant" && y.kind === "constant")
                            continue;
                        let w, S;
                        if (g.kind === "constant") {
                            if (w = g.value,
                            !w)
                                continue
                        } else
                            w = g.evaluate({
                                zoom: u
                            }, n);
                        S = y.kind === "constant" ? y.value : y.evaluate({
                            zoom: u
                        }, n),
                        a.addDash(w, S),
                        n.patterns[f.id] = a.getKey(w, S)
                    }
                }
                update(n, a, u, f) {
                    this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(n, a, this.stateDependentLayers, u, f)
                }
                addFeatures(n, a, u, f, g) {
                    for (let y of this.patternFeatures)
                        this.addFeature(y, y.geometry, y.index, a, u, f)
                }
                isEmpty() {
                    return this.layoutVertexArray.length === 0
                }
                uploadPending() {
                    return !this.uploaded || this.programConfigurations.needsUpload
                }
                upload(n) {
                    this.uploaded || (this.layoutVertexArray2.length !== 0 && (this.layoutVertexBuffer2 = n.createVertexBuffer(this.layoutVertexArray2, oL)),
                    this.layoutVertexBuffer = n.createVertexBuffer(this.layoutVertexArray, rL),
                    this.indexBuffer = n.createIndexBuffer(this.indexArray)),
                    this.programConfigurations.upload(n),
                    this.uploaded = !0
                }
                destroy() {
                    this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(),
                    this.indexBuffer.destroy(),
                    this.programConfigurations.destroy(),
                    this.segments.destroy())
                }
                lineFeatureClips(n) {
                    if (n.properties && n.properties.hasOwnProperty("mapbox_clip_start") && n.properties.hasOwnProperty("mapbox_clip_end"))
                        return {
                            start: +n.properties.mapbox_clip_start,
                            end: +n.properties.mapbox_clip_end
                        }
                }
                addFeature(n, a, u, f, g, y) {
                    let w = this.layers[0].layout
                      , S = w.get("line-join").evaluate(n, {})
                      , M = w.get("line-cap").evaluate(n, {})
                      , z = w.get("line-miter-limit")
                      , N = w.get("line-round-limit");
                    this.lineClips = this.lineFeatureClips(n);
                    for (let B of a)
                        this.addLine(B, n, S, M, z, N);
                    this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, n, u, g, y, f)
                }
                addLine(n, a, u, f, g, y) {
                    if (this.distance = 0,
                    this.scaledDistance = 0,
                    this.totalDistance = 0,
                    this.lineSoFar = 0,
                    this.lineClips) {
                        this.lineClipsArray.push(this.lineClips);
                        for (let Me = 0; Me < n.length - 1; Me++)
                            this.totalDistance += n[Me].dist(n[Me + 1]);
                        this.updateScaledDistance(),
                        this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance)
                    }
                    let w = aL[a.type] === "Polygon"
                      , S = n.length;
                    for (; S >= 2 && n[S - 1].equals(n[S - 2]); )
                        S--;
                    let M = 0;
                    for (; M < S - 1 && n[M].equals(n[M + 1]); )
                        M++;
                    if (S < (w ? 3 : 2))
                        return;
                    u === "bevel" && (g = 1.05);
                    let z = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0, N = this.segments.prepareSegment(10 * S, this.layoutVertexArray, this.indexArray), B, H, q, Q, de;
                    this.e1 = this.e2 = -1,
                    w && (B = n[S - 2],
                    de = n[M].sub(B)._unit()._perp());
                    for (let Me = M; Me < S; Me++) {
                        if (q = Me === S - 1 ? w ? n[M + 1] : void 0 : n[Me + 1],
                        q && n[Me].equals(q))
                            continue;
                        de && (Q = de),
                        B && (H = B),
                        B = n[Me],
                        de = q ? q.sub(B)._unit()._perp() : Q,
                        Q = Q || de;
                        let Pe = Q.add(de);
                        Pe.x === 0 && Pe.y === 0 || Pe._unit();
                        let we = Q.x * de.x + Q.y * de.y
                          , Le = Pe.x * de.x + Pe.y * de.y
                          , Ue = Le !== 0 ? 1 / Le : 1 / 0
                          , Ne = 2 * Math.sqrt(2 - 2 * Le)
                          , at = Le < lL && H && q
                          , it = Q.x * de.y - Q.y * de.x > 0;
                        if (at && Me > M) {
                            let dt = B.dist(H);
                            if (dt > 2 * z) {
                                let yt = B.sub(B.sub(H)._mult(z / dt)._round());
                                this.updateDistance(H, yt),
                                this.addCurrentVertex(yt, Q, 0, 0, N),
                                H = yt
                            }
                        }
                        let _t = H && q
                          , Ot = _t ? u : w ? "butt" : f;
                        if (_t && Ot === "round" && (Ue < y ? Ot = "miter" : Ue <= 2 && (Ot = "fakeround")),
                        Ot === "miter" && Ue > g && (Ot = "bevel"),
                        Ot === "bevel" && (Ue > 2 && (Ot = "flipbevel"),
                        Ue < g && (Ot = "miter")),
                        H && this.updateDistance(H, B),
                        Ot === "miter")
                            Pe._mult(Ue),
                            this.addCurrentVertex(B, Pe, 0, 0, N);
                        else if (Ot === "flipbevel") {
                            if (Ue > 100)
                                Pe = de.mult(-1);
                            else {
                                let dt = Ue * Q.add(de).mag() / Q.sub(de).mag();
                                Pe._perp()._mult(dt * (it ? -1 : 1))
                            }
                            this.addCurrentVertex(B, Pe, 0, 0, N),
                            this.addCurrentVertex(B, Pe.mult(-1), 0, 0, N)
                        } else if (Ot === "bevel" || Ot === "fakeround") {
                            let dt = -Math.sqrt(Ue * Ue - 1)
                              , yt = it ? dt : 0
                              , Tt = it ? 0 : dt;
                            if (H && this.addCurrentVertex(B, Q, yt, Tt, N),
                            Ot === "fakeround") {
                                let Lt = Math.round(180 * Ne / Math.PI / 20);
                                for (let Nt = 1; Nt < Lt; Nt++) {
                                    let mt = Nt / Lt;
                                    if (mt !== .5) {
                                        let Sn = mt - .5;
                                        mt += mt * Sn * (mt - 1) * ((1.0904 + we * (we * (3.55645 - 1.43519 * we) - 3.2452)) * Sn * Sn + (.848013 + we * (.215638 * we - 1.06021)))
                                    }
                                    let qt = de.sub(Q)._mult(mt)._add(Q)._unit()._mult(it ? -1 : 1);
                                    this.addHalfVertex(B, qt.x, qt.y, !1, it, 0, N)
                                }
                            }
                            q && this.addCurrentVertex(B, de, -yt, -Tt, N)
                        } else if (Ot === "butt")
                            this.addCurrentVertex(B, Pe, 0, 0, N);
                        else if (Ot === "square") {
                            let dt = H ? 1 : -1;
                            H || this.addCurrentVertex(B, Pe, dt, dt, N),
                            this.addCurrentVertex(B, Pe, 0, 0, N),
                            H && this.addCurrentVertex(B, Pe, dt, dt, N)
                        } else
                            Ot === "round" && (H && (this.addCurrentVertex(B, Q, 0, 0, N),
                            this.addCurrentVertex(B, Q, 1, 1, N, !0)),
                            q && (this.addCurrentVertex(B, de, -1, -1, N, !0),
                            this.addCurrentVertex(B, de, 0, 0, N)));
                        if (at && Me < S - 1) {
                            let dt = B.dist(q);
                            if (dt > 2 * z) {
                                let yt = B.add(q.sub(B)._mult(z / dt)._round());
                                this.updateDistance(B, yt),
                                this.addCurrentVertex(yt, de, 0, 0, N),
                                B = yt
                            }
                        }
                    }
                }
                addCurrentVertex(n, a, u, f, g, y=!1) {
                    let w = a.y * f - a.x
                      , S = -a.y - a.x * f;
                    this.addHalfVertex(n, a.x + a.y * u, a.y - a.x * u, y, !1, u, g),
                    this.addHalfVertex(n, w, S, y, !0, -f, g)
                }
                addHalfVertex({x: n, y: a}, u, f, g, y, w, S) {
                    this.layoutVertexArray.emplaceBack((n << 1) + (g ? 1 : 0), (a << 1) + (y ? 1 : 0), Math.round(63 * u) + 128, Math.round(63 * f) + 128, 1 + (w === 0 ? 0 : w < 0 ? -1 : 1), 0, this.lineSoFar),
                    this.lineClips && this.layoutVertexArray2.emplaceBack(this.scaledDistance, this.lineClipsArray.length, this.lineClips.start, this.lineClips.end);
                    let M = S.vertexLength++;
                    this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, M),
                    S.primitiveLength++),
                    y ? this.e2 = M : this.e1 = M
                }
                updateScaledDistance() {
                    if (this.lineClips) {
                        let n = this.totalDistance / (this.lineClips.end - this.lineClips.start);
                        this.scaledDistance = this.distance / this.totalDistance,
                        this.lineSoFar = n * this.lineClips.start + this.distance
                    } else
                        this.lineSoFar = this.distance
                }
                updateDistance(n, a) {
                    this.distance += n.dist(a),
                    this.updateScaledDistance()
                }
            }
            cn(A_, "LineBucket", {
                omit: ["layers", "patternFeatures"]
            });
            let cL = new Pt({
                "line-cap": new ct(ht.layout_line["line-cap"]),
                "line-join": new ct(ht.layout_line["line-join"]),
                "line-miter-limit": new Je(ht.layout_line["line-miter-limit"]),
                "line-round-limit": new Je(ht.layout_line["line-round-limit"]),
                "line-sort-key": new ct(ht.layout_line["line-sort-key"])
            });
            var eE = {
                paint: new Pt({
                    "line-opacity": new ct(ht.paint_line["line-opacity"]),
                    "line-color": new ct(ht.paint_line["line-color"]),
                    "line-translate": new Je(ht.paint_line["line-translate"]),
                    "line-translate-anchor": new Je(ht.paint_line["line-translate-anchor"]),
                    "line-width": new ct(ht.paint_line["line-width"]),
                    "line-gap-width": new ct(ht.paint_line["line-gap-width"]),
                    "line-offset": new ct(ht.paint_line["line-offset"]),
                    "line-blur": new ct(ht.paint_line["line-blur"]),
                    "line-dasharray": new ct(ht.paint_line["line-dasharray"]),
                    "line-pattern": new ct(ht.paint_line["line-pattern"]),
                    "line-gradient": new At(ht.paint_line["line-gradient"]),
                    "line-trim-offset": new Je(ht.paint_line["line-trim-offset"])
                }),
                layout: cL
            };
            let tE = new class extends ct {
                possiblyEvaluate(s, n) {
                    return n = new $e(Math.floor(n.zoom),{
                        now: n.now,
                        fadeDuration: n.fadeDuration,
                        transition: n.transition
                    }),
                    super.possiblyEvaluate(s, n)
                }
                evaluate(s, n, a, u) {
                    return n = Ke({}, n, {
                        zoom: Math.floor(n.zoom)
                    }),
                    super.evaluate(s, n, a, u)
                }
            }
            (eE.paint.properties["line-width"].specification);
            function nE(s, n) {
                return n > 0 ? n + 2 * s : s
            }
            tE.useIntegerZoom = !0;
            let uL = vn([{
                name: "a_pos_offset",
                components: 4,
                type: "Int16"
            }, {
                name: "a_tex_size",
                components: 4,
                type: "Uint16"
            }, {
                name: "a_pixeloffset",
                components: 4,
                type: "Int16"
            }], 4)
              , hL = vn([{
                name: "a_globe_anchor",
                components: 3,
                type: "Int16"
            }, {
                name: "a_globe_normal",
                components: 3,
                type: "Float32"
            }], 4)
              , dL = vn([{
                name: "a_projected_pos",
                components: 4,
                type: "Float32"
            }], 4);
            vn([{
                name: "a_fade_opacity",
                components: 1,
                type: "Uint32"
            }], 4);
            let fL = vn([{
                name: "a_placed",
                components: 2,
                type: "Uint8"
            }, {
                name: "a_shift",
                components: 2,
                type: "Float32"
            }])
              , pL = vn([{
                name: "a_size_scale",
                components: 1,
                type: "Float32"
            }, {
                name: "a_padding",
                components: 2,
                type: "Float32"
            }]);
            vn([{
                type: "Int16",
                name: "projectedAnchorX"
            }, {
                type: "Int16",
                name: "projectedAnchorY"
            }, {
                type: "Int16",
                name: "projectedAnchorZ"
            }, {
                type: "Int16",
                name: "tileAnchorX"
            }, {
                type: "Int16",
                name: "tileAnchorY"
            }, {
                type: "Float32",
                name: "x1"
            }, {
                type: "Float32",
                name: "y1"
            }, {
                type: "Float32",
                name: "x2"
            }, {
                type: "Float32",
                name: "y2"
            }, {
                type: "Int16",
                name: "padding"
            }, {
                type: "Uint32",
                name: "featureIndex"
            }, {
                type: "Uint16",
                name: "sourceLayerIndex"
            }, {
                type: "Uint16",
                name: "bucketIndex"
            }]);
            let iE = vn([{
                name: "a_pos",
                components: 3,
                type: "Int16"
            }, {
                name: "a_anchor_pos",
                components: 2,
                type: "Int16"
            }, {
                name: "a_extrude",
                components: 2,
                type: "Int16"
            }], 4)
              , mL = vn([{
                name: "a_pos_2f",
                components: 2,
                type: "Float32"
            }, {
                name: "a_radius",
                components: 1,
                type: "Float32"
            }, {
                name: "a_flags",
                components: 2,
                type: "Int16"
            }], 4);
            vn([{
                name: "triangle",
                components: 3,
                type: "Uint16"
            }]),
            vn([{
                type: "Int16",
                name: "projectedAnchorX"
            }, {
                type: "Int16",
                name: "projectedAnchorY"
            }, {
                type: "Int16",
                name: "projectedAnchorZ"
            }, {
                type: "Float32",
                name: "tileAnchorX"
            }, {
                type: "Float32",
                name: "tileAnchorY"
            }, {
                type: "Uint16",
                name: "glyphStartIndex"
            }, {
                type: "Uint16",
                name: "numGlyphs"
            }, {
                type: "Uint32",
                name: "vertexStartIndex"
            }, {
                type: "Uint32",
                name: "lineStartIndex"
            }, {
                type: "Uint32",
                name: "lineLength"
            }, {
                type: "Uint16",
                name: "segment"
            }, {
                type: "Uint16",
                name: "lowerSize"
            }, {
                type: "Uint16",
                name: "upperSize"
            }, {
                type: "Float32",
                name: "lineOffsetX"
            }, {
                type: "Float32",
                name: "lineOffsetY"
            }, {
                type: "Uint8",
                name: "writingMode"
            }, {
                type: "Uint8",
                name: "placedOrientation"
            }, {
                type: "Uint8",
                name: "hidden"
            }, {
                type: "Uint32",
                name: "crossTileID"
            }, {
                type: "Int16",
                name: "associatedIconIndex"
            }, {
                type: "Uint8",
                name: "flipState"
            }]),
            vn([{
                type: "Int16",
                name: "projectedAnchorX"
            }, {
                type: "Int16",
                name: "projectedAnchorY"
            }, {
                type: "Int16",
                name: "projectedAnchorZ"
            }, {
                type: "Float32",
                name: "tileAnchorX"
            }, {
                type: "Float32",
                name: "tileAnchorY"
            }, {
                type: "Int16",
                name: "rightJustifiedTextSymbolIndex"
            }, {
                type: "Int16",
                name: "centerJustifiedTextSymbolIndex"
            }, {
                type: "Int16",
                name: "leftJustifiedTextSymbolIndex"
            }, {
                type: "Int16",
                name: "verticalPlacedTextSymbolIndex"
            }, {
                type: "Int16",
                name: "placedIconSymbolIndex"
            }, {
                type: "Int16",
                name: "verticalPlacedIconSymbolIndex"
            }, {
                type: "Uint16",
                name: "key"
            }, {
                type: "Uint16",
                name: "textBoxStartIndex"
            }, {
                type: "Uint16",
                name: "textBoxEndIndex"
            }, {
                type: "Uint16",
                name: "verticalTextBoxStartIndex"
            }, {
                type: "Uint16",
                name: "verticalTextBoxEndIndex"
            }, {
                type: "Uint16",
                name: "iconBoxStartIndex"
            }, {
                type: "Uint16",
                name: "iconBoxEndIndex"
            }, {
                type: "Uint16",
                name: "verticalIconBoxStartIndex"
            }, {
                type: "Uint16",
                name: "verticalIconBoxEndIndex"
            }, {
                type: "Uint16",
                name: "featureIndex"
            }, {
                type: "Uint16",
                name: "numHorizontalGlyphVertices"
            }, {
                type: "Uint16",
                name: "numVerticalGlyphVertices"
            }, {
                type: "Uint16",
                name: "numIconVertices"
            }, {
                type: "Uint16",
                name: "numVerticalIconVertices"
            }, {
                type: "Uint16",
                name: "useRuntimeCollisionCircles"
            }, {
                type: "Uint32",
                name: "crossTileID"
            }, {
                type: "Float32",
                components: 2,
                name: "textOffset"
            }, {
                type: "Float32",
                name: "collisionCircleDiameter"
            }]),
            vn([{
                type: "Float32",
                name: "offsetX"
            }]),
            vn([{
                type: "Int16",
                name: "x"
            }, {
                type: "Int16",
                name: "y"
            }]);
            var Kr = 24;
            let sa = 128;
            function Hx(s, n) {
                let {expression: a} = n;
                if (a.kind === "constant")
                    return {
                        kind: "constant",
                        layoutSize: a.evaluate(new $e(s + 1))
                    };
                if (a.kind === "source")
                    return {
                        kind: "source"
                    };
                {
                    let {zoomStops: u, interpolationType: f} = a
                      , g = 0;
                    for (; g < u.length && u[g] <= s; )
                        g++;
                    g = Math.max(0, g - 1);
                    let y = g;
                    for (; y < u.length && u[y] < s + 1; )
                        y++;
                    y = Math.min(u.length - 1, y);
                    let w = u[g]
                      , S = u[y];
                    return a.kind === "composite" ? {
                        kind: "composite",
                        minZoom: w,
                        maxZoom: S,
                        interpolationType: f
                    } : {
                        kind: "camera",
                        minZoom: w,
                        maxZoom: S,
                        minSize: a.evaluate(new $e(w)),
                        maxSize: a.evaluate(new $e(S)),
                        interpolationType: f
                    }
                }
            }
            function M_(s, {uSize: n, uSizeT: a}, {lowerSize: u, upperSize: f}) {
                return s.kind === "source" ? u / sa : s.kind === "composite" ? si(u / sa, f / sa, a) : n
            }
            function rd(s, n) {
                let a = 0
                  , u = 0;
                if (s.kind === "constant")
                    u = s.layoutSize;
                else if (s.kind !== "source") {
                    let {interpolationType: f, minZoom: g, maxZoom: y} = s
                      , w = f ? ae(co.interpolationFactor(f, n, g, y), 0, 1) : 0;
                    s.kind === "camera" ? u = si(s.minSize, s.maxSize, w) : a = w
                }
                return {
                    uSizeT: a,
                    uSize: u
                }
            }
            var gL = Object.freeze({
                __proto__: null,
                getSizeData: Hx,
                evaluateSizeForFeature: M_,
                evaluateSizeForZoom: rd,
                SIZE_PACK_FACTOR: sa
            });
            function _L(s, n, a) {
                return s.sections.forEach(u=>{
                    u.text = function(f, g, y) {
                        let w = g.layout.get("text-transform").evaluate(y, {});
                        return w === "uppercase" ? f = f.toLocaleUpperCase() : w === "lowercase" && (f = f.toLocaleLowerCase()),
                        Xe.applyArabicShaping && (f = Xe.applyArabicShaping(f)),
                        f
                    }(u.text, n, a)
                }
                ),
                s
            }
            let Tp = {
                "!": "︕",
                "#": "＃",
                $: "＄",
                "%": "％",
                "&": "＆",
                "(": "︵",
                ")": "︶",
                "*": "＊",
                "+": "＋",
                ",": "︐",
                "-": "︲",
                ".": "・",
                "/": "／",
                ":": "︓",
                ";": "︔",
                "<": "︿",
                "=": "＝",
                ">": "﹀",
                "?": "︖",
                "@": "＠",
                "[": "﹇",
                "\\": "＼",
                "]": "﹈",
                "^": "＾",
                _: "︳",
                "`": "｀",
                "{": "︷",
                "|": "―",
                "}": "︸",
                "~": "～",
                "¢": "￠",
                "£": "￡",
                "¥": "￥",
                "¦": "￤",
                "¬": "￢",
                "¯": "￣",
                "–": "︲",
                "—": "︱",
                "‘": "﹃",
                "’": "﹄",
                "“": "﹁",
                "”": "﹂",
                "…": "︙",
                "‧": "・",
                "₩": "￦",
                "、": "︑",
                "。": "︒",
                "〈": "︿",
                "〉": "﹀",
                "《": "︽",
                "》": "︾",
                "「": "﹁",
                "」": "﹂",
                "『": "﹃",
                "』": "﹄",
                "【": "︻",
                "】": "︼",
                "〔": "︹",
                "〕": "︺",
                "〖": "︗",
                "〗": "︘",
                "！": "︕",
                "（": "︵",
                "）": "︶",
                "，": "︐",
                "－": "︲",
                "．": "・",
                "：": "︓",
                "；": "︔",
                "＜": "︿",
                "＞": "﹀",
                "？": "︖",
                "［": "﹇",
                "］": "﹈",
                "＿": "︳",
                "｛": "︷",
                "｜": "―",
                "｝": "︸",
                "｟": "︵",
                "｠": "︶",
                "｡": "︒",
                "｢": "﹁",
                "｣": "﹂"
            };
            function yL(s) {
                return s === "︶" || s === "﹈" || s === "︸" || s === "﹄" || s === "﹂" || s === "︾" || s === "︼" || s === "︺" || s === "︘" || s === "﹀" || s === "︐" || s === "︓" || s === "︔" || s === "｀" || s === "￣" || s === "︑" || s === "︒"
            }
            function xL(s) {
                return s === "︵" || s === "﹇" || s === "︷" || s === "﹃" || s === "﹁" || s === "︽" || s === "︻" || s === "︹" || s === "︗" || s === "︿"
            }
            var Ep = Pi
              , rE = function(s, n, a, u, f) {
                var g, y, w = 8 * f - u - 1, S = (1 << w) - 1, M = S >> 1, z = -7, N = a ? f - 1 : 0, B = a ? -1 : 1, H = s[n + N];
                for (N += B,
                g = H & (1 << -z) - 1,
                H >>= -z,
                z += w; z > 0; g = 256 * g + s[n + N],
                N += B,
                z -= 8)
                    ;
                for (y = g & (1 << -z) - 1,
                g >>= -z,
                z += u; z > 0; y = 256 * y + s[n + N],
                N += B,
                z -= 8)
                    ;
                if (g === 0)
                    g = 1 - M;
                else {
                    if (g === S)
                        return y ? NaN : 1 / 0 * (H ? -1 : 1);
                    y += Math.pow(2, u),
                    g -= M
                }
                return (H ? -1 : 1) * y * Math.pow(2, g - u)
            }
              , sE = function(s, n, a, u, f, g) {
                var y, w, S, M = 8 * g - f - 1, z = (1 << M) - 1, N = z >> 1, B = f === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, H = u ? 0 : g - 1, q = u ? 1 : -1, Q = n < 0 || n === 0 && 1 / n < 0 ? 1 : 0;
                for (n = Math.abs(n),
                isNaN(n) || n === 1 / 0 ? (w = isNaN(n) ? 1 : 0,
                y = z) : (y = Math.floor(Math.log(n) / Math.LN2),
                n * (S = Math.pow(2, -y)) < 1 && (y--,
                S *= 2),
                (n += y + N >= 1 ? B / S : B * Math.pow(2, 1 - N)) * S >= 2 && (y++,
                S /= 2),
                y + N >= z ? (w = 0,
                y = z) : y + N >= 1 ? (w = (n * S - 1) * Math.pow(2, f),
                y += N) : (w = n * Math.pow(2, N - 1) * Math.pow(2, f),
                y = 0)); f >= 8; s[a + H] = 255 & w,
                H += q,
                w /= 256,
                f -= 8)
                    ;
                for (y = y << f | w,
                M += f; M > 0; s[a + H] = 255 & y,
                H += q,
                y /= 256,
                M -= 8)
                    ;
                s[a + H - q] |= 128 * Q
            };
            function Pi(s) {
                this.buf = ArrayBuffer.isView && ArrayBuffer.isView(s) ? s : new Uint8Array(s || 0),
                this.pos = 0,
                this.type = 0,
                this.length = this.buf.length
            }
            Pi.Varint = 0,
            Pi.Fixed64 = 1,
            Pi.Bytes = 2,
            Pi.Fixed32 = 5;
            var Wx = 4294967296
              , oE = 1 / Wx
              , aE = typeof TextDecoder == "undefined" ? null : new TextDecoder("utf8");
            function Ba(s) {
                return s.type === Pi.Bytes ? s.readVarint() + s.pos : s.pos + 1
            }
            function sd(s, n, a) {
                return a ? 4294967296 * n + (s >>> 0) : 4294967296 * (n >>> 0) + (s >>> 0)
            }
            function lE(s, n, a) {
                var u = n <= 16383 ? 1 : n <= 2097151 ? 2 : n <= 268435455 ? 3 : Math.floor(Math.log(n) / (7 * Math.LN2));
                a.realloc(u);
                for (var f = a.pos - 1; f >= s; f--)
                    a.buf[f + u] = a.buf[f]
            }
            function vL(s, n) {
                for (var a = 0; a < s.length; a++)
                    n.writeVarint(s[a])
            }
            function bL(s, n) {
                for (var a = 0; a < s.length; a++)
                    n.writeSVarint(s[a])
            }
            function wL(s, n) {
                for (var a = 0; a < s.length; a++)
                    n.writeFloat(s[a])
            }
            function TL(s, n) {
                for (var a = 0; a < s.length; a++)
                    n.writeDouble(s[a])
            }
            function EL(s, n) {
                for (var a = 0; a < s.length; a++)
                    n.writeBoolean(s[a])
            }
            function SL(s, n) {
                for (var a = 0; a < s.length; a++)
                    n.writeFixed32(s[a])
            }
            function AL(s, n) {
                for (var a = 0; a < s.length; a++)
                    n.writeSFixed32(s[a])
            }
            function ML(s, n) {
                for (var a = 0; a < s.length; a++)
                    n.writeFixed64(s[a])
            }
            function IL(s, n) {
                for (var a = 0; a < s.length; a++)
                    n.writeSFixed64(s[a])
            }
            function I_(s, n) {
                return (s[n] | s[n + 1] << 8 | s[n + 2] << 16) + 16777216 * s[n + 3]
            }
            function od(s, n, a) {
                s[a] = n,
                s[a + 1] = n >>> 8,
                s[a + 2] = n >>> 16,
                s[a + 3] = n >>> 24
            }
            function cE(s, n) {
                return (s[n] | s[n + 1] << 8 | s[n + 2] << 16) + (s[n + 3] << 24)
            }
            function CL(s, n, a) {
                n.glyphs = [],
                s === 1 && a.readMessage(DL, n)
            }
            function DL(s, n, a) {
                if (s === 3) {
                    let {id: u, bitmap: f, width: g, height: y, left: w, top: S, advance: M} = a.readMessage(LL, {});
                    n.glyphs.push({
                        id: u,
                        bitmap: new Fa({
                            width: g + 6,
                            height: y + 6
                        },f),
                        metrics: {
                            width: g,
                            height: y,
                            left: w,
                            top: S,
                            advance: M
                        }
                    })
                } else
                    s === 4 ? n.ascender = a.readSVarint() : s === 5 && (n.descender = a.readSVarint())
            }
            function LL(s, n, a) {
                s === 1 ? n.id = a.readVarint() : s === 2 ? n.bitmap = a.readBytes() : s === 3 ? n.width = a.readVarint() : s === 4 ? n.height = a.readVarint() : s === 5 ? n.left = a.readSVarint() : s === 6 ? n.top = a.readSVarint() : s === 7 && (n.advance = a.readVarint())
            }
            function jx(s) {
                let n = 0
                  , a = 0;
                for (let y of s)
                    n += y.w * y.h,
                    a = Math.max(a, y.w);
                s.sort((y,w)=>w.h - y.h);
                let u = [{
                    x: 0,
                    y: 0,
                    w: Math.max(Math.ceil(Math.sqrt(n / .95)), a),
                    h: 1 / 0
                }]
                  , f = 0
                  , g = 0;
                for (let y of s)
                    for (let w = u.length - 1; w >= 0; w--) {
                        let S = u[w];
                        if (!(y.w > S.w || y.h > S.h)) {
                            if (y.x = S.x,
                            y.y = S.y,
                            g = Math.max(g, y.y + y.h),
                            f = Math.max(f, y.x + y.w),
                            y.w === S.w && y.h === S.h) {
                                let M = u.pop();
                                w < u.length && (u[w] = M)
                            } else
                                y.h === S.h ? (S.x += y.w,
                                S.w -= y.w) : y.w === S.w ? (S.y += y.h,
                                S.h -= y.h) : (u.push({
                                    x: S.x + y.w,
                                    y: S.y,
                                    w: S.w - y.w,
                                    h: y.h
                                }),
                                S.y += y.h,
                                S.h -= y.h);
                            break
                        }
                    }
                return {
                    w: f,
                    h: g,
                    fill: n / (f * g) || 0
                }
            }
            Pi.prototype = {
                destroy: function() {
                    this.buf = null
                },
                readFields: function(s, n, a) {
                    for (a = a || this.length; this.pos < a; ) {
                        var u = this.readVarint()
                          , f = u >> 3
                          , g = this.pos;
                        this.type = 7 & u,
                        s(f, n, this),
                        this.pos === g && this.skip(u)
                    }
                    return n
                },
                readMessage: function(s, n) {
                    return this.readFields(s, n, this.readVarint() + this.pos)
                },
                readFixed32: function() {
                    var s = I_(this.buf, this.pos);
                    return this.pos += 4,
                    s
                },
                readSFixed32: function() {
                    var s = cE(this.buf, this.pos);
                    return this.pos += 4,
                    s
                },
                readFixed64: function() {
                    var s = I_(this.buf, this.pos) + I_(this.buf, this.pos + 4) * Wx;
                    return this.pos += 8,
                    s
                },
                readSFixed64: function() {
                    var s = I_(this.buf, this.pos) + cE(this.buf, this.pos + 4) * Wx;
                    return this.pos += 8,
                    s
                },
                readFloat: function() {
                    var s = rE(this.buf, this.pos, !0, 23, 4);
                    return this.pos += 4,
                    s
                },
                readDouble: function() {
                    var s = rE(this.buf, this.pos, !0, 52, 8);
                    return this.pos += 8,
                    s
                },
                readVarint: function(s) {
                    var n, a, u = this.buf;
                    return n = 127 & (a = u[this.pos++]),
                    a < 128 ? n : (n |= (127 & (a = u[this.pos++])) << 7,
                    a < 128 ? n : (n |= (127 & (a = u[this.pos++])) << 14,
                    a < 128 ? n : (n |= (127 & (a = u[this.pos++])) << 21,
                    a < 128 ? n : function(f, g, y) {
                        var w, S, M = y.buf;
                        if (w = (112 & (S = M[y.pos++])) >> 4,
                        S < 128 || (w |= (127 & (S = M[y.pos++])) << 3,
                        S < 128) || (w |= (127 & (S = M[y.pos++])) << 10,
                        S < 128) || (w |= (127 & (S = M[y.pos++])) << 17,
                        S < 128) || (w |= (127 & (S = M[y.pos++])) << 24,
                        S < 128) || (w |= (1 & (S = M[y.pos++])) << 31,
                        S < 128))
                            return sd(f, w, g);
                        throw new Error("Expected varint not more than 10 bytes")
                    }(n |= (15 & (a = u[this.pos])) << 28, s, this))))
                },
                readVarint64: function() {
                    return this.readVarint(!0)
                },
                readSVarint: function() {
                    var s = this.readVarint();
                    return s % 2 == 1 ? (s + 1) / -2 : s / 2
                },
                readBoolean: function() {
                    return Boolean(this.readVarint())
                },
                readString: function() {
                    var s = this.readVarint() + this.pos
                      , n = this.pos;
                    return this.pos = s,
                    s - n >= 12 && aE ? function(a, u, f) {
                        return aE.decode(a.subarray(u, f))
                    }(this.buf, n, s) : function(a, u, f) {
                        for (var g = "", y = u; y < f; ) {
                            var w, S, M, z = a[y], N = null, B = z > 239 ? 4 : z > 223 ? 3 : z > 191 ? 2 : 1;
                            if (y + B > f)
                                break;
                            B === 1 ? z < 128 && (N = z) : B === 2 ? (192 & (w = a[y + 1])) == 128 && (N = (31 & z) << 6 | 63 & w) <= 127 && (N = null) : B === 3 ? (S = a[y + 2],
                            (192 & (w = a[y + 1])) == 128 && (192 & S) == 128 && ((N = (15 & z) << 12 | (63 & w) << 6 | 63 & S) <= 2047 || N >= 55296 && N <= 57343) && (N = null)) : B === 4 && (S = a[y + 2],
                            M = a[y + 3],
                            (192 & (w = a[y + 1])) == 128 && (192 & S) == 128 && (192 & M) == 128 && ((N = (15 & z) << 18 | (63 & w) << 12 | (63 & S) << 6 | 63 & M) <= 65535 || N >= 1114112) && (N = null)),
                            N === null ? (N = 65533,
                            B = 1) : N > 65535 && (N -= 65536,
                            g += String.fromCharCode(N >>> 10 & 1023 | 55296),
                            N = 56320 | 1023 & N),
                            g += String.fromCharCode(N),
                            y += B
                        }
                        return g
                    }(this.buf, n, s)
                },
                readBytes: function() {
                    var s = this.readVarint() + this.pos
                      , n = this.buf.subarray(this.pos, s);
                    return this.pos = s,
                    n
                },
                readPackedVarint: function(s, n) {
                    if (this.type !== Pi.Bytes)
                        return s.push(this.readVarint(n));
                    var a = Ba(this);
                    for (s = s || []; this.pos < a; )
                        s.push(this.readVarint(n));
                    return s
                },
                readPackedSVarint: function(s) {
                    if (this.type !== Pi.Bytes)
                        return s.push(this.readSVarint());
                    var n = Ba(this);
                    for (s = s || []; this.pos < n; )
                        s.push(this.readSVarint());
                    return s
                },
                readPackedBoolean: function(s) {
                    if (this.type !== Pi.Bytes)
                        return s.push(this.readBoolean());
                    var n = Ba(this);
                    for (s = s || []; this.pos < n; )
                        s.push(this.readBoolean());
                    return s
                },
                readPackedFloat: function(s) {
                    if (this.type !== Pi.Bytes)
                        return s.push(this.readFloat());
                    var n = Ba(this);
                    for (s = s || []; this.pos < n; )
                        s.push(this.readFloat());
                    return s
                },
                readPackedDouble: function(s) {
                    if (this.type !== Pi.Bytes)
                        return s.push(this.readDouble());
                    var n = Ba(this);
                    for (s = s || []; this.pos < n; )
                        s.push(this.readDouble());
                    return s
                },
                readPackedFixed32: function(s) {
                    if (this.type !== Pi.Bytes)
                        return s.push(this.readFixed32());
                    var n = Ba(this);
                    for (s = s || []; this.pos < n; )
                        s.push(this.readFixed32());
                    return s
                },
                readPackedSFixed32: function(s) {
                    if (this.type !== Pi.Bytes)
                        return s.push(this.readSFixed32());
                    var n = Ba(this);
                    for (s = s || []; this.pos < n; )
                        s.push(this.readSFixed32());
                    return s
                },
                readPackedFixed64: function(s) {
                    if (this.type !== Pi.Bytes)
                        return s.push(this.readFixed64());
                    var n = Ba(this);
                    for (s = s || []; this.pos < n; )
                        s.push(this.readFixed64());
                    return s
                },
                readPackedSFixed64: function(s) {
                    if (this.type !== Pi.Bytes)
                        return s.push(this.readSFixed64());
                    var n = Ba(this);
                    for (s = s || []; this.pos < n; )
                        s.push(this.readSFixed64());
                    return s
                },
                skip: function(s) {
                    var n = 7 & s;
                    if (n === Pi.Varint)
                        for (; this.buf[this.pos++] > 127; )
                            ;
                    else if (n === Pi.Bytes)
                        this.pos = this.readVarint() + this.pos;
                    else if (n === Pi.Fixed32)
                        this.pos += 4;
                    else {
                        if (n !== Pi.Fixed64)
                            throw new Error("Unimplemented type: " + n);
                        this.pos += 8
                    }
                },
                writeTag: function(s, n) {
                    this.writeVarint(s << 3 | n)
                },
                realloc: function(s) {
                    for (var n = this.length || 16; n < this.pos + s; )
                        n *= 2;
                    if (n !== this.length) {
                        var a = new Uint8Array(n);
                        a.set(this.buf),
                        this.buf = a,
                        this.length = n
                    }
                },
                finish: function() {
                    return this.length = this.pos,
                    this.pos = 0,
                    this.buf.subarray(0, this.length)
                },
                writeFixed32: function(s) {
                    this.realloc(4),
                    od(this.buf, s, this.pos),
                    this.pos += 4
                },
                writeSFixed32: function(s) {
                    this.realloc(4),
                    od(this.buf, s, this.pos),
                    this.pos += 4
                },
                writeFixed64: function(s) {
                    this.realloc(8),
                    od(this.buf, -1 & s, this.pos),
                    od(this.buf, Math.floor(s * oE), this.pos + 4),
                    this.pos += 8
                },
                writeSFixed64: function(s) {
                    this.realloc(8),
                    od(this.buf, -1 & s, this.pos),
                    od(this.buf, Math.floor(s * oE), this.pos + 4),
                    this.pos += 8
                },
                writeVarint: function(s) {
                    (s = +s || 0) > 268435455 || s < 0 ? function(n, a) {
                        var u, f;
                        if (n >= 0 ? (u = n % 4294967296 | 0,
                        f = n / 4294967296 | 0) : (f = ~(-n / 4294967296),
                        4294967295 ^ (u = ~(-n % 4294967296)) ? u = u + 1 | 0 : (u = 0,
                        f = f + 1 | 0)),
                        n >= 18446744073709552e3 || n < -18446744073709552e3)
                            throw new Error("Given varint doesn't fit into 10 bytes");
                        a.realloc(10),
                        function(g, y, w) {
                            w.buf[w.pos++] = 127 & g | 128,
                            g >>>= 7,
                            w.buf[w.pos++] = 127 & g | 128,
                            g >>>= 7,
                            w.buf[w.pos++] = 127 & g | 128,
                            g >>>= 7,
                            w.buf[w.pos++] = 127 & g | 128,
                            w.buf[w.pos] = 127 & (g >>>= 7)
                        }(u, 0, a),
                        function(g, y) {
                            var w = (7 & g) << 4;
                            y.buf[y.pos++] |= w | ((g >>>= 3) ? 128 : 0),
                            g && (y.buf[y.pos++] = 127 & g | ((g >>>= 7) ? 128 : 0),
                            g && (y.buf[y.pos++] = 127 & g | ((g >>>= 7) ? 128 : 0),
                            g && (y.buf[y.pos++] = 127 & g | ((g >>>= 7) ? 128 : 0),
                            g && (y.buf[y.pos++] = 127 & g | ((g >>>= 7) ? 128 : 0),
                            g && (y.buf[y.pos++] = 127 & g)))))
                        }(f, a)
                    }(s, this) : (this.realloc(4),
                    this.buf[this.pos++] = 127 & s | (s > 127 ? 128 : 0),
                    s <= 127 || (this.buf[this.pos++] = 127 & (s >>>= 7) | (s > 127 ? 128 : 0),
                    s <= 127 || (this.buf[this.pos++] = 127 & (s >>>= 7) | (s > 127 ? 128 : 0),
                    s <= 127 || (this.buf[this.pos++] = s >>> 7 & 127))))
                },
                writeSVarint: function(s) {
                    this.writeVarint(s < 0 ? 2 * -s - 1 : 2 * s)
                },
                writeBoolean: function(s) {
                    this.writeVarint(Boolean(s))
                },
                writeString: function(s) {
                    s = String(s),
                    this.realloc(4 * s.length),
                    this.pos++;
                    var n = this.pos;
                    this.pos = function(u, f, g) {
                        for (var y, w, S = 0; S < f.length; S++) {
                            if ((y = f.charCodeAt(S)) > 55295 && y < 57344) {
                                if (!w) {
                                    y > 56319 || S + 1 === f.length ? (u[g++] = 239,
                                    u[g++] = 191,
                                    u[g++] = 189) : w = y;
                                    continue
                                }
                                if (y < 56320) {
                                    u[g++] = 239,
                                    u[g++] = 191,
                                    u[g++] = 189,
                                    w = y;
                                    continue
                                }
                                y = w - 55296 << 10 | y - 56320 | 65536,
                                w = null
                            } else
                                w && (u[g++] = 239,
                                u[g++] = 191,
                                u[g++] = 189,
                                w = null);
                            y < 128 ? u[g++] = y : (y < 2048 ? u[g++] = y >> 6 | 192 : (y < 65536 ? u[g++] = y >> 12 | 224 : (u[g++] = y >> 18 | 240,
                            u[g++] = y >> 12 & 63 | 128),
                            u[g++] = y >> 6 & 63 | 128),
                            u[g++] = 63 & y | 128)
                        }
                        return g
                    }(this.buf, s, this.pos);
                    var a = this.pos - n;
                    a >= 128 && lE(n, a, this),
                    this.pos = n - 1,
                    this.writeVarint(a),
                    this.pos += a
                },
                writeFloat: function(s) {
                    this.realloc(4),
                    sE(this.buf, s, this.pos, !0, 23, 4),
                    this.pos += 4
                },
                writeDouble: function(s) {
                    this.realloc(8),
                    sE(this.buf, s, this.pos, !0, 52, 8),
                    this.pos += 8
                },
                writeBytes: function(s) {
                    var n = s.length;
                    this.writeVarint(n),
                    this.realloc(n);
                    for (var a = 0; a < n; a++)
                        this.buf[this.pos++] = s[a]
                },
                writeRawMessage: function(s, n) {
                    this.pos++;
                    var a = this.pos;
                    s(n, this);
                    var u = this.pos - a;
                    u >= 128 && lE(a, u, this),
                    this.pos = a - 1,
                    this.writeVarint(u),
                    this.pos += u
                },
                writeMessage: function(s, n, a) {
                    this.writeTag(s, Pi.Bytes),
                    this.writeRawMessage(n, a)
                },
                writePackedVarint: function(s, n) {
                    n.length && this.writeMessage(s, vL, n)
                },
                writePackedSVarint: function(s, n) {
                    n.length && this.writeMessage(s, bL, n)
                },
                writePackedBoolean: function(s, n) {
                    n.length && this.writeMessage(s, EL, n)
                },
                writePackedFloat: function(s, n) {
                    n.length && this.writeMessage(s, wL, n)
                },
                writePackedDouble: function(s, n) {
                    n.length && this.writeMessage(s, TL, n)
                },
                writePackedFixed32: function(s, n) {
                    n.length && this.writeMessage(s, SL, n)
                },
                writePackedSFixed32: function(s, n) {
                    n.length && this.writeMessage(s, AL, n)
                },
                writePackedFixed64: function(s, n) {
                    n.length && this.writeMessage(s, ML, n)
                },
                writePackedSFixed64: function(s, n) {
                    n.length && this.writeMessage(s, IL, n)
                },
                writeBytesField: function(s, n) {
                    this.writeTag(s, Pi.Bytes),
                    this.writeBytes(n)
                },
                writeFixed32Field: function(s, n) {
                    this.writeTag(s, Pi.Fixed32),
                    this.writeFixed32(n)
                },
                writeSFixed32Field: function(s, n) {
                    this.writeTag(s, Pi.Fixed32),
                    this.writeSFixed32(n)
                },
                writeFixed64Field: function(s, n) {
                    this.writeTag(s, Pi.Fixed64),
                    this.writeFixed64(n)
                },
                writeSFixed64Field: function(s, n) {
                    this.writeTag(s, Pi.Fixed64),
                    this.writeSFixed64(n)
                },
                writeVarintField: function(s, n) {
                    this.writeTag(s, Pi.Varint),
                    this.writeVarint(n)
                },
                writeSVarintField: function(s, n) {
                    this.writeTag(s, Pi.Varint),
                    this.writeSVarint(n)
                },
                writeStringField: function(s, n) {
                    this.writeTag(s, Pi.Bytes),
                    this.writeString(n)
                },
                writeFloatField: function(s, n) {
                    this.writeTag(s, Pi.Fixed32),
                    this.writeFloat(n)
                },
                writeDoubleField: function(s, n) {
                    this.writeTag(s, Pi.Fixed64),
                    this.writeDouble(n)
                },
                writeBooleanField: function(s, n) {
                    this.writeVarintField(s, Boolean(n))
                }
            };
            class Xx {
                constructor(n, {pixelRatio: a, version: u, stretchX: f, stretchY: g, content: y}) {
                    this.paddedRect = n,
                    this.pixelRatio = a,
                    this.stretchX = f,
                    this.stretchY = g,
                    this.content = y,
                    this.version = u
                }
                get tl() {
                    return [this.paddedRect.x + 1, this.paddedRect.y + 1]
                }
                get br() {
                    return [this.paddedRect.x + this.paddedRect.w - 1, this.paddedRect.y + this.paddedRect.h - 1]
                }
                get displaySize() {
                    return [(this.paddedRect.w - 2) / this.pixelRatio, (this.paddedRect.h - 2) / this.pixelRatio]
                }
            }
            class uE {
                constructor(n, a) {
                    let u = {}
                      , f = {};
                    this.haveRenderCallbacks = [];
                    let g = [];
                    this.addImages(n, u, g),
                    this.addImages(a, f, g);
                    let {w: y, h: w} = jx(g)
                      , S = new Fs({
                        width: y || 1,
                        height: w || 1
                    });
                    for (let M in n) {
                        let z = n[M]
                          , N = u[M].paddedRect;
                        Fs.copy(z.data, S, {
                            x: 0,
                            y: 0
                        }, {
                            x: N.x + 1,
                            y: N.y + 1
                        }, z.data)
                    }
                    for (let M in a) {
                        let z = a[M]
                          , N = f[M].paddedRect
                          , B = N.x + 1
                          , H = N.y + 1
                          , q = z.data.width
                          , Q = z.data.height;
                        Fs.copy(z.data, S, {
                            x: 0,
                            y: 0
                        }, {
                            x: B,
                            y: H
                        }, z.data),
                        Fs.copy(z.data, S, {
                            x: 0,
                            y: Q - 1
                        }, {
                            x: B,
                            y: H - 1
                        }, {
                            width: q,
                            height: 1
                        }),
                        Fs.copy(z.data, S, {
                            x: 0,
                            y: 0
                        }, {
                            x: B,
                            y: H + Q
                        }, {
                            width: q,
                            height: 1
                        }),
                        Fs.copy(z.data, S, {
                            x: q - 1,
                            y: 0
                        }, {
                            x: B - 1,
                            y: H
                        }, {
                            width: 1,
                            height: Q
                        }),
                        Fs.copy(z.data, S, {
                            x: 0,
                            y: 0
                        }, {
                            x: B + q,
                            y: H
                        }, {
                            width: 1,
                            height: Q
                        })
                    }
                    this.image = S,
                    this.iconPositions = u,
                    this.patternPositions = f
                }
                addImages(n, a, u) {
                    for (let f in n) {
                        let g = n[f]
                          , y = {
                            x: 0,
                            y: 0,
                            w: g.data.width + 2,
                            h: g.data.height + 2
                        };
                        u.push(y),
                        a[f] = new Xx(y,g),
                        g.hasRenderCallback && this.haveRenderCallbacks.push(f)
                    }
                }
                patchUpdatedImages(n, a) {
                    this.haveRenderCallbacks = this.haveRenderCallbacks.filter(u=>n.hasImage(u)),
                    n.dispatchRenderCallbacks(this.haveRenderCallbacks);
                    for (let u in n.updatedImages)
                        this.patchUpdatedImage(this.iconPositions[u], n.getImage(u), a),
                        this.patchUpdatedImage(this.patternPositions[u], n.getImage(u), a)
                }
                patchUpdatedImage(n, a, u) {
                    if (!n || !a || n.version === a.version)
                        return;
                    n.version = a.version;
                    let[f,g] = n.tl;
                    u.update(a.data, void 0, {
                        x: f,
                        y: g
                    })
                }
            }
            cn(Xx, "ImagePosition"),
            cn(uE, "ImageAtlas");
            let $s = {
                horizontal: 1,
                vertical: 2,
                horizontalOnly: 3
            };
            class Sp {
                constructor() {
                    this.scale = 1,
                    this.fontStack = "",
                    this.imageName = null
                }
                static forText(n, a) {
                    let u = new Sp;
                    return u.scale = n || 1,
                    u.fontStack = a,
                    u
                }
                static forImage(n) {
                    let a = new Sp;
                    return a.imageName = n,
                    a
                }
            }
            class ad {
                constructor() {
                    this.text = "",
                    this.sectionIndex = [],
                    this.sections = [],
                    this.imageSectionID = null
                }
                static fromFeature(n, a) {
                    let u = new ad;
                    for (let f = 0; f < n.sections.length; f++) {
                        let g = n.sections[f];
                        g.image ? u.addImageSection(g) : u.addTextSection(g, a)
                    }
                    return u
                }
                length() {
                    return this.text.length
                }
                getSection(n) {
                    return this.sections[this.sectionIndex[n]]
                }
                getSections() {
                    return this.sections
                }
                getSectionIndex(n) {
                    return this.sectionIndex[n]
                }
                getCharCode(n) {
                    return this.text.charCodeAt(n)
                }
                verticalizePunctuation(n) {
                    this.text = function(a, u) {
                        let f = "";
                        for (let g = 0; g < a.length; g++) {
                            let y = a.charCodeAt(g + 1) || null
                              , w = a.charCodeAt(g - 1) || null;
                            f += !u && (y && O(y) && !Tp[a[g + 1]] || w && O(w) && !Tp[a[g - 1]]) || !Tp[a[g]] ? a[g] : Tp[a[g]]
                        }
                        return f
                    }(this.text, n)
                }
                trim() {
                    let n = 0;
                    for (let u = 0; u < this.text.length && C_[this.text.charCodeAt(u)]; u++)
                        n++;
                    let a = this.text.length;
                    for (let u = this.text.length - 1; u >= 0 && u >= n && C_[this.text.charCodeAt(u)]; u--)
                        a--;
                    this.text = this.text.substring(n, a),
                    this.sectionIndex = this.sectionIndex.slice(n, a)
                }
                substring(n, a) {
                    let u = new ad;
                    return u.text = this.text.substring(n, a),
                    u.sectionIndex = this.sectionIndex.slice(n, a),
                    u.sections = this.sections,
                    u
                }
                toString() {
                    return this.text
                }
                getMaxScale() {
                    return this.sectionIndex.reduce((n,a)=>Math.max(n, this.sections[a].scale), 0)
                }
                addTextSection(n, a) {
                    this.text += n.text,
                    this.sections.push(Sp.forText(n.scale, n.fontStack || a));
                    let u = this.sections.length - 1;
                    for (let f = 0; f < n.text.length; ++f)
                        this.sectionIndex.push(u)
                }
                addImageSection(n) {
                    let a = n.image ? n.image.name : "";
                    if (a.length === 0)
                        return void ut("Can't add FormattedSection with an empty image.");
                    let u = this.getNextImageSectionCharCode();
                    u ? (this.text += String.fromCharCode(u),
                    this.sections.push(Sp.forImage(a)),
                    this.sectionIndex.push(this.sections.length - 1)) : ut("Reached maximum number of images 6401")
                }
                getNextImageSectionCharCode() {
                    return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344,
                    this.imageSectionID)
                }
            }
            function Zx(s, n, a, u, f, g, y, w, S, M, z, N, B, H, q) {
                let Q = ad.fromFeature(s, f);
                N === $s.vertical && Q.verticalizePunctuation(B);
                let de = []
                  , Me = function(Ne, at, it, _t, Ot, dt) {
                    if (!Ne)
                        return [];
                    let yt = []
                      , Tt = function(qt, Sn, en, hn, Yt, Cn) {
                        let ei = 0;
                        for (let Jn = 0; Jn < qt.length(); Jn++) {
                            let Kn = qt.getSection(Jn);
                            ei += hE(qt.getCharCode(Jn), Kn, hn, Yt, Sn, Cn)
                        }
                        return ei / Math.max(1, Math.ceil(ei / en))
                    }(Ne, at, it, _t, Ot, dt)
                      , Lt = Ne.text.indexOf("​") >= 0
                      , Nt = 0;
                    for (let qt = 0; qt < Ne.length(); qt++) {
                        let Sn = Ne.getSection(qt)
                          , en = Ne.getCharCode(qt);
                        if (C_[en] || (Nt += hE(en, Sn, _t, Ot, at, dt)),
                        qt < Ne.length() - 1) {
                            let hn = !((mt = en) < 11904 || !(Yg(mt) || jh(mt) || m(mt) || r_(mt) || Qg(mt) || Kg(mt) || Jg(mt) || iu(mt) || e_(mt) || tp(mt) || $g(mt) || _(mt) || Wh(mt) || Qf(mt) || $f(mt) || ep(mt) || Ll(mt) || ru(mt) || n_(mt) || t_(mt)));
                            (RL[en] || hn || Sn.imageName) && yt.push(fE(qt + 1, Nt, Tt, yt, PL(en, Ne.getCharCode(qt + 1), hn && Lt), !1))
                        }
                    }
                    var mt;
                    return pE(fE(Ne.length(), Nt, Tt, yt, 0, !0))
                }(Q, M, g, n, u, H)
                  , {processBidirectionalText: Pe, processStyledBidirectionalText: we} = Xe;
                if (Pe && Q.sections.length === 1) {
                    let Ne = Pe(Q.toString(), Me);
                    for (let at of Ne) {
                        let it = new ad;
                        it.text = at,
                        it.sections = Q.sections;
                        for (let _t = 0; _t < at.length; _t++)
                            it.sectionIndex.push(0);
                        de.push(it)
                    }
                } else if (we) {
                    let Ne = we(Q.text, Q.sectionIndex, Me);
                    for (let at of Ne) {
                        let it = new ad;
                        it.text = at[0],
                        it.sectionIndex = at[1],
                        it.sections = Q.sections,
                        de.push(it)
                    }
                } else
                    de = function(Ne, at) {
                        let it = []
                          , _t = Ne.text
                          , Ot = 0;
                        for (let dt of at)
                            it.push(Ne.substring(Ot, dt)),
                            Ot = dt;
                        return Ot < _t.length && it.push(Ne.substring(Ot, _t.length)),
                        it
                    }(Q, Me);
                let Le = []
                  , Ue = {
                    positionedLines: Le,
                    text: Q.toString(),
                    top: z[1],
                    bottom: z[1],
                    left: z[0],
                    right: z[0],
                    writingMode: N,
                    iconsInText: !1,
                    verticalizable: !1,
                    hasBaseline: !1
                };
                return function(Ne, at, it, _t, Ot, dt, yt, Tt, Lt, Nt, mt, qt) {
                    let Sn = 0
                      , en = 0
                      , hn = 0
                      , Yt = Tt === "right" ? 1 : Tt === "left" ? 0 : .5
                      , Cn = !1;
                    for (let Bn of Ot) {
                        let ti = Bn.getSections();
                        for (let Ei of ti) {
                            if (Ei.imageName)
                                continue;
                            let Ni = at[Ei.fontStack];
                            if (Ni && (Cn = Ni.ascender !== void 0 && Ni.descender !== void 0,
                            !Cn))
                                break
                        }
                        if (!Cn)
                            break
                    }
                    let ei = 0;
                    for (let Bn of Ot) {
                        Bn.trim();
                        let ti = Bn.getMaxScale()
                          , Ei = (ti - 1) * Kr
                          , Ni = {
                            positionedGlyphs: [],
                            lineOffset: 0
                        };
                        Ne.positionedLines[ei] = Ni;
                        let ki = Ni.positionedGlyphs
                          , Fi = 0;
                        if (!Bn.length()) {
                            en += dt,
                            ++ei;
                            continue
                        }
                        let Hi = 0
                          , $i = 0;
                        for (let bi = 0; bi < Bn.length(); bi++) {
                            let _r = Bn.getSection(bi)
                              , hr = Bn.getSectionIndex(bi)
                              , ci = Bn.getCharCode(bi)
                              , Xi = _r.scale
                              , br = null
                              , Si = null
                              , rr = null
                              , cs = Kr
                              , Rr = 0
                              , Pr = !(Lt === $s.horizontal || !mt && !R(ci) || mt && (C_[ci] || (Jn = ci,
                            nu(Jn) || qg(Jn) || Jf(Jn) || Xh(Jn) || h(Jn))));
                            if (_r.imageName) {
                                let vs = _t[_r.imageName];
                                if (!vs)
                                    continue;
                                rr = _r.imageName,
                                Ne.iconsInText = Ne.iconsInText || !0,
                                Si = vs.paddedRect;
                                let kr = vs.displaySize;
                                Xi = Xi * Kr / qt,
                                br = {
                                    width: kr[0],
                                    height: kr[1],
                                    left: 1,
                                    top: -3,
                                    advance: Pr ? kr[1] : kr[0],
                                    localGlyph: !1
                                },
                                Rr = Cn ? -br.height * Xi : ti * Kr - 17 - kr[1] * Xi,
                                cs = br.advance;
                                let Va = (Pr ? kr[0] : kr[1]) * Xi - Kr * ti;
                                Va > 0 && Va > Fi && (Fi = Va)
                            } else {
                                let vs = it[_r.fontStack];
                                if (!vs)
                                    continue;
                                vs[ci] && (Si = vs[ci]);
                                let kr = at[_r.fontStack];
                                if (!kr)
                                    continue;
                                let Va = kr.glyphs[ci];
                                if (!Va)
                                    continue;
                                if (br = Va.metrics,
                                cs = ci !== 8203 ? Kr : 0,
                                Cn) {
                                    let dd = kr.ascender !== void 0 ? Math.abs(kr.ascender) : 0
                                      , Pp = kr.descender !== void 0 ? Math.abs(kr.descender) : 0
                                      , kp = (dd + Pp) * Xi;
                                    Hi < kp && (Hi = kp,
                                    $i = (dd - Pp) / 2 * Xi),
                                    Rr = -dd * Xi
                                } else
                                    Rr = (ti - Xi) * Kr - 17
                            }
                            Pr ? (Ne.verticalizable = !0,
                            ki.push({
                                glyph: ci,
                                imageName: rr,
                                x: Sn,
                                y: en + Rr,
                                vertical: Pr,
                                scale: Xi,
                                localGlyph: br.localGlyph,
                                fontStack: _r.fontStack,
                                sectionIndex: hr,
                                metrics: br,
                                rect: Si
                            }),
                            Sn += cs * Xi + Nt) : (ki.push({
                                glyph: ci,
                                imageName: rr,
                                x: Sn,
                                y: en + Rr,
                                vertical: Pr,
                                scale: Xi,
                                localGlyph: br.localGlyph,
                                fontStack: _r.fontStack,
                                sectionIndex: hr,
                                metrics: br,
                                rect: Si
                            }),
                            Sn += br.advance * Xi + Nt)
                        }
                        ki.length !== 0 && (hn = Math.max(Sn - Nt, hn),
                        Cn ? mE(ki, Yt, Fi, $i, dt * ti / 2) : mE(ki, Yt, Fi, 0, dt / 2)),
                        Sn = 0;
                        let Lr = dt * ti + Fi;
                        Ni.lineOffset = Math.max(Fi, Ei),
                        en += Lr,
                        ++ei
                    }
                    var Jn;
                    let Kn = en
                      , {horizontalAlign: Rn, verticalAlign: vi} = qx(yt);
                    (function(Bn, ti, Ei, Ni, ki, Fi) {
                        let Hi = (ti - Ei) * ki
                          , $i = -Fi * Ni;
                        for (let Lr of Bn)
                            for (let bi of Lr.positionedGlyphs)
                                bi.x += Hi,
                                bi.y += $i
                    }
                    )(Ne.positionedLines, Yt, Rn, vi, hn, Kn),
                    Ne.top += -vi * Kn,
                    Ne.bottom = Ne.top + Kn,
                    Ne.left += -Rn * hn,
                    Ne.right = Ne.left + hn,
                    Ne.hasBaseline = Cn
                }(Ue, n, a, u, de, y, w, S, N, M, B, q),
                !function(Ne) {
                    for (let at of Ne)
                        if (at.positionedGlyphs.length !== 0)
                            return !1;
                    return !0
                }(Le) && Ue
            }
            let C_ = {
                9: !0,
                10: !0,
                11: !0,
                12: !0,
                13: !0,
                32: !0
            }
              , RL = {
                10: !0,
                32: !0,
                38: !0,
                40: !0,
                41: !0,
                43: !0,
                45: !0,
                47: !0,
                173: !0,
                183: !0,
                8203: !0,
                8208: !0,
                8211: !0,
                8231: !0
            };
            function hE(s, n, a, u, f, g) {
                if (n.imageName) {
                    let y = u[n.imageName];
                    return y ? y.displaySize[0] * n.scale * Kr / g + f : 0
                }
                {
                    let y = a[n.fontStack]
                      , w = y && y.glyphs[s];
                    return w ? w.metrics.advance * n.scale + f : 0
                }
            }
            function dE(s, n, a, u) {
                let f = Math.pow(s - n, 2);
                return u ? s < n ? f / 2 : 2 * f : f + Math.abs(a) * a
            }
            function PL(s, n, a) {
                let u = 0;
                return s === 10 && (u -= 1e4),
                a && (u += 150),
                s !== 40 && s !== 65288 || (u += 50),
                n !== 41 && n !== 65289 || (u += 50),
                u
            }
            function fE(s, n, a, u, f, g) {
                let y = null
                  , w = dE(n, a, f, g);
                for (let S of u) {
                    let M = dE(n - S.x, a, f, g) + S.badness;
                    M <= w && (y = S,
                    w = M)
                }
                return {
                    index: s,
                    x: n,
                    priorBreak: y,
                    badness: w
                }
            }
            function pE(s) {
                return s ? pE(s.priorBreak).concat(s.index) : []
            }
            function qx(s) {
                let n = .5
                  , a = .5;
                switch (s) {
                case "right":
                case "top-right":
                case "bottom-right":
                    n = 1;
                    break;
                case "left":
                case "top-left":
                case "bottom-left":
                    n = 0
                }
                switch (s) {
                case "bottom":
                case "bottom-right":
                case "bottom-left":
                    a = 1;
                    break;
                case "top":
                case "top-right":
                case "top-left":
                    a = 0
                }
                return {
                    horizontalAlign: n,
                    verticalAlign: a
                }
            }
            function mE(s, n, a, u, f) {
                if (!(n || a || u || f))
                    return;
                let g = s.length - 1
                  , y = s[g]
                  , w = (y.x + y.metrics.advance * y.scale) * n;
                for (let S = 0; S <= g; S++)
                    s[S].x -= w,
                    s[S].y += a + u + f
            }
            function kL(s, n, a) {
                let {horizontalAlign: u, verticalAlign: f} = qx(a)
                  , g = n[0] - s.displaySize[0] * u
                  , y = n[1] - s.displaySize[1] * f;
                return {
                    image: s,
                    top: y,
                    bottom: y + s.displaySize[1],
                    left: g,
                    right: g + s.displaySize[0]
                }
            }
            function gE(s, n, a, u, f, g) {
                let y = s.image, w;
                if (y.content) {
                    let de = y.content
                      , Me = y.pixelRatio || 1;
                    w = [de[0] / Me, de[1] / Me, y.displaySize[0] - de[2] / Me, y.displaySize[1] - de[3] / Me]
                }
                let S = n.left * g, M = n.right * g, z, N, B, H;
                a === "width" || a === "both" ? (H = f[0] + S - u[3],
                N = f[0] + M + u[1]) : (H = f[0] + (S + M - y.displaySize[0]) / 2,
                N = H + y.displaySize[0]);
                let q = n.top * g
                  , Q = n.bottom * g;
                return a === "height" || a === "both" ? (z = f[1] + q - u[0],
                B = f[1] + Q + u[2]) : (z = f[1] + (q + Q - y.displaySize[1]) / 2,
                B = z + y.displaySize[1]),
                {
                    image: y,
                    top: z,
                    right: N,
                    bottom: B,
                    left: H,
                    collisionPadding: w
                }
            }
            class Ua extends W {
                constructor(n, a, u, f, g) {
                    super(n, a),
                    this.angle = f,
                    this.z = u,
                    g !== void 0 && (this.segment = g)
                }
                clone() {
                    return new Ua(this.x,this.y,this.z,this.angle,this.segment)
                }
            }
            function _E(s, n, a, u, f) {
                if (n.segment === void 0)
                    return !0;
                let g = n
                  , y = n.segment + 1
                  , w = 0;
                for (; w > -a / 2; ) {
                    if (y--,
                    y < 0)
                        return !1;
                    w -= s[y].dist(g),
                    g = s[y]
                }
                w += s[y].dist(s[y + 1]),
                y++;
                let S = []
                  , M = 0;
                for (; w < a / 2; ) {
                    let z = s[y]
                      , N = s[y + 1];
                    if (!N)
                        return !1;
                    let B = s[y - 1].angleTo(z) - z.angleTo(N);
                    for (B = Math.abs((B + 3 * Math.PI) % (2 * Math.PI) - Math.PI),
                    S.push({
                        distance: w,
                        angleDelta: B
                    }),
                    M += B; w - S[0].distance > u; )
                        M -= S.shift().angleDelta;
                    if (M > f)
                        return !1;
                    y++,
                    w += z.dist(N)
                }
                return !0
            }
            function yE(s) {
                let n = 0;
                for (let a = 0; a < s.length - 1; a++)
                    n += s[a].dist(s[a + 1]);
                return n
            }
            function xE(s, n, a) {
                return s ? .6 * n * a : 0
            }
            function vE(s, n) {
                return Math.max(s ? s.right - s.left : 0, n ? n.right - n.left : 0)
            }
            function zL(s, n, a, u, f, g) {
                let y = xE(a, f, g)
                  , w = vE(a, u) * g
                  , S = 0
                  , M = yE(s) / 2;
                for (let z = 0; z < s.length - 1; z++) {
                    let N = s[z]
                      , B = s[z + 1]
                      , H = N.dist(B);
                    if (S + H > M) {
                        let q = (M - S) / H
                          , Q = si(N.x, B.x, q)
                          , de = si(N.y, B.y, q)
                          , Me = new Ua(Q,de,0,B.angleTo(N),z);
                        return !y || _E(s, Me, w, y, n) ? Me : void 0
                    }
                    S += H
                }
            }
            function OL(s, n, a, u, f, g, y, w, S) {
                let M = xE(u, g, y)
                  , z = vE(u, f)
                  , N = z * y
                  , B = s[0].x === 0 || s[0].x === S || s[0].y === 0 || s[0].y === S;
                return n - N < n / 4 && (n = N + n / 4),
                bE(s, B ? n / 2 * w % n : (z / 2 + 2 * g) * y * w % n, n, M, a, N, B, !1, S)
            }
            function bE(s, n, a, u, f, g, y, w, S) {
                let M = g / 2
                  , z = yE(s)
                  , N = 0
                  , B = n - a
                  , H = [];
                for (let q = 0; q < s.length - 1; q++) {
                    let Q = s[q]
                      , de = s[q + 1]
                      , Me = Q.dist(de)
                      , Pe = de.angleTo(Q);
                    for (; B + a < N + Me; ) {
                        B += a;
                        let we = (B - N) / Me
                          , Le = si(Q.x, de.x, we)
                          , Ue = si(Q.y, de.y, we);
                        if (Le >= 0 && Le < S && Ue >= 0 && Ue < S && B - M >= 0 && B + M <= z) {
                            let Ne = new Ua(Le,Ue,0,Pe,q);
                            Ne._round(),
                            u && !_E(s, Ne, g, u, f) || H.push(Ne)
                        }
                    }
                    N += Me
                }
                return w || H.length || y || (H = bE(s, N / 2, a, u, f, g, y, !0, S)),
                H
            }
            function wE(s, n, a, u, f) {
                let g = [];
                for (let y = 0; y < s.length; y++) {
                    let w = s[y], S;
                    for (let M = 0; M < w.length - 1; M++) {
                        let z = w[M]
                          , N = w[M + 1];
                        z.x < n && N.x < n || (z.x < n ? z = new W(n,z.y + (n - z.x) / (N.x - z.x) * (N.y - z.y))._round() : N.x < n && (N = new W(n,z.y + (n - z.x) / (N.x - z.x) * (N.y - z.y))._round()),
                        z.y < a && N.y < a || (z.y < a ? z = new W(z.x + (a - z.y) / (N.y - z.y) * (N.x - z.x),a)._round() : N.y < a && (N = new W(z.x + (a - z.y) / (N.y - z.y) * (N.x - z.x),a)._round()),
                        z.x >= u && N.x >= u || (z.x >= u ? z = new W(u,z.y + (u - z.x) / (N.x - z.x) * (N.y - z.y))._round() : N.x >= u && (N = new W(u,z.y + (u - z.x) / (N.x - z.x) * (N.y - z.y))._round()),
                        z.y >= f && N.y >= f || (z.y >= f ? z = new W(z.x + (f - z.y) / (N.y - z.y) * (N.x - z.x),f)._round() : N.y >= f && (N = new W(z.x + (f - z.y) / (N.y - z.y) * (N.x - z.x),f)._round()),
                        S && z.equals(S[S.length - 1]) || (S = [z],
                        g.push(S)),
                        S.push(N)))))
                    }
                }
                return g
            }
            cn(Ua, "Anchor");
            let Ap = 1e20;
            function TE(s, n, a, u, f, g, y, w, S) {
                for (let M = n; M < n + u; M++)
                    EE(s, a * g + M, g, f, y, w, S);
                for (let M = a; M < a + f; M++)
                    EE(s, M * g + n, 1, u, y, w, S)
            }
            function EE(s, n, a, u, f, g, y) {
                g[0] = 0,
                y[0] = -Ap,
                y[1] = Ap,
                f[0] = s[n];
                for (let w = 1, S = 0, M = 0; w < u; w++) {
                    f[w] = s[n + w * a];
                    let z = w * w;
                    do {
                        let N = g[S];
                        M = (f[w] - f[N] + z - N * N) / (w - N) / 2
                    } while (M <= y[S] && --S > -1);
                    S++,
                    g[S] = w,
                    y[S] = M,
                    y[S + 1] = Ap
                }
                for (let w = 0, S = 0; w < u; w++) {
                    for (; y[S + 1] < w; )
                        S++;
                    let M = g[S]
                      , z = w - M;
                    s[n + w * a] = f[M] + z * z
                }
            }
            let Kx = {
                none: 0,
                ideographs: 1,
                all: 2
            };
            class ld {
                constructor(n, a, u) {
                    this.requestManager = n,
                    this.localGlyphMode = a,
                    this.localFontFamily = u,
                    this.entries = {},
                    this.localGlyphs = {
                        200: {},
                        400: {},
                        500: {},
                        900: {}
                    }
                }
                setURL(n) {
                    this.url = n
                }
                getGlyphs(n, a) {
                    let u = [];
                    for (let f in n)
                        for (let g of n[f])
                            u.push({
                                stack: f,
                                id: g
                            });
                    Be(u, ({stack: f, id: g},y)=>{
                        let w = this.entries[f];
                        w || (w = this.entries[f] = {
                            glyphs: {},
                            requests: {},
                            ranges: {},
                            ascender: void 0,
                            descender: void 0
                        });
                        let S = w.glyphs[g];
                        if (S !== void 0)
                            return void y(null, {
                                stack: f,
                                id: g,
                                glyph: S
                            });
                        if (S = this._tinySDF(w, f, g),
                        S)
                            return w.glyphs[g] = S,
                            void y(null, {
                                stack: f,
                                id: g,
                                glyph: S
                            });
                        let M = Math.floor(g / 256);
                        if (256 * M > 65535)
                            return void y(new Error("glyphs > 65535 not supported"));
                        if (w.ranges[M])
                            return void y(null, {
                                stack: f,
                                id: g,
                                glyph: S
                            });
                        let z = w.requests[M];
                        z || (z = w.requests[M] = [],
                        ld.loadGlyphRange(f, M, this.url, this.requestManager, (N,B)=>{
                            if (B) {
                                w.ascender = B.ascender,
                                w.descender = B.descender;
                                for (let H in B.glyphs)
                                    this._doesCharSupportLocalGlyph(+H) || (w.glyphs[+H] = B.glyphs[+H]);
                                w.ranges[M] = !0
                            }
                            for (let H of z)
                                H(N, B);
                            delete w.requests[M]
                        }
                        )),
                        z.push((N,B)=>{
                            N ? y(N) : B && y(null, {
                                stack: f,
                                id: g,
                                glyph: B.glyphs[g] || null
                            })
                        }
                        )
                    }
                    , (f,g)=>{
                        if (f)
                            a(f);
                        else if (g) {
                            let y = {};
                            for (let {stack: w, id: S, glyph: M} of g)
                                y[w] === void 0 && (y[w] = {}),
                                y[w].glyphs === void 0 && (y[w].glyphs = {}),
                                y[w].glyphs[S] = M && {
                                    id: M.id,
                                    bitmap: M.bitmap.clone(),
                                    metrics: M.metrics
                                },
                                y[w].ascender = this.entries[w].ascender,
                                y[w].descender = this.entries[w].descender;
                            a(null, y)
                        }
                    }
                    )
                }
                _doesCharSupportLocalGlyph(n) {
                    return this.localGlyphMode !== Kx.none && (this.localGlyphMode === Kx.all ? !!this.localFontFamily : !!this.localFontFamily && (tp(n) || i_(n) || Wh(n) || Ll(n) || iu(n)))
                }
                _tinySDF(n, a, u) {
                    let f = this.localFontFamily;
                    if (!f || !this._doesCharSupportLocalGlyph(u))
                        return;
                    let g = n.tinySDF;
                    if (!g) {
                        let Q = "400";
                        /bold/i.test(a) ? Q = "900" : /medium/i.test(a) ? Q = "500" : /light/i.test(a) && (Q = "200"),
                        g = n.tinySDF = new ld.TinySDF({
                            fontFamily: f,
                            fontWeight: Q,
                            fontSize: 48,
                            buffer: 6,
                            radius: 16
                        }),
                        g.fontWeight = Q
                    }
                    if (this.localGlyphs[g.fontWeight][u])
                        return this.localGlyphs[g.fontWeight][u];
                    let y = String.fromCharCode(u)
                      , {data: w, width: S, height: M, glyphWidth: z, glyphHeight: N, glyphLeft: B, glyphTop: H, glyphAdvance: q} = g.draw(y);
                    return this.localGlyphs[g.fontWeight][u] = {
                        id: u,
                        bitmap: new Fa({
                            width: S,
                            height: M
                        },w),
                        metrics: {
                            width: z / 2,
                            height: N / 2,
                            left: B / 2,
                            top: H / 2 - 27,
                            advance: q / 2,
                            localGlyph: !0
                        }
                    }
                }
            }
            function SE(s, n, a, u) {
                let f = []
                  , g = s.image
                  , y = g.pixelRatio
                  , w = g.paddedRect.w - 2
                  , S = g.paddedRect.h - 2
                  , M = s.right - s.left
                  , z = s.bottom - s.top
                  , N = g.stretchX || [[0, w]]
                  , B = g.stretchY || [[0, S]]
                  , H = (dt,yt)=>dt + yt[1] - yt[0]
                  , q = N.reduce(H, 0)
                  , Q = B.reduce(H, 0)
                  , de = w - q
                  , Me = S - Q
                  , Pe = 0
                  , we = q
                  , Le = 0
                  , Ue = Q
                  , Ne = 0
                  , at = de
                  , it = 0
                  , _t = Me;
                if (g.content && u) {
                    let dt = g.content;
                    Pe = D_(N, 0, dt[0]),
                    Le = D_(B, 0, dt[1]),
                    we = D_(N, dt[0], dt[2]),
                    Ue = D_(B, dt[1], dt[3]),
                    Ne = dt[0] - Pe,
                    it = dt[1] - Le,
                    at = dt[2] - dt[0] - we,
                    _t = dt[3] - dt[1] - Ue
                }
                let Ot = (dt,yt,Tt,Lt)=>{
                    let Nt = L_(dt.stretch - Pe, we, M, s.left)
                      , mt = R_(dt.fixed - Ne, at, dt.stretch, q)
                      , qt = L_(yt.stretch - Le, Ue, z, s.top)
                      , Sn = R_(yt.fixed - it, _t, yt.stretch, Q)
                      , en = L_(Tt.stretch - Pe, we, M, s.left)
                      , hn = R_(Tt.fixed - Ne, at, Tt.stretch, q)
                      , Yt = L_(Lt.stretch - Le, Ue, z, s.top)
                      , Cn = R_(Lt.fixed - it, _t, Lt.stretch, Q)
                      , ei = new W(Nt,qt)
                      , Jn = new W(en,qt)
                      , Kn = new W(en,Yt)
                      , Rn = new W(Nt,Yt)
                      , vi = new W(mt / y,Sn / y)
                      , Bn = new W(hn / y,Cn / y)
                      , ti = n * Math.PI / 180;
                    if (ti) {
                        let ki = Math.sin(ti)
                          , Fi = Math.cos(ti)
                          , Hi = [Fi, -ki, ki, Fi];
                        ei._matMult(Hi),
                        Jn._matMult(Hi),
                        Rn._matMult(Hi),
                        Kn._matMult(Hi)
                    }
                    let Ei = dt.stretch + dt.fixed
                      , Ni = yt.stretch + yt.fixed;
                    return {
                        tl: ei,
                        tr: Jn,
                        bl: Rn,
                        br: Kn,
                        tex: {
                            x: g.paddedRect.x + 1 + Ei,
                            y: g.paddedRect.y + 1 + Ni,
                            w: Tt.stretch + Tt.fixed - Ei,
                            h: Lt.stretch + Lt.fixed - Ni
                        },
                        writingMode: void 0,
                        glyphOffset: [0, 0],
                        sectionIndex: 0,
                        pixelOffsetTL: vi,
                        pixelOffsetBR: Bn,
                        minFontScaleX: at / y / M,
                        minFontScaleY: _t / y / z,
                        isSDF: a
                    }
                }
                ;
                if (u && (g.stretchX || g.stretchY)) {
                    let dt = AE(N, de, q)
                      , yt = AE(B, Me, Q);
                    for (let Tt = 0; Tt < dt.length - 1; Tt++) {
                        let Lt = dt[Tt]
                          , Nt = dt[Tt + 1];
                        for (let mt = 0; mt < yt.length - 1; mt++)
                            f.push(Ot(Lt, yt[mt], Nt, yt[mt + 1]))
                    }
                } else
                    f.push(Ot({
                        fixed: 0,
                        stretch: -1
                    }, {
                        fixed: 0,
                        stretch: -1
                    }, {
                        fixed: 0,
                        stretch: w + 1
                    }, {
                        fixed: 0,
                        stretch: S + 1
                    }));
                return f
            }
            function D_(s, n, a) {
                let u = 0;
                for (let f of s)
                    u += Math.max(n, Math.min(a, f[1])) - Math.max(n, Math.min(a, f[0]));
                return u
            }
            function AE(s, n, a) {
                let u = [{
                    fixed: -1,
                    stretch: 0
                }];
                for (let[f,g] of s) {
                    let y = u[u.length - 1];
                    u.push({
                        fixed: f - y.stretch,
                        stretch: y.stretch
                    }),
                    u.push({
                        fixed: f - y.stretch,
                        stretch: y.stretch + (g - f)
                    })
                }
                return u.push({
                    fixed: n + 1,
                    stretch: a
                }),
                u
            }
            function L_(s, n, a, u) {
                return s / n * a + u
            }
            function R_(s, n, a, u) {
                return s - n * a / u
            }
            function NL(s, n, a, u) {
                let f = n + s.positionedLines[u].lineOffset;
                return u === 0 ? a + f / 2 : a + (f + (n + s.positionedLines[u - 1].lineOffset)) / 2
            }
            ld.loadGlyphRange = function(s, n, a, u, f) {
                let g = 256 * n
                  , y = g + 255
                  , w = u.transformRequest(u.normalizeGlyphsURL(a).replace("{fontstack}", s).replace("{range}", `${g}-${y}`), Ct.Glyphs);
                Wt(w, (S,M)=>{
                    if (S)
                        f(S);
                    else if (M) {
                        let z = {}
                          , N = function(B) {
                            return new Ep(B).readFields(CL, {})
                        }(M);
                        for (let B of N.glyphs)
                            z[B.id] = B;
                        f(null, {
                            glyphs: z,
                            ascender: N.ascender,
                            descender: N.descender
                        })
                    }
                }
                )
            }
            ,
            ld.TinySDF = class {
                constructor({fontSize: s=24, buffer: n=3, radius: a=8, cutoff: u=.25, fontFamily: f="sans-serif", fontWeight: g="normal", fontStyle: y="normal"}={}) {
                    this.buffer = n,
                    this.cutoff = u,
                    this.radius = a;
                    let w = this.size = s + 4 * n
                      , S = this._createCanvas(w)
                      , M = this.ctx = S.getContext("2d", {
                        willReadFrequently: !0
                    });
                    M.font = `${y} ${g} ${s}px ${f}`,
                    M.textBaseline = "alphabetic",
                    M.textAlign = "left",
                    M.fillStyle = "black",
                    this.gridOuter = new Float64Array(w * w),
                    this.gridInner = new Float64Array(w * w),
                    this.f = new Float64Array(w),
                    this.z = new Float64Array(w + 1),
                    this.v = new Uint16Array(w)
                }
                _createCanvas(s) {
                    let n = document.createElement("canvas");
                    return n.width = n.height = s,
                    n
                }
                draw(s) {
                    let {width: n, actualBoundingBoxAscent: a, actualBoundingBoxDescent: u, actualBoundingBoxLeft: f, actualBoundingBoxRight: g} = this.ctx.measureText(s)
                      , y = Math.ceil(a)
                      , w = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(g - f)))
                      , S = Math.min(this.size - this.buffer, y + Math.ceil(u))
                      , M = w + 2 * this.buffer
                      , z = S + 2 * this.buffer
                      , N = Math.max(M * z, 0)
                      , B = new Uint8ClampedArray(N)
                      , H = {
                        data: B,
                        width: M,
                        height: z,
                        glyphWidth: w,
                        glyphHeight: S,
                        glyphTop: y,
                        glyphLeft: 0,
                        glyphAdvance: n
                    };
                    if (w === 0 || S === 0)
                        return H;
                    let {ctx: q, buffer: Q, gridInner: de, gridOuter: Me} = this;
                    q.clearRect(Q, Q, w, S),
                    q.fillText(s, Q, Q + y);
                    let Pe = q.getImageData(Q, Q, w, S);
                    Me.fill(Ap, 0, N),
                    de.fill(0, 0, N);
                    for (let we = 0; we < S; we++)
                        for (let Le = 0; Le < w; Le++) {
                            let Ue = Pe.data[4 * (we * w + Le) + 3] / 255;
                            if (Ue === 0)
                                continue;
                            let Ne = (we + Q) * M + Le + Q;
                            if (Ue === 1)
                                Me[Ne] = 0,
                                de[Ne] = Ap;
                            else {
                                let at = .5 - Ue;
                                Me[Ne] = at > 0 ? at * at : 0,
                                de[Ne] = at < 0 ? at * at : 0
                            }
                        }
                    TE(Me, 0, 0, M, z, M, this.f, this.v, this.z),
                    TE(de, Q, Q, w, S, M, this.f, this.v, this.z);
                    for (let we = 0; we < N; we++) {
                        let Le = Math.sqrt(Me[we]) - Math.sqrt(de[we]);
                        B[we] = Math.round(255 - 255 * (Le / this.radius + this.cutoff))
                    }
                    return H
                }
            }
            ;
            class FL {
                constructor(n=[], a=BL) {
                    if (this.data = n,
                    this.length = this.data.length,
                    this.compare = a,
                    this.length > 0)
                        for (let u = (this.length >> 1) - 1; u >= 0; u--)
                            this._down(u)
                }
                push(n) {
                    this.data.push(n),
                    this.length++,
                    this._up(this.length - 1)
                }
                pop() {
                    if (this.length === 0)
                        return;
                    let n = this.data[0]
                      , a = this.data.pop();
                    return this.length--,
                    this.length > 0 && (this.data[0] = a,
                    this._down(0)),
                    n
                }
                peek() {
                    return this.data[0]
                }
                _up(n) {
                    let {data: a, compare: u} = this
                      , f = a[n];
                    for (; n > 0; ) {
                        let g = n - 1 >> 1
                          , y = a[g];
                        if (u(f, y) >= 0)
                            break;
                        a[n] = y,
                        n = g
                    }
                    a[n] = f
                }
                _down(n) {
                    let {data: a, compare: u} = this
                      , f = this.length >> 1
                      , g = a[n];
                    for (; n < f; ) {
                        let y = 1 + (n << 1)
                          , w = a[y]
                          , S = y + 1;
                        if (S < this.length && u(a[S], w) < 0 && (y = S,
                        w = a[S]),
                        u(w, g) >= 0)
                            break;
                        a[n] = w,
                        n = y
                    }
                    a[n] = g
                }
            }
            function BL(s, n) {
                return s < n ? -1 : s > n ? 1 : 0
            }
            function UL(s, n=1, a=!1) {
                let u = 1 / 0
                  , f = 1 / 0
                  , g = -1 / 0
                  , y = -1 / 0
                  , w = s[0];
                for (let H = 0; H < w.length; H++) {
                    let q = w[H];
                    (!H || q.x < u) && (u = q.x),
                    (!H || q.y < f) && (f = q.y),
                    (!H || q.x > g) && (g = q.x),
                    (!H || q.y > y) && (y = q.y)
                }
                let S = Math.min(g - u, y - f)
                  , M = S / 2
                  , z = new FL([],VL);
                if (S === 0)
                    return new W(u,f);
                for (let H = u; H < g; H += S)
                    for (let q = f; q < y; q += S)
                        z.push(new cd(H + M,q + M,M,s));
                let N = function(H) {
                    let q = 0
                      , Q = 0
                      , de = 0
                      , Me = H[0];
                    for (let Pe = 0, we = Me.length, Le = we - 1; Pe < we; Le = Pe++) {
                        let Ue = Me[Pe]
                          , Ne = Me[Le]
                          , at = Ue.x * Ne.y - Ne.x * Ue.y;
                        Q += (Ue.x + Ne.x) * at,
                        de += (Ue.y + Ne.y) * at,
                        q += 3 * at
                    }
                    return new cd(Q / q,de / q,0,H)
                }(s)
                  , B = z.length;
                for (; z.length; ) {
                    let H = z.pop();
                    (H.d > N.d || !N.d) && (N = H,
                    a && console.log("found best %d after %d probes", Math.round(1e4 * H.d) / 1e4, B)),
                    H.max - N.d <= n || (M = H.h / 2,
                    z.push(new cd(H.p.x - M,H.p.y - M,M,s)),
                    z.push(new cd(H.p.x + M,H.p.y - M,M,s)),
                    z.push(new cd(H.p.x - M,H.p.y + M,M,s)),
                    z.push(new cd(H.p.x + M,H.p.y + M,M,s)),
                    B += 4)
                }
                return a && (console.log(`num probes: ${B}`),
                console.log(`best distance: ${N.d}`)),
                N.p
            }
            function VL(s, n) {
                return n.max - s.max
            }
            function cd(s, n, a, u) {
                this.p = new W(s,n),
                this.h = a,
                this.d = function(f, g) {
                    let y = !1
                      , w = 1 / 0;
                    for (let S = 0; S < g.length; S++) {
                        let M = g[S];
                        for (let z = 0, N = M.length, B = N - 1; z < N; B = z++) {
                            let H = M[z]
                              , q = M[B];
                            H.y > f.y != q.y > f.y && f.x < (q.x - H.x) * (f.y - H.y) / (q.y - H.y) + H.x && (y = !y),
                            w = Math.min(w, ET(f, H, q))
                        }
                    }
                    return (y ? 1 : -1) * Math.sqrt(w)
                }(this.p, u),
                this.max = this.d + this.h * Math.SQRT2
            }
            let Yx = Number.POSITIVE_INFINITY
              , GL = Math.sqrt(2);
            function ME(s, [n,a]) {
                let u = 0
                  , f = 0;
                if (a === Yx) {
                    n < 0 && (n = 0);
                    let g = n / GL;
                    switch (s) {
                    case "top-right":
                    case "top-left":
                        f = g - 7;
                        break;
                    case "bottom-right":
                    case "bottom-left":
                        f = 7 - g;
                        break;
                    case "bottom":
                        f = 7 - n;
                        break;
                    case "top":
                        f = n - 7
                    }
                    switch (s) {
                    case "top-right":
                    case "bottom-right":
                        u = -g;
                        break;
                    case "top-left":
                    case "bottom-left":
                        u = g;
                        break;
                    case "left":
                        u = n;
                        break;
                    case "right":
                        u = -n
                    }
                } else {
                    switch (n = Math.abs(n),
                    a = Math.abs(a),
                    s) {
                    case "top-right":
                    case "top-left":
                    case "top":
                        f = a - 7;
                        break;
                    case "bottom-right":
                    case "bottom-left":
                    case "bottom":
                        f = 7 - a
                    }
                    switch (s) {
                    case "top-right":
                    case "bottom-right":
                    case "right":
                        u = -n;
                        break;
                    case "top-left":
                    case "bottom-left":
                    case "left":
                        u = n
                    }
                }
                return [u, f]
            }
            function HL(s, n, a, u, f, g, y, w, S, M) {
                s.createArrays(),
                s.tilePixelRatio = kn / (512 * s.overscaling),
                s.compareText = {},
                s.iconsNeedLinear = !1;
                let z = s.layers[0].layout
                  , N = s.layers[0]._unevaluatedLayout._values
                  , B = {};
                if (s.textSizeData.kind === "composite") {
                    let {minZoom: Q, maxZoom: de} = s.textSizeData;
                    B.compositeTextSizes = [N["text-size"].possiblyEvaluate(new $e(Q), w), N["text-size"].possiblyEvaluate(new $e(de), w)]
                }
                if (s.iconSizeData.kind === "composite") {
                    let {minZoom: Q, maxZoom: de} = s.iconSizeData;
                    B.compositeIconSizes = [N["icon-size"].possiblyEvaluate(new $e(Q), w), N["icon-size"].possiblyEvaluate(new $e(de), w)]
                }
                B.layoutTextSize = N["text-size"].possiblyEvaluate(new $e(S + 1), w),
                B.layoutIconSize = N["icon-size"].possiblyEvaluate(new $e(S + 1), w),
                B.textMaxSize = N["text-size"].possiblyEvaluate(new $e(18), w);
                let H = z.get("text-rotation-alignment") === "map" && z.get("symbol-placement") !== "point"
                  , q = z.get("text-size");
                for (let Q of s.features) {
                    let de = z.get("text-font").evaluate(Q, {}, w).join(","), Me = q.evaluate(Q, {}, w), Pe = B.layoutTextSize.evaluate(Q, {}, w), we = (B.layoutIconSize.evaluate(Q, {}, w),
                    {
                        horizontal: {},
                        vertical: void 0
                    }), Le = Q.text, Ue, Ne = [0, 0];
                    if (Le) {
                        let _t = Le.toString()
                          , Ot = z.get("text-letter-spacing").evaluate(Q, {}, w) * Kr
                          , dt = z.get("text-line-height").evaluate(Q, {}, w) * Kr
                          , yt = T(_t) ? Ot : 0
                          , Tt = z.get("text-anchor").evaluate(Q, {}, w)
                          , Lt = z.get("text-variable-anchor");
                        if (!Lt) {
                            let en = z.get("text-radial-offset").evaluate(Q, {}, w);
                            Ne = en ? ME(Tt, [en * Kr, Yx]) : z.get("text-offset").evaluate(Q, {}, w).map(hn=>hn * Kr)
                        }
                        let Nt = H ? "center" : z.get("text-justify").evaluate(Q, {}, w)
                          , mt = z.get("symbol-placement") === "point"
                          , qt = mt ? z.get("text-max-width").evaluate(Q, {}, w) * Kr : 1 / 0
                          , Sn = en=>{
                            s.allowVerticalPlacement && b(_t) && (we.vertical = Zx(Le, n, a, f, de, qt, dt, Tt, en, yt, Ne, $s.vertical, !0, Pe, Me))
                        }
                        ;
                        if (!H && Lt) {
                            let en = Nt === "auto" ? Lt.map(Yt=>Jx(Yt)) : [Nt]
                              , hn = !1;
                            for (let Yt = 0; Yt < en.length; Yt++) {
                                let Cn = en[Yt];
                                if (!we.horizontal[Cn])
                                    if (hn)
                                        we.horizontal[Cn] = we.horizontal[0];
                                    else {
                                        let ei = Zx(Le, n, a, f, de, qt, dt, "center", Cn, yt, Ne, $s.horizontal, !1, Pe, Me);
                                        ei && (we.horizontal[Cn] = ei,
                                        hn = ei.positionedLines.length === 1)
                                    }
                            }
                            Sn("left")
                        } else {
                            if (Nt === "auto" && (Nt = Jx(Tt)),
                            mt || z.get("text-writing-mode").indexOf("horizontal") >= 0 || !b(_t)) {
                                let en = Zx(Le, n, a, f, de, qt, dt, Tt, Nt, yt, Ne, $s.horizontal, !1, Pe, Me);
                                en && (we.horizontal[Nt] = en)
                            }
                            Sn(mt ? "left" : Nt)
                        }
                    }
                    let at = !1;
                    if (Q.icon && Q.icon.name) {
                        let _t = u[Q.icon.name];
                        _t && (Ue = kL(f[Q.icon.name], z.get("icon-offset").evaluate(Q, {}, w), z.get("icon-anchor").evaluate(Q, {}, w)),
                        at = _t.sdf,
                        s.sdfIcons === void 0 ? s.sdfIcons = _t.sdf : s.sdfIcons !== _t.sdf && ut("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"),
                        (_t.pixelRatio !== s.pixelRatio || z.get("icon-rotate").constantOr(1) !== 0) && (s.iconsNeedLinear = !0))
                    }
                    let it = CE(we.horizontal) || we.vertical;
                    s.iconsInText || (s.iconsInText = !!it && it.iconsInText),
                    (it || Ue) && WL(s, Q, we, Ue, u, B, Pe, 0, Ne, at, y, w, M)
                }
                g && s.generateCollisionDebugBuffers(S, s.collisionBoxArray)
            }
            function Jx(s) {
                switch (s) {
                case "right":
                case "top-right":
                case "bottom-right":
                    return "right";
                case "left":
                case "top-left":
                case "bottom-left":
                    return "left"
                }
                return "center"
            }
            function WL(s, n, a, u, f, g, y, w, S, M, z, N, B) {
                let H = g.textMaxSize.evaluate(n, {}, N);
                H === void 0 && (H = y);
                let q = s.layers[0].layout
                  , Q = q.get("icon-offset").evaluate(n, {}, N)
                  , de = CE(a.horizontal) || a.vertical
                  , Me = B.name === "globe"
                  , Pe = y / 24
                  , we = s.tilePixelRatio * H / 24
                  , Le = (yt = s.overscaling,
                s.zoom > 18 && yt > 2 && (yt >>= 1),
                Math.max(kn / (512 * yt), 1) * q.get("symbol-spacing"))
                  , Ue = q.get("text-padding") * s.tilePixelRatio
                  , Ne = q.get("icon-padding") * s.tilePixelRatio
                  , at = oe(q.get("text-max-angle"))
                  , it = q.get("text-rotation-alignment") === "map" && q.get("symbol-placement") !== "point"
                  , _t = q.get("icon-rotation-alignment") === "map" && q.get("symbol-placement") !== "point"
                  , Ot = q.get("symbol-placement")
                  , dt = Le / 2;
                var yt;
                let Tt = q.get("icon-text-fit"), Lt;
                u && Tt !== "none" && (s.allowVerticalPlacement && a.vertical && (Lt = gE(u, a.vertical, Tt, q.get("icon-text-fit-padding"), Q, Pe)),
                de && (u = gE(u, de, Tt, q.get("icon-text-fit-padding"), Q, Pe)));
                let Nt = (mt,qt,Sn)=>{
                    if (qt.x < 0 || qt.x >= kn || qt.y < 0 || qt.y >= kn)
                        return;
                    let en = null;
                    if (Me) {
                        let {x: hn, y: Yt, z: Cn} = B.projectTilePoint(qt.x, qt.y, Sn);
                        en = {
                            anchor: new Ua(hn,Yt,Cn,0,void 0),
                            up: B.upVector(Sn, qt.x, qt.y)
                        }
                    }
                    (function(hn, Yt, Cn, ei, Jn, Kn, Rn, vi, Bn, ti, Ei, Ni, ki, Fi, Hi, $i, Lr, bi, _r, hr, ci, Xi, br, Si, rr) {
                        let cs = hn.addToLineVertexArray(Yt, ei), Rr, Pr, vs, kr, Va, dd, Pp, kp = 0, rS = 0, sS = 0, oS = 0, cv = -1, uv = -1, ca = {}, aS = su(""), _u = Cn ? Cn.anchor : Yt, hv = 0, dv = 0;
                        if (Bn._unevaluatedLayout.getValue("text-radial-offset") === void 0 ? [hv,dv] = Bn.layout.get("text-offset").evaluate(ci, {}, rr).map(Bs=>Bs * Kr) : (hv = Bn.layout.get("text-radial-offset").evaluate(ci, {}, rr) * Kr,
                        dv = Yx),
                        hn.allowVerticalPlacement && Jn.vertical) {
                            let Bs = Jn.vertical;
                            if (Hi)
                                dd = $x(Bs),
                                vi && (Pp = $x(vi));
                            else {
                                let Us = Bn.layout.get("text-rotate").evaluate(ci, {}, rr) + 90;
                                vs = P_(ti, _u, Yt, Ei, Ni, ki, Bs, Fi, Us, $i),
                                vi && (kr = P_(ti, _u, Yt, Ei, Ni, ki, vi, bi, Us))
                            }
                        }
                        if (Kn) {
                            let Bs = Bn.layout.get("icon-rotate").evaluate(ci, {}, rr)
                              , Us = Bn.layout.get("icon-text-fit") !== "none"
                              , zp = SE(Kn, Bs, br, Us)
                              , pv = vi ? SE(vi, Bs, br, Us) : void 0;
                            Pr = P_(ti, _u, Yt, Ei, Ni, ki, Kn, bi, Bs),
                            kp = 4 * zp.length;
                            let lS = hn.iconSizeData
                              , yu = null;
                            lS.kind === "source" ? (yu = [sa * Bn.layout.get("icon-size").evaluate(ci, {}, rr)],
                            yu[0] > Nl && ut(`${hn.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)) : lS.kind === "composite" && (yu = [sa * Xi.compositeIconSizes[0].evaluate(ci, {}, rr), sa * Xi.compositeIconSizes[1].evaluate(ci, {}, rr)],
                            (yu[0] > Nl || yu[1] > Nl) && ut(`${hn.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)),
                            hn.addSymbols(hn.icon, zp, yu, hr, _r, ci, !1, Cn, Yt, cs.lineStartIndex, cs.lineLength, -1, Si, rr),
                            cv = hn.icon.placedSymbolArray.length - 1,
                            pv && (rS = 4 * pv.length,
                            hn.addSymbols(hn.icon, pv, yu, hr, _r, ci, $s.vertical, Cn, Yt, cs.lineStartIndex, cs.lineLength, -1, Si, rr),
                            uv = hn.icon.placedSymbolArray.length - 1)
                        }
                        for (let Bs in Jn.horizontal) {
                            let Us = Jn.horizontal[Bs];
                            Rr || (aS = su(Us.text),
                            Hi ? Va = $x(Us) : Rr = P_(ti, _u, Yt, Ei, Ni, ki, Us, Fi, Bn.layout.get("text-rotate").evaluate(ci, {}, rr), $i));
                            let zp = Us.positionedLines.length === 1;
                            if (sS += IE(hn, Cn, Yt, Us, Rn, Bn, Hi, ci, $i, cs, Jn.vertical ? $s.horizontal : $s.horizontalOnly, zp ? Object.keys(Jn.horizontal) : [Bs], ca, cv, Xi, Si, rr),
                            zp)
                                break
                        }
                        Jn.vertical && (oS += IE(hn, Cn, Yt, Jn.vertical, Rn, Bn, Hi, ci, $i, cs, $s.vertical, ["vertical"], ca, uv, Xi, Si, rr));
                        let Hl = -1
                          , fv = (Bs,Us)=>Bs ? Math.max(Bs, Us) : Us;
                        Hl = fv(Va, Hl),
                        Hl = fv(dd, Hl),
                        Hl = fv(Pp, Hl);
                        let gR = Hl > -1 ? 1 : 0;
                        hn.glyphOffsetArray.length >= Bl.MAX_GLYPHS && ut("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"),
                        ci.sortKey !== void 0 && hn.addToSortKeyRanges(hn.symbolInstances.length, ci.sortKey),
                        hn.symbolInstances.emplaceBack(_u.x, _u.y, _u.z, Yt.x, Yt.y, ca.right >= 0 ? ca.right : -1, ca.center >= 0 ? ca.center : -1, ca.left >= 0 ? ca.left : -1, ca.vertical >= 0 ? ca.vertical : -1, cv, uv, aS, Rr !== void 0 ? Rr : hn.collisionBoxArray.length, Rr !== void 0 ? Rr + 1 : hn.collisionBoxArray.length, vs !== void 0 ? vs : hn.collisionBoxArray.length, vs !== void 0 ? vs + 1 : hn.collisionBoxArray.length, Pr !== void 0 ? Pr : hn.collisionBoxArray.length, Pr !== void 0 ? Pr + 1 : hn.collisionBoxArray.length, kr || hn.collisionBoxArray.length, kr ? kr + 1 : hn.collisionBoxArray.length, Ei, sS, oS, kp, rS, gR, 0, hv, dv, Hl)
                    }
                    )(s, qt, en, mt, a, u, f, Lt, s.layers[0], s.collisionBoxArray, n.index, n.sourceLayerIndex, s.index, Ue, it, S, 0, Ne, _t, Q, n, g, M, z, N)
                }
                ;
                if (Ot === "line")
                    for (let mt of wE(n.geometry, 0, 0, kn, kn)) {
                        let qt = OL(mt, Le, at, a.vertical || de, u, 24, we, s.overscaling, kn);
                        for (let Sn of qt) {
                            let en = de;
                            en && jL(s, en.text, dt, Sn) || Nt(mt, Sn, N)
                        }
                    }
                else if (Ot === "line-center") {
                    for (let mt of n.geometry)
                        if (mt.length > 1) {
                            let qt = zL(mt, at, a.vertical || de, u, 24, we);
                            qt && Nt(mt, qt, N)
                        }
                } else if (n.type === "Polygon")
                    for (let mt of Bx(n.geometry, 0)) {
                        let qt = UL(mt, 16);
                        Nt(mt[0], new Ua(qt.x,qt.y,0,0,void 0), N)
                    }
                else if (n.type === "LineString")
                    for (let mt of n.geometry)
                        Nt(mt, new Ua(mt[0].x,mt[0].y,0,0,void 0), N);
                else if (n.type === "Point")
                    for (let mt of n.geometry)
                        for (let qt of mt)
                            Nt([qt], new Ua(qt.x,qt.y,0,0,void 0), N)
            }
            let Nl = 32640;
            function IE(s, n, a, u, f, g, y, w, S, M, z, N, B, H, q, Q, de) {
                let Me = function(Le, Ue, Ne, at, it, _t, Ot, dt) {
                    let yt = [];
                    if (Ue.positionedLines.length === 0)
                        return yt;
                    let Tt = at.layout.get("text-rotate").evaluate(_t, {}) * Math.PI / 180
                      , Lt = function(en) {
                        let hn = en[0]
                          , Yt = en[1]
                          , Cn = hn * Yt;
                        return Cn > 0 ? [hn, -Yt] : Cn < 0 ? [-hn, Yt] : hn === 0 ? [Yt, hn] : [Yt, -hn]
                    }(Ne)
                      , Nt = Math.abs(Ue.top - Ue.bottom);
                    for (let en of Ue.positionedLines)
                        Nt -= en.lineOffset;
                    let mt = Ue.positionedLines.length
                      , qt = Nt / mt
                      , Sn = Ue.top - Ne[1];
                    for (let en = 0; en < mt; ++en) {
                        let hn = Ue.positionedLines[en];
                        Sn = NL(Ue, qt, Sn, en);
                        for (let Yt of hn.positionedGlyphs) {
                            if (!Yt.rect)
                                continue;
                            let Cn = Yt.rect || {}
                              , ei = 4
                              , Jn = !0
                              , Kn = 1
                              , Rn = 0;
                            if (Yt.imageName) {
                                let Si = Ot[Yt.imageName];
                                if (!Si)
                                    continue;
                                if (Si.sdf) {
                                    ut("SDF images are not supported in formatted text and will be ignored.");
                                    continue
                                }
                                Jn = !1,
                                Kn = Si.pixelRatio,
                                ei = 1 / Kn
                            }
                            let vi = (it || dt) && Yt.vertical
                              , Bn = Yt.metrics.advance * Yt.scale / 2
                              , ti = Yt.metrics
                              , Ei = Yt.rect;
                            if (Ei === null)
                                continue;
                            dt && Ue.verticalizable && (Rn = Yt.imageName ? Bn - Yt.metrics.width * Yt.scale / 2 : 0);
                            let Ni = it ? [Yt.x + Bn, Yt.y] : [0, 0]
                              , ki = [0, 0]
                              , Fi = [0, 0]
                              , Hi = !1;
                            it || (vi ? (Fi = [Yt.x + Bn + Lt[0], Yt.y + Lt[1] - Rn],
                            Hi = !0) : ki = [Yt.x + Bn + Ne[0], Yt.y + Ne[1] - Rn]);
                            let $i = Ei.w * Yt.scale / (Kn * (Yt.localGlyph ? 2 : 1)), Lr = Ei.h * Yt.scale / (Kn * (Yt.localGlyph ? 2 : 1)), bi, _r, hr, ci;
                            if (vi) {
                                let Si = Yt.y - Sn
                                  , rr = new W(-Bn,Bn - Si)
                                  , cs = -Math.PI / 2
                                  , Rr = new W(...Fi);
                                bi = new W(-Bn + ki[0],ki[1]),
                                bi._rotateAround(cs, rr)._add(Rr),
                                bi.x += -Si + Bn,
                                bi.y -= (ti.left - ei) * Yt.scale;
                                let Pr = Yt.imageName ? ti.advance * Yt.scale : Kr * Yt.scale
                                  , vs = String.fromCharCode(Yt.glyph);
                                yL(vs) ? bi.x += (1 - ei) * Yt.scale : xL(vs) ? bi.x += Pr - ti.height * Yt.scale + (-ei - 1) * Yt.scale : bi.x += Yt.imageName || ti.width + 2 * ei === Ei.w && ti.height + 2 * ei === Ei.h ? (Pr - Lr) / 2 : (Pr - (ti.height + 2 * ei) * Yt.scale) / 2,
                                _r = new W(bi.x,bi.y - $i),
                                hr = new W(bi.x + Lr,bi.y),
                                ci = new W(bi.x + Lr,bi.y - $i)
                            } else {
                                let Si = (ti.left - ei) * Yt.scale - Bn + ki[0]
                                  , rr = (-ti.top - ei) * Yt.scale + ki[1]
                                  , cs = Si + $i
                                  , Rr = rr + Lr;
                                bi = new W(Si,rr),
                                _r = new W(cs,rr),
                                hr = new W(Si,Rr),
                                ci = new W(cs,Rr)
                            }
                            if (Tt) {
                                let Si;
                                Si = it ? new W(0,0) : Hi ? new W(Lt[0],Lt[1]) : new W(Ne[0],Ne[1]),
                                bi._rotateAround(Tt, Si),
                                _r._rotateAround(Tt, Si),
                                hr._rotateAround(Tt, Si),
                                ci._rotateAround(Tt, Si)
                            }
                            let Xi = new W(0,0)
                              , br = new W(0,0);
                            yt.push({
                                tl: bi,
                                tr: _r,
                                bl: hr,
                                br: ci,
                                tex: Cn,
                                writingMode: Ue.writingMode,
                                glyphOffset: Ni,
                                sectionIndex: Yt.sectionIndex,
                                isSDF: Jn,
                                pixelOffsetTL: Xi,
                                pixelOffsetBR: br,
                                minFontScaleX: 0,
                                minFontScaleY: 0
                            })
                        }
                    }
                    return yt
                }(0, u, S, g, y, w, f, s.allowVerticalPlacement)
                  , Pe = s.textSizeData
                  , we = null;
                Pe.kind === "source" ? (we = [sa * g.layout.get("text-size").evaluate(w, {}, de)],
                we[0] > Nl && ut(`${s.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)) : Pe.kind === "composite" && (we = [sa * q.compositeTextSizes[0].evaluate(w, {}, de), sa * q.compositeTextSizes[1].evaluate(w, {}, de)],
                (we[0] > Nl || we[1] > Nl) && ut(`${s.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)),
                s.addSymbols(s.text, Me, we, S, y, w, z, n, a, M.lineStartIndex, M.lineLength, H, Q, de);
                for (let Le of N)
                    B[Le] = s.text.placedSymbolArray.length - 1;
                return 4 * Me.length
            }
            function CE(s) {
                for (let n in s)
                    return s[n];
                return null
            }
            function P_(s, n, a, u, f, g, y, w, S, M) {
                let z = y.top
                  , N = y.bottom
                  , B = y.left
                  , H = y.right
                  , q = y.collisionPadding;
                if (q && (B -= q[0],
                z -= q[1],
                H += q[2],
                N += q[3]),
                S) {
                    let Q = new W(B,z)
                      , de = new W(H,z)
                      , Me = new W(B,N)
                      , Pe = new W(H,N)
                      , we = oe(S)
                      , Le = new W(0,0);
                    M && (Le = new W(M[0],M[1])),
                    Q._rotateAround(we, Le),
                    de._rotateAround(we, Le),
                    Me._rotateAround(we, Le),
                    Pe._rotateAround(we, Le),
                    B = Math.min(Q.x, de.x, Me.x, Pe.x),
                    H = Math.max(Q.x, de.x, Me.x, Pe.x),
                    z = Math.min(Q.y, de.y, Me.y, Pe.y),
                    N = Math.max(Q.y, de.y, Me.y, Pe.y)
                }
                return s.emplaceBack(n.x, n.y, n.z, a.x, a.y, B, z, H, N, w, u, f, g),
                s.length - 1
            }
            function $x(s) {
                s.collisionPadding && (s.top -= s.collisionPadding[1],
                s.bottom += s.collisionPadding[3]);
                let n = s.bottom - s.top;
                return n > 0 ? Math.max(10, n) : null
            }
            function jL(s, n, a, u) {
                let f = s.compareText;
                if (n in f) {
                    let g = f[n];
                    for (let y = g.length - 1; y >= 0; y--)
                        if (u.dist(g[y]) < a)
                            return !0
                } else
                    f[n] = [];
                return f[n].push(u),
                !1
            }
            function DE(s, n) {
                let a = s.fovAboveCenter
                  , u = s.elevation ? s.elevation.getMinElevationBelowMSL() * n : 0
                  , f = (s._camera.position[2] * s.worldSize - u) / Math.cos(s._pitch)
                  , g = Math.sin(a) * f / Math.sin(Math.max(Math.PI / 2 - s._pitch - a, .01))
                  , y = Math.sin(s._pitch) * g + f;
                return Math.min(1.01 * y, f * (1 / s._horizonShift))
            }
            function mu(s, n) {
                if (!n.isReprojectedInTileSpace)
                    return {
                        scale: 1 << s.z,
                        x: s.x,
                        y: s.y,
                        x2: s.x + 1,
                        y2: s.y + 1,
                        projection: n
                    };
                let a = Math.pow(2, -s.z)
                  , u = s.x * a
                  , f = (s.x + 1) * a
                  , g = s.y * a
                  , y = (s.y + 1) * a
                  , w = Js(u)
                  , S = Js(f)
                  , M = Zr(g)
                  , z = Zr(y)
                  , N = n.project(w, M)
                  , B = n.project(S, M)
                  , H = n.project(S, z)
                  , q = n.project(w, z)
                  , Q = Math.min(N.x, B.x, H.x, q.x)
                  , de = Math.min(N.y, B.y, H.y, q.y)
                  , Me = Math.max(N.x, B.x, H.x, q.x)
                  , Pe = Math.max(N.y, B.y, H.y, q.y)
                  , we = a / 16;
                function Le(Ne, at, it, _t, Ot, dt) {
                    let yt = (it + Ot) / 2
                      , Tt = (_t + dt) / 2
                      , Lt = n.project(Js(yt), Zr(Tt))
                      , Nt = Math.max(0, Q - Lt.x, de - Lt.y, Lt.x - Me, Lt.y - Pe);
                    Q = Math.min(Q, Lt.x),
                    Me = Math.max(Me, Lt.x),
                    de = Math.min(de, Lt.y),
                    Pe = Math.max(Pe, Lt.y),
                    Nt > we && (Le(Ne, Lt, it, _t, yt, Tt),
                    Le(Lt, at, yt, Tt, Ot, dt))
                }
                Le(N, B, u, g, f, g),
                Le(B, H, f, g, f, y),
                Le(H, q, f, y, u, y),
                Le(q, N, u, y, u, g),
                Q -= we,
                de -= we,
                Me += we,
                Pe += we;
                let Ue = 1 / Math.max(Me - Q, Pe - de);
                return {
                    scale: Ue,
                    x: Q * Ue,
                    y: de * Ue,
                    x2: Me * Ue,
                    y2: Pe * Ue,
                    projection: n
                }
            }
            let XL = Po(new Float32Array(16));
            class Fl {
                constructor(n) {
                    this.spec = n,
                    this.name = n.name,
                    this.wrap = !1,
                    this.requiresDraping = !1,
                    this.supportsWorldCopies = !1,
                    this.supportsTerrain = !1,
                    this.supportsFog = !1,
                    this.supportsFreeCamera = !1,
                    this.zAxisUnit = "meters",
                    this.isReprojectedInTileSpace = !0,
                    this.unsupportedLayers = ["custom"],
                    this.center = [0, 0],
                    this.range = [3.5, 7]
                }
                project(n, a) {
                    return {
                        x: 0,
                        y: 0,
                        z: 0
                    }
                }
                unproject(n, a) {
                    return new oi(0,0)
                }
                projectTilePoint(n, a, u) {
                    return {
                        x: n,
                        y: a,
                        z: 0
                    }
                }
                locationPoint(n, a, u=!0) {
                    return n._coordinatePoint(n.locationCoordinate(a), u)
                }
                pixelsPerMeter(n, a) {
                    return zo(1, n) * a
                }
                pixelSpaceConversion(n, a, u) {
                    return 1
                }
                farthestPixelDistance(n) {
                    return DE(n, n.pixelsPerMeter)
                }
                pointCoordinate(n, a, u, f) {
                    let g = n.horizonLineFromTop(!1)
                      , y = new W(a,Math.max(g, u));
                    return n.rayIntersectionCoordinate(n.pointRayIntersection(y, f))
                }
                pointCoordinate3D(n, a, u) {
                    let f = new W(a,u);
                    if (n.elevation)
                        return n.elevation.pointCoordinate(f);
                    {
                        let g = this.pointCoordinate(n, f.x, f.y, 0);
                        return [g.x, g.y, g.z]
                    }
                }
                isPointAboveHorizon(n, a) {
                    if (n.elevation)
                        return !this.pointCoordinate3D(n, a.x, a.y);
                    let u = n.horizonLineFromTop();
                    return a.y < u
                }
                createInversionMatrix(n, a) {
                    return XL
                }
                createTileMatrix(n, a, u) {
                    let f, g, y, w = u.canonical, S = Po(new Float64Array(16));
                    if (this.isReprojectedInTileSpace) {
                        let M = mu(w, this);
                        f = 1,
                        g = M.x + u.wrap * M.scale,
                        y = M.y,
                        lu(S, S, [f / M.scale, f / M.scale, n.pixelsPerMeter / a])
                    } else
                        f = a / n.zoomScale(w.z),
                        g = (w.x + Math.pow(2, w.z) * u.wrap) * f,
                        y = w.y * f;
                    return ip(S, S, [g, y, 0]),
                    lu(S, S, [f / kn, f / kn, 1]),
                    S
                }
                upVector(n, a, u) {
                    return [0, 0, 1]
                }
                upVectorScale(n, a, u) {
                    return {
                        metersToTile: 1
                    }
                }
            }
            class ZL extends Fl {
                constructor(n) {
                    super(n),
                    this.range = [4, 7],
                    this.center = n.center || [-96, 37.5];
                    let[a,u] = this.parallels = n.parallels || [29.5, 45.5]
                      , f = Math.sin(oe(a));
                    this.n = (f + Math.sin(oe(u))) / 2,
                    this.c = 1 + f * (2 * this.n - f),
                    this.r0 = Math.sqrt(this.c) / this.n
                }
                project(n, a) {
                    let {n: u, c: f, r0: g} = this
                      , y = oe(n - this.center[0])
                      , w = oe(a)
                      , S = Math.sqrt(f - 2 * u * Math.sin(w)) / u;
                    return {
                        x: S * Math.sin(y * u),
                        y: S * Math.cos(y * u) - g,
                        z: 0
                    }
                }
                unproject(n, a) {
                    let {n: u, c: f, r0: g} = this
                      , y = g + a
                      , w = Math.atan2(n, Math.abs(y)) * Math.sign(y);
                    y * u < 0 && (w -= Math.PI * Math.sign(n) * Math.sign(y));
                    let S = oe(this.center[0]) * u;
                    w = ke(w, -Math.PI - S, Math.PI - S);
                    let M = ae(ee(w / u) + this.center[0], -180, 180)
                      , z = Math.asin(ae((f - (n * n + y * y) * u * u) / (2 * u), -1, 1))
                      , N = ae(ee(z), -qr, qr);
                    return new oi(M,N)
                }
            }
            let Mp = 1.340264
              , Ip = -.081106
              , Cp = 893e-6
              , Dp = .003796
              , k_ = Math.sqrt(3) / 2;
            class qL extends Fl {
                project(n, a) {
                    a = a / 180 * Math.PI,
                    n = n / 180 * Math.PI;
                    let u = Math.asin(k_ * Math.sin(a))
                      , f = u * u
                      , g = f * f * f;
                    return {
                        x: .5 * (n * Math.cos(u) / (k_ * (Mp + 3 * Ip * f + g * (7 * Cp + 9 * Dp * f))) / Math.PI + .5),
                        y: 1 - .5 * (u * (Mp + Ip * f + g * (Cp + Dp * f)) / Math.PI + 1),
                        z: 0
                    }
                }
                unproject(n, a) {
                    n = (2 * n - .5) * Math.PI;
                    let u = a = (2 * (1 - a) - 1) * Math.PI
                      , f = u * u
                      , g = f * f * f;
                    for (let z, N, B, H = 0; H < 12 && (N = u * (Mp + Ip * f + g * (Cp + Dp * f)) - a,
                    B = Mp + 3 * Ip * f + g * (7 * Cp + 9 * Dp * f),
                    z = N / B,
                    u = ae(u - z, -Math.PI / 3, Math.PI / 3),
                    f = u * u,
                    g = f * f * f,
                    !(Math.abs(z) < 1e-12)); ++H)
                        ;
                    let y = k_ * n * (Mp + 3 * Ip * f + g * (7 * Cp + 9 * Dp * f)) / Math.cos(u)
                      , w = Math.asin(Math.sin(u) / k_)
                      , S = ae(180 * y / Math.PI, -180, 180)
                      , M = ae(180 * w / Math.PI, -qr, qr);
                    return new oi(S,M)
                }
            }
            class KL extends Fl {
                constructor(n) {
                    super(n),
                    this.wrap = !0,
                    this.supportsWorldCopies = !0
                }
                project(n, a) {
                    return {
                        x: .5 + n / 360,
                        y: .5 - a / 360,
                        z: 0
                    }
                }
                unproject(n, a) {
                    let u = 360 * (n - .5)
                      , f = ae(360 * (.5 - a), -qr, qr);
                    return new oi(u,f)
                }
            }
            let ud = Math.PI / 2;
            function z_(s) {
                return Math.tan((ud + s) / 2)
            }
            class YL extends Fl {
                constructor(n) {
                    super(n),
                    this.center = n.center || [0, 30];
                    let[a,u] = this.parallels = n.parallels || [30, 30]
                      , f = oe(a)
                      , g = oe(u);
                    this.southernCenter = f + g < 0,
                    this.southernCenter && (f = -f,
                    g = -g);
                    let y = Math.cos(f)
                      , w = z_(f);
                    this.n = f === g ? Math.sin(f) : Math.log(y / Math.cos(g)) / Math.log(z_(g) / w),
                    this.f = y * Math.pow(z_(f), this.n) / this.n
                }
                project(n, a) {
                    a = oe(a),
                    this.southernCenter && (a = -a),
                    n = oe(n - this.center[0]);
                    let u = 1e-6
                      , {n: f, f: g} = this;
                    g > 0 ? a < -ud + u && (a = -ud + u) : a > ud - u && (a = ud - u);
                    let y = g / Math.pow(z_(a), f)
                      , w = y * Math.sin(f * n)
                      , S = g - y * Math.cos(f * n);
                    return w = .5 * (w / Math.PI + .5),
                    S = .5 * (S / Math.PI + .5),
                    {
                        x: w,
                        y: this.southernCenter ? S : 1 - S,
                        z: 0
                    }
                }
                unproject(n, a) {
                    n = (2 * n - .5) * Math.PI,
                    this.southernCenter && (a = 1 - a),
                    a = (2 * (1 - a) - .5) * Math.PI;
                    let {n: u, f} = this
                      , g = f - a
                      , y = Math.sign(g)
                      , w = Math.sign(u) * Math.sqrt(n * n + g * g)
                      , S = Math.atan2(n, Math.abs(g)) * y;
                    g * u < 0 && (S -= Math.PI * Math.sign(n) * y);
                    let M = ae(ee(S / u) + this.center[0], -180, 180)
                      , z = ae(ee(2 * Math.atan(Math.pow(f / w, 1 / u)) - ud), -qr, qr);
                    return new oi(M,this.southernCenter ? -z : z)
                }
            }
            class LE extends Fl {
                constructor(n) {
                    super(n),
                    this.wrap = !0,
                    this.supportsWorldCopies = !0,
                    this.supportsTerrain = !0,
                    this.supportsFog = !0,
                    this.supportsFreeCamera = !0,
                    this.isReprojectedInTileSpace = !1,
                    this.unsupportedLayers = [],
                    this.range = null
                }
                project(n, a) {
                    return {
                        x: ia(n),
                        y: ra(a),
                        z: 0
                    }
                }
                unproject(n, a) {
                    let u = Js(n)
                      , f = Zr(a);
                    return new oi(u,f)
                }
            }
            let RE = oe(qr);
            class JL extends Fl {
                project(n, a) {
                    let u = (a = oe(a)) * a
                      , f = u * u;
                    return {
                        x: .5 * ((n = oe(n)) * (.8707 - .131979 * u + f * (f * (.003971 * u - .001529 * f) - .013791)) / Math.PI + .5),
                        y: 1 - .5 * (a * (1.007226 + u * (.015085 + f * (.028874 * u - .044475 - .005916 * f))) / Math.PI + 1),
                        z: 0
                    }
                }
                unproject(n, a) {
                    n = (2 * n - .5) * Math.PI;
                    let u = a = (2 * (1 - a) - 1) * Math.PI
                      , f = 25
                      , g = 0
                      , y = u * u;
                    do {
                        y = u * u;
                        let M = y * y;
                        g = (u * (1.007226 + y * (.015085 + M * (.028874 * y - .044475 - .005916 * M))) - a) / (1.007226 + y * (.045255 + M * (.259866 * y - .311325 - .005916 * 11 * M))),
                        u = ae(u - g, -RE, RE)
                    } while (Math.abs(g) > 1e-6 && --f > 0);
                    y = u * u;
                    let w = ae(ee(n / (.8707 + y * (y * (y * y * y * (.003971 - .001529 * y) - .013791) - .131979))), -180, 180)
                      , S = ee(u);
                    return new oi(w,S)
                }
            }
            let PE = oe(qr);
            class $L extends Fl {
                project(n, a) {
                    a = oe(a),
                    n = oe(n);
                    let u = Math.cos(a)
                      , f = 2 / Math.PI
                      , g = Math.acos(u * Math.cos(n / 2))
                      , y = Math.sin(g) / g
                      , w = .5 * (n * f + 2 * u * Math.sin(n / 2) / y) || 0
                      , S = .5 * (a + Math.sin(a) / y) || 0;
                    return {
                        x: .5 * (w / Math.PI + .5),
                        y: 1 - .5 * (S / Math.PI + 1),
                        z: 0
                    }
                }
                unproject(n, a) {
                    let u = n = (2 * n - .5) * Math.PI
                      , f = a = (2 * (1 - a) - 1) * Math.PI
                      , g = 25
                      , y = 1e-6
                      , w = 0
                      , S = 0;
                    do {
                        let M = Math.cos(f)
                          , z = Math.sin(f)
                          , N = 2 * z * M
                          , B = z * z
                          , H = M * M
                          , q = Math.cos(u / 2)
                          , Q = Math.sin(u / 2)
                          , de = 2 * q * Q
                          , Me = Q * Q
                          , Pe = 1 - H * q * q
                          , we = Pe ? 1 / Pe : 0
                          , Le = Pe ? Math.acos(M * q) * Math.sqrt(1 / Pe) : 0
                          , Ue = .5 * (2 * Le * M * Q + 2 * u / Math.PI) - n
                          , Ne = .5 * (Le * z + f) - a
                          , at = .5 * we * (H * Me + Le * M * q * B) + 1 / Math.PI
                          , it = we * (de * N / 4 - Le * z * Q)
                          , _t = .125 * we * (N * Q - Le * z * H * de)
                          , Ot = .5 * we * (B * q + Le * Me * M) + .5
                          , dt = it * _t - Ot * at;
                        w = (Ne * it - Ue * Ot) / dt,
                        S = (Ue * _t - Ne * at) / dt,
                        u = ae(u - w, -Math.PI, Math.PI),
                        f = ae(f - S, -PE, PE)
                    } while ((Math.abs(w) > y || Math.abs(S) > y) && --g > 0);
                    return new oi(ee(u),ee(f))
                }
            }
            class kE extends Fl {
                constructor(n) {
                    super(n),
                    this.center = n.center || [0, 0],
                    this.parallels = n.parallels || [0, 0],
                    this.cosPhi = Math.max(.01, Math.cos(oe(this.parallels[0]))),
                    this.scale = 1 / (2 * Math.max(Math.PI * this.cosPhi, 1 / this.cosPhi)),
                    this.wrap = !0,
                    this.supportsWorldCopies = !0
                }
                project(n, a) {
                    let {scale: u, cosPhi: f} = this;
                    return {
                        x: oe(n) * f * u + .5,
                        y: -Math.sin(oe(a)) / f * u + .5,
                        z: 0
                    }
                }
                unproject(n, a) {
                    let {scale: u, cosPhi: f} = this
                      , g = -(a - .5) / u
                      , y = ae(ee((n - .5) / u) / f, -180, 180)
                      , w = Math.asin(ae(g * f, -1, 1))
                      , S = ae(ee(w), -qr, qr);
                    return new oi(y,S)
                }
            }
            class QL extends LE {
                constructor(n) {
                    super(n),
                    this.requiresDraping = !0,
                    this.supportsWorldCopies = !1,
                    this.supportsFog = !0,
                    this.zAxisUnit = "pixels",
                    this.unsupportedLayers = ["debug"],
                    this.range = [3, 5]
                }
                projectTilePoint(n, a, u) {
                    let f = hp(n, a, u);
                    return ir(f, f, dp(na(u))),
                    {
                        x: f[0],
                        y: f[1],
                        z: f[2]
                    }
                }
                locationPoint(n, a) {
                    let u = Yh(a.lat, a.lng)
                      , f = _s([], u)
                      , g = n.elevation ? n.elevation.getAtPointOrZero(n.locationCoordinate(a), n._centerAltitude) : n._centerAltitude;
                    ap(u, u, f, zo(1, 0) * kn * g);
                    let y = Po(new Float64Array(16));
                    return au(y, n.pixelMatrix, n.globeMatrix),
                    ir(u, u, y),
                    new W(u[0],u[1])
                }
                pixelsPerMeter(n, a) {
                    return zo(1, 0) * a
                }
                pixelSpaceConversion(n, a, u) {
                    let f = zo(1, n) * a
                      , g = si(zo(1, 45) * a, f, u);
                    return this.pixelsPerMeter(n, a) / g
                }
                createTileMatrix(n, a, u) {
                    let f = Sx(na(u.canonical));
                    return au(new Float64Array(16), n.globeMatrix, f)
                }
                createInversionMatrix(n, a) {
                    let {center: u} = n
                      , f = dp(na(a));
                    return u_(f, f, oe(u.lng)),
                    gx(f, f, oe(u.lat)),
                    lu(f, f, [n._pixelsPerMercatorPixel, n._pixelsPerMercatorPixel, 1]),
                    Float32Array.from(f)
                }
                pointCoordinate(n, a, u, f) {
                    return uT(n, a, u, !0) || new $h(0,0)
                }
                pointCoordinate3D(n, a, u) {
                    let f = this.pointCoordinate(n, a, u, 0);
                    return [f.x, f.y, f.z]
                }
                isPointAboveHorizon(n, a) {
                    return !uT(n, a.x, a.y, !1)
                }
                farthestPixelDistance(n) {
                    let a = function(f, g) {
                        let y = f.cameraToCenterDistance, w = f._centerAltitude * g, S = f._camera, M = f._camera.forward(), z = Oa([], Ys([], M, -y), [0, 0, w]), N = f.worldSize / (2 * Math.PI), B = [0, 0, -N], H = f.width / f.height, q = Math.tan(f.fovAboveCenter), Q = Ys([], S.up(), q), de = Ys([], S.right(), q * H), Me = _s([], Oa([], Oa([], M, Q), de)), Pe = [], we;
                        if (new vx(z,Me).closestPointOnSphere(B, N, Pe)) {
                            let Le = Oa([], Pe, B)
                              , Ue = ko([], Le, z);
                            we = Math.cos(f.fovAboveCenter) * rp(Ue)
                        } else {
                            let Le = ko([], z, B)
                              , Ue = ko([], B, z);
                            _s(Ue, Ue);
                            let Ne = rp(Le) - N;
                            we = Math.sqrt(Ne * (Ne + 2 * N));
                            let at = Math.acos(we / (N + Ne)) - Math.acos(ho(M, Ue));
                            we *= Math.cos(at)
                        }
                        return 1.01 * we
                    }(n, this.pixelsPerMeter(n.center.lat, n.worldSize))
                      , u = Jh(n.zoom);
                    if (u > 0) {
                        let f = DE(n, zo(1, n.center.lat) * n.worldSize)
                          , g = n.worldSize / (2 * Math.PI)
                          , y = Math.max(n.width, n.height) / n.worldSize * Math.PI;
                        return si(a, f + g * (1 - Math.cos(y)), Math.pow(u, 10))
                    }
                    return a
                }
                upVector(n, a, u) {
                    return hp(a, u, n, 1)
                }
                upVectorScale(n) {
                    return {
                        metersToTile: h_(f_(na(n)))
                    }
                }
            }
            function zE(s) {
                let n = s.parallels
                  , a = !!n && Math.abs(n[0] + n[1]) < .01;
                switch (s.name) {
                case "mercator":
                    return new LE(s);
                case "equirectangular":
                    return new KL(s);
                case "naturalEarth":
                    return new JL(s);
                case "equalEarth":
                    return new qL(s);
                case "winkelTripel":
                    return new $L(s);
                case "albers":
                    return a ? new kE(s) : new ZL(s);
                case "lambertConformalConic":
                    return a ? new kE(s) : new YL(s);
                case "globe":
                    return new QL(s)
                }
                throw new Error(`Invalid projection name: ${s.name}`)
            }
            let eR = T_.types
              , tR = [{
                name: "a_fade_opacity",
                components: 1,
                type: "Uint8",
                offset: 0
            }];
            function O_(s, n, a, u, f, g, y, w, S, M, z, N, B) {
                let H = w ? Math.min(Nl, Math.round(w[0])) : 0
                  , q = w ? Math.min(Nl, Math.round(w[1])) : 0;
                s.emplaceBack(n, a, Math.round(32 * u), Math.round(32 * f), g, y, (H << 1) + (S ? 1 : 0), q, 16 * M, 16 * z, 256 * N, 256 * B)
            }
            function N_(s, n, a, u, f, g, y) {
                s.emplaceBack(n, a, u, f, g, y)
            }
            function F_(s, n, a, u, f) {
                s.emplaceBack(n, a, u, f),
                s.emplaceBack(n, a, u, f),
                s.emplaceBack(n, a, u, f),
                s.emplaceBack(n, a, u, f)
            }
            function nR(s) {
                for (let n of s.sections)
                    if (J(n.text))
                        return !0;
                return !1
            }
            class Qx {
                constructor(n) {
                    this.layoutVertexArray = new Co,
                    this.indexArray = new Xr,
                    this.programConfigurations = n,
                    this.segments = new cr,
                    this.dynamicLayoutVertexArray = new Mi,
                    this.opacityVertexArray = new Ii,
                    this.placedSymbolArray = new Ow,
                    this.globeExtVertexArray = new Gi
                }
                isEmpty() {
                    return this.layoutVertexArray.length === 0 && this.indexArray.length === 0 && this.dynamicLayoutVertexArray.length === 0 && this.opacityVertexArray.length === 0
                }
                upload(n, a, u, f) {
                    this.isEmpty() || (u && (this.layoutVertexBuffer = n.createVertexBuffer(this.layoutVertexArray, uL.members),
                    this.indexBuffer = n.createIndexBuffer(this.indexArray, a),
                    this.dynamicLayoutVertexBuffer = n.createVertexBuffer(this.dynamicLayoutVertexArray, dL.members, !0),
                    this.opacityVertexBuffer = n.createVertexBuffer(this.opacityVertexArray, tR, !0),
                    this.globeExtVertexArray.length > 0 && (this.globeExtVertexBuffer = n.createVertexBuffer(this.globeExtVertexArray, hL.members, !0)),
                    this.opacityVertexBuffer.itemSize = 1),
                    (u || f) && this.programConfigurations.upload(n))
                }
                destroy() {
                    this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(),
                    this.indexBuffer.destroy(),
                    this.programConfigurations.destroy(),
                    this.segments.destroy(),
                    this.dynamicLayoutVertexBuffer.destroy(),
                    this.opacityVertexBuffer.destroy(),
                    this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy())
                }
            }
            cn(Qx, "SymbolBuffers");
            class ev {
                constructor(n, a, u) {
                    this.layoutVertexArray = new n,
                    this.layoutAttributes = a,
                    this.indexArray = new u,
                    this.segments = new cr,
                    this.collisionVertexArray = new Oi,
                    this.collisionVertexArrayExt = new jr
                }
                upload(n) {
                    this.layoutVertexBuffer = n.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes),
                    this.indexBuffer = n.createIndexBuffer(this.indexArray),
                    this.collisionVertexBuffer = n.createVertexBuffer(this.collisionVertexArray, fL.members, !0),
                    this.collisionVertexBufferExt = n.createVertexBuffer(this.collisionVertexArrayExt, pL.members, !0)
                }
                destroy() {
                    this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(),
                    this.indexBuffer.destroy(),
                    this.segments.destroy(),
                    this.collisionVertexBuffer.destroy(),
                    this.collisionVertexBufferExt.destroy())
                }
            }
            cn(ev, "CollisionBuffers");
            class Bl {
                constructor(n) {
                    this.collisionBoxArray = n.collisionBoxArray,
                    this.zoom = n.zoom,
                    this.overscaling = n.overscaling,
                    this.layers = n.layers,
                    this.layerIds = this.layers.map(y=>y.id),
                    this.index = n.index,
                    this.pixelRatio = n.pixelRatio,
                    this.sourceLayerIndex = n.sourceLayerIndex,
                    this.hasPattern = !1,
                    this.hasRTLText = !1,
                    this.fullyClipped = !1,
                    this.sortKeyRanges = [],
                    this.collisionCircleArray = [],
                    this.placementInvProjMatrix = Po([]),
                    this.placementViewportMatrix = Po([]);
                    let a = this.layers[0]._unevaluatedLayout._values;
                    this.textSizeData = Hx(this.zoom, a["text-size"]),
                    this.iconSizeData = Hx(this.zoom, a["icon-size"]);
                    let u = this.layers[0].layout
                      , f = u.get("symbol-sort-key")
                      , g = u.get("symbol-z-order");
                    this.canOverlap = u.get("text-allow-overlap") || u.get("icon-allow-overlap") || u.get("text-ignore-placement") || u.get("icon-ignore-placement"),
                    this.sortFeaturesByKey = g !== "viewport-y" && f.constantOr(1) !== void 0,
                    this.sortFeaturesByY = (g === "viewport-y" || g === "auto" && !this.sortFeaturesByKey) && this.canOverlap,
                    this.writingModes = u.get("text-writing-mode").map(y=>$s[y]),
                    this.stateDependentLayerIds = this.layers.filter(y=>y.isStateDependent()).map(y=>y.id),
                    this.sourceID = n.sourceID,
                    this.projection = n.projection
                }
                createArrays() {
                    this.text = new Qx(new ou(this.layers,this.zoom,n=>/^text/.test(n))),
                    this.icon = new Qx(new ou(this.layers,this.zoom,n=>/^icon/.test(n))),
                    this.glyphOffsetArray = new Bw,
                    this.lineVertexArray = new Uw,
                    this.symbolInstances = new Fw
                }
                calculateGlyphDependencies(n, a, u, f, g) {
                    for (let y = 0; y < n.length; y++)
                        if (a[n.charCodeAt(y)] = !0,
                        f && g) {
                            let w = Tp[n.charAt(y)];
                            w && (a[w.charCodeAt(0)] = !0)
                        }
                }
                populate(n, a, u, f) {
                    let g = this.layers[0]
                      , y = g.layout
                      , w = this.projection.name === "globe"
                      , S = y.get("text-font")
                      , M = y.get("text-field")
                      , z = y.get("icon-image")
                      , N = (M.value.kind !== "constant" || M.value.value instanceof ms && !M.value.value.isEmpty() || M.value.value.toString().length > 0) && (S.value.kind !== "constant" || S.value.value.length > 0)
                      , B = z.value.kind !== "constant" || !!z.value.value || Object.keys(z.parameters).length > 0
                      , H = y.get("symbol-sort-key");
                    if (this.features = [],
                    !N && !B)
                        return;
                    let q = a.iconDependencies
                      , Q = a.glyphDependencies
                      , de = a.availableImages
                      , Me = new $e(this.zoom);
                    for (let {feature: Pe, id: we, index: Le, sourceLayerIndex: Ue} of n) {
                        let Ne = g._featureFilter.needGeometry
                          , at = du(Pe, Ne);
                        if (!g._featureFilter.filter(Me, at, u))
                            continue;
                        if (Ne || (at.geometry = Na(Pe, u, f)),
                        w && Pe.type !== 1 && u.z <= 5) {
                            let dt = at.geometry
                              , yt = .98078528056
                              , Tt = (Lt,Nt)=>ho(hp(Lt.x, Lt.y, u, 1), hp(Nt.x, Nt.y, u, 1)) < yt;
                            for (let Lt = 0; Lt < dt.length; Lt++)
                                dt[Lt] = dD(dt[Lt], Tt)
                        }
                        let it, _t;
                        if (N) {
                            let dt = g.getValueAndResolveTokens("text-field", at, u, de)
                              , yt = ms.factory(dt);
                            nR(yt) && (this.hasRTLText = !0),
                            (!this.hasRTLText || Ve() === "unavailable" || this.hasRTLText && Xe.isParsed()) && (it = _L(yt, g, at))
                        }
                        if (B) {
                            let dt = g.getValueAndResolveTokens("icon-image", at, u, de);
                            _t = dt instanceof ls ? dt : ls.fromString(dt)
                        }
                        if (!it && !_t)
                            continue;
                        let Ot = this.sortFeaturesByKey ? H.evaluate(at, {}, u) : void 0;
                        if (this.features.push({
                            id: we,
                            text: it,
                            icon: _t,
                            index: Le,
                            sourceLayerIndex: Ue,
                            geometry: at.geometry,
                            properties: Pe.properties,
                            type: eR[Pe.type],
                            sortKey: Ot
                        }),
                        _t && (q[_t.name] = !0),
                        it) {
                            let dt = S.evaluate(at, {}, u).join(",")
                              , yt = y.get("text-rotation-alignment") === "map" && y.get("symbol-placement") !== "point";
                            this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf($s.vertical) >= 0;
                            for (let Tt of it.sections)
                                if (Tt.image)
                                    q[Tt.image.name] = !0;
                                else {
                                    let Lt = b(it.toString())
                                      , Nt = Tt.fontStack || dt
                                      , mt = Q[Nt] = Q[Nt] || {};
                                    this.calculateGlyphDependencies(Tt.text, mt, yt, this.allowVerticalPlacement, Lt)
                                }
                        }
                    }
                    y.get("symbol-placement") === "line" && (this.features = function(Pe) {
                        let we = {}
                          , Le = {}
                          , Ue = []
                          , Ne = 0;
                        function at(dt) {
                            Ue.push(Pe[dt]),
                            Ne++
                        }
                        function it(dt, yt, Tt) {
                            let Lt = Le[dt];
                            return delete Le[dt],
                            Le[yt] = Lt,
                            Ue[Lt].geometry[0].pop(),
                            Ue[Lt].geometry[0] = Ue[Lt].geometry[0].concat(Tt[0]),
                            Lt
                        }
                        function _t(dt, yt, Tt) {
                            let Lt = we[yt];
                            return delete we[yt],
                            we[dt] = Lt,
                            Ue[Lt].geometry[0].shift(),
                            Ue[Lt].geometry[0] = Tt[0].concat(Ue[Lt].geometry[0]),
                            Lt
                        }
                        function Ot(dt, yt, Tt) {
                            let Lt = Tt ? yt[0][yt[0].length - 1] : yt[0][0];
                            return `${dt}:${Lt.x}:${Lt.y}`
                        }
                        for (let dt = 0; dt < Pe.length; dt++) {
                            let yt = Pe[dt]
                              , Tt = yt.geometry
                              , Lt = yt.text ? yt.text.toString() : null;
                            if (!Lt) {
                                at(dt);
                                continue
                            }
                            let Nt = Ot(Lt, Tt)
                              , mt = Ot(Lt, Tt, !0);
                            if (Nt in Le && mt in we && Le[Nt] !== we[mt]) {
                                let qt = _t(Nt, mt, Tt)
                                  , Sn = it(Nt, mt, Ue[qt].geometry);
                                delete we[Nt],
                                delete Le[mt],
                                Le[Ot(Lt, Ue[Sn].geometry, !0)] = Sn,
                                Ue[qt].geometry = null
                            } else
                                Nt in Le ? it(Nt, mt, Tt) : mt in we ? _t(Nt, mt, Tt) : (at(dt),
                                we[Nt] = Ne - 1,
                                Le[mt] = Ne - 1)
                        }
                        return Ue.filter(dt=>dt.geometry)
                    }(this.features)),
                    this.sortFeaturesByKey && this.features.sort((Pe,we)=>Pe.sortKey - we.sortKey)
                }
                update(n, a, u, f) {
                    this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(n, a, this.layers, u, f),
                    this.icon.programConfigurations.updatePaintArrays(n, a, this.layers, u, f))
                }
                isEmpty() {
                    return this.symbolInstances.length === 0 && !this.hasRTLText
                }
                uploadPending() {
                    return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload
                }
                upload(n) {
                    !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(n),
                    this.iconCollisionBox.upload(n)),
                    this.text.upload(n, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload),
                    this.icon.upload(n, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload),
                    this.uploaded = !0
                }
                destroyDebugData() {
                    this.textCollisionBox.destroy(),
                    this.iconCollisionBox.destroy()
                }
                getProjection() {
                    return this.projectionInstance || (this.projectionInstance = zE(this.projection)),
                    this.projectionInstance
                }
                destroy() {
                    this.text.destroy(),
                    this.icon.destroy(),
                    this.hasDebugData() && this.destroyDebugData()
                }
                addToLineVertexArray(n, a) {
                    let u = this.lineVertexArray.length;
                    if (n.segment !== void 0)
                        for (let {x: f, y: g} of a)
                            this.lineVertexArray.emplaceBack(f, g);
                    return {
                        lineStartIndex: u,
                        lineLength: this.lineVertexArray.length - u
                    }
                }
                addSymbols(n, a, u, f, g, y, w, S, M, z, N, B, H, q) {
                    let Q = n.indexArray
                      , de = n.layoutVertexArray
                      , Me = n.globeExtVertexArray
                      , Pe = n.segments.prepareSegment(4 * a.length, de, Q, this.canOverlap ? y.sortKey : void 0)
                      , we = this.glyphOffsetArray.length
                      , Le = Pe.vertexLength
                      , Ue = this.allowVerticalPlacement && w === $s.vertical ? Math.PI / 2 : 0
                      , Ne = y.text && y.text.sections;
                    for (let it = 0; it < a.length; it++) {
                        let {tl: _t, tr: Ot, bl: dt, br: yt, tex: Tt, pixelOffsetTL: Lt, pixelOffsetBR: Nt, minFontScaleX: mt, minFontScaleY: qt, glyphOffset: Sn, isSDF: en, sectionIndex: hn} = a[it]
                          , Yt = Pe.vertexLength
                          , Cn = Sn[1];
                        if (O_(de, M.x, M.y, _t.x, Cn + _t.y, Tt.x, Tt.y, u, en, Lt.x, Lt.y, mt, qt),
                        O_(de, M.x, M.y, Ot.x, Cn + Ot.y, Tt.x + Tt.w, Tt.y, u, en, Nt.x, Lt.y, mt, qt),
                        O_(de, M.x, M.y, dt.x, Cn + dt.y, Tt.x, Tt.y + Tt.h, u, en, Lt.x, Nt.y, mt, qt),
                        O_(de, M.x, M.y, yt.x, Cn + yt.y, Tt.x + Tt.w, Tt.y + Tt.h, u, en, Nt.x, Nt.y, mt, qt),
                        S) {
                            let {x: ei, y: Jn, z: Kn} = S.anchor
                              , [Rn,vi,Bn] = S.up;
                            N_(Me, ei, Jn, Kn, Rn, vi, Bn),
                            N_(Me, ei, Jn, Kn, Rn, vi, Bn),
                            N_(Me, ei, Jn, Kn, Rn, vi, Bn),
                            N_(Me, ei, Jn, Kn, Rn, vi, Bn),
                            F_(n.dynamicLayoutVertexArray, ei, Jn, Kn, Ue)
                        } else
                            F_(n.dynamicLayoutVertexArray, M.x, M.y, M.z, Ue);
                        Q.emplaceBack(Yt, Yt + 1, Yt + 2),
                        Q.emplaceBack(Yt + 1, Yt + 2, Yt + 3),
                        Pe.vertexLength += 4,
                        Pe.primitiveLength += 2,
                        this.glyphOffsetArray.emplaceBack(Sn[0]),
                        it !== a.length - 1 && hn === a[it + 1].sectionIndex || n.programConfigurations.populatePaintArrays(de.length, y, y.index, {}, H, q, Ne && Ne[hn])
                    }
                    let at = S ? S.anchor : M;
                    n.placedSymbolArray.emplaceBack(at.x, at.y, at.z, M.x, M.y, we, this.glyphOffsetArray.length - we, Le, z, N, M.segment, u ? u[0] : 0, u ? u[1] : 0, f[0], f[1], w, 0, !1, 0, B, 0)
                }
                _commitLayoutVertex(n, a, u, f, g, y, w) {
                    n.emplaceBack(a, u, f, g, y, Math.round(w.x), Math.round(w.y))
                }
                _addCollisionDebugVertices(n, a, u, f, g, y, w) {
                    let S = u.segments.prepareSegment(4, u.layoutVertexArray, u.indexArray)
                      , M = S.vertexLength
                      , z = w.tileAnchorX
                      , N = w.tileAnchorY;
                    for (let H = 0; H < 4; H++)
                        u.collisionVertexArray.emplaceBack(0, 0, 0, 0);
                    u.collisionVertexArrayExt.emplaceBack(a, -n.padding, -n.padding),
                    u.collisionVertexArrayExt.emplaceBack(a, n.padding, -n.padding),
                    u.collisionVertexArrayExt.emplaceBack(a, n.padding, n.padding),
                    u.collisionVertexArrayExt.emplaceBack(a, -n.padding, n.padding),
                    this._commitLayoutVertex(u.layoutVertexArray, f, g, y, z, N, new W(n.x1,n.y1)),
                    this._commitLayoutVertex(u.layoutVertexArray, f, g, y, z, N, new W(n.x2,n.y1)),
                    this._commitLayoutVertex(u.layoutVertexArray, f, g, y, z, N, new W(n.x2,n.y2)),
                    this._commitLayoutVertex(u.layoutVertexArray, f, g, y, z, N, new W(n.x1,n.y2)),
                    S.vertexLength += 4;
                    let B = u.indexArray;
                    B.emplaceBack(M, M + 1),
                    B.emplaceBack(M + 1, M + 2),
                    B.emplaceBack(M + 2, M + 3),
                    B.emplaceBack(M + 3, M),
                    S.primitiveLength += 4
                }
                _addTextDebugCollisionBoxes(n, a, u, f, g, y) {
                    for (let w = f; w < g; w++) {
                        let S = u.get(w)
                          , M = this.getSymbolInstanceTextSize(n, y, a, w);
                        this._addCollisionDebugVertices(S, M, this.textCollisionBox, S.projectedAnchorX, S.projectedAnchorY, S.projectedAnchorZ, y)
                    }
                }
                _addIconDebugCollisionBoxes(n, a, u, f, g, y) {
                    for (let w = f; w < g; w++) {
                        let S = u.get(w)
                          , M = this.getSymbolInstanceIconSize(n, a, y.placedIconSymbolIndex);
                        this._addCollisionDebugVertices(S, M, this.iconCollisionBox, S.projectedAnchorX, S.projectedAnchorY, S.projectedAnchorZ, y)
                    }
                }
                generateCollisionDebugBuffers(n, a) {
                    this.hasDebugData() && this.destroyDebugData(),
                    this.textCollisionBox = new ev(Ji,iE.members,Qo),
                    this.iconCollisionBox = new ev(Ji,iE.members,Qo);
                    let u = rd(this.iconSizeData, n)
                      , f = rd(this.textSizeData, n);
                    for (let g = 0; g < this.symbolInstances.length; g++) {
                        let y = this.symbolInstances.get(g);
                        this._addTextDebugCollisionBoxes(f, n, a, y.textBoxStartIndex, y.textBoxEndIndex, y),
                        this._addTextDebugCollisionBoxes(f, n, a, y.verticalTextBoxStartIndex, y.verticalTextBoxEndIndex, y),
                        this._addIconDebugCollisionBoxes(u, n, a, y.iconBoxStartIndex, y.iconBoxEndIndex, y),
                        this._addIconDebugCollisionBoxes(u, n, a, y.verticalIconBoxStartIndex, y.verticalIconBoxEndIndex, y)
                    }
                }
                getSymbolInstanceTextSize(n, a, u, f) {
                    let g = this.text.placedSymbolArray.get(a.rightJustifiedTextSymbolIndex >= 0 ? a.rightJustifiedTextSymbolIndex : a.centerJustifiedTextSymbolIndex >= 0 ? a.centerJustifiedTextSymbolIndex : a.leftJustifiedTextSymbolIndex >= 0 ? a.leftJustifiedTextSymbolIndex : a.verticalPlacedTextSymbolIndex >= 0 ? a.verticalPlacedTextSymbolIndex : f)
                      , y = M_(this.textSizeData, n, g) / Kr;
                    return this.tilePixelRatio * y
                }
                getSymbolInstanceIconSize(n, a, u) {
                    let f = this.icon.placedSymbolArray.get(u)
                      , g = M_(this.iconSizeData, n, f);
                    return this.tilePixelRatio * g
                }
                _commitDebugCollisionVertexUpdate(n, a, u) {
                    n.emplaceBack(a, -u, -u),
                    n.emplaceBack(a, u, -u),
                    n.emplaceBack(a, u, u),
                    n.emplaceBack(a, -u, u)
                }
                _updateTextDebugCollisionBoxes(n, a, u, f, g, y) {
                    for (let w = f; w < g; w++) {
                        let S = u.get(w)
                          , M = this.getSymbolInstanceTextSize(n, y, a, w);
                        this._commitDebugCollisionVertexUpdate(this.textCollisionBox.collisionVertexArrayExt, M, S.padding)
                    }
                }
                _updateIconDebugCollisionBoxes(n, a, u, f, g, y) {
                    for (let w = f; w < g; w++) {
                        let S = u.get(w)
                          , M = this.getSymbolInstanceIconSize(n, a, y);
                        this._commitDebugCollisionVertexUpdate(this.iconCollisionBox.collisionVertexArrayExt, M, S.padding)
                    }
                }
                updateCollisionDebugBuffers(n, a) {
                    if (!this.hasDebugData())
                        return;
                    this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexArrayExt.clear(),
                    this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexArrayExt.clear();
                    let u = rd(this.iconSizeData, n)
                      , f = rd(this.textSizeData, n);
                    for (let g = 0; g < this.symbolInstances.length; g++) {
                        let y = this.symbolInstances.get(g);
                        this._updateTextDebugCollisionBoxes(f, n, a, y.textBoxStartIndex, y.textBoxEndIndex, y),
                        this._updateTextDebugCollisionBoxes(f, n, a, y.verticalTextBoxStartIndex, y.verticalTextBoxEndIndex, y),
                        this._updateIconDebugCollisionBoxes(u, n, a, y.iconBoxStartIndex, y.iconBoxEndIndex, y.placedIconSymbolIndex),
                        this._updateIconDebugCollisionBoxes(u, n, a, y.verticalIconBoxStartIndex, y.verticalIconBoxEndIndex, y.placedIconSymbolIndex)
                    }
                    this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexBufferExt && this.textCollisionBox.collisionVertexBufferExt.updateData(this.textCollisionBox.collisionVertexArrayExt),
                    this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexBufferExt && this.iconCollisionBox.collisionVertexBufferExt.updateData(this.iconCollisionBox.collisionVertexArrayExt)
                }
                _deserializeCollisionBoxesForSymbol(n, a, u, f, g, y, w, S, M) {
                    let z = {};
                    if (a < u) {
                        let {x1: N, y1: B, x2: H, y2: q, padding: Q, projectedAnchorX: de, projectedAnchorY: Me, projectedAnchorZ: Pe, tileAnchorX: we, tileAnchorY: Le, featureIndex: Ue} = n.get(a);
                        z.textBox = {
                            x1: N,
                            y1: B,
                            x2: H,
                            y2: q,
                            padding: Q,
                            projectedAnchorX: de,
                            projectedAnchorY: Me,
                            projectedAnchorZ: Pe,
                            tileAnchorX: we,
                            tileAnchorY: Le
                        },
                        z.textFeatureIndex = Ue
                    }
                    if (f < g) {
                        let {x1: N, y1: B, x2: H, y2: q, padding: Q, projectedAnchorX: de, projectedAnchorY: Me, projectedAnchorZ: Pe, tileAnchorX: we, tileAnchorY: Le, featureIndex: Ue} = n.get(f);
                        z.verticalTextBox = {
                            x1: N,
                            y1: B,
                            x2: H,
                            y2: q,
                            padding: Q,
                            projectedAnchorX: de,
                            projectedAnchorY: Me,
                            projectedAnchorZ: Pe,
                            tileAnchorX: we,
                            tileAnchorY: Le
                        },
                        z.verticalTextFeatureIndex = Ue
                    }
                    if (y < w) {
                        let {x1: N, y1: B, x2: H, y2: q, padding: Q, projectedAnchorX: de, projectedAnchorY: Me, projectedAnchorZ: Pe, tileAnchorX: we, tileAnchorY: Le, featureIndex: Ue} = n.get(y);
                        z.iconBox = {
                            x1: N,
                            y1: B,
                            x2: H,
                            y2: q,
                            padding: Q,
                            projectedAnchorX: de,
                            projectedAnchorY: Me,
                            projectedAnchorZ: Pe,
                            tileAnchorX: we,
                            tileAnchorY: Le
                        },
                        z.iconFeatureIndex = Ue
                    }
                    if (S < M) {
                        let {x1: N, y1: B, x2: H, y2: q, padding: Q, projectedAnchorX: de, projectedAnchorY: Me, projectedAnchorZ: Pe, tileAnchorX: we, tileAnchorY: Le, featureIndex: Ue} = n.get(S);
                        z.verticalIconBox = {
                            x1: N,
                            y1: B,
                            x2: H,
                            y2: q,
                            padding: Q,
                            projectedAnchorX: de,
                            projectedAnchorY: Me,
                            projectedAnchorZ: Pe,
                            tileAnchorX: we,
                            tileAnchorY: Le
                        },
                        z.verticalIconFeatureIndex = Ue
                    }
                    return z
                }
                deserializeCollisionBoxes(n) {
                    this.collisionArrays = [];
                    for (let a = 0; a < this.symbolInstances.length; a++) {
                        let u = this.symbolInstances.get(a);
                        this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(n, u.textBoxStartIndex, u.textBoxEndIndex, u.verticalTextBoxStartIndex, u.verticalTextBoxEndIndex, u.iconBoxStartIndex, u.iconBoxEndIndex, u.verticalIconBoxStartIndex, u.verticalIconBoxEndIndex))
                    }
                }
                hasTextData() {
                    return this.text.segments.get().length > 0
                }
                hasIconData() {
                    return this.icon.segments.get().length > 0
                }
                hasDebugData() {
                    return this.textCollisionBox && this.iconCollisionBox
                }
                hasTextCollisionBoxData() {
                    return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0
                }
                hasIconCollisionBoxData() {
                    return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0
                }
                addIndicesForPlacedSymbol(n, a) {
                    let u = n.placedSymbolArray.get(a)
                      , f = u.vertexStartIndex + 4 * u.numGlyphs;
                    for (let g = u.vertexStartIndex; g < f; g += 4)
                        n.indexArray.emplaceBack(g, g + 1, g + 2),
                        n.indexArray.emplaceBack(g + 1, g + 2, g + 3)
                }
                getSortedSymbolIndexes(n) {
                    if (this.sortedAngle === n && this.symbolInstanceIndexes !== void 0)
                        return this.symbolInstanceIndexes;
                    let a = Math.sin(n)
                      , u = Math.cos(n)
                      , f = []
                      , g = []
                      , y = [];
                    for (let w = 0; w < this.symbolInstances.length; ++w) {
                        y.push(w);
                        let S = this.symbolInstances.get(w);
                        f.push(0 | Math.round(a * S.tileAnchorX + u * S.tileAnchorY)),
                        g.push(S.featureIndex)
                    }
                    return y.sort((w,S)=>f[w] - f[S] || g[S] - g[w]),
                    y
                }
                addToSortKeyRanges(n, a) {
                    let u = this.sortKeyRanges[this.sortKeyRanges.length - 1];
                    u && u.sortKey === a ? u.symbolInstanceEnd = n + 1 : this.sortKeyRanges.push({
                        sortKey: a,
                        symbolInstanceStart: n,
                        symbolInstanceEnd: n + 1
                    })
                }
                sortFeatures(n) {
                    if (this.sortFeaturesByY && this.sortedAngle !== n && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
                        this.symbolInstanceIndexes = this.getSortedSymbolIndexes(n),
                        this.sortedAngle = n,
                        this.text.indexArray.clear(),
                        this.icon.indexArray.clear(),
                        this.featureSortOrder = [];
                        for (let a of this.symbolInstanceIndexes) {
                            let u = this.symbolInstances.get(a);
                            this.featureSortOrder.push(u.featureIndex);
                            let {rightJustifiedTextSymbolIndex: f, centerJustifiedTextSymbolIndex: g, leftJustifiedTextSymbolIndex: y, verticalPlacedTextSymbolIndex: w, placedIconSymbolIndex: S, verticalPlacedIconSymbolIndex: M} = u;
                            f >= 0 && this.addIndicesForPlacedSymbol(this.text, f),
                            g >= 0 && g !== f && this.addIndicesForPlacedSymbol(this.text, g),
                            y >= 0 && y !== g && y !== f && this.addIndicesForPlacedSymbol(this.text, y),
                            w >= 0 && this.addIndicesForPlacedSymbol(this.text, w),
                            S >= 0 && this.addIndicesForPlacedSymbol(this.icon, S),
                            M >= 0 && this.addIndicesForPlacedSymbol(this.icon, M)
                        }
                        this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray),
                        this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray)
                    }
                }
            }
            cn(Bl, "SymbolBucket", {
                omit: ["layers", "collisionBoxArray", "features", "compareText"]
            }),
            Bl.MAX_GLYPHS = 65535,
            Bl.addDynamicAttributes = F_;
            let iR = new Pt({
                "symbol-placement": new Je(ht.layout_symbol["symbol-placement"]),
                "symbol-spacing": new Je(ht.layout_symbol["symbol-spacing"]),
                "symbol-avoid-edges": new Je(ht.layout_symbol["symbol-avoid-edges"]),
                "symbol-sort-key": new ct(ht.layout_symbol["symbol-sort-key"]),
                "symbol-z-order": new Je(ht.layout_symbol["symbol-z-order"]),
                "icon-allow-overlap": new Je(ht.layout_symbol["icon-allow-overlap"]),
                "icon-ignore-placement": new Je(ht.layout_symbol["icon-ignore-placement"]),
                "icon-optional": new Je(ht.layout_symbol["icon-optional"]),
                "icon-rotation-alignment": new Je(ht.layout_symbol["icon-rotation-alignment"]),
                "icon-size": new ct(ht.layout_symbol["icon-size"]),
                "icon-text-fit": new Je(ht.layout_symbol["icon-text-fit"]),
                "icon-text-fit-padding": new Je(ht.layout_symbol["icon-text-fit-padding"]),
                "icon-image": new ct(ht.layout_symbol["icon-image"]),
                "icon-rotate": new ct(ht.layout_symbol["icon-rotate"]),
                "icon-padding": new Je(ht.layout_symbol["icon-padding"]),
                "icon-keep-upright": new Je(ht.layout_symbol["icon-keep-upright"]),
                "icon-offset": new ct(ht.layout_symbol["icon-offset"]),
                "icon-anchor": new ct(ht.layout_symbol["icon-anchor"]),
                "icon-pitch-alignment": new Je(ht.layout_symbol["icon-pitch-alignment"]),
                "text-pitch-alignment": new Je(ht.layout_symbol["text-pitch-alignment"]),
                "text-rotation-alignment": new Je(ht.layout_symbol["text-rotation-alignment"]),
                "text-field": new ct(ht.layout_symbol["text-field"]),
                "text-font": new ct(ht.layout_symbol["text-font"]),
                "text-size": new ct(ht.layout_symbol["text-size"]),
                "text-max-width": new ct(ht.layout_symbol["text-max-width"]),
                "text-line-height": new ct(ht.layout_symbol["text-line-height"]),
                "text-letter-spacing": new ct(ht.layout_symbol["text-letter-spacing"]),
                "text-justify": new ct(ht.layout_symbol["text-justify"]),
                "text-radial-offset": new ct(ht.layout_symbol["text-radial-offset"]),
                "text-variable-anchor": new Je(ht.layout_symbol["text-variable-anchor"]),
                "text-anchor": new ct(ht.layout_symbol["text-anchor"]),
                "text-max-angle": new Je(ht.layout_symbol["text-max-angle"]),
                "text-writing-mode": new Je(ht.layout_symbol["text-writing-mode"]),
                "text-rotate": new ct(ht.layout_symbol["text-rotate"]),
                "text-padding": new Je(ht.layout_symbol["text-padding"]),
                "text-keep-upright": new Je(ht.layout_symbol["text-keep-upright"]),
                "text-transform": new ct(ht.layout_symbol["text-transform"]),
                "text-offset": new ct(ht.layout_symbol["text-offset"]),
                "text-allow-overlap": new Je(ht.layout_symbol["text-allow-overlap"]),
                "text-ignore-placement": new Je(ht.layout_symbol["text-ignore-placement"]),
                "text-optional": new Je(ht.layout_symbol["text-optional"])
            });
            var tv = {
                paint: new Pt({
                    "icon-opacity": new ct(ht.paint_symbol["icon-opacity"]),
                    "icon-color": new ct(ht.paint_symbol["icon-color"]),
                    "icon-halo-color": new ct(ht.paint_symbol["icon-halo-color"]),
                    "icon-halo-width": new ct(ht.paint_symbol["icon-halo-width"]),
                    "icon-halo-blur": new ct(ht.paint_symbol["icon-halo-blur"]),
                    "icon-translate": new Je(ht.paint_symbol["icon-translate"]),
                    "icon-translate-anchor": new Je(ht.paint_symbol["icon-translate-anchor"]),
                    "text-opacity": new ct(ht.paint_symbol["text-opacity"]),
                    "text-color": new ct(ht.paint_symbol["text-color"],{
                        runtimeType: lo,
                        getOverride: s=>s.textColor,
                        hasOverride: s=>!!s.textColor
                    }),
                    "text-halo-color": new ct(ht.paint_symbol["text-halo-color"]),
                    "text-halo-width": new ct(ht.paint_symbol["text-halo-width"]),
                    "text-halo-blur": new ct(ht.paint_symbol["text-halo-blur"]),
                    "text-translate": new Je(ht.paint_symbol["text-translate"]),
                    "text-translate-anchor": new Je(ht.paint_symbol["text-translate-anchor"])
                }),
                layout: iR
            };
            class OE {
                constructor(n) {
                    this.type = n.property.overrides ? n.property.overrides.runtimeType : Zo,
                    this.defaultValue = n
                }
                evaluate(n) {
                    if (n.formattedSection) {
                        let a = this.defaultValue.property.overrides;
                        if (a && a.hasOverride(n.formattedSection))
                            return a.getOverride(n.formattedSection)
                    }
                    return n.feature && n.featureState ? this.defaultValue.evaluate(n.feature, n.featureState) : this.defaultValue.property.specification.default
                }
                eachChild(n) {
                    this.defaultValue.isConstant() || n(this.defaultValue.value._styleExpression.expression)
                }
                outputDefined() {
                    return !1
                }
                serialize() {
                    return null
                }
            }
            cn(OE, "FormatSectionOverride", {
                omit: ["defaultValue"]
            });
            class B_ extends Ro {
                constructor(n) {
                    super(n, tv)
                }
                recalculate(n, a) {
                    super.recalculate(n, a),
                    this.layout.get("icon-rotation-alignment") === "auto" && (this.layout._values["icon-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"),
                    this.layout.get("text-rotation-alignment") === "auto" && (this.layout._values["text-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"),
                    this.layout.get("text-pitch-alignment") === "auto" && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment")),
                    this.layout.get("icon-pitch-alignment") === "auto" && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment"));
                    let u = this.layout.get("text-writing-mode");
                    if (u) {
                        let f = [];
                        for (let g of u)
                            f.indexOf(g) < 0 && f.push(g);
                        this.layout._values["text-writing-mode"] = f
                    } else
                        this.layout._values["text-writing-mode"] = this.layout.get("symbol-placement") === "point" ? ["horizontal"] : ["horizontal", "vertical"];
                    this._setPaintOverrides()
                }
                getValueAndResolveTokens(n, a, u, f) {
                    let g = this.layout.get(n).evaluate(a, {}, u, f)
                      , y = this._unevaluatedLayout._values[n];
                    return y.isDataDriven() || Sl(y.value) || !g ? g : function(w, S) {
                        return S.replace(/{([^{}]+)}/g, (M,z)=>z in w ? String(w[z]) : "")
                    }(a.properties, g)
                }
                createBucket(n) {
                    return new Bl(n)
                }
                queryRadius() {
                    return 0
                }
                queryIntersectsFeature() {
                    return !1
                }
                _setPaintOverrides() {
                    for (let n of tv.paint.overridableProperties) {
                        if (!B_.hasPaintOverride(this.layout, n))
                            continue;
                        let a = this.paint.get(n)
                          , u = new OE(a)
                          , f = new Ph(u,a.property.specification)
                          , g = null;
                        g = a.value.kind === "constant" || a.value.kind === "source" ? new kh("source",f) : new Ra("composite",f,a.value.zoomStops,a.value._interpolationType),
                        this.paint._values[n] = new Dt(a.property,g,a.parameters)
                    }
                }
                _handleOverridablePaintPropertyUpdate(n, a, u) {
                    return !(!this.layout || a.isDataDriven() || u.isDataDriven()) && B_.hasPaintOverride(this.layout, n)
                }
                static hasPaintOverride(n, a) {
                    let u = n.get("text-field")
                      , f = tv.paint.properties[a]
                      , g = !1
                      , y = w=>{
                        for (let S of w)
                            if (f.overrides && f.overrides.hasOverride(S))
                                return void (g = !0)
                    }
                    ;
                    if (u.value.kind === "constant" && u.value.value instanceof ms)
                        y(u.value.value.sections);
                    else if (u.value.kind === "source") {
                        let w = M=>{
                            g || (M instanceof Pc && gr(M.value) === pl ? y(M.value.sections) : M instanceof kc ? y(M.sections) : M.eachChild(w))
                        }
                          , S = u.value;
                        S._styleExpression && w(S._styleExpression.expression)
                    }
                    return g
                }
                getProgramConfiguration(n) {
                    return new zl(this,n)
                }
            }
            var rR = {
                paint: new Pt({
                    "background-color": new Je(ht.paint_background["background-color"]),
                    "background-pattern": new Je(ht.paint_background["background-pattern"]),
                    "background-opacity": new Je(ht.paint_background["background-opacity"])
                })
            }
              , sR = {
                paint: new Pt({
                    "raster-opacity": new Je(ht.paint_raster["raster-opacity"]),
                    "raster-hue-rotate": new Je(ht.paint_raster["raster-hue-rotate"]),
                    "raster-brightness-min": new Je(ht.paint_raster["raster-brightness-min"]),
                    "raster-brightness-max": new Je(ht.paint_raster["raster-brightness-max"]),
                    "raster-saturation": new Je(ht.paint_raster["raster-saturation"]),
                    "raster-contrast": new Je(ht.paint_raster["raster-contrast"]),
                    "raster-resampling": new Je(ht.paint_raster["raster-resampling"]),
                    "raster-fade-duration": new Je(ht.paint_raster["raster-fade-duration"])
                })
            };
            class oR extends Ro {
                constructor(n) {
                    super(n, {}),
                    this.implementation = n
                }
                is3D() {
                    return this.implementation.renderingMode === "3d"
                }
                hasOffscreenPass() {
                    return this.implementation.prerender !== void 0
                }
                isLayerDraped() {
                    return this.implementation.renderToTile !== void 0
                }
                shouldRedrape() {
                    return !!this.implementation.shouldRerenderTiles && this.implementation.shouldRerenderTiles()
                }
                recalculate() {}
                updateTransitions() {}
                hasTransition() {
                    return !1
                }
                serialize() {}
                onAdd(n) {
                    this.implementation.onAdd && this.implementation.onAdd(n, n.painter.context.gl)
                }
                onRemove(n) {
                    this.implementation.onRemove && this.implementation.onRemove(n, n.painter.context.gl)
                }
            }
            var aR = {
                paint: new Pt({
                    "sky-type": new Je(ht.paint_sky["sky-type"]),
                    "sky-atmosphere-sun": new Je(ht.paint_sky["sky-atmosphere-sun"]),
                    "sky-atmosphere-sun-intensity": new Je(ht.paint_sky["sky-atmosphere-sun-intensity"]),
                    "sky-gradient-center": new Je(ht.paint_sky["sky-gradient-center"]),
                    "sky-gradient-radius": new Je(ht.paint_sky["sky-gradient-radius"]),
                    "sky-gradient": new At(ht.paint_sky["sky-gradient"]),
                    "sky-atmosphere-halo-color": new Je(ht.paint_sky["sky-atmosphere-halo-color"]),
                    "sky-atmosphere-color": new Je(ht.paint_sky["sky-atmosphere-color"]),
                    "sky-opacity": new Je(ht.paint_sky["sky-opacity"])
                })
            };
            function nv(s, n, a) {
                let u = [0, 0, 1]
                  , f = sT([]);
                return aT(f, f, a ? -oe(s) + Math.PI : oe(s)),
                oT(f, f, -oe(n)),
                tT(u, u, f),
                _s(u, u)
            }
            let lR = {
                circle: class extends Ro {
                    constructor(s) {
                        super(s, xD)
                    }
                    createBucket(s) {
                        return new Lx(s)
                    }
                    queryRadius(s) {
                        let n = s;
                        return Qh("circle-radius", this, n) + Qh("circle-stroke-width", this, n) + g_(this.paint.get("circle-translate"))
                    }
                    queryIntersectsFeature(s, n, a, u, f, g, y, w) {
                        let S = IT(this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), g.angle, s.pixelToTileUnitsFactor)
                          , M = this.paint.get("circle-radius").evaluate(n, a) + this.paint.get("circle-stroke-width").evaluate(n, a);
                        return CT(s, u, g, y, w, this.paint.get("circle-pitch-alignment") === "map", this.paint.get("circle-pitch-scale") === "map", S, M)
                    }
                    getProgramIds() {
                        return ["circle"]
                    }
                    getProgramConfiguration(s) {
                        return new zl(this,s)
                    }
                }
                ,
                heatmap: class extends Ro {
                    createBucket(s) {
                        return new LT(s)
                    }
                    constructor(s) {
                        super(s, TD),
                        this._updateColorRamp()
                    }
                    _handleSpecialPaintPropertyUpdate(s) {
                        s === "heatmap-color" && this._updateColorRamp()
                    }
                    _updateColorRamp() {
                        this.colorRamp = zx({
                            expression: this._transitionablePaint._values["heatmap-color"].value.expression,
                            evaluationKey: "heatmapDensity",
                            image: this.colorRamp
                        }),
                        this.colorRampTexture = null
                    }
                    resize() {
                        this.heatmapFbo && (this.heatmapFbo.destroy(),
                        this.heatmapFbo = null)
                    }
                    queryRadius(s) {
                        return Qh("heatmap-radius", this, s)
                    }
                    queryIntersectsFeature(s, n, a, u, f, g, y, w) {
                        let S = this.paint.get("heatmap-radius").evaluate(n, a);
                        return CT(s, u, g, y, w, !0, !0, new W(0,0), S)
                    }
                    hasOffscreenPass() {
                        return this.paint.get("heatmap-opacity") !== 0 && this.visibility !== "none"
                    }
                    getProgramIds() {
                        return ["heatmap", "heatmapTexture"]
                    }
                    getProgramConfiguration(s) {
                        return new zl(this,s)
                    }
                }
                ,
                hillshade: class extends Ro {
                    constructor(s) {
                        super(s, ED)
                    }
                    hasOffscreenPass() {
                        return this.paint.get("hillshade-exaggeration") !== 0 && this.visibility !== "none"
                    }
                    getProgramIds() {
                        return ["hillshade", "hillshadePrepare"]
                    }
                }
                ,
                fill: class extends Ro {
                    constructor(s) {
                        super(s, UD)
                    }
                    getProgramIds() {
                        let s = this.paint.get("fill-pattern")
                          , n = s && s.constantOr(1)
                          , a = [n ? "fillPattern" : "fill"];
                        return this.paint.get("fill-antialias") && a.push(n && !this.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline"),
                        a
                    }
                    getProgramConfiguration(s) {
                        return new zl(this,s)
                    }
                    recalculate(s, n) {
                        super.recalculate(s, n);
                        let a = this.paint._values["fill-outline-color"];
                        a.value.kind === "constant" && a.value.value === void 0 && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"])
                    }
                    createBucket(s) {
                        return new b_(s)
                    }
                    queryRadius() {
                        return g_(this.paint.get("fill-translate"))
                    }
                    queryIntersectsFeature(s, n, a, u, f, g) {
                        return !s.queryGeometry.isAboveHorizon && TT(MT(s.tilespaceGeometry, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), g.angle, s.pixelToTileUnitsFactor), u)
                    }
                    isTileClipped() {
                        return !0
                    }
                }
                ,
                "fill-extrusion": class extends Ro {
                    constructor(s) {
                        super(s, nL)
                    }
                    createBucket(s) {
                        return new vp(s)
                    }
                    queryRadius() {
                        return g_(this.paint.get("fill-extrusion-translate"))
                    }
                    is3D() {
                        return !0
                    }
                    getProgramIds() {
                        return [this.paint.get("fill-extrusion-pattern").constantOr(1) ? "fillExtrusionPattern" : "fillExtrusion"]
                    }
                    getProgramConfiguration(s) {
                        return new zl(this,s)
                    }
                    queryIntersectsFeature(s, n, a, u, f, g, y, w, S) {
                        let M = IT(this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), g.angle, s.pixelToTileUnitsFactor)
                          , z = this.paint.get("fill-extrusion-height").evaluate(n, a)
                          , N = this.paint.get("fill-extrusion-base").evaluate(n, a)
                          , B = [0, 0]
                          , H = w && g.elevation
                          , q = g.elevation ? g.elevation.exaggeration() : 1
                          , Q = s.tile.getBucket(this);
                        if (H && Q instanceof vp) {
                            let Le = Q.centroidVertexArray
                              , Ue = S + 1;
                            Ue < Le.length && (B[0] = Le.geta_centroid_pos0(Ue),
                            B[1] = Le.geta_centroid_pos1(Ue))
                        }
                        if (B[0] === 0 && B[1] === 1)
                            return !1;
                        g.projection.name === "globe" && (u = KT([u], [new W(0,0), new W(kn,kn)], s.tileID.canonical).map(Le=>Le.polygon).flat());
                        let de = H ? w : null
                          , [Me,Pe] = function(Le, Ue, Ne, at, it, _t, Ot, dt, yt, Tt, Lt) {
                            return Le.projection.name === "globe" ? function(Nt, mt, qt, Sn, en, hn, Yt, Cn, ei, Jn, Kn) {
                                let Rn = []
                                  , vi = []
                                  , Bn = Nt.projection.upVectorScale(Kn, Nt.center.lat, Nt.worldSize).metersToTile
                                  , ti = [0, 0, 0, 1]
                                  , Ei = [0, 0, 0, 1]
                                  , Ni = (Fi,Hi,$i,Lr)=>{
                                    Fi[0] = Hi,
                                    Fi[1] = $i,
                                    Fi[2] = Lr,
                                    Fi[3] = 1
                                }
                                  , ki = qT();
                                qt > 0 && (qt += ki),
                                Sn += ki;
                                for (let Fi of mt) {
                                    let Hi = []
                                      , $i = [];
                                    for (let Lr of Fi) {
                                        let bi = Lr.x + en.x
                                          , _r = Lr.y + en.y
                                          , hr = Nt.projection.projectTilePoint(bi, _r, Kn)
                                          , ci = Nt.projection.upVector(Kn, Lr.x, Lr.y)
                                          , Xi = qt
                                          , br = Sn;
                                        if (Yt) {
                                            let Si = QT(bi, _r, qt, Sn, Yt, Cn, ei, Jn);
                                            Xi += Si.base,
                                            br += Si.top
                                        }
                                        qt !== 0 ? Ni(ti, hr.x + ci[0] * Bn * Xi, hr.y + ci[1] * Bn * Xi, hr.z + ci[2] * Bn * Xi) : Ni(ti, hr.x, hr.y, hr.z),
                                        Ni(Ei, hr.x + ci[0] * Bn * br, hr.y + ci[1] * Bn * br, hr.z + ci[2] * Bn * br),
                                        ir(ti, ti, hn),
                                        ir(Ei, Ei, hn),
                                        Hi.push(new id(ti[0],ti[1],ti[2])),
                                        $i.push(new id(Ei[0],Ei[1],Ei[2]))
                                    }
                                    Rn.push(Hi),
                                    vi.push($i)
                                }
                                return [Rn, vi]
                            }(Le, Ue, Ne, at, it, _t, Ot, dt, yt, Tt, Lt) : Ot ? function(Nt, mt, qt, Sn, en, hn, Yt, Cn, ei) {
                                let Jn = []
                                  , Kn = []
                                  , Rn = [0, 0, 0, 1];
                                for (let vi of Nt) {
                                    let Bn = []
                                      , ti = [];
                                    for (let Ei of vi) {
                                        let Ni = Ei.x + Sn.x
                                          , ki = Ei.y + Sn.y
                                          , Fi = QT(Ni, ki, mt, qt, hn, Yt, Cn, ei);
                                        Rn[0] = Ni,
                                        Rn[1] = ki,
                                        Rn[2] = Fi.base,
                                        Rn[3] = 1,
                                        cu(Rn, Rn, en),
                                        Rn[3] = Math.max(Rn[3], 1e-5);
                                        let Hi = new id(Rn[0] / Rn[3],Rn[1] / Rn[3],Rn[2] / Rn[3]);
                                        Rn[0] = Ni,
                                        Rn[1] = ki,
                                        Rn[2] = Fi.top,
                                        Rn[3] = 1,
                                        cu(Rn, Rn, en),
                                        Rn[3] = Math.max(Rn[3], 1e-5);
                                        let $i = new id(Rn[0] / Rn[3],Rn[1] / Rn[3],Rn[2] / Rn[3]);
                                        Bn.push(Hi),
                                        ti.push($i)
                                    }
                                    Jn.push(Bn),
                                    Kn.push(ti)
                                }
                                return [Jn, Kn]
                            }(Ue, Ne, at, it, _t, Ot, dt, yt, Tt) : function(Nt, mt, qt, Sn, en) {
                                let hn = []
                                  , Yt = []
                                  , Cn = en[8] * mt
                                  , ei = en[9] * mt
                                  , Jn = en[10] * mt
                                  , Kn = en[11] * mt
                                  , Rn = en[8] * qt
                                  , vi = en[9] * qt
                                  , Bn = en[10] * qt
                                  , ti = en[11] * qt;
                                for (let Ei of Nt) {
                                    let Ni = []
                                      , ki = [];
                                    for (let Fi of Ei) {
                                        let Hi = Fi.x + Sn.x
                                          , $i = Fi.y + Sn.y
                                          , Lr = en[0] * Hi + en[4] * $i + en[12]
                                          , bi = en[1] * Hi + en[5] * $i + en[13]
                                          , _r = en[2] * Hi + en[6] * $i + en[14]
                                          , hr = en[3] * Hi + en[7] * $i + en[15]
                                          , ci = Lr + Cn
                                          , Xi = bi + ei
                                          , br = _r + Jn
                                          , Si = Math.max(hr + Kn, 1e-5)
                                          , rr = Lr + Rn
                                          , cs = bi + vi
                                          , Rr = _r + Bn
                                          , Pr = Math.max(hr + ti, 1e-5);
                                        Ni.push(new id(ci / Si,Xi / Si,br / Si)),
                                        ki.push(new id(rr / Pr,cs / Pr,Rr / Pr))
                                    }
                                    hn.push(Ni),
                                    Yt.push(ki)
                                }
                                return [hn, Yt]
                            }(Ue, Ne, at, it, _t)
                        }(g, u, N, z, M, y, de, B, q, g.center.lat, s.tileID.canonical)
                          , we = s.queryGeometry;
                        return function(Le, Ue, Ne) {
                            let at = 1 / 0;
                            TT(Ne, Ue) && (at = $T(Ne, Ue[0]));
                            for (let it = 0; it < Ue.length; it++) {
                                let _t = Ue[it]
                                  , Ot = Le[it];
                                for (let dt = 0; dt < _t.length - 1; dt++) {
                                    let yt = _t[dt]
                                      , Tt = [yt, _t[dt + 1], Ot[dt + 1], Ot[dt], yt];
                                    wT(Ne, Tt) && (at = Math.min(at, $T(Ne, Tt)))
                                }
                            }
                            return at !== 1 / 0 && at
                        }(Me, Pe, we.isPointQuery() ? we.screenBounds : we.screenGeometry)
                    }
                }
                ,
                line: class extends Ro {
                    constructor(s) {
                        super(s, eE),
                        this.gradientVersion = 0
                    }
                    _handleSpecialPaintPropertyUpdate(s) {
                        if (s === "line-gradient") {
                            let n = this._transitionablePaint._values["line-gradient"].value.expression;
                            this.stepInterpolant = n._styleExpression && n._styleExpression.expression instanceof Af,
                            this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER
                        }
                    }
                    gradientExpression() {
                        return this._transitionablePaint._values["line-gradient"].value.expression
                    }
                    widthExpression() {
                        return this._transitionablePaint._values["line-width"].value.expression
                    }
                    recalculate(s, n) {
                        super.recalculate(s, n),
                        this.paint._values["line-floorwidth"] = tE.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, s)
                    }
                    createBucket(s) {
                        return new A_(s)
                    }
                    getProgramIds() {
                        return [this.paint.get("line-pattern").constantOr(1) ? "linePattern" : "line"]
                    }
                    getProgramConfiguration(s) {
                        return new zl(this,s)
                    }
                    queryRadius(s) {
                        let n = s
                          , a = nE(Qh("line-width", this, n), Qh("line-gap-width", this, n))
                          , u = Qh("line-offset", this, n);
                        return a / 2 + Math.abs(u) + g_(this.paint.get("line-translate"))
                    }
                    queryIntersectsFeature(s, n, a, u, f, g) {
                        if (s.queryGeometry.isAboveHorizon)
                            return !1;
                        let y = MT(s.tilespaceGeometry, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), g.angle, s.pixelToTileUnitsFactor)
                          , w = s.pixelToTileUnitsFactor / 2 * nE(this.paint.get("line-width").evaluate(n, a), this.paint.get("line-gap-width").evaluate(n, a))
                          , S = this.paint.get("line-offset").evaluate(n, a);
                        return S && (u = function(M, z) {
                            let N = []
                              , B = new W(0,0);
                            for (let H = 0; H < M.length; H++) {
                                let q = M[H]
                                  , Q = [];
                                for (let de = 0; de < q.length; de++) {
                                    let Me = q[de - 1]
                                      , Pe = q[de]
                                      , we = q[de + 1]
                                      , Le = de === 0 ? B : Pe.sub(Me)._unit()._perp()
                                      , Ue = de === q.length - 1 ? B : we.sub(Pe)._unit()._perp()
                                      , Ne = Le._add(Ue)._unit();
                                    Ne._mult(1 / (Ne.x * Ue.x + Ne.y * Ue.y)),
                                    Q.push(Ne._mult(z)._add(Pe))
                                }
                                N.push(Q)
                            }
                            return N
                        }(u, S * s.pixelToTileUnitsFactor)),
                        function(M, z, N) {
                            for (let B = 0; B < z.length; B++) {
                                let H = z[B];
                                if (M.length >= 3) {
                                    for (let q = 0; q < H.length; q++)
                                        if (fu(M, H[q]))
                                            return !0
                                }
                                if (mD(M, H, N))
                                    return !0
                            }
                            return !1
                        }(y, u, w)
                    }
                    isTileClipped() {
                        return !0
                    }
                }
                ,
                symbol: B_,
                background: class extends Ro {
                    constructor(s) {
                        super(s, rR)
                    }
                    getProgramIds() {
                        return [this.paint.get("background-pattern") ? "backgroundPattern" : "background"]
                    }
                }
                ,
                raster: class extends Ro {
                    constructor(s) {
                        super(s, sR)
                    }
                    getProgramIds() {
                        return ["raster"]
                    }
                }
                ,
                sky: class extends Ro {
                    constructor(s) {
                        super(s, aR),
                        this._updateColorRamp()
                    }
                    _handleSpecialPaintPropertyUpdate(s) {
                        s === "sky-gradient" ? this._updateColorRamp() : s !== "sky-atmosphere-sun" && s !== "sky-atmosphere-halo-color" && s !== "sky-atmosphere-color" && s !== "sky-atmosphere-sun-intensity" || (this._skyboxInvalidated = !0)
                    }
                    _updateColorRamp() {
                        this.colorRamp = zx({
                            expression: this._transitionablePaint._values["sky-gradient"].value.expression,
                            evaluationKey: "skyRadialProgress"
                        }),
                        this.colorRampTexture && (this.colorRampTexture.destroy(),
                        this.colorRampTexture = null)
                    }
                    needsSkyboxCapture(s) {
                        if (this._skyboxInvalidated || !this.skyboxTexture || !this.skyboxGeometry)
                            return !0;
                        if (!this.paint.get("sky-atmosphere-sun")) {
                            let n = s.style.light.properties.get("position");
                            return this._lightPosition.azimuthal !== n.azimuthal || this._lightPosition.polar !== n.polar
                        }
                        return !1
                    }
                    getCenter(s, n) {
                        if (this.paint.get("sky-type") === "atmosphere") {
                            let u = this.paint.get("sky-atmosphere-sun")
                              , f = !u
                              , g = s.style.light
                              , y = g.properties.get("position");
                            return f && g.properties.get("anchor") === "viewport" && ut("The sun direction is attached to a light with viewport anchor, lighting may behave unexpectedly."),
                            f ? nv(y.azimuthal, 90 - y.polar, n) : nv(u[0], 90 - u[1], n)
                        }
                        let a = this.paint.get("sky-gradient-center");
                        return nv(a[0], 90 - a[1], n)
                    }
                    is3D() {
                        return !1
                    }
                    isSky() {
                        return !0
                    }
                    markSkyboxValid(s) {
                        this._skyboxInvalidated = !1,
                        this._lightPosition = s.style.light.properties.get("position")
                    }
                    hasOffscreenPass() {
                        return !0
                    }
                    getProgramIds() {
                        let s = this.paint.get("sky-type");
                        return s === "atmosphere" ? ["skyboxCapture", "skybox"] : s === "gradient" ? ["skyboxGradient"] : null
                    }
                }
            };
            class Lp {
                constructor(n, a, u, f) {
                    this.context = n,
                    this.format = u,
                    this.texture = n.gl.createTexture(),
                    this.update(a, f)
                }
                update(n, a, u) {
                    let {width: f, height: g} = n
                      , {context: y} = this
                      , {gl: w} = y
                      , {HTMLImageElement: S, HTMLCanvasElement: M, HTMLVideoElement: z, ImageData: N, ImageBitmap: B} = v;
                    if (w.bindTexture(w.TEXTURE_2D, this.texture),
                    y.pixelStoreUnpackFlipY.set(!1),
                    y.pixelStoreUnpack.set(1),
                    y.pixelStoreUnpackPremultiplyAlpha.set(this.format === w.RGBA && (!a || a.premultiply !== !1)),
                    u || this.size && this.size[0] === f && this.size[1] === g) {
                        let {x: H, y: q} = u || {
                            x: 0,
                            y: 0
                        };
                        n instanceof S || n instanceof M || n instanceof z || n instanceof N || B && n instanceof B ? w.texSubImage2D(w.TEXTURE_2D, 0, H, q, w.RGBA, w.UNSIGNED_BYTE, n) : w.texSubImage2D(w.TEXTURE_2D, 0, H, q, f, g, w.RGBA, w.UNSIGNED_BYTE, n.data)
                    } else
                        this.size = [f, g],
                        n instanceof S || n instanceof M || n instanceof z || n instanceof N || B && n instanceof B ? w.texImage2D(w.TEXTURE_2D, 0, this.format, this.format, w.UNSIGNED_BYTE, n) : w.texImage2D(w.TEXTURE_2D, 0, this.format, f, g, 0, this.format, w.UNSIGNED_BYTE, n.data);
                    this.useMipmap = Boolean(a && a.useMipmap && this.isSizePowerOfTwo()),
                    this.useMipmap && w.generateMipmap(w.TEXTURE_2D)
                }
                bind(n, a) {
                    let {context: u} = this
                      , {gl: f} = u;
                    f.bindTexture(f.TEXTURE_2D, this.texture),
                    n !== this.filter && (f.texParameteri(f.TEXTURE_2D, f.TEXTURE_MAG_FILTER, n),
                    f.texParameteri(f.TEXTURE_2D, f.TEXTURE_MIN_FILTER, this.useMipmap ? n === f.NEAREST ? f.NEAREST_MIPMAP_NEAREST : f.LINEAR_MIPMAP_NEAREST : n),
                    this.filter = n),
                    a !== this.wrap && (f.texParameteri(f.TEXTURE_2D, f.TEXTURE_WRAP_S, a),
                    f.texParameteri(f.TEXTURE_2D, f.TEXTURE_WRAP_T, a),
                    this.wrap = a)
                }
                isSizePowerOfTwo() {
                    return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0
                }
                destroy() {
                    let {gl: n} = this.context;
                    n.deleteTexture(this.texture),
                    this.texture = null
                }
            }
            class cR {
                constructor(n) {
                    this._callback = n,
                    this._triggered = !1,
                    typeof MessageChannel != "undefined" && (this._channel = new MessageChannel,
                    this._channel.port2.onmessage = ()=>{
                        this._triggered = !1,
                        this._callback()
                    }
                    )
                }
                trigger() {
                    this._triggered || (this._triggered = !0,
                    this._channel ? this._channel.port1.postMessage(!0) : setTimeout(()=>{
                        this._triggered = !1,
                        this._callback()
                    }
                    , 0))
                }
                remove() {
                    this._channel = void 0,
                    this._callback = ()=>{}
                }
            }
            class uR {
                constructor() {
                    this.tasks = {},
                    this.taskQueue = [],
                    gt(["process"], this),
                    this.invoker = new cR(this.process),
                    this.nextId = 0
                }
                add(n, a) {
                    let u = this.nextId++
                      , f = function({type: g, isSymbolTile: y, zoom: w}) {
                        return w = w || 0,
                        g === "message" ? 0 : g !== "maybePrepare" || y ? g !== "parseTile" || y ? g === "parseTile" && y ? 300 - w : g === "maybePrepare" && y ? 400 - w : 500 : 200 - w : 100 - w
                    }(a);
                    if (f === 0) {
                        on();
                        try {
                            n()
                        } finally {}
                        return {
                            cancel: ()=>{}
                        }
                    }
                    return this.tasks[u] = {
                        fn: n,
                        metadata: a,
                        priority: f,
                        id: u
                    },
                    this.taskQueue.push(u),
                    this.invoker.trigger(),
                    {
                        cancel: ()=>{
                            delete this.tasks[u]
                        }
                    }
                }
                process() {
                    on();
                    try {
                        if (this.taskQueue = this.taskQueue.filter(u=>!!this.tasks[u]),
                        !this.taskQueue.length)
                            return;
                        let n = this.pick();
                        if (n === null)
                            return;
                        let a = this.tasks[n];
                        if (delete this.tasks[n],
                        this.taskQueue.length && this.invoker.trigger(),
                        !a)
                            return;
                        a.fn()
                    } finally {}
                }
                pick() {
                    let n = null
                      , a = 1 / 0;
                    for (let f = 0; f < this.taskQueue.length; f++) {
                        let g = this.tasks[this.taskQueue[f]];
                        g.priority < a && (a = g.priority,
                        n = f)
                    }
                    if (n === null)
                        return null;
                    let u = this.taskQueue[n];
                    return this.taskQueue.splice(n, 1),
                    u
                }
                remove() {
                    this.invoker.remove()
                }
            }
            class NE {
                constructor(n) {
                    this._stringToNumber = {},
                    this._numberToString = [];
                    for (let a = 0; a < n.length; a++) {
                        let u = n[a];
                        this._stringToNumber[u] = a,
                        this._numberToString[a] = u
                    }
                }
                encode(n) {
                    return this._stringToNumber[n]
                }
                decode(n) {
                    return this._numberToString[n]
                }
            }
            let hR = ["tile", "layer", "source", "sourceLayer", "state"];
            class FE {
                constructor(n, a, u, f, g) {
                    this.type = "Feature",
                    this._vectorTileFeature = n,
                    this._z = a,
                    this._x = u,
                    this._y = f,
                    this.properties = n.properties,
                    this.id = g
                }
                get geometry() {
                    return this._geometry === void 0 && (this._geometry = this._vectorTileFeature.toGeoJSON(this._x, this._y, this._z).geometry),
                    this._geometry
                }
                set geometry(n) {
                    this._geometry = n
                }
                toJSON() {
                    let n = {
                        type: "Feature",
                        geometry: this.geometry,
                        properties: this.properties
                    };
                    this.id !== void 0 && (n.id = this.id);
                    for (let a of hR)
                        this[a] !== void 0 && (n[a] = this[a]);
                    return n
                }
            }
            let mo = 32
              , oa = 33
              , Ul = new Uint16Array(8184);
            for (let s = 0; s < 2046; s++) {
                let n = s + 2
                  , a = 0
                  , u = 0
                  , f = 0
                  , g = 0
                  , y = 0
                  , w = 0;
                for (1 & n ? f = g = y = mo : a = u = w = mo; (n >>= 1) > 1; ) {
                    let M = a + f >> 1
                      , z = u + g >> 1;
                    1 & n ? (f = a,
                    g = u,
                    a = y,
                    u = w) : (a = f,
                    u = g,
                    f = y,
                    g = w),
                    y = M,
                    w = z
                }
                let S = 4 * s;
                Ul[S + 0] = a,
                Ul[S + 1] = u,
                Ul[S + 2] = f,
                Ul[S + 3] = g
            }
            let aa = new Uint16Array(2178)
              , Vl = new Uint8Array(1089)
              , U_ = new Uint16Array(1089);
            function BE(s) {
                return s === 0 ? -.03125 : s === 32 ? .03125 : 0
            }
            var UE = vn([{
                name: "a_pos",
                type: "Int16",
                components: 2
            }, {
                name: "a_texture_pos",
                type: "Int16",
                components: 2
            }]);
            let VE = {
                type: 2,
                extent: kn,
                loadGeometry: ()=>[[new W(0,0), new W(8193,0), new W(8193,8193), new W(0,8193), new W(0,0)]]
            };
            class iv {
                constructor(n, a, u, f, g) {
                    this.tileID = n,
                    this.uid = Et(),
                    this.uses = 0,
                    this.tileSize = a,
                    this.tileZoom = u,
                    this.buckets = {},
                    this.expirationTime = null,
                    this.queryPadding = 0,
                    this.hasSymbolBuckets = !1,
                    this.hasRTLText = !1,
                    this.dependencies = {},
                    this.isRaster = g,
                    this.expiredRequestCount = 0,
                    this.state = "loading",
                    f && f.transform && (this.projection = f.transform.projection)
                }
                registerFadeDuration(n) {
                    let a = n + this.timeAdded;
                    a < Nn.now() || this.fadeEndTime && a < this.fadeEndTime || (this.fadeEndTime = a)
                }
                wasRequested() {
                    return this.state === "errored" || this.state === "loaded" || this.state === "reloading"
                }
                get tileTransform() {
                    return this._tileTransform || (this._tileTransform = mu(this.tileID.canonical, this.projection)),
                    this._tileTransform
                }
                loadVectorData(n, a, u) {
                    if (this.unloadVectorData(),
                    this.state = "loaded",
                    n) {
                        n.featureIndex && (this.latestFeatureIndex = n.featureIndex,
                        n.rawTileData ? (this.latestRawTileData = n.rawTileData,
                        this.latestFeatureIndex.rawTileData = n.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)),
                        this.collisionBoxArray = n.collisionBoxArray,
                        this.buckets = function(f, g) {
                            let y = {};
                            if (!g)
                                return y;
                            for (let w of f) {
                                let S = w.layerIds.map(M=>g.getLayer(M)).filter(Boolean);
                                if (S.length !== 0) {
                                    w.layers = S,
                                    w.stateDependentLayerIds && (w.stateDependentLayers = w.stateDependentLayerIds.map(M=>S.filter(z=>z.id === M)[0]));
                                    for (let M of S)
                                        y[M.id] = w
                                }
                            }
                            return y
                        }(n.buckets, a.style),
                        this.hasSymbolBuckets = !1;
                        for (let f in this.buckets) {
                            let g = this.buckets[f];
                            if (g instanceof Bl) {
                                if (this.hasSymbolBuckets = !0,
                                !u)
                                    break;
                                g.justReloaded = !0
                            }
                        }
                        if (this.hasRTLText = !1,
                        this.hasSymbolBuckets)
                            for (let f in this.buckets) {
                                let g = this.buckets[f];
                                if (g instanceof Bl && g.hasRTLText) {
                                    this.hasRTLText = !0,
                                    Xe.isLoading() || Xe.isLoaded() || Ve() !== "deferred" || Fe();
                                    break
                                }
                            }
                        this.queryPadding = 0;
                        for (let f in this.buckets) {
                            let g = this.buckets[f];
                            this.queryPadding = Math.max(this.queryPadding, a.style.getLayer(f).queryRadius(g))
                        }
                        n.imageAtlas && (this.imageAtlas = n.imageAtlas),
                        n.glyphAtlasImage && (this.glyphAtlasImage = n.glyphAtlasImage),
                        n.lineAtlas && (this.lineAtlas = n.lineAtlas)
                    } else
                        this.collisionBoxArray = new ux
                }
                unloadVectorData() {
                    if (this.hasData()) {
                        for (let n in this.buckets)
                            this.buckets[n].destroy();
                        this.buckets = {},
                        this.imageAtlas && (this.imageAtlas = null),
                        this.lineAtlas && (this.lineAtlas = null),
                        this.imageAtlasTexture && this.imageAtlasTexture.destroy(),
                        this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(),
                        this.lineAtlasTexture && this.lineAtlasTexture.destroy(),
                        this._tileBoundsBuffer && (this._tileBoundsBuffer.destroy(),
                        this._tileBoundsIndexBuffer.destroy(),
                        this._tileBoundsSegments.destroy(),
                        this._tileBoundsBuffer = null),
                        this._tileDebugBuffer && (this._tileDebugBuffer.destroy(),
                        this._tileDebugSegments.destroy(),
                        this._tileDebugBuffer = null),
                        this._tileDebugIndexBuffer && (this._tileDebugIndexBuffer.destroy(),
                        this._tileDebugIndexBuffer = null),
                        this._globeTileDebugBorderBuffer && (this._globeTileDebugBorderBuffer.destroy(),
                        this._globeTileDebugBorderBuffer = null),
                        this._tileDebugTextBuffer && (this._tileDebugTextBuffer.destroy(),
                        this._tileDebugTextSegments.destroy(),
                        this._tileDebugTextIndexBuffer.destroy(),
                        this._tileDebugTextBuffer = null),
                        this._globeTileDebugTextBuffer && (this._globeTileDebugTextBuffer.destroy(),
                        this._globeTileDebugTextBuffer = null),
                        this.latestFeatureIndex = null,
                        this.state = "unloaded"
                    }
                }
                getBucket(n) {
                    return this.buckets[n.id]
                }
                upload(n) {
                    for (let u in this.buckets) {
                        let f = this.buckets[u];
                        f.uploadPending() && f.upload(n)
                    }
                    let a = n.gl;
                    this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new Lp(n,this.imageAtlas.image,a.RGBA),
                    this.imageAtlas.uploaded = !0),
                    this.glyphAtlasImage && (this.glyphAtlasTexture = new Lp(n,this.glyphAtlasImage,a.ALPHA),
                    this.glyphAtlasImage = null),
                    this.lineAtlas && !this.lineAtlas.uploaded && (this.lineAtlasTexture = new Lp(n,this.lineAtlas.image,a.ALPHA),
                    this.lineAtlas.uploaded = !0)
                }
                prepare(n) {
                    this.imageAtlas && this.imageAtlas.patchUpdatedImages(n, this.imageAtlasTexture)
                }
                queryRenderedFeatures(n, a, u, f, g, y, w, S) {
                    return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({
                        tileResult: f,
                        pixelPosMatrix: w,
                        transform: y,
                        params: g,
                        tileTransform: this.tileTransform
                    }, n, a, u) : {}
                }
                querySourceFeatures(n, a) {
                    let u = this.latestFeatureIndex;
                    if (!u || !u.rawTileData)
                        return;
                    let f = u.loadVTLayers()
                      , g = a ? a.sourceLayer : ""
                      , y = f._geojsonTileLayer || f[g];
                    if (!y)
                        return;
                    let w = Oh(a && a.filter)
                      , {z: S, x: M, y: z} = this.tileID.canonical
                      , N = {
                        z: S,
                        x: M,
                        y: z
                    };
                    for (let B = 0; B < y.length; B++) {
                        let H = y.feature(B);
                        if (w.needGeometry) {
                            let de = du(H, !0);
                            if (!w.filter(new $e(this.tileID.overscaledZ), de, this.tileID.canonical))
                                continue
                        } else if (!w.filter(new $e(this.tileID.overscaledZ), H))
                            continue;
                        let q = u.getId(H, g)
                          , Q = new FE(H,S,M,z,q);
                        Q.tile = N,
                        n.push(Q)
                    }
                }
                hasData() {
                    return this.state === "loaded" || this.state === "reloading" || this.state === "expired"
                }
                patternsLoaded() {
                    return !!this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length
                }
                setExpiryData(n) {
                    let a = this.expirationTime;
                    if (n.cacheControl) {
                        let u = $t(n.cacheControl);
                        u["max-age"] && (this.expirationTime = Date.now() + 1e3 * u["max-age"])
                    } else
                        n.expires && (this.expirationTime = new Date(n.expires).getTime());
                    if (this.expirationTime) {
                        let u = Date.now()
                          , f = !1;
                        if (this.expirationTime > u)
                            f = !1;
                        else if (a)
                            if (this.expirationTime < a)
                                f = !0;
                            else {
                                let g = this.expirationTime - a;
                                g ? this.expirationTime = u + Math.max(g, 3e4) : f = !0
                            }
                        else
                            f = !0;
                        f ? (this.expiredRequestCount++,
                        this.state = "expired") : this.expiredRequestCount = 0
                    }
                }
                getExpiryTimeout() {
                    if (this.expirationTime)
                        return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - new Date().getTime(), Math.pow(2, 31) - 1)
                }
                setFeatureState(n, a) {
                    if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || Object.keys(n).length === 0 || !a)
                        return;
                    let u = this.latestFeatureIndex.loadVTLayers()
                      , f = a.style.listImages();
                    for (let g in this.buckets) {
                        if (!a.style.hasLayer(g))
                            continue;
                        let y = this.buckets[g]
                          , w = y.layers[0].sourceLayer || "_geojsonTileLayer"
                          , S = u[w]
                          , M = n[w];
                        if (!S || !M || Object.keys(M).length === 0)
                            continue;
                        if (y.update(M, S, f, this.imageAtlas && this.imageAtlas.patternPositions || {}),
                        y instanceof A_ || y instanceof b_) {
                            let N = a.style._getSourceCache(y.layers[0].source);
                            a._terrain && a._terrain.enabled && N && y.programConfigurations.needsUpload && a._terrain._clearRenderCacheForTile(N.id, this.tileID)
                        }
                        let z = a && a.style && a.style.getLayer(g);
                        z && (this.queryPadding = Math.max(this.queryPadding, z.queryRadius(y)))
                    }
                }
                holdingForFade() {
                    return this.symbolFadeHoldUntil !== void 0
                }
                symbolFadeFinished() {
                    return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < Nn.now()
                }
                clearFadeHold() {
                    this.symbolFadeHoldUntil = void 0
                }
                setHoldDuration(n) {
                    this.symbolFadeHoldUntil = Nn.now() + n
                }
                setTexture(n, a) {
                    let u = a.context
                      , f = u.gl;
                    this.texture = this.texture || a.getTileTexture(n.width),
                    this.texture ? this.texture.update(n, {
                        useMipmap: !0
                    }) : (this.texture = new Lp(u,n,f.RGBA,{
                        useMipmap: !0
                    }),
                    this.texture.bind(f.LINEAR, f.CLAMP_TO_EDGE),
                    u.extTextureFilterAnisotropic && f.texParameterf(f.TEXTURE_2D, u.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, u.extTextureFilterAnisotropicMax))
                }
                setDependencies(n, a) {
                    let u = {};
                    for (let f of a)
                        u[f] = !0;
                    this.dependencies[n] = u
                }
                hasDependency(n, a) {
                    for (let u of n) {
                        let f = this.dependencies[u];
                        if (f) {
                            for (let g of a)
                                if (f[g])
                                    return !0
                        }
                    }
                    return !1
                }
                clearQueryDebugViz() {}
                _makeDebugTileBoundsBuffers(n, a) {
                    if (!a || a.name === "mercator" || this._tileDebugBuffer)
                        return;
                    let u = Na(VE, this.tileID.canonical, this.tileTransform)[0]
                      , f = new En
                      , g = new ea;
                    for (let y = 0; y < u.length; y++) {
                        let {x: w, y: S} = u[y];
                        f.emplaceBack(w, S),
                        g.emplaceBack(y)
                    }
                    g.emplaceBack(0),
                    this._tileDebugIndexBuffer = n.createIndexBuffer(g),
                    this._tileDebugBuffer = n.createVertexBuffer(f, cp.members),
                    this._tileDebugSegments = cr.simpleSegment(0, 0, f.length, g.length)
                }
                _makeTileBoundsBuffers(n, a) {
                    if (this._tileBoundsBuffer || !a || a.name === "mercator")
                        return;
                    let u = Na(VE, this.tileID.canonical, this.tileTransform)[0], f, g;
                    if (this.isRaster) {
                        let y = function(w, S) {
                            let M = mu(w, S)
                              , z = Math.pow(2, w.z);
                            for (let de = 0; de < oa; de++)
                                for (let Me = 0; Me < oa; Me++) {
                                    let Pe = Js((w.x + (Me + BE(Me)) / mo) / z)
                                      , we = Zr((w.y + (de + BE(de)) / mo) / z)
                                      , Le = S.project(Pe, we)
                                      , Ue = de * oa + Me;
                                    aa[2 * Ue + 0] = Math.round((Le.x * M.scale - M.x) * kn),
                                    aa[2 * Ue + 1] = Math.round((Le.y * M.scale - M.y) * kn)
                                }
                            Vl.fill(0),
                            U_.fill(0);
                            for (let de = 2045; de >= 0; de--) {
                                let Me = 4 * de
                                  , Pe = Ul[Me + 0]
                                  , we = Ul[Me + 1]
                                  , Le = Ul[Me + 2]
                                  , Ue = Ul[Me + 3]
                                  , Ne = Pe + Le >> 1
                                  , at = we + Ue >> 1
                                  , it = Ne + at - we
                                  , _t = at + Pe - Ne
                                  , Ot = we * oa + Pe
                                  , dt = Ue * oa + Le
                                  , yt = at * oa + Ne
                                  , Tt = Math.hypot((aa[2 * Ot + 0] + aa[2 * dt + 0]) / 2 - aa[2 * yt + 0], (aa[2 * Ot + 1] + aa[2 * dt + 1]) / 2 - aa[2 * yt + 1]) >= 16;
                                if (Vl[yt] = Vl[yt] || (Tt ? 1 : 0),
                                de < 1022) {
                                    let Lt = (we + _t >> 1) * oa + (Pe + it >> 1)
                                      , Nt = (Ue + _t >> 1) * oa + (Le + it >> 1);
                                    Vl[yt] = Vl[yt] || Vl[Lt] || Vl[Nt]
                                }
                            }
                            let N = new Ti
                              , B = new Xr
                              , H = 0;
                            function q(de, Me) {
                                let Pe = Me * oa + de;
                                return U_[Pe] === 0 && (N.emplaceBack(aa[2 * Pe + 0], aa[2 * Pe + 1], de * kn / mo, Me * kn / mo),
                                U_[Pe] = ++H),
                                U_[Pe] - 1
                            }
                            function Q(de, Me, Pe, we, Le, Ue) {
                                let Ne = de + Pe >> 1
                                  , at = Me + we >> 1;
                                if (Math.abs(de - Le) + Math.abs(Me - Ue) > 1 && Vl[at * oa + Ne])
                                    Q(Le, Ue, de, Me, Ne, at),
                                    Q(Pe, we, Le, Ue, Ne, at);
                                else {
                                    let it = q(de, Me)
                                      , _t = q(Pe, we)
                                      , Ot = q(Le, Ue);
                                    B.emplaceBack(it, _t, Ot)
                                }
                            }
                            return Q(0, 0, mo, mo, mo, 0),
                            Q(mo, mo, 0, 0, 0, mo),
                            {
                                vertices: N,
                                indices: B
                            }
                        }(this.tileID.canonical, a);
                        f = y.vertices,
                        g = y.indices
                    } else {
                        f = new Ti,
                        g = new Xr;
                        for (let {x: w, y: S} of u)
                            f.emplaceBack(w, S, 0, 0);
                        let y = ed(f.int16, void 0, 4);
                        for (let w = 0; w < y.length; w += 3)
                            g.emplaceBack(y[w], y[w + 1], y[w + 2])
                    }
                    this._tileBoundsBuffer = n.createVertexBuffer(f, UE.members),
                    this._tileBoundsIndexBuffer = n.createIndexBuffer(g),
                    this._tileBoundsSegments = cr.simpleSegment(0, 0, f.length, g.length)
                }
                _makeGlobeTileDebugBuffers(n, a) {
                    let u = a.projection;
                    if (!u || u.name !== "globe" || a.freezeTileCoverage)
                        return;
                    let f = this.tileID.canonical, g = dp(hT(f, a)), y = Jh(a.zoom), w;
                    y > 0 && (w = mx(new Float64Array(16), a.globeMatrix)),
                    this._makeGlobeTileDebugBorderBuffer(n, f, a, g, w, y),
                    this._makeGlobeTileDebugTextBuffer(n, f, a, g, w, y)
                }
                _globePoint(n, a, u, f, g, y, w) {
                    let S = hp(n, a, u);
                    if (y) {
                        let M = 1 << u.z
                          , z = ia(f.center.lng)
                          , N = ra(f.center.lat)
                          , B = (u.x + .5) / M - z
                          , H = 0;
                        B > .5 ? H = -1 : B < -.5 && (H = 1);
                        let q = (n / kn + u.x) / M + H
                          , Q = (a / kn + u.y) / M;
                        q = (q - z) * f._pixelsPerMercatorPixel + z,
                        Q = (Q - N) * f._pixelsPerMercatorPixel + N;
                        let de = [q * f.worldSize, Q * f.worldSize, 0];
                        ir(de, de, y),
                        S = hu(S, de, w)
                    }
                    return ir(S, S, g)
                }
                _makeGlobeTileDebugBorderBuffer(n, a, u, f, g, y) {
                    let w = new En
                      , S = new ea
                      , M = new pi
                      , z = (B,H,q,Q,de)=>{
                        let Me = (q - B) / (de - 1)
                          , Pe = (Q - H) / (de - 1)
                          , we = w.length;
                        for (let Le = 0; Le < de; Le++) {
                            let Ue = B + Le * Me
                              , Ne = H + Le * Pe;
                            w.emplaceBack(Ue, Ne);
                            let at = this._globePoint(Ue, Ne, a, u, f, g, y);
                            M.emplaceBack(at[0], at[1], at[2]),
                            S.emplaceBack(we + Le)
                        }
                    }
                      , N = kn;
                    z(0, 0, N, 0, 16),
                    z(N, 0, N, N, 16),
                    z(N, N, 0, N, 16),
                    z(0, N, 0, 0, 16),
                    this._tileDebugIndexBuffer = n.createIndexBuffer(S),
                    this._tileDebugBuffer = n.createVertexBuffer(w, cp.members),
                    this._globeTileDebugBorderBuffer = n.createVertexBuffer(M, cT.members),
                    this._tileDebugSegments = cr.simpleSegment(0, 0, w.length, S.length)
                }
                _makeGlobeTileDebugTextBuffer(n, a, u, f, g, y) {
                    let w = new En
                      , S = new Xr
                      , M = new pi
                      , z = 25;
                    S.reserve(32),
                    w.reserve(z),
                    M.reserve(z);
                    let N = (B,H)=>z * B + H;
                    for (let B = 0; B < z; B++) {
                        let H = 2048 * B;
                        for (let q = 0; q < z; q++) {
                            let Q = 2048 * q;
                            w.emplaceBack(Q, H);
                            let de = this._globePoint(Q, H, a, u, f, g, y);
                            M.emplaceBack(de[0], de[1], de[2])
                        }
                    }
                    for (let B = 0; B < 4; B++)
                        for (let H = 0; H < 4; H++) {
                            let q = N(B, H)
                              , Q = N(B, H + 1)
                              , de = N(B + 1, H)
                              , Me = N(B + 1, H + 1);
                            S.emplaceBack(q, Q, de),
                            S.emplaceBack(de, Q, Me)
                        }
                    this._tileDebugTextIndexBuffer = n.createIndexBuffer(S),
                    this._tileDebugTextBuffer = n.createVertexBuffer(w, cp.members),
                    this._globeTileDebugTextBuffer = n.createVertexBuffer(M, cT.members),
                    this._tileDebugTextSegments = cr.simpleSegment(0, 0, z, 32)
                }
            }
            class dR {
                constructor() {
                    this.state = {},
                    this.stateChanges = {},
                    this.deletedStates = {}
                }
                updateState(n, a, u) {
                    let f = String(a);
                    if (this.stateChanges[n] = this.stateChanges[n] || {},
                    this.stateChanges[n][f] = this.stateChanges[n][f] || {},
                    Ke(this.stateChanges[n][f], u),
                    this.deletedStates[n] === null) {
                        this.deletedStates[n] = {};
                        for (let g in this.state[n])
                            g !== f && (this.deletedStates[n][g] = null)
                    } else if (this.deletedStates[n] && this.deletedStates[n][f] === null) {
                        this.deletedStates[n][f] = {};
                        for (let g in this.state[n][f])
                            u[g] || (this.deletedStates[n][f][g] = null)
                    } else
                        for (let g in u)
                            this.deletedStates[n] && this.deletedStates[n][f] && this.deletedStates[n][f][g] === null && delete this.deletedStates[n][f][g]
                }
                removeFeatureState(n, a, u) {
                    if (this.deletedStates[n] === null)
                        return;
                    let f = String(a);
                    if (this.deletedStates[n] = this.deletedStates[n] || {},
                    u && a !== void 0)
                        this.deletedStates[n][f] !== null && (this.deletedStates[n][f] = this.deletedStates[n][f] || {},
                        this.deletedStates[n][f][u] = null);
                    else if (a !== void 0)
                        if (this.stateChanges[n] && this.stateChanges[n][f])
                            for (u in this.deletedStates[n][f] = {},
                            this.stateChanges[n][f])
                                this.deletedStates[n][f][u] = null;
                        else
                            this.deletedStates[n][f] = null;
                    else
                        this.deletedStates[n] = null
                }
                getState(n, a) {
                    let u = String(a)
                      , f = Ke({}, (this.state[n] || {})[u], (this.stateChanges[n] || {})[u]);
                    if (this.deletedStates[n] === null)
                        return {};
                    if (this.deletedStates[n]) {
                        let g = this.deletedStates[n][a];
                        if (g === null)
                            return {};
                        for (let y in g)
                            delete f[y]
                    }
                    return f
                }
                initializeTileState(n, a) {
                    n.setFeatureState(this.state, a)
                }
                coalesceChanges(n, a) {
                    let u = {};
                    for (let f in this.stateChanges) {
                        this.state[f] = this.state[f] || {};
                        let g = {};
                        for (let y in this.stateChanges[f])
                            this.state[f][y] || (this.state[f][y] = {}),
                            Ke(this.state[f][y], this.stateChanges[f][y]),
                            g[y] = this.state[f][y];
                        u[f] = g
                    }
                    for (let f in this.deletedStates) {
                        this.state[f] = this.state[f] || {};
                        let g = {};
                        if (this.deletedStates[f] === null)
                            for (let y in this.state[f])
                                g[y] = {},
                                this.state[f][y] = {};
                        else
                            for (let y in this.deletedStates[f]) {
                                if (this.deletedStates[f][y] === null)
                                    this.state[f][y] = {};
                                else if (this.state[f][y])
                                    for (let w of Object.keys(this.deletedStates[f][y]))
                                        delete this.state[f][y][w];
                                g[y] = this.state[f][y]
                            }
                        u[f] = u[f] || {},
                        Ke(u[f], g)
                    }
                    if (this.stateChanges = {},
                    this.deletedStates = {},
                    Object.keys(u).length !== 0)
                        for (let f in n)
                            n[f].setFeatureState(u, a)
                }
            }
            class GE {
                constructor(n) {
                    this.size = n,
                    this.minimums = [],
                    this.maximums = [],
                    this.leaves = []
                }
                getElevation(n, a) {
                    let u = this.toIdx(n, a);
                    return {
                        min: this.minimums[u],
                        max: this.maximums[u]
                    }
                }
                isLeaf(n, a) {
                    return this.leaves[this.toIdx(n, a)]
                }
                toIdx(n, a) {
                    return a * this.size + n
                }
            }
            function HE(s, n, a, u) {
                let f = 0
                  , g = Number.MAX_VALUE;
                for (let y = 0; y < 3; y++)
                    if (Math.abs(u[y]) < 1e-15) {
                        if (a[y] < s[y] || a[y] > n[y])
                            return null
                    } else {
                        let w = 1 / u[y]
                          , S = (s[y] - a[y]) * w
                          , M = (n[y] - a[y]) * w;
                        if (S > M) {
                            let z = S;
                            S = M,
                            M = z
                        }
                        if (S > f && (f = S),
                        M < g && (g = M),
                        f > g)
                            return null
                    }
                return f
            }
            function WE(s, n, a, u, f, g, y, w, S, M, z) {
                let N = u - s
                  , B = f - n
                  , H = g - a
                  , q = y - s
                  , Q = w - n
                  , de = S - a
                  , Me = z[1] * de - z[2] * Q
                  , Pe = z[2] * q - z[0] * de
                  , we = z[0] * Q - z[1] * q
                  , Le = N * Me + B * Pe + H * we;
                if (Math.abs(Le) < 1e-15)
                    return null;
                let Ue = 1 / Le
                  , Ne = M[0] - s
                  , at = M[1] - n
                  , it = M[2] - a
                  , _t = (Ne * Me + at * Pe + it * we) * Ue;
                if (_t < 0 || _t > 1)
                    return null;
                let Ot = at * H - it * B
                  , dt = it * N - Ne * H
                  , yt = Ne * B - at * N
                  , Tt = (z[0] * Ot + z[1] * dt + z[2] * yt) * Ue;
                return Tt < 0 || _t + Tt > 1 ? null : (q * Ot + Q * dt + de * yt) * Ue
            }
            function jE(s, n, a) {
                return (s - n) / (a - n)
            }
            function XE(s, n, a, u, f, g, y, w, S) {
                let M = 1 << a
                  , z = g - u
                  , N = y - f
                  , B = (s + 1) / M * z + u
                  , H = (n + 0) / M * N + f
                  , q = (n + 1) / M * N + f;
                w[0] = (s + 0) / M * z + u,
                w[1] = H,
                S[0] = B,
                S[1] = q
            }
            class ZE {
                constructor(n) {
                    if (this.maximums = [],
                    this.minimums = [],
                    this.leaves = [],
                    this.childOffsets = [],
                    this.nodeCount = 0,
                    this.dem = n,
                    this._siblingOffset = [[0, 0], [1, 0], [0, 1], [1, 1]],
                    !this.dem)
                        return;
                    let a = function(g) {
                        let y = Math.ceil(Math.log2(g.dim / 8))
                          , w = []
                          , S = Math.ceil(Math.pow(2, y))
                          , M = 1 / S
                          , z = (H,q,Q,de,Me)=>{
                            let Pe = de ? 1 : 0
                              , we = (H + 1) * Q - Pe
                              , Le = q * Q
                              , Ue = (q + 1) * Q - Pe;
                            Me[0] = H * Q,
                            Me[1] = Le,
                            Me[2] = we,
                            Me[3] = Ue
                        }
                          , N = new GE(S)
                          , B = [];
                        for (let H = 0; H < S * S; H++) {
                            z(H % S, Math.floor(H / S), M, !1, B);
                            let q = Gl(B[0], B[1], g)
                              , Q = Gl(B[2], B[1], g)
                              , de = Gl(B[2], B[3], g)
                              , Me = Gl(B[0], B[3], g);
                            N.minimums.push(Math.min(q, Q, de, Me)),
                            N.maximums.push(Math.max(q, Q, de, Me)),
                            N.leaves.push(1)
                        }
                        for (w.push(N),
                        S /= 2; S >= 1; S /= 2) {
                            let H = w[w.length - 1];
                            N = new GE(S);
                            for (let q = 0; q < S * S; q++) {
                                z(q % S, Math.floor(q / S), 2, !0, B);
                                let Q = H.getElevation(B[0], B[1])
                                  , de = H.getElevation(B[2], B[1])
                                  , Me = H.getElevation(B[2], B[3])
                                  , Pe = H.getElevation(B[0], B[3])
                                  , we = H.isLeaf(B[0], B[1])
                                  , Le = H.isLeaf(B[2], B[1])
                                  , Ue = H.isLeaf(B[2], B[3])
                                  , Ne = H.isLeaf(B[0], B[3])
                                  , at = Math.min(Q.min, de.min, Me.min, Pe.min)
                                  , it = Math.max(Q.max, de.max, Me.max, Pe.max)
                                  , _t = we && Le && Ue && Ne;
                                N.maximums.push(it),
                                N.minimums.push(at),
                                N.leaves.push(it - at <= 5 && _t ? 1 : 0)
                            }
                            w.push(N)
                        }
                        return w
                    }(this.dem)
                      , u = a.length - 1
                      , f = a[u];
                    this._addNode(f.minimums[0], f.maximums[0], f.leaves[0]),
                    this._construct(a, 0, 0, u, 0)
                }
                raycastRoot(n, a, u, f, g, y, w=1) {
                    return HE([n, a, -100], [u, f, this.maximums[0] * w], g, y)
                }
                raycast(n, a, u, f, g, y, w=1) {
                    if (!this.nodeCount)
                        return null;
                    let S = this.raycastRoot(n, a, u, f, g, y, w);
                    if (S == null)
                        return null;
                    let M = []
                      , z = []
                      , N = []
                      , B = []
                      , H = [{
                        idx: 0,
                        t: S,
                        nodex: 0,
                        nodey: 0,
                        depth: 0
                    }];
                    for (; H.length > 0; ) {
                        let {idx: q, t: Q, nodex: de, nodey: Me, depth: Pe} = H.pop();
                        if (this.leaves[q]) {
                            XE(de, Me, Pe, n, a, u, f, N, B);
                            let Le = 1 << Pe
                              , Ue = (de + 0) / Le
                              , Ne = (de + 1) / Le
                              , at = (Me + 0) / Le
                              , it = (Me + 1) / Le
                              , _t = Gl(Ue, at, this.dem) * w
                              , Ot = Gl(Ne, at, this.dem) * w
                              , dt = Gl(Ne, it, this.dem) * w
                              , yt = Gl(Ue, it, this.dem) * w
                              , Tt = WE(N[0], N[1], _t, B[0], N[1], Ot, B[0], B[1], dt, g, y)
                              , Lt = WE(B[0], B[1], dt, N[0], B[1], yt, N[0], N[1], _t, g, y)
                              , Nt = Math.min(Tt !== null ? Tt : Number.MAX_VALUE, Lt !== null ? Lt : Number.MAX_VALUE);
                            if (Nt !== Number.MAX_VALUE)
                                return Nt;
                            {
                                let mt = ap([], g, y, Q);
                                if (qE(_t, Ot, yt, dt, jE(mt[0], N[0], B[0]), jE(mt[1], N[1], B[1])) >= mt[2])
                                    return Q
                            }
                            continue
                        }
                        let we = 0;
                        for (let Le = 0; Le < this._siblingOffset.length; Le++) {
                            XE((de << 1) + this._siblingOffset[Le][0], (Me << 1) + this._siblingOffset[Le][1], Pe + 1, n, a, u, f, N, B),
                            N[2] = -100,
                            B[2] = this.maximums[this.childOffsets[q] + Le] * w;
                            let Ue = HE(N, B, g, y);
                            if (Ue != null) {
                                let Ne = Ue;
                                M[Le] = Ne;
                                let at = !1;
                                for (let it = 0; it < we && !at; it++)
                                    Ne >= M[z[it]] && (z.splice(it, 0, Le),
                                    at = !0);
                                at || (z[we] = Le),
                                we++
                            }
                        }
                        for (let Le = 0; Le < we; Le++) {
                            let Ue = z[Le];
                            H.push({
                                idx: this.childOffsets[q] + Ue,
                                t: M[Ue],
                                nodex: (de << 1) + this._siblingOffset[Ue][0],
                                nodey: (Me << 1) + this._siblingOffset[Ue][1],
                                depth: Pe + 1
                            })
                        }
                    }
                    return null
                }
                _addNode(n, a, u) {
                    return this.minimums.push(n),
                    this.maximums.push(a),
                    this.leaves.push(u),
                    this.childOffsets.push(0),
                    this.nodeCount++
                }
                _construct(n, a, u, f, g) {
                    if (n[f].isLeaf(a, u) === 1)
                        return;
                    this.childOffsets[g] || (this.childOffsets[g] = this.nodeCount);
                    let y = f - 1
                      , w = n[y]
                      , S = 0
                      , M = 0;
                    for (let z = 0; z < this._siblingOffset.length; z++) {
                        let N = 2 * a + this._siblingOffset[z][0]
                          , B = 2 * u + this._siblingOffset[z][1]
                          , H = w.getElevation(N, B)
                          , q = w.isLeaf(N, B)
                          , Q = this._addNode(H.min, H.max, q);
                        q && (S |= 1 << z),
                        M || (M = Q)
                    }
                    for (let z = 0; z < this._siblingOffset.length; z++)
                        S & 1 << z || this._construct(n, 2 * a + this._siblingOffset[z][0], 2 * u + this._siblingOffset[z][1], y, M + z)
                }
            }
            function qE(s, n, a, u, f, g) {
                return si(si(s, a, g), si(n, u, g), f)
            }
            function Gl(s, n, a) {
                let u = a.dim
                  , f = ae(s * u - .5, 0, u - 1)
                  , g = ae(n * u - .5, 0, u - 1)
                  , y = Math.floor(f)
                  , w = Math.floor(g)
                  , S = Math.min(y + 1, u - 1)
                  , M = Math.min(w + 1, u - 1);
                return qE(a.get(y, w), a.get(S, w), a.get(y, M), a.get(S, M), f - y, g - w)
            }
            let KE = {
                mapbox: [6553.6, 25.6, .1, 1e4],
                terrarium: [256, 1, 1 / 256, 32768]
            };
            class V_ {
                get tree() {
                    return this._tree || this._buildQuadTree(),
                    this._tree
                }
                constructor(n, a, u, f=!1, g=!1) {
                    if (this.uid = n,
                    a.height !== a.width)
                        throw new RangeError("DEM tiles must be square");
                    if (u && u !== "mapbox" && u !== "terrarium")
                        return ut(`"${u}" is not a valid encoding type. Valid types include "mapbox" and "terrarium".`);
                    this.stride = a.height;
                    let y = this.dim = a.height - 2
                      , w = new Uint32Array(a.data.buffer);
                    if (this.pixels = new Uint8Array(a.data.buffer),
                    this.encoding = u || "mapbox",
                    this.borderReady = f,
                    !f) {
                        for (let S = 0; S < y; S++)
                            w[this._idx(-1, S)] = w[this._idx(0, S)],
                            w[this._idx(y, S)] = w[this._idx(y - 1, S)],
                            w[this._idx(S, -1)] = w[this._idx(S, 0)],
                            w[this._idx(S, y)] = w[this._idx(S, y - 1)];
                        w[this._idx(-1, -1)] = w[this._idx(0, 0)],
                        w[this._idx(y, -1)] = w[this._idx(y - 1, 0)],
                        w[this._idx(-1, y)] = w[this._idx(0, y - 1)],
                        w[this._idx(y, y)] = w[this._idx(y - 1, y - 1)],
                        g && this._buildQuadTree()
                    }
                }
                _buildQuadTree() {
                    this._tree = new ZE(this)
                }
                get(n, a, u=!1) {
                    u && (n = ae(n, -1, this.dim),
                    a = ae(a, -1, this.dim));
                    let f = 4 * this._idx(n, a);
                    return (this.encoding === "terrarium" ? this._unpackTerrarium : this._unpackMapbox)(this.pixels[f], this.pixels[f + 1], this.pixels[f + 2])
                }
                static getUnpackVector(n) {
                    return KE[n]
                }
                get unpackVector() {
                    return KE[this.encoding]
                }
                _idx(n, a) {
                    if (n < -1 || n >= this.dim + 1 || a < -1 || a >= this.dim + 1)
                        throw new RangeError("out of range source coordinates for DEM data");
                    return (a + 1) * this.stride + (n + 1)
                }
                _unpackMapbox(n, a, u) {
                    return (256 * n * 256 + 256 * a + u) / 10 - 1e4
                }
                _unpackTerrarium(n, a, u) {
                    return 256 * n + a + u / 256 - 32768
                }
                static pack(n, a) {
                    let u = [0, 0, 0, 0]
                      , f = V_.getUnpackVector(a)
                      , g = Math.floor((n + f[3]) / f[2]);
                    return u[2] = g % 256,
                    g = Math.floor(g / 256),
                    u[1] = g % 256,
                    g = Math.floor(g / 256),
                    u[0] = g,
                    u
                }
                getPixels() {
                    return new Fs({
                        width: this.stride,
                        height: this.stride
                    },this.pixels)
                }
                backfillBorder(n, a, u) {
                    if (this.dim !== n.dim)
                        throw new Error("dem dimension mismatch");
                    let f = a * this.dim
                      , g = a * this.dim + this.dim
                      , y = u * this.dim
                      , w = u * this.dim + this.dim;
                    switch (a) {
                    case -1:
                        f = g - 1;
                        break;
                    case 1:
                        g = f + 1
                    }
                    switch (u) {
                    case -1:
                        y = w - 1;
                        break;
                    case 1:
                        w = y + 1
                    }
                    let S = -a * this.dim
                      , M = -u * this.dim;
                    for (let z = y; z < w; z++)
                        for (let N = f; N < g; N++) {
                            let B = 4 * this._idx(N, z)
                              , H = 4 * this._idx(N + S, z + M);
                            this.pixels[B + 0] = n.pixels[H + 0],
                            this.pixels[B + 1] = n.pixels[H + 1],
                            this.pixels[B + 2] = n.pixels[H + 2],
                            this.pixels[B + 3] = n.pixels[H + 3]
                        }
                }
                onDeserialize() {
                    this._tree && (this._tree.dem = this)
                }
            }
            cn(V_, "DEMData"),
            cn(ZE, "DemMinMaxQuadTree", {
                omit: ["dem"]
            });
            class fR {
                constructor(n, a) {
                    this.max = n,
                    this.onRemove = a,
                    this.reset()
                }
                reset() {
                    for (let n in this.data)
                        for (let a of this.data[n])
                            a.timeout && clearTimeout(a.timeout),
                            this.onRemove(a.value);
                    return this.data = {},
                    this.order = [],
                    this
                }
                add(n, a, u) {
                    let f = n.wrapped().key;
                    this.data[f] === void 0 && (this.data[f] = []);
                    let g = {
                        value: a,
                        timeout: void 0
                    };
                    if (u !== void 0 && (g.timeout = setTimeout(()=>{
                        this.remove(n, g)
                    }
                    , u)),
                    this.data[f].push(g),
                    this.order.push(f),
                    this.order.length > this.max) {
                        let y = this._getAndRemoveByKey(this.order[0]);
                        y && this.onRemove(y)
                    }
                    return this
                }
                has(n) {
                    return n.wrapped().key in this.data
                }
                getAndRemove(n) {
                    return this.has(n) ? this._getAndRemoveByKey(n.wrapped().key) : null
                }
                _getAndRemoveByKey(n) {
                    let a = this.data[n].shift();
                    return a.timeout && clearTimeout(a.timeout),
                    this.data[n].length === 0 && delete this.data[n],
                    this.order.splice(this.order.indexOf(n), 1),
                    a.value
                }
                getByKey(n) {
                    let a = this.data[n];
                    return a ? a[0].value : null
                }
                get(n) {
                    return this.has(n) ? this.data[n.wrapped().key][0].value : null
                }
                remove(n, a) {
                    if (!this.has(n))
                        return this;
                    let u = n.wrapped().key
                      , f = a === void 0 ? 0 : this.data[u].indexOf(a)
                      , g = this.data[u][f];
                    return this.data[u].splice(f, 1),
                    g.timeout && clearTimeout(g.timeout),
                    this.data[u].length === 0 && delete this.data[u],
                    this.onRemove(g.value),
                    this.order.splice(this.order.indexOf(u), 1),
                    this
                }
                setMaxSize(n) {
                    for (this.max = n; this.order.length > this.max; ) {
                        let a = this._getAndRemoveByKey(this.order[0]);
                        a && this.onRemove(a)
                    }
                    return this
                }
                filter(n) {
                    let a = [];
                    for (let u in this.data)
                        for (let f of this.data[u])
                            n(f.value) || a.push(f);
                    for (let u of a)
                        this.remove(u.value.tileID, u)
                }
            }
            class hd {
                constructor(n, a, u) {
                    this.func = n,
                    this.mask = a,
                    this.range = u
                }
            }
            hd.ReadOnly = !1,
            hd.ReadWrite = !0,
            hd.disabled = new hd(519,hd.ReadOnly,[0, 1]);
            let rv = 7680;
            class sv {
                constructor(n, a, u, f, g, y) {
                    this.test = n,
                    this.ref = a,
                    this.mask = u,
                    this.fail = f,
                    this.depthFail = g,
                    this.pass = y
                }
            }
            sv.disabled = new sv({
                func: 519,
                mask: 0
            },0,0,rv,rv,rv);
            class la {
                constructor(n, a, u) {
                    this.blendFunction = n,
                    this.blendColor = a,
                    this.mask = u
                }
            }
            la.Replace = [1, 0],
            la.disabled = new la(la.Replace,nr.transparent,[!1, !1, !1, !1]),
            la.unblended = new la(la.Replace,nr.transparent,[!0, !0, !0, !0]),
            la.alphaBlended = new la([1, 771],nr.transparent,[!0, !0, !0, !0]);
            let ov = 1029
              , av = 2305;
            class Oo {
                constructor(n, a, u) {
                    this.enable = n,
                    this.mode = a,
                    this.frontFace = u
                }
            }
            Oo.disabled = new Oo(!1,ov,av),
            Oo.backCCW = new Oo(!0,ov,av),
            Oo.backCW = new Oo(!0,ov,2304),
            Oo.frontCW = new Oo(!0,1028,2304),
            Oo.frontCCW = new Oo(!0,1028,av);
            class gu extends pr {
                constructor(n, a, u) {
                    super(),
                    this.id = n,
                    this._onlySymbols = u,
                    a.on("data", f=>{
                        f.dataType === "source" && f.sourceDataType === "metadata" && (this._sourceLoaded = !0),
                        this._sourceLoaded && !this._paused && f.dataType === "source" && f.sourceDataType === "content" && (this.reload(),
                        this.transform && this.update(this.transform))
                    }
                    ),
                    a.on("error", ()=>{
                        this._sourceErrored = !0
                    }
                    ),
                    this._source = a,
                    this._tiles = {},
                    this._cache = new fR(0,this._unloadTile.bind(this)),
                    this._timers = {},
                    this._cacheTimers = {},
                    this._minTileCacheSize = a.minTileCacheSize,
                    this._maxTileCacheSize = a.maxTileCacheSize,
                    this._loadedParentTiles = {},
                    this._coveredTiles = {},
                    this._state = new dR,
                    this._isRaster = this._source.type === "raster" || this._source.type === "raster-dem" || this._source.type === "custom" && this._source._dataType === "raster"
                }
                onAdd(n) {
                    this.map = n,
                    this._minTileCacheSize = this._minTileCacheSize === void 0 && n ? n._minTileCacheSize : this._minTileCacheSize,
                    this._maxTileCacheSize = this._maxTileCacheSize === void 0 && n ? n._maxTileCacheSize : this._maxTileCacheSize
                }
                loaded() {
                    if (this._sourceErrored)
                        return !0;
                    if (!this._sourceLoaded || !this._source.loaded())
                        return !1;
                    for (let n in this._tiles) {
                        let a = this._tiles[n];
                        if (a.state !== "loaded" && a.state !== "errored")
                            return !1
                    }
                    return !0
                }
                getSource() {
                    return this._source
                }
                pause() {
                    this._paused = !0
                }
                resume() {
                    if (!this._paused)
                        return;
                    let n = this._shouldReloadOnResume;
                    this._paused = !1,
                    this._shouldReloadOnResume = !1,
                    n && this.reload(),
                    this.transform && this.update(this.transform)
                }
                _loadTile(n, a) {
                    return n.isSymbolTile = this._onlySymbols,
                    this._source.loadTile(n, a)
                }
                _unloadTile(n) {
                    if (this._source.unloadTile)
                        return this._source.unloadTile(n, ()=>{}
                        )
                }
                _abortTile(n) {
                    if (this._source.abortTile)
                        return this._source.abortTile(n, ()=>{}
                        )
                }
                serialize() {
                    return this._source.serialize()
                }
                prepare(n) {
                    this._source.prepare && this._source.prepare(),
                    this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
                    for (let a in this._tiles) {
                        let u = this._tiles[a];
                        u.upload(n),
                        u.prepare(this.map.style.imageManager)
                    }
                }
                getIds() {
                    return tt(this._tiles).map(n=>n.tileID).sort(YE).map(n=>n.key)
                }
                getRenderableIds(n) {
                    let a = [];
                    for (let u in this._tiles)
                        this._isIdRenderable(+u, n) && a.push(this._tiles[u]);
                    return n ? a.sort((u,f)=>{
                        let g = u.tileID
                          , y = f.tileID
                          , w = new W(g.canonical.x,g.canonical.y)._rotate(this.transform.angle)
                          , S = new W(y.canonical.x,y.canonical.y)._rotate(this.transform.angle);
                        return g.overscaledZ - y.overscaledZ || S.y - w.y || S.x - w.x
                    }
                    ).map(u=>u.tileID.key) : a.map(u=>u.tileID).sort(YE).map(u=>u.key)
                }
                hasRenderableParent(n) {
                    let a = this.findLoadedParent(n, 0);
                    return !!a && this._isIdRenderable(a.tileID.key)
                }
                _isIdRenderable(n, a) {
                    return this._tiles[n] && this._tiles[n].hasData() && !this._coveredTiles[n] && (a || !this._tiles[n].holdingForFade())
                }
                reload() {
                    if (this._paused)
                        this._shouldReloadOnResume = !0;
                    else {
                        this._cache.reset();
                        for (let n in this._tiles)
                            this._tiles[n].state !== "errored" && this._reloadTile(+n, "reloading")
                    }
                }
                _reloadTile(n, a) {
                    let u = this._tiles[n];
                    u && (u.state !== "loading" && (u.state = a),
                    this._loadTile(u, this._tileLoaded.bind(this, u, n, a)))
                }
                _tileLoaded(n, a, u, f) {
                    if (f)
                        if (n.state = "errored",
                        f.status !== 404)
                            this._source.fire(new ar(f,{
                                tile: n
                            }));
                        else if (this._source.type === "raster-dem" && this.usedForTerrain && this.map.painter.terrain) {
                            let g = this.map.painter.terrain;
                            this.update(this.transform, g.getScaledDemTileSize(), !0),
                            g.resetTileLookupCache(this.id)
                        } else
                            this.update(this.transform);
                    else
                        n.timeAdded = Nn.now(),
                        u === "expired" && (n.refreshedUponExpiration = !0),
                        this._setTileReloadTimer(a, n),
                        this._source.type === "raster-dem" && n.dem && this._backfillDEM(n),
                        this._state.initializeTileState(n, this.map ? this.map.painter : null),
                        this._source.fire(new On("data",{
                            dataType: "source",
                            tile: n,
                            coord: n.tileID,
                            sourceCacheId: this.id
                        }))
                }
                _backfillDEM(n) {
                    let a = this.getRenderableIds();
                    for (let f = 0; f < a.length; f++) {
                        let g = a[f];
                        if (n.neighboringTiles && n.neighboringTiles[g]) {
                            let y = this.getTileByID(g);
                            u(n, y),
                            u(y, n)
                        }
                    }
                    function u(f, g) {
                        if (!f.dem || f.dem.borderReady)
                            return;
                        f.needsHillshadePrepare = !0,
                        f.needsDEMTextureUpload = !0;
                        let y = g.tileID.canonical.x - f.tileID.canonical.x
                          , w = g.tileID.canonical.y - f.tileID.canonical.y
                          , S = Math.pow(2, f.tileID.canonical.z)
                          , M = g.tileID.key;
                        y === 0 && w === 0 || Math.abs(w) > 1 || (Math.abs(y) > 1 && (Math.abs(y + S) === 1 ? y += S : Math.abs(y - S) === 1 && (y -= S)),
                        g.dem && f.dem && (f.dem.backfillBorder(g.dem, y, w),
                        f.neighboringTiles && f.neighboringTiles[M] && (f.neighboringTiles[M].backfilled = !0)))
                    }
                }
                getTile(n) {
                    return this.getTileByID(n.key)
                }
                getTileByID(n) {
                    return this._tiles[n]
                }
                _retainLoadedChildren(n, a, u, f) {
                    for (let g in this._tiles) {
                        let y = this._tiles[g];
                        if (f[g] || !y.hasData() || y.tileID.overscaledZ <= a || y.tileID.overscaledZ > u)
                            continue;
                        let w = y.tileID;
                        for (; y && y.tileID.overscaledZ > a + 1; ) {
                            let M = y.tileID.scaledTo(y.tileID.overscaledZ - 1);
                            y = this._tiles[M.key],
                            y && y.hasData() && (w = M)
                        }
                        let S = w;
                        for (; S.overscaledZ > a; )
                            if (S = S.scaledTo(S.overscaledZ - 1),
                            n[S.key]) {
                                f[w.key] = w;
                                break
                            }
                    }
                }
                findLoadedParent(n, a) {
                    if (n.key in this._loadedParentTiles) {
                        let u = this._loadedParentTiles[n.key];
                        return u && u.tileID.overscaledZ >= a ? u : null
                    }
                    for (let u = n.overscaledZ - 1; u >= a; u--) {
                        let f = n.scaledTo(u)
                          , g = this._getLoadedTile(f);
                        if (g)
                            return g
                    }
                }
                _getLoadedTile(n) {
                    let a = this._tiles[n.key];
                    return a && a.hasData() ? a : this._cache.getByKey(this._source.reparseOverscaled ? n.wrapped().key : n.canonical.key)
                }
                updateCacheSize(n, a) {
                    a = a || this._source.tileSize;
                    let u = Math.ceil(n.width / a) + 1
                      , f = Math.ceil(n.height / a) + 1
                      , g = Math.floor(u * f * 5)
                      , y = typeof this._minTileCacheSize == "number" ? Math.max(this._minTileCacheSize, g) : g
                      , w = typeof this._maxTileCacheSize == "number" ? Math.min(this._maxTileCacheSize, y) : y;
                    this._cache.setMaxSize(w)
                }
                handleWrapJump(n) {
                    let a = Math.round((n - (this._prevLng === void 0 ? n : this._prevLng)) / 360);
                    if (this._prevLng = n,
                    a) {
                        let u = {};
                        for (let f in this._tiles) {
                            let g = this._tiles[f];
                            g.tileID = g.tileID.unwrapTo(g.tileID.wrap + a),
                            u[g.tileID.key] = g
                        }
                        this._tiles = u;
                        for (let f in this._timers)
                            clearTimeout(this._timers[f]),
                            delete this._timers[f];
                        for (let f in this._tiles)
                            this._setTileReloadTimer(+f, this._tiles[f])
                    }
                }
                update(n, a, u) {
                    if (this.transform = n,
                    !this._sourceLoaded || this._paused || this.transform.freezeTileCoverage || this.usedForTerrain && !u)
                        return;
                    let f;
                    this.updateCacheSize(n, a),
                    this.transform.projection.name !== "globe" && this.handleWrapJump(this.transform.center.lng),
                    this._coveredTiles = {},
                    this.used || this.usedForTerrain ? this._source.tileID ? f = n.getVisibleUnwrappedCoordinates(this._source.tileID).map(w=>new xs(w.canonical.z,w.wrap,w.canonical.z,w.canonical.x,w.canonical.y)) : (f = n.coveringTiles({
                        tileSize: a || this._source.tileSize,
                        minzoom: this._source.minzoom,
                        maxzoom: this._source.maxzoom,
                        roundZoom: this._source.roundZoom && !u,
                        reparseOverscaled: this._source.reparseOverscaled,
                        isTerrainDEM: this.usedForTerrain
                    }),
                    this._source.hasTile && (f = f.filter(w=>this._source.hasTile(w)))) : f = [];
                    let g = this._updateRetainedTiles(f);
                    if (JE(this._source.type) && f.length !== 0) {
                        let w = {}
                          , S = {}
                          , M = Object.keys(g);
                        for (let N of M) {
                            let B = g[N]
                              , H = this._tiles[N];
                            if (!H || H.fadeEndTime && H.fadeEndTime <= Nn.now())
                                continue;
                            let q = this.findLoadedParent(B, Math.max(B.overscaledZ - gu.maxOverzooming, this._source.minzoom));
                            q && (this._addTile(q.tileID),
                            w[q.tileID.key] = q.tileID),
                            S[N] = B
                        }
                        let z = f[f.length - 1].overscaledZ;
                        for (let N in this._tiles) {
                            let B = this._tiles[N];
                            if (g[N] || !B.hasData())
                                continue;
                            let H = B.tileID;
                            for (; H.overscaledZ > z; ) {
                                H = H.scaledTo(H.overscaledZ - 1);
                                let q = this._tiles[H.key];
                                if (q && q.hasData() && S[H.key]) {
                                    g[N] = B.tileID;
                                    break
                                }
                            }
                        }
                        for (let N in w)
                            g[N] || (this._coveredTiles[N] = !0,
                            g[N] = w[N])
                    }
                    for (let w in g)
                        this._tiles[w].clearFadeHold();
                    let y = function(w, S) {
                        let M = [];
                        for (let z in w)
                            z in S || M.push(z);
                        return M
                    }(this._tiles, g);
                    for (let w of y) {
                        let S = this._tiles[w];
                        S.hasSymbolBuckets && !S.holdingForFade() ? S.setHoldDuration(this.map._fadeDuration) : S.hasSymbolBuckets && !S.symbolFadeFinished() || this._removeTile(+w)
                    }
                    this._updateLoadedParentTileCache(),
                    this._onlySymbols && this._source.afterUpdate && this._source.afterUpdate()
                }
                releaseSymbolFadeTiles() {
                    for (let n in this._tiles)
                        this._tiles[n].holdingForFade() && this._removeTile(+n)
                }
                _updateRetainedTiles(n) {
                    let a = {};
                    if (n.length === 0)
                        return a;
                    let u = {}
                      , f = n.reduce((M,z)=>Math.min(M, z.overscaledZ), 1 / 0)
                      , g = n[0].overscaledZ
                      , y = Math.max(g - gu.maxOverzooming, this._source.minzoom)
                      , w = Math.max(g + gu.maxUnderzooming, this._source.minzoom)
                      , S = {};
                    for (let M of n) {
                        let z = this._addTile(M);
                        a[M.key] = M,
                        z.hasData() || f < this._source.maxzoom && (S[M.key] = M)
                    }
                    this._retainLoadedChildren(S, f, w, a);
                    for (let M of n) {
                        let z = this._tiles[M.key];
                        if (z.hasData())
                            continue;
                        if (M.canonical.z >= this._source.maxzoom) {
                            let B = M.children(this._source.maxzoom)[0]
                              , H = this.getTile(B);
                            if (H && H.hasData()) {
                                a[B.key] = B;
                                continue
                            }
                        } else {
                            let B = M.children(this._source.maxzoom);
                            if (a[B[0].key] && a[B[1].key] && a[B[2].key] && a[B[3].key])
                                continue
                        }
                        let N = z.wasRequested();
                        for (let B = M.overscaledZ - 1; B >= y; --B) {
                            let H = M.scaledTo(B);
                            if (u[H.key] || (u[H.key] = !0,
                            z = this.getTile(H),
                            !z && N && (z = this._addTile(H)),
                            z && (a[H.key] = H,
                            N = z.wasRequested(),
                            z.hasData())))
                                break
                        }
                    }
                    return a
                }
                _updateLoadedParentTileCache() {
                    this._loadedParentTiles = {};
                    for (let n in this._tiles) {
                        let a = [], u, f = this._tiles[n].tileID;
                        for (; f.overscaledZ > 0; ) {
                            if (f.key in this._loadedParentTiles) {
                                u = this._loadedParentTiles[f.key];
                                break
                            }
                            a.push(f.key);
                            let g = f.scaledTo(f.overscaledZ - 1);
                            if (u = this._getLoadedTile(g),
                            u)
                                break;
                            f = g
                        }
                        for (let g of a)
                            this._loadedParentTiles[g] = u
                    }
                }
                _addTile(n) {
                    let a = this._tiles[n.key];
                    if (a)
                        return a;
                    a = this._cache.getAndRemove(n),
                    a && (this._setTileReloadTimer(n.key, a),
                    a.tileID = n,
                    this._state.initializeTileState(a, this.map ? this.map.painter : null),
                    this._cacheTimers[n.key] && (clearTimeout(this._cacheTimers[n.key]),
                    delete this._cacheTimers[n.key],
                    this._setTileReloadTimer(n.key, a)));
                    let u = Boolean(a);
                    if (!u) {
                        let f = this.map ? this.map.painter : null;
                        a = new iv(n,this._source.tileSize * n.overscaleFactor(),this.transform.tileZoom,f,this._isRaster),
                        this._loadTile(a, this._tileLoaded.bind(this, a, n.key, a.state))
                    }
                    return a ? (a.uses++,
                    this._tiles[n.key] = a,
                    u || this._source.fire(new On("dataloading",{
                        tile: a,
                        coord: a.tileID,
                        dataType: "source"
                    })),
                    a) : null
                }
                _setTileReloadTimer(n, a) {
                    n in this._timers && (clearTimeout(this._timers[n]),
                    delete this._timers[n]);
                    let u = a.getExpiryTimeout();
                    u && (this._timers[n] = setTimeout(()=>{
                        this._reloadTile(n, "expired"),
                        delete this._timers[n]
                    }
                    , u))
                }
                _removeTile(n) {
                    let a = this._tiles[n];
                    a && (a.uses--,
                    delete this._tiles[n],
                    this._timers[n] && (clearTimeout(this._timers[n]),
                    delete this._timers[n]),
                    a.uses > 0 || (a.hasData() && a.state !== "reloading" ? this._cache.add(a.tileID, a, a.getExpiryTimeout()) : (a.aborted = !0,
                    this._abortTile(a),
                    this._unloadTile(a))))
                }
                clearTiles() {
                    this._shouldReloadOnResume = !1,
                    this._paused = !1;
                    for (let n in this._tiles)
                        this._removeTile(+n);
                    this._source._clear && this._source._clear(),
                    this._cache.reset(),
                    this.map && this.usedForTerrain && this.map.painter.terrain && this.map.painter.terrain.resetTileLookupCache(this.id)
                }
                tilesIn(n, a, u) {
                    let f = []
                      , g = this.transform;
                    if (!g)
                        return f;
                    let y = g.projection.name === "globe"
                      , w = ia(g.center.lng);
                    for (let S in this._tiles) {
                        let M = this._tiles[S];
                        if (u && M.clearQueryDebugViz(),
                        M.holdingForFade())
                            continue;
                        let z;
                        if (y) {
                            let N = M.tileID.canonical;
                            if (N.z === 0) {
                                let B = [Math.abs(ae(w, ...Rp(N, -1)) - w), Math.abs(ae(w, ...Rp(N, 1)) - w)];
                                z = [0, 2 * B.indexOf(Math.min(...B)) - 1]
                            } else {
                                let B = [Math.abs(ae(w, ...Rp(N, -1)) - w), Math.abs(ae(w, ...Rp(N, 0)) - w), Math.abs(ae(w, ...Rp(N, 1)) - w)];
                                z = [B.indexOf(Math.min(...B)) - 1]
                            }
                        } else
                            z = [0];
                        for (let N of z) {
                            let B = n.containsTile(M, g, a, N);
                            B && f.push(B)
                        }
                    }
                    return f
                }
                getVisibleCoordinates(n) {
                    let a = this.getRenderableIds(n).map(u=>this._tiles[u].tileID);
                    for (let u of a)
                        u.projMatrix = this.transform.calculateProjMatrix(u.toUnwrapped());
                    return a
                }
                hasTransition() {
                    if (this._source.hasTransition())
                        return !0;
                    if (JE(this._source.type))
                        for (let n in this._tiles) {
                            let a = this._tiles[n];
                            if (a.fadeEndTime !== void 0 && a.fadeEndTime >= Nn.now())
                                return !0
                        }
                    return !1
                }
                setFeatureState(n, a, u) {
                    this._state.updateState(n = n || "_geojsonTileLayer", a, u)
                }
                removeFeatureState(n, a, u) {
                    this._state.removeFeatureState(n = n || "_geojsonTileLayer", a, u)
                }
                getFeatureState(n, a) {
                    return this._state.getState(n = n || "_geojsonTileLayer", a)
                }
                setDependencies(n, a, u) {
                    let f = this._tiles[n];
                    f && f.setDependencies(a, u)
                }
                reloadTilesForDependencies(n, a) {
                    for (let u in this._tiles)
                        this._tiles[u].hasDependency(n, a) && this._reloadTile(+u, "reloading");
                    this._cache.filter(u=>!u.hasDependency(n, a))
                }
                _preloadTiles(n, a) {
                    let u = new Map
                      , f = Array.isArray(n) ? n : [n]
                      , g = this.map.painter.terrain
                      , y = this.usedForTerrain && g ? g.getScaledDemTileSize() : this._source.tileSize;
                    for (let w of f) {
                        let S = w.coveringTiles({
                            tileSize: y,
                            minzoom: this._source.minzoom,
                            maxzoom: this._source.maxzoom,
                            roundZoom: this._source.roundZoom && !this.usedForTerrain,
                            reparseOverscaled: this._source.reparseOverscaled,
                            isTerrainDEM: this.usedForTerrain
                        });
                        for (let M of S)
                            u.set(M.key, M);
                        this.usedForTerrain && w.updateElevation(!1)
                    }
                    Be(Array.from(u.values()), (w,S)=>{
                        let M = new iv(w,this._source.tileSize * w.overscaleFactor(),this.transform.tileZoom,this.map.painter,this._isRaster);
                        this._loadTile(M, z=>{
                            this._source.type === "raster-dem" && M.dem && this._backfillDEM(M),
                            S(z, M)
                        }
                        )
                    }
                    , a)
                }
            }
            function YE(s, n) {
                let a = Math.abs(2 * s.wrap) - +(s.wrap < 0)
                  , u = Math.abs(2 * n.wrap) - +(n.wrap < 0);
                return s.overscaledZ - n.overscaledZ || u - a || n.canonical.y - s.canonical.y || n.canonical.x - s.canonical.x
            }
            function JE(s) {
                return s === "raster" || s === "image" || s === "video" || s === "custom"
            }
            function Rp(s, n) {
                let a = 1 << s.z;
                return [s.x / a + n, (s.x + 1) / a + n]
            }
            gu.maxOverzooming = 10,
            gu.maxUnderzooming = 3;
            class G_ {
                constructor(n, a, u) {
                    this._demTile = n,
                    this._dem = this._demTile.dem,
                    this._scale = a,
                    this._offset = u
                }
                static create(n, a, u) {
                    let f = u || n.findDEMTileFor(a);
                    if (!f || !f.dem)
                        return;
                    let g = f.dem
                      , y = f.tileID
                      , w = 1 << a.canonical.z - y.canonical.z;
                    return new G_(f,f.tileSize / kn / w,[(a.canonical.x / w - y.canonical.x) * g.dim, (a.canonical.y / w - y.canonical.y) * g.dim])
                }
                tileCoordToPixel(n, a) {
                    let u = a * this._scale + this._offset[1]
                      , f = Math.floor(n * this._scale + this._offset[0])
                      , g = Math.floor(u);
                    return new W(f,g)
                }
                getElevationAt(n, a, u, f) {
                    let g = n * this._scale + this._offset[0]
                      , y = a * this._scale + this._offset[1]
                      , w = Math.floor(g)
                      , S = Math.floor(y)
                      , M = this._dem;
                    return f = !!f,
                    u ? si(si(M.get(w, S, f), M.get(w, S + 1, f), y - S), si(M.get(w + 1, S, f), M.get(w + 1, S + 1, f), y - S), g - w) : M.get(w, S, f)
                }
                getElevationAtPixel(n, a, u) {
                    return this._dem.get(n, a, !!u)
                }
                getMeterToDEM(n) {
                    return (1 << this._demTile.tileID.canonical.z) * zo(1, n) * this._dem.stride
                }
            }
            class $E {
                constructor(n, a) {
                    this.tileID = n,
                    this.x = n.canonical.x,
                    this.y = n.canonical.y,
                    this.z = n.canonical.z,
                    this.grid = new Dl(kn,16,0),
                    this.featureIndexArray = new Gw,
                    this.promoteId = a
                }
                insert(n, a, u, f, g, y=0) {
                    let w = this.featureIndexArray.length;
                    this.featureIndexArray.emplaceBack(u, f, g, y);
                    let S = this.grid;
                    for (let M = 0; M < a.length; M++) {
                        let z = a[M]
                          , N = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
                        for (let B = 0; B < z.length; B++) {
                            let H = z[B];
                            N[0] = Math.min(N[0], H.x),
                            N[1] = Math.min(N[1], H.y),
                            N[2] = Math.max(N[2], H.x),
                            N[3] = Math.max(N[3], H.y)
                        }
                        N[0] < kn && N[1] < kn && N[2] >= 0 && N[3] >= 0 && S.insert(w, N[0], N[1], N[2], N[3])
                    }
                }
                loadVTLayers() {
                    if (!this.vtLayers) {
                        this.vtLayers = new Gx(new Ep(this.rawTileData)).layers,
                        this.sourceLayerCoder = new NE(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"]),
                        this.vtFeatures = {};
                        for (let n in this.vtLayers)
                            this.vtFeatures[n] = []
                    }
                    return this.vtLayers
                }
                query(n, a, u, f) {
                    this.loadVTLayers();
                    let g = n.params || {}
                      , y = Oh(g.filter)
                      , w = n.tileResult
                      , S = n.transform
                      , M = w.bufferedTilespaceBounds
                      , z = this.grid.query(M.min.x, M.min.y, M.max.x, M.max.y, (q,Q,de,Me)=>AT(w.bufferedTilespaceGeometry, q, Q, de, Me));
                    z.sort(pR);
                    let N = null;
                    S.elevation && z.length > 0 && (N = G_.create(S.elevation, this.tileID));
                    let B = {}, H;
                    for (let q = 0; q < z.length; q++) {
                        let Q = z[q];
                        if (Q === H)
                            continue;
                        H = Q;
                        let de = this.featureIndexArray.get(Q)
                          , Me = null;
                        this.loadMatchingFeature(B, de, y, g.layers, g.availableImages, a, u, f, (Pe,we,Le,Ue=0)=>(Me || (Me = Na(Pe, this.tileID.canonical, n.tileTransform)),
                        we.queryIntersectsFeature(w, Pe, Le, Me, this.z, n.transform, n.pixelPosMatrix, N, Ue)))
                    }
                    return B
                }
                loadMatchingFeature(n, a, u, f, g, y, w, S, M) {
                    let {featureIndex: z, bucketIndex: N, sourceLayerIndex: B, layoutVertexArrayOffset: H} = a
                      , q = this.bucketLayerIDs[N];
                    if (f && !function(Pe, we) {
                        for (let Le = 0; Le < Pe.length; Le++)
                            if (we.indexOf(Pe[Le]) >= 0)
                                return !0;
                        return !1
                    }(f, q))
                        return;
                    let Q = this.sourceLayerCoder.decode(B)
                      , de = this.vtLayers[Q].feature(z);
                    if (u.needGeometry) {
                        let Pe = du(de, !0);
                        if (!u.filter(new $e(this.tileID.overscaledZ), Pe, this.tileID.canonical))
                            return
                    } else if (!u.filter(new $e(this.tileID.overscaledZ), de))
                        return;
                    let Me = this.getId(de, Q);
                    for (let Pe = 0; Pe < q.length; Pe++) {
                        let we = q[Pe];
                        if (f && f.indexOf(we) < 0)
                            continue;
                        let Le = y[we];
                        if (!Le)
                            continue;
                        let Ue = {};
                        Me !== void 0 && S && (Ue = S.getState(Le.sourceLayer || "_geojsonTileLayer", Me));
                        let Ne = Ke({}, w[we]);
                        Ne.paint = QE(Ne.paint, Le.paint, de, Ue, g),
                        Ne.layout = QE(Ne.layout, Le.layout, de, Ue, g);
                        let at = !M || M(de, Le, Ue, H);
                        if (!at)
                            continue;
                        let it = new FE(de,this.z,this.x,this.y,Me);
                        it.layer = Ne;
                        let _t = n[we];
                        _t === void 0 && (_t = n[we] = []),
                        _t.push({
                            featureIndex: z,
                            feature: it,
                            intersectionZ: at
                        })
                    }
                }
                lookupSymbolFeatures(n, a, u, f, g, y, w, S) {
                    let M = {};
                    this.loadVTLayers();
                    let z = Oh(g);
                    for (let N of n)
                        this.loadMatchingFeature(M, {
                            bucketIndex: u,
                            sourceLayerIndex: f,
                            featureIndex: N,
                            layoutVertexArrayOffset: 0
                        }, z, y, w, S, a);
                    return M
                }
                loadFeature(n) {
                    let {featureIndex: a, sourceLayerIndex: u} = n;
                    this.loadVTLayers();
                    let f = this.sourceLayerCoder.decode(u)
                      , g = this.vtFeatures[f];
                    if (g[a])
                        return g[a];
                    let y = this.vtLayers[f].feature(a);
                    return g[a] = y,
                    y
                }
                hasLayer(n) {
                    for (let a of this.bucketLayerIDs)
                        for (let u of a)
                            if (n === u)
                                return !0;
                    return !1
                }
                getId(n, a) {
                    let u = n.id;
                    if (this.promoteId) {
                        let f = typeof this.promoteId == "string" ? this.promoteId : this.promoteId[a];
                        f != null && (u = n.properties[f]),
                        typeof u == "boolean" && (u = Number(u))
                    }
                    return u
                }
            }
            function QE(s, n, a, u, f) {
                return xn(s, (g,y)=>{
                    let w = n instanceof st ? n.get(y) : null;
                    return w && w.evaluate ? w.evaluate(a, u, f) : w
                }
                )
            }
            function pR(s, n) {
                return n - s
            }
            cn($E, "FeatureIndex", {
                omit: ["rawTileData", "sourceLayerCoder"]
            });
            class eS {
                constructor(n, a) {
                    this.width = n,
                    this.height = a,
                    this.nextRow = 0,
                    this.image = new Fa({
                        width: n,
                        height: a
                    }),
                    this.positions = {},
                    this.uploaded = !1
                }
                getDash(n, a) {
                    let u = this.getKey(n, a);
                    return this.positions[u]
                }
                trim() {
                    let n = this.width
                      , a = this.height = Ye(this.nextRow);
                    this.image.resize({
                        width: n,
                        height: a
                    })
                }
                getKey(n, a) {
                    return n.join(",") + a
                }
                getDashRanges(n, a, u) {
                    let f = []
                      , g = n.length % 2 == 1 ? -n[n.length - 1] * u : 0
                      , y = n[0] * u
                      , w = !0;
                    f.push({
                        left: g,
                        right: y,
                        isDash: w,
                        zeroLength: n[0] === 0
                    });
                    let S = n[0];
                    for (let M = 1; M < n.length; M++) {
                        w = !w;
                        let z = n[M];
                        g = S * u,
                        S += z,
                        y = S * u,
                        f.push({
                            left: g,
                            right: y,
                            isDash: w,
                            zeroLength: z === 0
                        })
                    }
                    return f
                }
                addRoundDash(n, a, u) {
                    let f = a / 2;
                    for (let g = -u; g <= u; g++) {
                        let y = this.width * (this.nextRow + u + g)
                          , w = 0
                          , S = n[w];
                        for (let M = 0; M < this.width; M++) {
                            M / S.right > 1 && (S = n[++w]);
                            let z = Math.abs(M - S.left), N = Math.abs(M - S.right), B = Math.min(z, N), H, q = g / u * (f + 1);
                            if (S.isDash) {
                                let Q = f - Math.abs(q);
                                H = Math.sqrt(B * B + Q * Q)
                            } else
                                H = f - Math.sqrt(B * B + q * q);
                            this.image.data[y + M] = Math.max(0, Math.min(255, H + 128))
                        }
                    }
                }
                addRegularDash(n, a) {
                    for (let S = n.length - 1; S >= 0; --S) {
                        let M = n[S]
                          , z = n[S + 1];
                        M.zeroLength ? n.splice(S, 1) : z && z.isDash === M.isDash && (z.left = M.left,
                        n.splice(S, 1))
                    }
                    let u = n[0]
                      , f = n[n.length - 1];
                    u.isDash === f.isDash && (u.left = f.left - this.width,
                    f.right = u.right + this.width);
                    let g = this.width * this.nextRow
                      , y = 0
                      , w = n[y];
                    for (let S = 0; S < this.width; S++) {
                        S / w.right > 1 && (w = n[++y]);
                        let M = Math.abs(S - w.left)
                          , z = Math.abs(S - w.right)
                          , N = Math.min(M, z);
                        this.image.data[g + S] = Math.max(0, Math.min(255, (w.isDash ? N : -N) + a + 128))
                    }
                }
                addDash(n, a) {
                    let u = this.getKey(n, a);
                    if (this.positions[u])
                        return this.positions[u];
                    let f = a === "round"
                      , g = f ? 7 : 0
                      , y = 2 * g + 1;
                    if (this.nextRow + y > this.height)
                        return ut("LineAtlas out of space"),
                        null;
                    n.length === 0 && n.push(1);
                    let w = 0;
                    for (let z = 0; z < n.length; z++)
                        n[z] < 0 && (ut("Negative value is found in line dasharray, replacing values with 0"),
                        n[z] = 0),
                        w += n[z];
                    if (w !== 0) {
                        let z = this.width / w
                          , N = this.getDashRanges(n, this.width, z);
                        f ? this.addRoundDash(N, z, g) : this.addRegularDash(N, a === "square" ? .5 * z : 0)
                    }
                    let S = this.nextRow + g;
                    this.nextRow += y;
                    let M = {
                        tl: [S, g],
                        br: [w, 0]
                    };
                    return this.positions[u] = M,
                    M
                }
            }
            cn(eS, "LineAtlas");
            class tS {
                constructor(n) {
                    let a = {}
                      , u = [];
                    for (let w in n) {
                        let S = n[w]
                          , M = a[w] = {};
                        for (let z in S.glyphs) {
                            let N = S.glyphs[+z];
                            if (!N || N.bitmap.width === 0 || N.bitmap.height === 0)
                                continue;
                            let B = N.metrics.localGlyph ? 2 : 1
                              , H = {
                                x: 0,
                                y: 0,
                                w: N.bitmap.width + 2 * B,
                                h: N.bitmap.height + 2 * B
                            };
                            u.push(H),
                            M[z] = H
                        }
                    }
                    let {w: f, h: g} = jx(u)
                      , y = new Fa({
                        width: f || 1,
                        height: g || 1
                    });
                    for (let w in n) {
                        let S = n[w];
                        for (let M in S.glyphs) {
                            let z = S.glyphs[+M];
                            if (!z || z.bitmap.width === 0 || z.bitmap.height === 0)
                                continue;
                            let N = a[w][M]
                              , B = z.metrics.localGlyph ? 2 : 1;
                            Fa.copy(z.bitmap, y, {
                                x: 0,
                                y: 0
                            }, {
                                x: N.x + B,
                                y: N.y + B
                            }, z.bitmap)
                        }
                    }
                    this.image = y,
                    this.positions = a
                }
            }
            cn(tS, "GlyphAtlas");
            class mR {
                constructor(n) {
                    this.tileID = new xs(n.tileID.overscaledZ,n.tileID.wrap,n.tileID.canonical.z,n.tileID.canonical.x,n.tileID.canonical.y),
                    this.tileZoom = n.tileZoom,
                    this.uid = n.uid,
                    this.zoom = n.zoom,
                    this.canonical = n.tileID.canonical,
                    this.pixelRatio = n.pixelRatio,
                    this.tileSize = n.tileSize,
                    this.source = n.source,
                    this.overscaling = this.tileID.overscaleFactor(),
                    this.showCollisionBoxes = n.showCollisionBoxes,
                    this.collectResourceTiming = !!n.collectResourceTiming,
                    this.returnDependencies = !!n.returnDependencies,
                    this.promoteId = n.promoteId,
                    this.enableTerrain = !!n.enableTerrain,
                    this.isSymbolTile = n.isSymbolTile,
                    this.tileTransform = mu(n.tileID.canonical, n.projection),
                    this.projection = n.projection
                }
                parse(n, a, u, f, g) {
                    this.status = "parsing",
                    this.data = n,
                    this.collisionBoxArray = new ux;
                    let y = new NE(Object.keys(n.layers).sort())
                      , w = new $E(this.tileID,this.promoteId);
                    w.bucketLayerIDs = [];
                    let S = {}
                      , M = new eS(256,256)
                      , z = {
                        featureIndex: w,
                        iconDependencies: {},
                        patternDependencies: {},
                        glyphDependencies: {},
                        lineAtlas: M,
                        availableImages: u
                    }
                      , N = a.familiesBySource[this.source];
                    for (let Ue in N) {
                        let Ne = n.layers[Ue];
                        if (!Ne)
                            continue;
                        let at = !1
                          , it = !1;
                        for (let dt of N[Ue])
                            dt[0].type === "symbol" ? at = !0 : it = !0;
                        if (this.isSymbolTile === !0 && !at || this.isSymbolTile === !1 && !it)
                            continue;
                        Ne.version === 1 && ut(`Vector tile source "${this.source}" layer "${Ue}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
                        let _t = y.encode(Ue)
                          , Ot = [];
                        for (let dt = 0; dt < Ne.length; dt++) {
                            let yt = Ne.feature(dt)
                              , Tt = w.getId(yt, Ue);
                            Ot.push({
                                feature: yt,
                                id: Tt,
                                index: dt,
                                sourceLayerIndex: _t
                            })
                        }
                        for (let dt of N[Ue]) {
                            let yt = dt[0];
                            this.isSymbolTile !== void 0 && yt.type === "symbol" !== this.isSymbolTile || yt.minzoom && this.zoom < Math.floor(yt.minzoom) || yt.maxzoom && this.zoom >= yt.maxzoom || yt.visibility !== "none" && (lv(dt, this.zoom, u),
                            (S[yt.id] = yt.createBucket({
                                index: w.bucketLayerIDs.length,
                                layers: dt,
                                zoom: this.zoom,
                                canonical: this.canonical,
                                pixelRatio: this.pixelRatio,
                                overscaling: this.overscaling,
                                collisionBoxArray: this.collisionBoxArray,
                                sourceLayerIndex: _t,
                                sourceID: this.source,
                                enableTerrain: this.enableTerrain,
                                projection: this.projection.spec,
                                availableImages: u
                            })).populate(Ot, z, this.tileID.canonical, this.tileTransform),
                            w.bucketLayerIDs.push(dt.map(Tt=>Tt.id)))
                        }
                    }
                    let B, H, q, Q;
                    M.trim();
                    let de = {
                        type: "maybePrepare",
                        isSymbolTile: this.isSymbolTile,
                        zoom: this.zoom
                    }
                      , Me = xn(z.glyphDependencies, Ue=>Object.keys(Ue).map(Number));
                    Object.keys(Me).length ? f.send("getGlyphs", {
                        uid: this.uid,
                        stacks: Me
                    }, (Ue,Ne)=>{
                        B || (B = Ue,
                        H = Ne,
                        Le.call(this))
                    }
                    , void 0, !1, de) : H = {};
                    let Pe = Object.keys(z.iconDependencies);
                    Pe.length ? f.send("getImages", {
                        icons: Pe,
                        source: this.source,
                        tileID: this.tileID,
                        type: "icons"
                    }, (Ue,Ne)=>{
                        B || (B = Ue,
                        q = Ne,
                        Le.call(this))
                    }
                    , void 0, !1, de) : q = {};
                    let we = Object.keys(z.patternDependencies);
                    function Le() {
                        if (B)
                            return g(B);
                        if (H && q && Q) {
                            let Ue = new tS(H)
                              , Ne = new uE(q,Q);
                            for (let at in S) {
                                let it = S[at];
                                it instanceof Bl ? (lv(it.layers, this.zoom, u),
                                HL(it, H, Ue.positions, q, Ne.iconPositions, this.showCollisionBoxes, u, this.tileID.canonical, this.tileZoom, this.projection)) : it.hasPattern && (it instanceof A_ || it instanceof b_ || it instanceof vp) && (lv(it.layers, this.zoom, u),
                                it.addFeatures(z, this.tileID.canonical, Ne.patternPositions, u, this.tileTransform))
                            }
                            this.status = "done",
                            g(null, {
                                buckets: tt(S).filter(at=>!at.isEmpty()),
                                featureIndex: w,
                                collisionBoxArray: this.collisionBoxArray,
                                glyphAtlasImage: Ue.image,
                                lineAtlas: M,
                                imageAtlas: Ne,
                                glyphMap: this.returnDependencies ? H : null,
                                iconMap: this.returnDependencies ? q : null,
                                glyphPositions: this.returnDependencies ? Ue.positions : null
                            })
                        }
                    }
                    we.length ? f.send("getImages", {
                        icons: we,
                        source: this.source,
                        tileID: this.tileID,
                        type: "patterns"
                    }, (Ue,Ne)=>{
                        B || (B = Ue,
                        Q = Ne,
                        Le.call(this))
                    }
                    , void 0, !1, de) : Q = {},
                    Le.call(this)
                }
            }
            function lv(s, n, a) {
                let u = new $e(n);
                for (let f of s)
                    f.recalculate(u, a)
            }
            class nS {
                constructor(n) {
                    this.entries = {},
                    this.scheduler = n
                }
                request(n, a, u, f) {
                    let g = this.entries[n] = this.entries[n] || {
                        callbacks: []
                    };
                    if (g.result) {
                        let[y,w] = g.result;
                        return this.scheduler ? this.scheduler.add(()=>{
                            f(y, w)
                        }
                        , a) : f(y, w),
                        ()=>{}
                    }
                    return g.callbacks.push(f),
                    g.cancel || (g.cancel = u((y,w)=>{
                        g.result = [y, w];
                        for (let S of g.callbacks)
                            this.scheduler ? this.scheduler.add(()=>{
                                S(y, w)
                            }
                            , a) : S(y, w);
                        setTimeout(()=>delete this.entries[n], 3e3)
                    }
                    )),
                    ()=>{
                        g.result || (g.callbacks = g.callbacks.filter(y=>y !== f),
                        g.callbacks.length || (g.cancel(),
                        delete this.entries[n]))
                    }
                }
            }
            function iS(s, n, a) {
                let u = JSON.stringify(s.request);
                return s.data && (this.deduped.entries[u] = {
                    result: [null, s.data]
                }),
                this.deduped.request(u, {
                    type: "parseTile",
                    isSymbolTile: s.isSymbolTile,
                    zoom: s.tileZoom
                }, f=>{
                    let g = Wt(s.request, (y,w,S,M)=>{
                        y ? f(y) : w && f(null, {
                            vectorTile: a ? void 0 : new Gx(new Ep(w)),
                            rawData: w,
                            cacheControl: S,
                            expires: M
                        })
                    }
                    );
                    return ()=>{
                        g.cancel(),
                        f()
                    }
                }
                , n)
            }
            i.ARRAY_TYPE = Ns,
            i.AUTH_ERR_MSG = Ln,
            i.Aabb = ys,
            i.Actor = class {
                constructor(s, n, a) {
                    this.target = s,
                    this.parent = n,
                    this.mapId = a,
                    this.callbacks = {},
                    this.cancelCallbacks = {},
                    gt(["receive"], this),
                    this.target.addEventListener("message", this.receive, !1),
                    this.globalScope = on() ? s : v,
                    this.scheduler = new uR
                }
                send(s, n, a, u, f=!1, g) {
                    let y = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);
                    a && (a.metadata = g,
                    this.callbacks[y] = a);
                    let w = kt(this.globalScope) ? void 0 : [];
                    return this.target.postMessage({
                        id: y,
                        type: s,
                        hasCallback: !!a,
                        targetMapId: u,
                        mustQueue: f,
                        sourceMapId: this.mapId,
                        data: eu(n, w)
                    }, w),
                    {
                        cancel: ()=>{
                            a && delete this.callbacks[y],
                            this.target.postMessage({
                                id: y,
                                type: "<cancel>",
                                targetMapId: u,
                                sourceMapId: this.mapId
                            })
                        }
                    }
                }
                receive(s) {
                    let n = s.data
                      , a = n.id;
                    if (a && (!n.targetMapId || this.mapId === n.targetMapId))
                        if (n.type === "<cancel>") {
                            let u = this.cancelCallbacks[a];
                            delete this.cancelCallbacks[a],
                            u && u.cancel()
                        } else if (n.mustQueue || on()) {
                            let u = this.callbacks[a];
                            this.cancelCallbacks[a] = this.scheduler.add(()=>this.processTask(a, n), u && u.metadata || {
                                type: "message"
                            })
                        } else
                            this.processTask(a, n)
                }
                processTask(s, n) {
                    if (n.type === "<response>") {
                        let a = this.callbacks[s];
                        delete this.callbacks[s],
                        a && (n.error ? a(tu(n.error)) : a(null, tu(n.data)))
                    } else {
                        let a = kt(this.globalScope) ? void 0 : []
                          , u = n.hasCallback ? (g,y)=>{
                            delete this.cancelCallbacks[s],
                            this.target.postMessage({
                                id: s,
                                type: "<response>",
                                sourceMapId: this.mapId,
                                error: g ? eu(g) : null,
                                data: eu(y, a)
                            }, a)
                        }
                        : g=>{}
                          , f = tu(n.data);
                        if (this.parent[n.type])
                            this.parent[n.type](n.sourceMapId, f, u);
                        else if (this.parent.getWorkerSource) {
                            let g = n.type.split(".");
                            this.parent.getWorkerSource(n.sourceMapId, g[0], f.source)[g[1]](f, u)
                        } else
                            u(new Error(`Could not find function ${n.type}`))
                    }
                }
                remove() {
                    this.scheduler.remove(),
                    this.target.removeEventListener("message", this.receive, !1)
                }
            }
            ,
            i.CanonicalTileID = S_,
            i.Color = nr,
            i.ColorMode = la,
            i.CullFaceMode = Oo,
            i.DEMData = V_,
            i.DataConstantProperty = Je,
            i.DedupedRequest = nS,
            i.DepthMode = hd,
            i.EXTENT = kn,
            i.Elevation = class {
                isDataAvailableAtPoint(s) {
                    let n = this._source();
                    if (this.isUsingMockSource() || !n || s.y < 0 || s.y > 1)
                        return !1;
                    let a = n.getSource().maxzoom
                      , u = 1 << a
                      , f = Math.floor(s.x)
                      , g = Math.floor((s.x - f) * u)
                      , y = Math.floor(s.y * u)
                      , w = this.findDEMTileFor(new xs(a,f,a,g,y));
                    return !(!w || !w.dem)
                }
                getAtPointOrZero(s, n=0) {
                    return this.getAtPoint(s, n) || 0
                }
                getAtPoint(s, n, a=!0) {
                    if (this.isUsingMockSource())
                        return null;
                    n == null && (n = null);
                    let u = this._source();
                    if (!u || s.y < 0 || s.y > 1)
                        return n;
                    let f = u.getSource().maxzoom
                      , g = 1 << f
                      , y = Math.floor(s.x)
                      , w = s.x - y
                      , S = new xs(f,y,f,Math.floor(w * g),Math.floor(s.y * g))
                      , M = this.findDEMTileFor(S);
                    if (!M || !M.dem)
                        return n;
                    let z = M.dem
                      , N = 1 << M.tileID.canonical.z
                      , B = (w * N - M.tileID.canonical.x) * z.dim
                      , H = (s.y * N - M.tileID.canonical.y) * z.dim
                      , q = Math.floor(B)
                      , Q = Math.floor(H);
                    return (a ? this.exaggeration() : 1) * si(si(z.get(q, Q), z.get(q, Q + 1), H - Q), si(z.get(q + 1, Q), z.get(q + 1, Q + 1), H - Q), B - q)
                }
                getAtTileOffset(s, n, a) {
                    let u = 1 << s.canonical.z;
                    return this.getAtPointOrZero(new $h(s.wrap + (s.canonical.x + n / kn) / u,(s.canonical.y + a / kn) / u))
                }
                getAtTileOffsetFunc(s, n, a, u) {
                    return f=>{
                        let g = this.getAtTileOffset(s, f.x, f.y)
                          , y = u.upVector(s.canonical, f.x, f.y);
                        return Ys(y, y, g * u.upVectorScale(s.canonical, n, a).metersToTile),
                        y
                    }
                }
                getForTilePoints(s, n, a, u) {
                    if (this.isUsingMockSource())
                        return !1;
                    let f = G_.create(this, s, u);
                    return !!f && (n.forEach(g=>{
                        g[2] = this.exaggeration() * f.getElevationAt(g[0], g[1], a)
                    }
                    ),
                    !0)
                }
                getMinMaxForTile(s) {
                    if (this.isUsingMockSource())
                        return null;
                    let n = this.findDEMTileFor(s);
                    if (!n || !n.dem)
                        return null;
                    let a = n.dem.tree
                      , u = n.tileID
                      , f = 1 << s.canonical.z - u.canonical.z
                      , g = s.canonical.x / f - u.canonical.x
                      , y = s.canonical.y / f - u.canonical.y
                      , w = 0;
                    for (let S = 0; S < s.canonical.z - u.canonical.z && !a.leaves[w]; S++) {
                        g *= 2,
                        y *= 2;
                        let M = 2 * Math.floor(y) + Math.floor(g);
                        w = a.childOffsets[w] + M,
                        g %= 1,
                        y %= 1
                    }
                    return {
                        min: this.exaggeration() * a.minimums[w],
                        max: this.exaggeration() * a.maximums[w]
                    }
                }
                getMinElevationBelowMSL() {
                    throw new Error("Pure virtual method called.")
                }
                raycast(s, n, a) {
                    throw new Error("Pure virtual method called.")
                }
                pointCoordinate(s) {
                    throw new Error("Pure virtual method called.")
                }
                _source() {
                    throw new Error("Pure virtual method called.")
                }
                isUsingMockSource() {
                    throw new Error("Pure virtual method called.")
                }
                exaggeration() {
                    throw new Error("Pure virtual method called.")
                }
                findDEMTileFor(s) {
                    throw new Error("Pure virtual method called.")
                }
                get visibleDemTiles() {
                    throw new Error("Getter must be implemented in subclass.")
                }
            }
            ,
            i.ErrorEvent = ar,
            i.EvaluationParameters = $e,
            i.Event = On,
            i.Evented = pr,
            i.FillExtrusionBucket = vp,
            i.Frustum = wx,
            i.FrustumCorners = bx,
            i.GLOBE_RADIUS = ta,
            i.GLOBE_SCALE_MATCH_LATITUDE = 45,
            i.GLOBE_ZOOM_THRESHOLD_MAX = 6,
            i.GLOBE_ZOOM_THRESHOLD_MIN = 5,
            i.GlobeSharedBuffers = class {
                constructor(s) {
                    this._createGrid(s),
                    this._createPoles(s)
                }
                destroy() {
                    this._poleIndexBuffer.destroy(),
                    this._gridBuffer.destroy(),
                    this._gridIndexBuffer.destroy(),
                    this._poleNorthVertexBuffer.destroy(),
                    this._poleSouthVertexBuffer.destroy();
                    for (let s of this._poleSegments)
                        s.destroy();
                    for (let s of this._gridSegments)
                        s.withSkirts.destroy(),
                        s.withoutSkirts.destroy();
                    if (this._wireframeIndexBuffer) {
                        this._wireframeIndexBuffer.destroy();
                        for (let s of this._wireframeSegments)
                            s.destroy()
                    }
                }
                _fillGridMeshWithLods(s, n) {
                    let a = new En
                      , u = new Xr
                      , f = []
                      , g = s + 1 + 2
                      , y = n[0] + 1
                      , w = n[0] + 1 + (1 + n.length)
                      , S = (M,z,N)=>{
                        let B = M === g - 1 ? M - 2 : M === 0 ? M : M - 1;
                        return B += N ? 24575 : 0,
                        [B, z]
                    }
                    ;
                    for (let M = 0; M < g; ++M)
                        a.emplaceBack(...S(M, 0, !0));
                    for (let M = 0; M < y; ++M)
                        for (let z = 0; z < g; ++z)
                            a.emplaceBack(...S(z, M, (z === 0 || z === g - 1) && !0));
                    for (let M = 0; M < n.length; ++M) {
                        let z = n[M];
                        for (let N = 0; N < g; ++N)
                            a.emplaceBack(...S(N, z, !0))
                    }
                    for (let M = 0; M < n.length; ++M) {
                        let z = u.length
                          , N = n[M] + 1 + 2
                          , B = new Xr;
                        for (let Q = 0; Q < N - 1; Q++) {
                            let de = Q === N - 2
                              , Me = de ? g * (w - n.length + M - Q) : g;
                            for (let Pe = 0; Pe < g - 1; Pe++) {
                                let we = Q * g + Pe;
                                Q === 0 || de || Pe === 0 || Pe === g - 2 ? (B.emplaceBack(we + 1, we, we + Me),
                                B.emplaceBack(we + Me, we + Me + 1, we + 1)) : (u.emplaceBack(we + 1, we, we + Me),
                                u.emplaceBack(we + Me, we + Me + 1, we + 1))
                            }
                        }
                        let H = cr.simpleSegment(0, z, a.length, u.length - z);
                        for (let Q = 0; Q < B.uint16.length; Q += 3)
                            u.emplaceBack(B.uint16[Q], B.uint16[Q + 1], B.uint16[Q + 2]);
                        let q = cr.simpleSegment(0, z, a.length, u.length - z);
                        f.push({
                            withoutSkirts: H,
                            withSkirts: q
                        })
                    }
                    return {
                        vertices: a,
                        indices: u,
                        segments: f
                    }
                }
                _createGrid(s) {
                    let n = this._fillGridMeshWithLods(uu, up);
                    this._gridSegments = n.segments,
                    this._gridBuffer = s.createVertexBuffer(n.vertices, cp.members),
                    this._gridIndexBuffer = s.createIndexBuffer(n.indices, !0)
                }
                _createPoles(s) {
                    let n = new Xr;
                    for (let f = 0; f <= uu; f++)
                        n.emplaceBack(0, f + 1, f + 2);
                    this._poleIndexBuffer = s.createIndexBuffer(n, !0);
                    let a = new Os
                      , u = new Os;
                    this._poleSegments = [];
                    for (let f = 0, g = 0; f < 5; f++) {
                        let y = 360 / (1 << f);
                        a.emplaceBack(0, -ta, 0, .5, 0),
                        u.emplaceBack(0, -ta, 0, .5, 1);
                        for (let w = 0; w <= uu; w++) {
                            let S = w / uu
                              , M = si(0, y, S)
                              , [z,N,B] = Kh(uD, hD, M, ta);
                            a.emplaceBack(z, N, B, S, 0),
                            u.emplaceBack(z, N, B, S, 1)
                        }
                        this._poleSegments.push(cr.simpleSegment(g, 0, 66, 64)),
                        g += 66
                    }
                    this._poleNorthVertexBuffer = s.createVertexBuffer(a, lT, !1),
                    this._poleSouthVertexBuffer = s.createVertexBuffer(u, lT, !1)
                }
                getGridBuffers(s, n) {
                    return [this._gridBuffer, this._gridIndexBuffer, n ? this._gridSegments[s].withSkirts : this._gridSegments[s].withoutSkirts]
                }
                getPoleBuffers(s) {
                    return [this._poleNorthVertexBuffer, this._poleSouthVertexBuffer, this._poleIndexBuffer, this._poleSegments[s]]
                }
                getWirefameBuffers(s, n) {
                    if (!this._wireframeSegments) {
                        let a = new Qo
                          , u = uu
                          , f = u + 1 + 2
                          , g = 1;
                        this._wireframeSegments = [];
                        for (let y = 0, w = 0; y < up.length; y++) {
                            let S = up[y];
                            for (let z = g; z < S + g; z++)
                                for (let N = g; N < u + g; N++) {
                                    let B = z * f + N;
                                    a.emplaceBack(B, B + 1),
                                    a.emplaceBack(B, B + f),
                                    a.emplaceBack(B, B + f + 1)
                                }
                            let M = S * u * 3;
                            this._wireframeSegments.push(cr.simpleSegment(0, w, (S + 1) * f, M)),
                            w += M
                        }
                        this._wireframeIndexBuffer = s.createIndexBuffer(a)
                    }
                    return [this._gridBuffer, this._wireframeIndexBuffer, this._wireframeSegments[n]]
                }
            }
            ,
            i.GlyphManager = ld,
            i.ImagePosition = Xx,
            i.LivePerformanceUtils = ye,
            i.LngLat = oi,
            i.LngLatBounds = Ol,
            i.LocalGlyphMode = Kx,
            i.MAX_MERCATOR_LATITUDE = qr,
            i.MercatorCoordinate = $h,
            i.ONE_EM = Kr,
            i.OverscaledTileID = xs,
            i.PerformanceMarkers = Ze,
            i.Properties = Pt,
            i.RGBAImage = Fs,
            i.Ray = vx,
            i.RequestManager = class {
                constructor(s, n, a) {
                    this._transformRequestFn = s,
                    this._customAccessToken = n,
                    this._silenceAuthErrors = !!a,
                    this._createSkuToken()
                }
                _createSkuToken() {
                    let s = function() {
                        let n = "";
                        for (let a = 0; a < 10; a++)
                            n += "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"[Math.floor(62 * Math.random())];
                        return {
                            token: ["1", Z, n].join(""),
                            tokenExpiresAt: Date.now() + 432e5
                        }
                    }();
                    this._skuToken = s.token,
                    this._skuTokenExpiresAt = s.tokenExpiresAt
                }
                _isSkuTokenExpired() {
                    return Date.now() > this._skuTokenExpiresAt
                }
                transformRequest(s, n) {
                    return this._transformRequestFn && this._transformRequestFn(s, n) || {
                        url: s
                    }
                }
                normalizeStyleURL(s, n) {
                    if (!Zn(s))
                        return s;
                    let a = Vr(s);
                    return a.path = `/styles/v1 ${a.path}`,
                    this._makeAPIURL(a, this._customAccessToken || n)
                }
                normalizeGlyphsURL(s, n) {
                    if (!Zn(s))
                        return s;
                    let a = Vr(s);
                    return a.path = `/fonts/v1 ${a.path}`,
                    this._makeAPIURL(a, this._customAccessToken || n)
                }
                normalizeSourceURL(s, n, a, u) {
                    if (!Zn(s))
                        return s;
                    let f = Vr(s);
                    return f.path = `/v4/${f.authority}.json`,
                    f.params.push("secure"),
                    a && f.params.push(`language=${a}`),
                    u && f.params.push(`worldview=${u}`),
                    this._makeAPIURL(f, this._customAccessToken || n)
                }
                normalizeSpriteURL(s, n, a, u) {
                    let f = Vr(s);
                    return Zn(s) ? (f.path = `/styles/v1 ${f.path}/sprite ${n}${a}`,
                    this._makeAPIURL(f, this._customAccessToken || u)) : (f.path += `${n}${a}`,
                    Gr(f))
                }
                normalizeTileURL(s, n, a) {
                    if (this._isSkuTokenExpired() && this._createSkuToken(),
                    s && !Zn(s))
                        return s;
                    let u = Vr(s);
                    u.path = u.path.replace(/(\.(png|jpg)\d*)(?=$)/, `${n || a && u.authority !== "raster" && a === 512 ? "@2x" : ""}${C.supported ? ".webp" : "$1"}`),
                    u.authority === "raster" ? u.path = `/${A.RASTER_URL_PREFIX}${u.path}` : (u.path = u.path.replace(/^.+\/v4\//, "/"),
                    u.path = `/${A.TILE_URL_VERSION}${u.path}`);
                    let f = this._customAccessToken || function(g) {
                        for (let y of g) {
                            let w = y.match(/^access_token=(.*)$/);
                            if (w)
                                return w[1]
                        }
                        return null
                    }(u.params) || A.ACCESS_TOKEN;
                    return A.REQUIRE_ACCESS_TOKEN && f && this._skuToken && u.params.push(`sku=${this._skuToken}`),
                    this._makeAPIURL(u, f)
                }
                canonicalizeTileURL(s, n) {
                    let a = Vr(s);
                    if (!a.path.match(/^(\/v4\/|\/raster\/v1\/)/) || !a.path.match(/\.[\w]+$/))
                        return s;
                    let u = "mapbox://";
                    a.path.match(/^\/raster\/v1\//) ? u += `raster/${a.path.replace(`/${A.RASTER_URL_PREFIX}/`, "")}` : u += `tiles/${a.path.replace(`/${A.TILE_URL_VERSION}/`, "")}`;
                    let f = a.params;
                    return n && (f = f.filter(g=>!g.match(/^access_token=/))),
                    f.length && (u += `?${f.join("&")}`),
                    u
                }
                canonicalizeTileset(s, n) {
                    let a = !!n && Zn(n)
                      , u = [];
                    for (let f of s.tiles || [])
                        Vn(f) ? u.push(this.canonicalizeTileURL(f, a)) : u.push(f);
                    return u
                }
                _makeAPIURL(s, n) {
                    let a = "See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes"
                      , u = Vr(A.API_URL);
                    if (s.protocol = u.protocol,
                    s.authority = u.authority,
                    s.protocol === "http") {
                        let f = s.params.indexOf("secure");
                        f >= 0 && s.params.splice(f, 1)
                    }
                    if (u.path !== "/" && (s.path = `${u.path}${s.path}`),
                    !A.REQUIRE_ACCESS_TOKEN)
                        return Gr(s);
                    if (n = n || A.ACCESS_TOKEN,
                    !this._silenceAuthErrors) {
                        if (!n)
                            throw new Error(`An API access token is required to use Mapbox GL. ${a}`);
                        if (n[0] === "s")
                            throw new Error(`Use a public access token (pk.*) with Mapbox GL, not a secret access token (sk.*). ${a}`)
                    }
                    return s.params = s.params.filter(f=>f.indexOf("access_token") === -1),
                    s.params.push(`access_token=${n || ""}`),
                    Gr(s)
                }
            }
            ,
            i.ResourceType = Ct,
            i.SegmentVector = cr,
            i.SourceCache = gu,
            i.StencilMode = sv,
            i.StructArrayLayout1ui2 = ea,
            i.StructArrayLayout2f1f2i16 = Wr,
            i.StructArrayLayout2i4 = En,
            i.StructArrayLayout2ui4 = Qo,
            i.StructArrayLayout3f12 = jr,
            i.StructArrayLayout3ui6 = Xr,
            i.StructArrayLayout4i8 = Ti,
            i.StructArrayLayout5f20 = Os,
            i.Texture = Lp,
            i.Tile = iv,
            i.Transitionable = Vt,
            i.Uniform1f = a_,
            i.Uniform1i = class extends ka {
                constructor(s) {
                    super(s),
                    this.current = 0
                }
                set(s, n, a) {
                    this.fetchUniformLocation(s, n) && this.current !== a && (this.current = a,
                    this.gl.uniform1i(this.location, a))
                }
            }
            ,
            i.Uniform2f = class extends ka {
                constructor(s) {
                    super(s),
                    this.current = [0, 0]
                }
                set(s, n, a) {
                    this.fetchUniformLocation(s, n) && (a[0] === this.current[0] && a[1] === this.current[1] || (this.current = a,
                    this.gl.uniform2f(this.location, a[0], a[1])))
                }
            }
            ,
            i.Uniform3f = class extends ka {
                constructor(s) {
                    super(s),
                    this.current = [0, 0, 0]
                }
                set(s, n, a) {
                    this.fetchUniformLocation(s, n) && (a[0] === this.current[0] && a[1] === this.current[1] && a[2] === this.current[2] || (this.current = a,
                    this.gl.uniform3f(this.location, a[0], a[1], a[2])))
                }
            }
            ,
            i.Uniform4f = Xw,
            i.UniformColor = Zw,
            i.UniformMatrix2f = class extends ka {
                constructor(s) {
                    super(s),
                    this.current = K3
                }
                set(s, n, a) {
                    if (this.fetchUniformLocation(s, n)) {
                        for (let u = 0; u < 4; u++)
                            if (a[u] !== this.current[u]) {
                                this.current = a,
                                this.gl.uniformMatrix2fv(this.location, !1, a);
                                break
                            }
                    }
                }
            }
            ,
            i.UniformMatrix3f = class extends ka {
                constructor(s) {
                    super(s),
                    this.current = q3
                }
                set(s, n, a) {
                    if (this.fetchUniformLocation(s, n)) {
                        for (let u = 0; u < 9; u++)
                            if (a[u] !== this.current[u]) {
                                this.current = a,
                                this.gl.uniformMatrix3fv(this.location, !1, a);
                                break
                            }
                    }
                }
            }
            ,
            i.UniformMatrix4f = class extends ka {
                constructor(s) {
                    super(s),
                    this.current = Z3
                }
                set(s, n, a) {
                    if (this.fetchUniformLocation(s, n)) {
                        if (a[12] !== this.current[12] || a[0] !== this.current[0])
                            return this.current = a,
                            void this.gl.uniformMatrix4fv(this.location, !1, a);
                        for (let u = 1; u < 16; u++)
                            if (a[u] !== this.current[u]) {
                                this.current = a,
                                this.gl.uniformMatrix4fv(this.location, !1, a);
                                break
                            }
                    }
                }
            }
            ,
            i.UnwrappedTileID = JT,
            i.ValidationError = rn,
            i.VectorTileFeature = T_,
            i.VectorTileWorkerSource = class extends pr {
                constructor(s, n, a, u, f) {
                    super(),
                    this.actor = s,
                    this.layerIndex = n,
                    this.availableImages = a,
                    this.loadVectorData = f || iS,
                    this.loading = {},
                    this.loaded = {},
                    this.deduped = new nS(s.scheduler),
                    this.isSpriteLoaded = u,
                    this.scheduler = s.scheduler
                }
                loadTile(s, n) {
                    let a = s.uid
                      , u = s && s.request
                      , f = u && u.collectResourceTiming
                      , g = this.loading[a] = new mR(s);
                    g.abort = this.loadVectorData(s, (y,w)=>{
                        let S = !this.loading[a];
                        if (delete this.loading[a],
                        S || y || !w)
                            return g.status = "done",
                            S || (this.loaded[a] = g),
                            n(y);
                        let M = w.rawData
                          , z = {};
                        w.expires && (z.expires = w.expires),
                        w.cacheControl && (z.cacheControl = w.cacheControl),
                        g.vectorTile = w.vectorTile || new Gx(new Ep(M));
                        let N = ()=>{
                            g.parse(g.vectorTile, this.layerIndex, this.availableImages, this.actor, (B,H)=>{
                                if (B || !H)
                                    return n(B);
                                let q = {};
                                if (f) {
                                    let Q = ze(u);
                                    Q.length > 0 && (q.resourceTiming = JSON.parse(JSON.stringify(Q)))
                                }
                                n(null, Ke({
                                    rawTileData: M.slice(0)
                                }, H, z, q))
                            }
                            )
                        }
                        ;
                        this.isSpriteLoaded ? N() : this.once("isSpriteLoaded", ()=>{
                            this.scheduler ? this.scheduler.add(N, {
                                type: "parseTile",
                                isSymbolTile: s.isSymbolTile,
                                zoom: s.tileZoom
                            }) : N()
                        }
                        ),
                        this.loaded = this.loaded || {},
                        this.loaded[a] = g
                    }
                    )
                }
                reloadTile(s, n) {
                    let a = this.loaded
                      , u = s.uid
                      , f = this;
                    if (a && a[u]) {
                        let g = a[u];
                        g.showCollisionBoxes = s.showCollisionBoxes,
                        g.enableTerrain = !!s.enableTerrain,
                        g.projection = s.projection,
                        g.tileTransform = mu(s.tileID.canonical, s.projection);
                        let y = (w,S)=>{
                            let M = g.reloadCallback;
                            M && (delete g.reloadCallback,
                            g.parse(g.vectorTile, f.layerIndex, this.availableImages, f.actor, M)),
                            n(w, S)
                        }
                        ;
                        g.status === "parsing" ? g.reloadCallback = y : g.status === "done" && (g.vectorTile ? g.parse(g.vectorTile, this.layerIndex, this.availableImages, this.actor, y) : y())
                    }
                }
                abortTile(s, n) {
                    let a = s.uid
                      , u = this.loading[a];
                    u && (u.abort && u.abort(),
                    delete this.loading[a]),
                    n()
                }
                removeTile(s, n) {
                    let a = this.loaded
                      , u = s.uid;
                    a && a[u] && delete a[u],
                    n()
                }
            }
            ,
            i.WritingMode = $s,
            i.ZoomDependentExpression = Ra,
            i.add = Oa,
            i.addDynamicAttributes = F_,
            i.adjoint = function(s, n) {
                var a = n[0]
                  , u = n[1]
                  , f = n[2]
                  , g = n[3]
                  , y = n[4]
                  , w = n[5]
                  , S = n[6]
                  , M = n[7]
                  , z = n[8];
                return s[0] = y * z - w * M,
                s[1] = f * M - u * z,
                s[2] = u * w - f * y,
                s[3] = w * S - g * z,
                s[4] = a * z - f * S,
                s[5] = f * g - a * w,
                s[6] = g * M - y * S,
                s[7] = u * S - a * M,
                s[8] = a * y - u * g,
                s
            }
            ,
            i.asyncAll = Be,
            i.bezier = be,
            i.bindAll = gt,
            i.boundsAttributes = UE,
            i.bufferConvexPolygon = function(s, n) {
                let a = [];
                for (let u = 0; u < s.length; u++) {
                    let f = ke(u - 1, -1, s.length - 1)
                      , g = ke(u + 1, -1, s.length - 1)
                      , y = s[u]
                      , w = s[g]
                      , S = s[f].sub(y).unit()
                      , M = w.sub(y).unit()
                      , z = M.angleWithSep(S.x, S.y)
                      , N = S.add(M).unit().mult(-1 * n / Math.sin(z / 2));
                    a.push(y.add(N))
                }
                return a
            }
            ,
            i.cacheEntryPossiblyAdded = function(s) {
                Ie++,
                Ie > ft && (s.getActor().send("enforceCacheSizeLimit", Qe),
                Ie = 0)
            }
            ,
            i.calculateGlobeLabelMatrix = function(s, n) {
                let {x: a, y: u} = s.point
                  , f = pT(a, u, s.worldSize / s._pixelsPerMercatorPixel, 0, 0);
                return au(f, f, Sx(na(n)))
            }
            ,
            i.calculateGlobeMatrix = function(s) {
                let {x: n, y: a} = s.point
                  , {lng: u, lat: f} = s._center;
                return pT(n, a, s.worldSize, u, f)
            }
            ,
            i.calculateGlobeMercatorMatrix = function(s) {
                let n = s.pixelsPerMeter
                  , a = n / zo(1, s.center.lat)
                  , u = Po(new Float64Array(16));
                return ip(u, u, [s.point.x, s.point.y, 0]),
                lu(u, u, [a, a, n]),
                Float32Array.from(u)
            }
            ,
            i.circumferenceAtLatitude = Mx,
            i.clamp = ae,
            i.clearTileCache = function(s) {
                if (!St())
                    return;
                let n = v.caches.delete(Qt);
                s && n.catch(s).then(()=>s())
            }
            ,
            i.clipLine = wE,
            i.clone = function(s) {
                var n = new Ns(16);
                return n[0] = s[0],
                n[1] = s[1],
                n[2] = s[2],
                n[3] = s[3],
                n[4] = s[4],
                n[5] = s[5],
                n[6] = s[6],
                n[7] = s[7],
                n[8] = s[8],
                n[9] = s[9],
                n[10] = s[10],
                n[11] = s[11],
                n[12] = s[12],
                n[13] = s[13],
                n[14] = s[14],
                n[15] = s[15],
                n
            }
            ,
            i.clone$1 = Bt,
            i.collisionCircleLayout = mL,
            i.config = A,
            i.conjugate = function(s, n) {
                return s[0] = -n[0],
                s[1] = -n[1],
                s[2] = -n[2],
                s[3] = n[3],
                s
            }
            ,
            i.create = function() {
                var s = new Ns(16);
                return Ns != Float32Array && (s[1] = 0,
                s[2] = 0,
                s[3] = 0,
                s[4] = 0,
                s[6] = 0,
                s[7] = 0,
                s[8] = 0,
                s[9] = 0,
                s[11] = 0,
                s[12] = 0,
                s[13] = 0,
                s[14] = 0),
                s[0] = 1,
                s[5] = 1,
                s[10] = 1,
                s[15] = 1,
                s
            }
            ,
            i.create$1 = Kw,
            i.createExpression = Al,
            i.createLayout = vn,
            i.createStyleLayer = function(s) {
                return s.type === "custom" ? new oR(s) : new lR[s.type](s)
            }
            ,
            i.cross = xx,
            i.degToRad = oe,
            i.distance = function(s, n) {
                return Math.hypot(n[0] - s[0], n[1] - s[1], n[2] - s[2])
            }
            ,
            i.div = function(s, n, a) {
                return s[0] = n[0] / a[0],
                s[1] = n[1] / a[1],
                s[2] = n[2] / a[2],
                s
            }
            ,
            i.dot = ho,
            i.earthRadius = fp,
            i.ease = te,
            i.easeCubicInOut = ne,
            i.ecefToLatLng = function([s,n,a]) {
                let u = Math.hypot(s, n, a)
                  , f = Math.atan2(s, a)
                  , g = .5 * Math.PI - Math.acos(-n / u);
                return new oi(ee(f),ee(g))
            }
            ,
            i.emitValidationErrors = Xg,
            i.endsWith = Tn,
            i.enforceCacheSizeLimit = function(s) {
                Mt(),
                xe && xe.then(n=>{
                    n.keys().then(a=>{
                        for (let u = 0; u < a.length - s; u++)
                            n.delete(a[u])
                    }
                    )
                }
                )
            }
            ,
            i.evaluateSizeForFeature = M_,
            i.evaluateSizeForZoom = rd,
            i.evaluateVariableOffset = ME,
            i.evented = De,
            i.exactEquals = function(s, n) {
                return s[0] === n[0] && s[1] === n[1] && s[2] === n[2] && s[3] === n[3]
            }
            ,
            i.exactEquals$1 = function(s, n) {
                return s[0] === n[0] && s[1] === n[1] && s[2] === n[2]
            }
            ,
            i.exported = Nn,
            i.exported$1 = C,
            i.extend = Ke,
            i.extend$1 = mr,
            i.fillExtrusionHeightLift = qT,
            i.filterObject = Dn,
            i.fromMat4 = function(s, n) {
                return s[0] = n[0],
                s[1] = n[1],
                s[2] = n[2],
                s[3] = n[4],
                s[4] = n[5],
                s[5] = n[6],
                s[6] = n[8],
                s[7] = n[9],
                s[8] = n[10],
                s
            }
            ,
            i.fromQuat = function(s, n) {
                var a = n[0]
                  , u = n[1]
                  , f = n[2]
                  , g = n[3]
                  , y = a + a
                  , w = u + u
                  , S = f + f
                  , M = a * y
                  , z = u * y
                  , N = u * w
                  , B = f * y
                  , H = f * w
                  , q = f * S
                  , Q = g * y
                  , de = g * w
                  , Me = g * S;
                return s[0] = 1 - N - q,
                s[1] = z + Me,
                s[2] = B - de,
                s[3] = 0,
                s[4] = z - Me,
                s[5] = 1 - M - q,
                s[6] = H + Q,
                s[7] = 0,
                s[8] = B + de,
                s[9] = H - Q,
                s[10] = 1 - M - N,
                s[11] = 0,
                s[12] = 0,
                s[13] = 0,
                s[14] = 0,
                s[15] = 1,
                s
            }
            ,
            i.fromRotation = function(s, n) {
                var a = Math.sin(n)
                  , u = Math.cos(n);
                return s[0] = u,
                s[1] = a,
                s[2] = 0,
                s[3] = -a,
                s[4] = u,
                s[5] = 0,
                s[6] = 0,
                s[7] = 0,
                s[8] = 1,
                s
            }
            ,
            i.fromScaling = Jw,
            i.furthestTileCorner = function(s) {
                let n = Math.round((s + 45 + 360) % 360 / 90) % 4;
                return j[n]
            }
            ,
            i.getAABBPointSquareDist = function(s, n, a) {
                let u = 0;
                for (let f = 0; f < 2; ++f) {
                    let g = a ? a[f] : 0;
                    s[f] > g && (u += (s[f] - g) * (s[f] - g)),
                    n[f] < g && (u += (g - n[f]) * (g - n[f]))
                }
                return u
            }
            ,
            i.getAnchorAlignment = qx,
            i.getAnchorJustification = Jx,
            i.getBounds = function(s) {
                let n = 1 / 0
                  , a = 1 / 0
                  , u = -1 / 0
                  , f = -1 / 0;
                for (let g of s)
                    n = Math.min(n, g.x),
                    a = Math.min(a, g.y),
                    u = Math.max(u, g.x),
                    f = Math.max(f, g.y);
                return {
                    min: new W(n,a),
                    max: new W(u,f)
                }
            }
            ,
            i.getColumn = zn,
            i.getGridMatrix = function(s, n, a, u) {
                let f = n.getNorth()
                  , g = n.getSouth()
                  , y = n.getWest()
                  , w = n.getEast()
                  , S = 1 << s.z
                  , M = w - y
                  , z = f - g
                  , N = M / uu
                  , B = -z / up[a]
                  , H = [0, N, 0, B, 0, 0, f, y, 0];
                if (s.z > 0) {
                    let q = 180 / u;
                    Yw(H, H, [q / M + 1, 0, 0, 0, q / z + 1, 0, -.5 * q / N, .5 * q / B, 1])
                }
                return H[2] = S,
                H[5] = s.x,
                H[8] = s.y,
                H
            }
            ,
            i.getImage = Jt,
            i.getJSON = function(s, n) {
                return Ge(Ke(s, {
                    type: "json"
                }), n)
            }
            ,
            i.getLatitudinalLod = function(s) {
                let n = qr - 5;
                s = ae(s, -n, n) / n * 90;
                let a = Math.pow(Math.abs(Math.sin(oe(s))), 3);
                return Math.round(a * (up.length - 1))
            }
            ,
            i.getMapSessionAPI = He,
            i.getPerformanceMeasurement = ze,
            i.getProjection = zE,
            i.getRTLTextPluginStatus = Ve,
            i.getReferrer = Kt,
            i.getTilePoint = function(s, {x: n, y: a}, u=0) {
                return new W(((n - u) * s.scale - s.x) * kn,(a * s.scale - s.y) * kn)
            }
            ,
            i.getTileVec3 = function(s, n, a=0) {
                return qh(((n.x - a) * s.scale - s.x) * kn, (n.y * s.scale - s.y) * kn, yT(n.z, n.y))
            }
            ,
            i.getVideo = function(s, n) {
                let a = v.document.createElement("video");
                a.muted = !0,
                a.onloadstart = function() {
                    n(null, a)
                }
                ;
                for (let u = 0; u < s.length; u++) {
                    let f = v.document.createElement("source");
                    Ut(s[u]) || (a.crossOrigin = "Anonymous"),
                    f.src = s[u],
                    a.appendChild(f)
                }
                return {
                    cancel: ()=>{}
                }
            }
            ,
            i.globeCenterToScreenPoint = function(s) {
                let n = [0, 0, 0]
                  , a = Po(new Float64Array(16));
                return au(a, s.pixelMatrix, s.globeMatrix),
                ir(n, n, a),
                new W(n[0],n[1])
            }
            ,
            i.globeDenormalizeECEF = Sx,
            i.globeECEFOrigin = function(s, n) {
                let a = [0, 0, 0];
                return ir(a, a, dp(na(n.canonical))),
                ir(a, a, s),
                a
            }
            ,
            i.globeMetersToEcef = h_,
            i.globeNormalizeECEF = dp,
            i.globePixelsToTileUnits = function(s, n) {
                return kn / (512 * Math.pow(2, s)) * f_(na(n))
            }
            ,
            i.globePoleMatrixForTile = function(s, n, a) {
                let u = Po(new Float64Array(16))
                  , f = (n / (1 << s) - .5) * Math.PI * 2;
                return u_(u, a.globeMatrix, f),
                Float32Array.from(u)
            }
            ,
            i.globeTileBounds = na,
            i.globeTiltAtLngLat = mT,
            i.globeToMercatorTransition = Jh,
            i.globeUseCustomAntiAliasing = function(s, n, a) {
                let u = Jh(a.zoom)
                  , f = s.style.map._antialias
                  , g = !!n.extStandardDerivatives
                  , y = n.extStandardDerivativesForceOff || s.terrain && s.terrain.exaggeration() > 0;
                return u === 0 && !f && !y && g
            }
            ,
            i.identity = Po,
            i.identity$1 = sT,
            i.invert = mx,
            i.isFullscreen = function() {
                return !!v.document.fullscreenElement || !!v.document.webkitFullscreenElement
            }
            ,
            i.isLngLatBehindGlobe = Ax,
            i.isMapAuthenticated = function(s) {
                return Re.has(s)
            }
            ,
            i.isMapboxURL = Zn,
            i.isSafariWithAntialiasingBug = function(s) {
                let n = s.navigator ? s.navigator.userAgent : null;
                return !!kt(s) && n && (n.match("Version/15.4") || n.match("Version/15.5") || n.match(/CPU (OS|iPhone OS) (15_4|15_5) like Mac OS X/))
            }
            ,
            i.latFromMercatorY = Zr,
            i.latLngToECEF = Yh,
            i.len = rD,
            i.length = rp,
            i.length$1 = function(s) {
                return Math.hypot(s[0], s[1], s[2], s[3])
            }
            ,
            i.lngFromMercatorX = Js,
            i.loadVectorTile = iS,
            i.makeRequest = Ge,
            i.mapValue = function(s, n, a, u, f) {
                return ae((s - n) / (a - n) * (f - u) + u, u, f)
            }
            ,
            i.mercatorScale = xT,
            i.mercatorXfromLng = ia,
            i.mercatorYfromLat = ra,
            i.mercatorZfromAltitude = zo,
            i.mul = nD,
            i.mul$1 = iD,
            i.multiply = au,
            i.multiply$1 = Yw,
            i.multiply$2 = eT,
            i.nextPowerOfTwo = Ye,
            i.normalize = _s,
            i.normalize$1 = sD,
            i.normalize$2 = iT,
            i.number = si,
            i.ortho = function(s, n, a, u, f, g, y) {
                var w = 1 / (n - a)
                  , S = 1 / (u - f)
                  , M = 1 / (g - y);
                return s[0] = -2 * w,
                s[1] = 0,
                s[2] = 0,
                s[3] = 0,
                s[4] = 0,
                s[5] = -2 * S,
                s[6] = 0,
                s[7] = 0,
                s[8] = 0,
                s[9] = 0,
                s[10] = 2 * M,
                s[11] = 0,
                s[12] = (n + a) * w,
                s[13] = (f + u) * S,
                s[14] = (y + g) * M,
                s[15] = 1,
                s
            }
            ,
            i.pbf = Ep,
            i.perspective = function(s, n, a, u, f) {
                var g, y = 1 / Math.tan(n / 2);
                return s[0] = y / a,
                s[1] = 0,
                s[2] = 0,
                s[3] = 0,
                s[4] = 0,
                s[5] = y,
                s[6] = 0,
                s[7] = 0,
                s[8] = 0,
                s[9] = 0,
                s[11] = -1,
                s[12] = 0,
                s[13] = 0,
                s[15] = 0,
                f != null && f !== 1 / 0 ? (s[10] = (f + u) * (g = 1 / (u - f)),
                s[14] = 2 * f * u * g) : (s[10] = -1,
                s[14] = -2 * u),
                s
            }
            ,
            i.pick = function(s, n) {
                let a = {};
                for (let u = 0; u < n.length; u++) {
                    let f = n[u];
                    f in s && (a[f] = s[f])
                }
                return a
            }
            ,
            i.plugin = Xe,
            i.pointGeometry = W,
            i.polesInViewport = function(s) {
                let n = Po(new Float64Array(16));
                au(n, s.pixelMatrix, s.globeMatrix);
                let a = [0, fo, 0]
                  , u = [0, po, 0];
                return ir(a, a, n),
                ir(u, u, n),
                [a[0] > 0 && a[0] <= s.width && a[1] > 0 && a[1] <= s.height && !Ax(s, new oi(s.center.lat,90)), u[0] > 0 && u[0] <= s.width && u[1] > 0 && u[1] <= s.height && !Ax(s, new oi(s.center.lat,-90))]
            }
            ,
            i.polygonContainsPoint = fu,
            i.polygonIntersectsBox = AT,
            i.polygonIntersectsPolygon = wT,
            i.polygonizeBounds = function(s, n, a=0, u=!0) {
                let f = new W(a,a)
                  , g = s.sub(f)
                  , y = n.add(f)
                  , w = [g, new W(y.x,g.y), y, new W(g.x,y.y)];
                return u && w.push(g.clone()),
                w
            }
            ,
            i.posAttributes = cp,
            i.postMapLoadEvent = $,
            i.postPerformanceEvent = ue,
            i.postTurnstileEvent = Y,
            i.potpack = jx,
            i.prevPowerOfTwo = function(s) {
                return s <= 1 ? 1 : Math.pow(2, Math.floor(Math.log(s) / Math.LN2))
            }
            ,
            i.radToDeg = ee,
            i.refProperties = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"],
            i.registerForPluginStateChange = function(s) {
                return s({
                    pluginStatus: ve,
                    pluginURL: re
                }),
                De.on("pluginStateChange", s),
                s
            }
            ,
            i.removeAuthState = function(s) {
                Re.delete(s)
            }
            ,
            i.renderColorRamp = zx,
            i.resample = vT,
            i.rotateX = gx,
            i.rotateX$1 = oT,
            i.rotateY = u_,
            i.rotateY$1 = aT,
            i.rotateZ = function(s, n, a) {
                var u = Math.sin(a)
                  , f = Math.cos(a)
                  , g = n[0]
                  , y = n[1]
                  , w = n[2]
                  , S = n[3]
                  , M = n[4]
                  , z = n[5]
                  , N = n[6]
                  , B = n[7];
                return n !== s && (s[8] = n[8],
                s[9] = n[9],
                s[10] = n[10],
                s[11] = n[11],
                s[12] = n[12],
                s[13] = n[13],
                s[14] = n[14],
                s[15] = n[15]),
                s[0] = g * f + M * u,
                s[1] = y * f + z * u,
                s[2] = w * f + N * u,
                s[3] = S * f + B * u,
                s[4] = M * f - g * u,
                s[5] = z * f - y * u,
                s[6] = N * f - w * u,
                s[7] = B * f - S * u,
                s
            }
            ,
            i.rotateZ$1 = function(s, n, a) {
                a *= .5;
                var u = n[0]
                  , f = n[1]
                  , g = n[2]
                  , y = n[3]
                  , w = Math.sin(a)
                  , S = Math.cos(a);
                return s[0] = u * S + f * w,
                s[1] = f * S - u * w,
                s[2] = g * S + y * w,
                s[3] = y * S - g * w,
                s
            }
            ,
            i.scale = lu,
            i.scale$1 = nT,
            i.scale$2 = Ys,
            i.scaleAndAdd = ap,
            i.set = function(s, n, a, u) {
                return s[0] = n,
                s[1] = a,
                s[2] = u,
                s
            }
            ,
            i.setCacheLimits = function(s, n) {
                Qe = s,
                ft = n
            }
            ,
            i.setColumn = function(s, n, a) {
                s[4 * n + 0] = a[0],
                s[4 * n + 1] = a[1],
                s[4 * n + 2] = a[2],
                s[4 * n + 3] = a[3]
            }
            ,
            i.setRTLTextPlugin = function(s, n, a=!1) {
                if (ve === le || ve === me || ve === pe)
                    throw new Error("setRTLTextPlugin cannot be called multiple times.");
                re = Nn.resolveURL(s),
                ve = le,
                ge = n,
                Ae(),
                a || Fe()
            }
            ,
            i.smoothstep = se,
            i.spec = ht,
            i.squaredLength = function(s) {
                var n = s[0]
                  , a = s[1]
                  , u = s[2];
                return n * n + a * a + u * u
            }
            ,
            i.storeAuthState = function(s, n) {
                n ? Re.add(s) : Re.delete(s)
            }
            ,
            i.sub = ko,
            i.subtract = yx,
            i.symbolSize = gL,
            i.tileAABB = function(s, n, a, u, f, g, y, w, S) {
                if (S.name === "globe")
                    return cD(s, n, new S_(a,u,f));
                let M = mu({
                    z: a,
                    x: u,
                    y: f
                }, S);
                return new ys([(g + M.x / M.scale) * n, n * (M.y / M.scale), y],[(g + M.x2 / M.scale) * n, n * (M.y2 / M.scale), w])
            }
            ,
            i.tileCornersToBounds = d_,
            i.tileTransform = mu,
            i.transformMat3 = function(s, n, a) {
                var u = n[0]
                  , f = n[1]
                  , g = n[2];
                return s[0] = u * a[0] + f * a[3] + g * a[6],
                s[1] = u * a[1] + f * a[4] + g * a[7],
                s[2] = u * a[2] + f * a[5] + g * a[8],
                s
            }
            ,
            i.transformMat4 = ir,
            i.transformMat4$1 = cu,
            i.transformQuat = tT,
            i.transitionTileAABBinECEF = hT,
            i.translate = ip,
            i.transpose = function(s, n) {
                if (s === n) {
                    var a = n[1]
                      , u = n[2]
                      , f = n[5];
                    s[1] = n[3],
                    s[2] = n[6],
                    s[3] = a,
                    s[5] = n[7],
                    s[6] = u,
                    s[7] = f
                } else
                    s[0] = n[0],
                    s[1] = n[3],
                    s[2] = n[6],
                    s[3] = n[1],
                    s[4] = n[4],
                    s[5] = n[7],
                    s[6] = n[2],
                    s[7] = n[5],
                    s[8] = n[8];
                return s
            }
            ,
            i.triggerPluginCompletionEvent = Ce,
            i.uniqueId = Et,
            i.updateGlobeVertexNormal = function(s, n, a, u, f) {
                let g = 5 * n + 2;
                s.float32[g + 0] = a,
                s.float32[g + 1] = u,
                s.float32[g + 2] = f
            }
            ,
            i.validateCustomStyleLayer = function(s) {
                let n = []
                  , a = s.id;
                return a === void 0 && n.push({
                    message: `layers.${a}: missing required property "id"`
                }),
                s.render === void 0 && n.push({
                    message: `layers.${a}: missing required method "render"`
                }),
                s.renderingMode && s.renderingMode !== "2d" && s.renderingMode !== "3d" && n.push({
                    message: `layers.${a}: property "renderingMode" must be either "2d" or "3d"`
                }),
                n
            }
            ,
            i.validateFilter = s=>Io(Zf(s)),
            i.validateFog = s=>Io(Hg(s)),
            i.validateLayer = s=>Io(Kf(s)),
            i.validateLight = s=>Io(Gg(s)),
            i.validateSource = s=>Io($c(s)),
            i.validateStyle = Wg,
            i.validateTerrain = s=>Io(Yf(s)),
            i.values = tt,
            i.vectorTile = w_,
            i.version = x,
            i.warnOnce = ut,
            i.window = v,
            i.wrap = ke
        }),
        d(["./shared"], function(i) {
            function v(Te) {
                if (typeof Te == "number" || typeof Te == "boolean" || typeof Te == "string" || Te == null)
                    return JSON.stringify(Te);
                if (Array.isArray(Te)) {
                    let F = "[";
                    for (let $ of Te)
                        F += `${v($)},`;
                    return `${F}]`
                }
                let Y = "{";
                for (let F of Object.keys(Te).sort())
                    Y += `${F}:${v(Te[F])},`;
                return `${Y}}`
            }
            function x(Te) {
                let Y = "";
                for (let F of i.refProperties)
                    Y += `/${v(Te[F])}`;
                return Y
            }
            class E {
                constructor(Y) {
                    this.keyCache = {},
                    Y && this.replace(Y)
                }
                replace(Y) {
                    this._layerConfigs = {},
                    this._layers = {},
                    this.update(Y, [])
                }
                update(Y, F) {
                    for (let ie of Y)
                        this._layerConfigs[ie.id] = ie,
                        (this._layers[ie.id] = i.createStyleLayer(ie)).compileFilter(),
                        this.keyCache[ie.id] && delete this.keyCache[ie.id];
                    for (let ie of F)
                        delete this.keyCache[ie],
                        delete this._layerConfigs[ie],
                        delete this._layers[ie];
                    this.familiesBySource = {};
                    let $ = function(ie, ue) {
                        let Ee = {};
                        for (let Re = 0; Re < ie.length; Re++) {
                            let Ze = ue && ue[ie[Re].id] || x(ie[Re]);
                            ue && (ue[ie[Re].id] = Ze);
                            let ye = Ee[Ze];
                            ye || (ye = Ee[Ze] = []),
                            ye.push(ie[Re])
                        }
                        let He = [];
                        for (let Re in Ee)
                            He.push(Ee[Re]);
                        return He
                    }(i.values(this._layerConfigs), this.keyCache);
                    for (let ie of $) {
                        let ue = ie.map(et=>this._layers[et.id])
                          , Ee = ue[0];
                        if (Ee.visibility === "none")
                            continue;
                        let He = Ee.source || ""
                          , Re = this.familiesBySource[He];
                        Re || (Re = this.familiesBySource[He] = {});
                        let Ze = Ee.sourceLayer || "_geojsonTileLayer"
                          , ye = Re[Ze];
                        ye || (ye = Re[Ze] = []),
                        ye.push(ue)
                    }
                }
            }
            class A {
                loadTile(Y, F) {
                    let {uid: $, encoding: ie, rawImageData: ue, padding: Ee, buildQuadTree: He} = Y
                      , Re = i.window.ImageBitmap && ue instanceof i.window.ImageBitmap ? this.getImageData(ue, Ee) : ue;
                    F(null, new i.DEMData($,Re,ie,Ee < 1,He))
                }
                getImageData(Y, F) {
                    this.offscreenCanvas && this.offscreenCanvasContext || (this.offscreenCanvas = new OffscreenCanvas(Y.width,Y.height),
                    this.offscreenCanvasContext = this.offscreenCanvas.getContext("2d", {
                        willReadFrequently: !0
                    })),
                    this.offscreenCanvas.width = Y.width,
                    this.offscreenCanvas.height = Y.height,
                    this.offscreenCanvasContext.drawImage(Y, 0, 0, Y.width, Y.height);
                    let $ = this.offscreenCanvasContext.getImageData(-F, -F, Y.width + 2 * F, Y.height + 2 * F);
                    return this.offscreenCanvasContext.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height),
                    $
                }
            }
            var C = function Te(Y, F) {
                var $, ie = Y && Y.type;
                if (ie === "FeatureCollection")
                    for ($ = 0; $ < Y.features.length; $++)
                        Te(Y.features[$], F);
                else if (ie === "GeometryCollection")
                    for ($ = 0; $ < Y.geometries.length; $++)
                        Te(Y.geometries[$], F);
                else if (ie === "Feature")
                    Te(Y.geometry, F);
                else if (ie === "Polygon")
                    I(Y.coordinates, F);
                else if (ie === "MultiPolygon")
                    for ($ = 0; $ < Y.coordinates.length; $++)
                        I(Y.coordinates[$], F);
                return Y
            };
            function I(Te, Y) {
                if (Te.length !== 0) {
                    D(Te[0], Y);
                    for (var F = 1; F < Te.length; F++)
                        D(Te[F], !Y)
                }
            }
            function D(Te, Y) {
                for (var F = 0, $ = 0, ie = 0, ue = Te.length, Ee = ue - 1; ie < ue; Ee = ie++) {
                    var He = (Te[ie][0] - Te[Ee][0]) * (Te[Ee][1] + Te[ie][1])
                      , Re = F + He;
                    $ += Math.abs(F) >= Math.abs(He) ? F - Re + He : He - Re + F,
                    F = Re
                }
                F + $ >= 0 != !!Y && Te.reverse()
            }
            let P = i.VectorTileFeature.prototype.toGeoJSON;
            class k {
                constructor(Y) {
                    this._feature = Y,
                    this.extent = i.EXTENT,
                    this.type = Y.type,
                    this.properties = Y.tags,
                    "id"in Y && !isNaN(Y.id) && (this.id = parseInt(Y.id, 10))
                }
                loadGeometry() {
                    if (this._feature.type === 1) {
                        let Y = [];
                        for (let F of this._feature.geometry)
                            Y.push([new i.pointGeometry(F[0],F[1])]);
                        return Y
                    }
                    {
                        let Y = [];
                        for (let F of this._feature.geometry) {
                            let $ = [];
                            for (let ie of F)
                                $.push(new i.pointGeometry(ie[0],ie[1]));
                            Y.push($)
                        }
                        return Y
                    }
                }
                toGeoJSON(Y, F, $) {
                    return P.call(this, Y, F, $)
                }
            }
            class U {
                constructor(Y) {
                    this.layers = {
                        _geojsonTileLayer: this
                    },
                    this.name = "_geojsonTileLayer",
                    this.extent = i.EXTENT,
                    this.length = Y.length,
                    this._features = Y
                }
                feature(Y) {
                    return new k(this._features[Y])
                }
            }
            var Z = {}
              , K = {
                get exports() {
                    return Z
                },
                set exports(Te) {
                    Z = Te
                }
            }
              , X = i.pointGeometry
              , W = i.vectorTile.VectorTileFeature
              , fe = ce;
            function ce(Te, Y) {
                this.options = Y || {},
                this.features = Te,
                this.length = Te.length
            }
            function _e(Te, Y) {
                this.id = typeof Te.id == "number" ? Te.id : void 0,
                this.type = Te.type,
                this.rawGeometry = Te.type === 1 ? [Te.geometry] : Te.geometry,
                this.properties = Te.tags,
                this.extent = Y || 4096
            }
            ce.prototype.feature = function(Te) {
                return new _e(this.features[Te],this.options.extent)
            }
            ,
            _e.prototype.loadGeometry = function() {
                var Te = this.rawGeometry;
                this.geometry = [];
                for (var Y = 0; Y < Te.length; Y++) {
                    for (var F = Te[Y], $ = [], ie = 0; ie < F.length; ie++)
                        $.push(new X(F[ie][0],F[ie][1]));
                    this.geometry.push($)
                }
                return this.geometry
            }
            ,
            _e.prototype.bbox = function() {
                this.geometry || this.loadGeometry();
                for (var Te = this.geometry, Y = 1 / 0, F = -1 / 0, $ = 1 / 0, ie = -1 / 0, ue = 0; ue < Te.length; ue++)
                    for (var Ee = Te[ue], He = 0; He < Ee.length; He++) {
                        var Re = Ee[He];
                        Y = Math.min(Y, Re.x),
                        F = Math.max(F, Re.x),
                        $ = Math.min($, Re.y),
                        ie = Math.max(ie, Re.y)
                    }
                return [Y, $, F, ie]
            }
            ,
            _e.prototype.toGeoJSON = W.prototype.toGeoJSON;
            var oe = i.pbf
              , ee = fe;
            function j(Te) {
                var Y = new oe;
                return function(F, $) {
                    for (var ie in F.layers)
                        $.writeMessage(3, ne, F.layers[ie])
                }(Te, Y),
                Y.finish()
            }
            function ne(Te, Y) {
                var F;
                Y.writeVarintField(15, Te.version || 1),
                Y.writeStringField(1, Te.name || ""),
                Y.writeVarintField(5, Te.extent || 4096);
                var $ = {
                    keys: [],
                    values: [],
                    keycache: {},
                    valuecache: {}
                };
                for (F = 0; F < Te.length; F++)
                    $.feature = Te.feature(F),
                    Y.writeMessage(2, be, $);
                var ie = $.keys;
                for (F = 0; F < ie.length; F++)
                    Y.writeStringField(3, ie[F]);
                var ue = $.values;
                for (F = 0; F < ue.length; F++)
                    Y.writeMessage(4, Be, ue[F])
            }
            function be(Te, Y) {
                var F = Te.feature;
                F.id !== void 0 && Y.writeVarintField(1, F.id),
                Y.writeMessage(2, te, Te),
                Y.writeVarintField(3, F.type),
                Y.writeMessage(4, ke, F)
            }
            function te(Te, Y) {
                var F = Te.feature
                  , $ = Te.keys
                  , ie = Te.values
                  , ue = Te.keycache
                  , Ee = Te.valuecache;
                for (var He in F.properties) {
                    var Re = F.properties[He]
                      , Ze = ue[He];
                    if (Re !== null) {
                        Ze === void 0 && ($.push(He),
                        ue[He] = Ze = $.length - 1),
                        Y.writeVarint(Ze);
                        var ye = typeof Re;
                        ye !== "string" && ye !== "boolean" && ye !== "number" && (Re = JSON.stringify(Re));
                        var et = ye + ":" + Re
                          , We = Ee[et];
                        We === void 0 && (ie.push(Re),
                        Ee[et] = We = ie.length - 1),
                        Y.writeVarint(We)
                    }
                }
            }
            function ae(Te, Y) {
                return (Y << 3) + (7 & Te)
            }
            function se(Te) {
                return Te << 1 ^ Te >> 31
            }
            function ke(Te, Y) {
                for (var F = Te.loadGeometry(), $ = Te.type, ie = 0, ue = 0, Ee = F.length, He = 0; He < Ee; He++) {
                    var Re = F[He]
                      , Ze = 1;
                    $ === 1 && (Ze = Re.length),
                    Y.writeVarint(ae(1, Ze));
                    for (var ye = $ === 3 ? Re.length - 1 : Re.length, et = 0; et < ye; et++) {
                        et === 1 && $ !== 1 && Y.writeVarint(ae(2, ye - 1));
                        var We = Re[et].x - ie
                          , ze = Re[et].y - ue;
                        Y.writeVarint(se(We)),
                        Y.writeVarint(se(ze)),
                        ie += We,
                        ue += ze
                    }
                    $ === 3 && Y.writeVarint(ae(7, 1))
                }
            }
            function Be(Te, Y) {
                var F = typeof Te;
                F === "string" ? Y.writeStringField(1, Te) : F === "boolean" ? Y.writeBooleanField(7, Te) : F === "number" && (Te % 1 != 0 ? Y.writeDoubleField(3, Te) : Te < 0 ? Y.writeSVarintField(6, Te) : Y.writeVarintField(5, Te))
            }
            function tt(Te, Y, F, $, ie, ue) {
                if (ie - $ <= F)
                    return;
                let Ee = $ + ie >> 1;
                Ke(Te, Y, Ee, $, ie, ue % 2),
                tt(Te, Y, F, $, Ee - 1, ue + 1),
                tt(Te, Y, F, Ee + 1, ie, ue + 1)
            }
            function Ke(Te, Y, F, $, ie, ue) {
                for (; ie > $; ) {
                    if (ie - $ > 600) {
                        let Ze = ie - $ + 1
                          , ye = F - $ + 1
                          , et = Math.log(Ze)
                          , We = .5 * Math.exp(2 * et / 3)
                          , ze = .5 * Math.sqrt(et * We * (Ze - We) / Ze) * (ye - Ze / 2 < 0 ? -1 : 1);
                        Ke(Te, Y, F, Math.max($, Math.floor(F - ye * We / Ze + ze)), Math.min(ie, Math.floor(F + (Ze - ye) * We / Ze + ze)), ue)
                    }
                    let Ee = Y[2 * F + ue]
                      , He = $
                      , Re = ie;
                    for (bt(Te, Y, $, F),
                    Y[2 * ie + ue] > Ee && bt(Te, Y, $, ie); He < Re; ) {
                        for (bt(Te, Y, He, Re),
                        He++,
                        Re--; Y[2 * He + ue] < Ee; )
                            He++;
                        for (; Y[2 * Re + ue] > Ee; )
                            Re--
                    }
                    Y[2 * $ + ue] === Ee ? bt(Te, Y, $, Re) : (Re++,
                    bt(Te, Y, Re, ie)),
                    Re <= F && ($ = Re + 1),
                    F <= Re && (ie = Re - 1)
                }
            }
            function bt(Te, Y, F, $) {
                Et(Te, F, $),
                Et(Y, 2 * F, 2 * $),
                Et(Y, 2 * F + 1, 2 * $ + 1)
            }
            function Et(Te, Y, F) {
                let $ = Te[Y];
                Te[Y] = Te[F],
                Te[F] = $
            }
            function Gt(Te, Y, F, $) {
                let ie = Te - F
                  , ue = Y - $;
                return ie * ie + ue * ue
            }
            K.exports = j,
            Z.fromVectorTileJs = j,
            Z.fromGeojsonVt = function(Te, Y) {
                Y = Y || {};
                var F = {};
                for (var $ in Te)
                    F[$] = new ee(Te[$].features,Y),
                    F[$].name = $,
                    F[$].version = Y.version,
                    F[$].extent = Y.extent;
                return j({
                    layers: F
                })
            }
            ,
            Z.GeoJSONWrapper = ee;
            let Ye = Te=>Te[0]
              , gn = Te=>Te[1];
            class gt {
                constructor(Y, F=Ye, $=gn, ie=64, ue=Float64Array) {
                    this.nodeSize = ie,
                    this.points = Y;
                    let Ee = Y.length < 65536 ? Uint16Array : Uint32Array
                      , He = this.ids = new Ee(Y.length)
                      , Re = this.coords = new ue(2 * Y.length);
                    for (let Ze = 0; Ze < Y.length; Ze++)
                        He[Ze] = Ze,
                        Re[2 * Ze] = F(Y[Ze]),
                        Re[2 * Ze + 1] = $(Y[Ze]);
                    tt(He, Re, ie, 0, He.length - 1, 0)
                }
                range(Y, F, $, ie) {
                    return function(ue, Ee, He, Re, Ze, ye, et) {
                        let We = [0, ue.length - 1, 0], ze = [], Rt, wt;
                        for (; We.length; ) {
                            let fn = We.pop()
                              , Mn = We.pop()
                              , Nn = We.pop();
                            if (Mn - Nn <= et) {
                                for (let On = Nn; On <= Mn; On++)
                                    Rt = Ee[2 * On],
                                    wt = Ee[2 * On + 1],
                                    Rt >= He && Rt <= Ze && wt >= Re && wt <= ye && ze.push(ue[On]);
                                continue
                            }
                            let jt = Math.floor((Nn + Mn) / 2);
                            Rt = Ee[2 * jt],
                            wt = Ee[2 * jt + 1],
                            Rt >= He && Rt <= Ze && wt >= Re && wt <= ye && ze.push(ue[jt]);
                            let qn = (fn + 1) % 2;
                            (fn === 0 ? He <= Rt : Re <= wt) && (We.push(Nn),
                            We.push(jt - 1),
                            We.push(qn)),
                            (fn === 0 ? Ze >= Rt : ye >= wt) && (We.push(jt + 1),
                            We.push(Mn),
                            We.push(qn))
                        }
                        return ze
                    }(this.ids, this.coords, Y, F, $, ie, this.nodeSize)
                }
                within(Y, F, $) {
                    return function(ie, ue, Ee, He, Re, Ze) {
                        let ye = [0, ie.length - 1, 0]
                          , et = []
                          , We = Re * Re;
                        for (; ye.length; ) {
                            let ze = ye.pop()
                              , Rt = ye.pop()
                              , wt = ye.pop();
                            if (Rt - wt <= Ze) {
                                for (let qn = wt; qn <= Rt; qn++)
                                    Gt(ue[2 * qn], ue[2 * qn + 1], Ee, He) <= We && et.push(ie[qn]);
                                continue
                            }
                            let fn = Math.floor((wt + Rt) / 2)
                              , Mn = ue[2 * fn]
                              , Nn = ue[2 * fn + 1];
                            Gt(Mn, Nn, Ee, He) <= We && et.push(ie[fn]);
                            let jt = (ze + 1) % 2;
                            (ze === 0 ? Ee - Re <= Mn : He - Re <= Nn) && (ye.push(wt),
                            ye.push(fn - 1),
                            ye.push(jt)),
                            (ze === 0 ? Ee + Re >= Mn : He + Re >= Nn) && (ye.push(fn + 1),
                            ye.push(Rt),
                            ye.push(jt))
                        }
                        return et
                    }(this.ids, this.coords, Y, F, $, this.nodeSize)
                }
            }
            let Tn = {
                minZoom: 0,
                maxZoom: 16,
                minPoints: 2,
                radius: 40,
                extent: 512,
                nodeSize: 64,
                log: !1,
                generateId: !1,
                reduce: null,
                map: Te=>Te
            }
              , xn = Math.fround || (Dn = new Float32Array(1),
            Te=>(Dn[0] = +Te,
            Dn[0]));
            var Dn;
            class Bt {
                constructor(Y) {
                    this.options = kt(Object.create(Tn), Y),
                    this.trees = new Array(this.options.maxZoom + 1)
                }
                load(Y) {
                    let {log: F, minZoom: $, maxZoom: ie, nodeSize: ue} = this.options;
                    F && console.time("total time");
                    let Ee = `prepare ${Y.length} points`;
                    F && console.time(Ee),
                    this.points = Y;
                    let He = [];
                    for (let Re = 0; Re < Y.length; Re++)
                        Y[Re].geometry && He.push(ut(Y[Re], Re));
                    this.trees[ie + 1] = new gt(He,Zt,zn,ue,Float32Array),
                    F && console.timeEnd(Ee);
                    for (let Re = ie; Re >= $; Re--) {
                        let Ze = +Date.now();
                        He = this._cluster(He, Re),
                        this.trees[Re] = new gt(He,Zt,zn,ue,Float32Array),
                        F && console.log("z%d: %d clusters in %dms", Re, He.length, +Date.now() - Ze)
                    }
                    return F && console.timeEnd("total time"),
                    this
                }
                getClusters(Y, F) {
                    let $ = ((Y[0] + 180) % 360 + 360) % 360 - 180
                      , ie = Math.max(-90, Math.min(90, Y[1]))
                      , ue = Y[2] === 180 ? 180 : ((Y[2] + 180) % 360 + 360) % 360 - 180
                      , Ee = Math.max(-90, Math.min(90, Y[3]));
                    if (Y[2] - Y[0] >= 360)
                        $ = -180,
                        ue = 180;
                    else if ($ > ue) {
                        let ye = this.getClusters([$, ie, 180, Ee], F)
                          , et = this.getClusters([-180, ie, ue, Ee], F);
                        return ye.concat(et)
                    }
                    let He = this.trees[this._limitZoom(F)]
                      , Re = He.range(on($), $t(Ee), on(ue), $t(ie))
                      , Ze = [];
                    for (let ye of Re) {
                        let et = He.points[ye];
                        Ze.push(et.numPoints ? ot(et) : this.points[et.index])
                    }
                    return Ze
                }
                getChildren(Y) {
                    let F = this._getOriginId(Y)
                      , $ = this._getOriginZoom(Y)
                      , ie = "No cluster with the specified id."
                      , ue = this.trees[$];
                    if (!ue)
                        throw new Error(ie);
                    let Ee = ue.points[F];
                    if (!Ee)
                        throw new Error(ie);
                    let He = this.options.radius / (this.options.extent * Math.pow(2, $ - 1))
                      , Re = ue.within(Ee.x, Ee.y, He)
                      , Ze = [];
                    for (let ye of Re) {
                        let et = ue.points[ye];
                        et.parentId === Y && Ze.push(et.numPoints ? ot(et) : this.points[et.index])
                    }
                    if (Ze.length === 0)
                        throw new Error(ie);
                    return Ze
                }
                getLeaves(Y, F, $) {
                    let ie = [];
                    return this._appendLeaves(ie, Y, F = F || 10, $ = $ || 0, 0),
                    ie
                }
                getTile(Y, F, $) {
                    let ie = this.trees[this._limitZoom(Y)]
                      , ue = Math.pow(2, Y)
                      , {extent: Ee, radius: He} = this.options
                      , Re = He / Ee
                      , Ze = ($ - Re) / ue
                      , ye = ($ + 1 + Re) / ue
                      , et = {
                        features: []
                    };
                    return this._addTileFeatures(ie.range((F - Re) / ue, Ze, (F + 1 + Re) / ue, ye), ie.points, F, $, ue, et),
                    F === 0 && this._addTileFeatures(ie.range(1 - Re / ue, Ze, 1, ye), ie.points, ue, $, ue, et),
                    F === ue - 1 && this._addTileFeatures(ie.range(0, Ze, Re / ue, ye), ie.points, -1, $, ue, et),
                    et.features.length ? et : null
                }
                getClusterExpansionZoom(Y) {
                    let F = this._getOriginZoom(Y) - 1;
                    for (; F <= this.options.maxZoom; ) {
                        let $ = this.getChildren(Y);
                        if (F++,
                        $.length !== 1)
                            break;
                        Y = $[0].properties.cluster_id
                    }
                    return F
                }
                _appendLeaves(Y, F, $, ie, ue) {
                    let Ee = this.getChildren(F);
                    for (let He of Ee) {
                        let Re = He.properties;
                        if (Re && Re.cluster ? ue + Re.point_count <= ie ? ue += Re.point_count : ue = this._appendLeaves(Y, Re.cluster_id, $, ie, ue) : ue < ie ? ue++ : Y.push(He),
                        Y.length === $)
                            break
                    }
                    return ue
                }
                _addTileFeatures(Y, F, $, ie, ue, Ee) {
                    for (let He of Y) {
                        let Re = F[He], Ze = Re.numPoints, ye, et, We;
                        if (Ze)
                            ye = xt(Re),
                            et = Re.x,
                            We = Re.y;
                        else {
                            let wt = this.points[Re.index];
                            ye = wt.properties,
                            et = on(wt.geometry.coordinates[0]),
                            We = $t(wt.geometry.coordinates[1])
                        }
                        let ze = {
                            type: 1,
                            geometry: [[Math.round(this.options.extent * (et * ue - $)), Math.round(this.options.extent * (We * ue - ie))]],
                            tags: ye
                        }, Rt;
                        Ze ? Rt = Re.id : this.options.generateId ? Rt = Re.index : this.points[Re.index].id && (Rt = this.points[Re.index].id),
                        Rt !== void 0 && (ze.id = Rt),
                        Ee.features.push(ze)
                    }
                }
                _limitZoom(Y) {
                    return Math.max(this.options.minZoom, Math.min(Math.floor(+Y), this.options.maxZoom + 1))
                }
                _cluster(Y, F) {
                    let $ = []
                      , {radius: ie, extent: ue, reduce: Ee, minPoints: He} = this.options
                      , Re = ie / (ue * Math.pow(2, F));
                    for (let Ze = 0; Ze < Y.length; Ze++) {
                        let ye = Y[Ze];
                        if (ye.zoom <= F)
                            continue;
                        ye.zoom = F;
                        let et = this.trees[F + 1]
                          , We = et.within(ye.x, ye.y, Re)
                          , ze = ye.numPoints || 1
                          , Rt = ze;
                        for (let wt of We) {
                            let fn = et.points[wt];
                            fn.zoom > F && (Rt += fn.numPoints || 1)
                        }
                        if (Rt > ze && Rt >= He) {
                            let wt = ye.x * ze
                              , fn = ye.y * ze
                              , Mn = Ee && ze > 1 ? this._map(ye, !0) : null
                              , Nn = (Ze << 5) + (F + 1) + this.points.length;
                            for (let jt of We) {
                                let qn = et.points[jt];
                                if (qn.zoom <= F)
                                    continue;
                                qn.zoom = F;
                                let On = qn.numPoints || 1;
                                wt += qn.x * On,
                                fn += qn.y * On,
                                qn.parentId = Nn,
                                Ee && (Mn || (Mn = this._map(ye, !0)),
                                Ee(Mn, this._map(qn)))
                            }
                            ye.parentId = Nn,
                            $.push(An(wt / Rt, fn / Rt, Nn, Rt, Mn))
                        } else if ($.push(ye),
                        Rt > 1)
                            for (let wt of We) {
                                let fn = et.points[wt];
                                fn.zoom <= F || (fn.zoom = F,
                                $.push(fn))
                            }
                    }
                    return $
                }
                _getOriginId(Y) {
                    return Y - this.points.length >> 5
                }
                _getOriginZoom(Y) {
                    return (Y - this.points.length) % 32
                }
                _map(Y, F) {
                    if (Y.numPoints)
                        return F ? kt({}, Y.properties) : Y.properties;
                    let $ = this.points[Y.index].properties
                      , ie = this.options.map($);
                    return F && ie === $ ? kt({}, ie) : ie
                }
            }
            function An(Te, Y, F, $, ie) {
                return {
                    x: xn(Te),
                    y: xn(Y),
                    zoom: 1 / 0,
                    id: F,
                    parentId: -1,
                    numPoints: $,
                    properties: ie
                }
            }
            function ut(Te, Y) {
                let[F,$] = Te.geometry.coordinates;
                return {
                    x: xn(on(F)),
                    y: xn($t($)),
                    zoom: 1 / 0,
                    index: Y,
                    parentId: -1
                }
            }
            function ot(Te) {
                return {
                    type: "Feature",
                    id: Te.id,
                    properties: xt(Te),
                    geometry: {
                        type: "Point",
                        coordinates: [(Y = Te.x,
                        360 * (Y - .5)), Pn(Te.y)]
                    }
                };
                var Y
            }
            function xt(Te) {
                let Y = Te.numPoints
                  , F = Y >= 1e4 ? `${Math.round(Y / 1e3)}k` : Y >= 1e3 ? Math.round(Y / 100) / 10 + "k" : Y;
                return kt(kt({}, Te.properties), {
                    cluster: !0,
                    cluster_id: Te.id,
                    point_count: Y,
                    point_count_abbreviated: F
                })
            }
            function on(Te) {
                return Te / 360 + .5
            }
            function $t(Te) {
                let Y = Math.sin(Te * Math.PI / 180)
                  , F = .5 - .25 * Math.log((1 + Y) / (1 - Y)) / Math.PI;
                return F < 0 ? 0 : F > 1 ? 1 : F
            }
            function Pn(Te) {
                let Y = (180 - 360 * Te) * Math.PI / 180;
                return 360 * Math.atan(Math.exp(Y)) / Math.PI - 90
            }
            function kt(Te, Y) {
                for (let F in Y)
                    Te[F] = Y[F];
                return Te
            }
            function Zt(Te) {
                return Te.x
            }
            function zn(Te) {
                return Te.y
            }
            function Qt(Te, Y, F, $) {
                for (var ie, ue = $, Ee = F - Y >> 1, He = F - Y, Re = Te[Y], Ze = Te[Y + 1], ye = Te[F], et = Te[F + 1], We = Y + 3; We < F; We += 3) {
                    var ze = xe(Te[We], Te[We + 1], Re, Ze, ye, et);
                    if (ze > ue)
                        ie = We,
                        ue = ze;
                    else if (ze === ue) {
                        var Rt = Math.abs(We - Ee);
                        Rt < He && (ie = We,
                        He = Rt)
                    }
                }
                ue > $ && (ie - Y > 3 && Qt(Te, Y, ie, $),
                Te[ie + 2] = ue,
                F - ie > 3 && Qt(Te, ie, F, $))
            }
            function xe(Te, Y, F, $, ie, ue) {
                var Ee = ie - F
                  , He = ue - $;
                if (Ee !== 0 || He !== 0) {
                    var Re = ((Te - F) * Ee + (Y - $) * He) / (Ee * Ee + He * He);
                    Re > 1 ? (F = ie,
                    $ = ue) : Re > 0 && (F += Ee * Re,
                    $ += He * Re)
                }
                return (Ee = Te - F) * Ee + (He = Y - $) * He
            }
            function he(Te, Y, F, $) {
                var ie = {
                    id: Te === void 0 ? null : Te,
                    type: Y,
                    geometry: F,
                    tags: $,
                    minX: 1 / 0,
                    minY: 1 / 0,
                    maxX: -1 / 0,
                    maxY: -1 / 0
                };
                return function(ue) {
                    var Ee = ue.geometry
                      , He = ue.type;
                    if (He === "Point" || He === "MultiPoint" || He === "LineString")
                        Qe(ue, Ee);
                    else if (He === "Polygon" || He === "MultiLineString")
                        for (var Re = 0; Re < Ee.length; Re++)
                            Qe(ue, Ee[Re]);
                    else if (He === "MultiPolygon")
                        for (Re = 0; Re < Ee.length; Re++)
                            for (var Ze = 0; Ze < Ee[Re].length; Ze++)
                                Qe(ue, Ee[Re][Ze])
                }(ie),
                ie
            }
            function Qe(Te, Y) {
                for (var F = 0; F < Y.length; F += 3)
                    Te.minX = Math.min(Te.minX, Y[F]),
                    Te.minY = Math.min(Te.minY, Y[F + 1]),
                    Te.maxX = Math.max(Te.maxX, Y[F]),
                    Te.maxY = Math.max(Te.maxY, Y[F + 1])
            }
            function ft(Te, Y, F, $) {
                if (Y.geometry) {
                    var ie = Y.geometry.coordinates
                      , ue = Y.geometry.type
                      , Ee = Math.pow(F.tolerance / ((1 << F.maxZoom) * F.extent), 2)
                      , He = []
                      , Re = Y.id;
                    if (F.promoteId ? Re = Y.properties[F.promoteId] : F.generateId && (Re = $ || 0),
                    ue === "Point")
                        St(ie, He);
                    else if (ue === "MultiPoint")
                        for (var Ze = 0; Ze < ie.length; Ze++)
                            St(ie[Ze], He);
                    else if (ue === "LineString")
                        Mt(ie, He, Ee, !1);
                    else if (ue === "MultiLineString") {
                        if (F.lineMetrics) {
                            for (Ze = 0; Ze < ie.length; Ze++)
                                Mt(ie[Ze], He = [], Ee, !1),
                                Te.push(he(Re, "LineString", He, Y.properties));
                            return
                        }
                        an(ie, He, Ee, !1)
                    } else if (ue === "Polygon")
                        an(ie, He, Ee, !0);
                    else {
                        if (ue !== "MultiPolygon") {
                            if (ue === "GeometryCollection") {
                                for (Ze = 0; Ze < Y.geometry.geometries.length; Ze++)
                                    ft(Te, {
                                        id: Re,
                                        geometry: Y.geometry.geometries[Ze],
                                        properties: Y.properties
                                    }, F, $);
                                return
                            }
                            throw new Error("Input data is not a valid GeoJSON object.")
                        }
                        for (Ze = 0; Ze < ie.length; Ze++) {
                            var ye = [];
                            an(ie[Ze], ye, Ee, !0),
                            He.push(ye)
                        }
                    }
                    Te.push(he(Re, ue, He, Y.properties))
                }
            }
            function St(Te, Y) {
                Y.push(Ie(Te[0])),
                Y.push(Ct(Te[1])),
                Y.push(0)
            }
            function Mt(Te, Y, F, $) {
                for (var ie, ue, Ee = 0, He = 0; He < Te.length; He++) {
                    var Re = Ie(Te[He][0])
                      , Ze = Ct(Te[He][1]);
                    Y.push(Re),
                    Y.push(Ze),
                    Y.push(0),
                    He > 0 && (Ee += $ ? (ie * Ze - Re * ue) / 2 : Math.sqrt(Math.pow(Re - ie, 2) + Math.pow(Ze - ue, 2))),
                    ie = Re,
                    ue = Ze
                }
                var ye = Y.length - 3;
                Y[2] = 1,
                Qt(Y, 0, ye, F),
                Y[ye + 2] = 1,
                Y.size = Math.abs(Ee),
                Y.start = 0,
                Y.end = Y.size
            }
            function an(Te, Y, F, $) {
                for (var ie = 0; ie < Te.length; ie++) {
                    var ue = [];
                    Mt(Te[ie], ue, F, $),
                    Y.push(ue)
                }
            }
            function Ie(Te) {
                return Te / 360 + .5
            }
            function Ct(Te) {
                var Y = Math.sin(Te * Math.PI / 180)
                  , F = .5 - .25 * Math.log((1 + Y) / (1 - Y)) / Math.PI;
                return F < 0 ? 0 : F > 1 ? 1 : F
            }
            function ln(Te, Y, F, $, ie, ue, Ee, He) {
                if ($ /= Y,
                ue >= (F /= Y) && Ee < $)
                    return Te;
                if (Ee < F || ue >= $)
                    return null;
                for (var Re = [], Ze = 0; Ze < Te.length; Ze++) {
                    var ye = Te[Ze]
                      , et = ye.geometry
                      , We = ye.type
                      , ze = ie === 0 ? ye.minX : ye.minY
                      , Rt = ie === 0 ? ye.maxX : ye.maxY;
                    if (ze >= F && Rt < $)
                        Re.push(ye);
                    else if (!(Rt < F || ze >= $)) {
                        var wt = [];
                        if (We === "Point" || We === "MultiPoint")
                            Kt(et, wt, F, $, ie);
                        else if (We === "LineString")
                            Ge(et, wt, F, $, ie, !1, He.lineMetrics);
                        else if (We === "MultiLineString")
                            Ut(et, wt, F, $, ie, !1);
                        else if (We === "Polygon")
                            Ut(et, wt, F, $, ie, !0);
                        else if (We === "MultiPolygon")
                            for (var fn = 0; fn < et.length; fn++) {
                                var Mn = [];
                                Ut(et[fn], Mn, F, $, ie, !0),
                                Mn.length && wt.push(Mn)
                            }
                        if (wt.length) {
                            if (He.lineMetrics && We === "LineString") {
                                for (fn = 0; fn < wt.length; fn++)
                                    Re.push(he(ye.id, We, wt[fn], ye.tags));
                                continue
                            }
                            We !== "LineString" && We !== "MultiLineString" || (wt.length === 1 ? (We = "LineString",
                            wt = wt[0]) : We = "MultiLineString"),
                            We !== "Point" && We !== "MultiPoint" || (We = wt.length === 3 ? "Point" : "MultiPoint"),
                            Re.push(he(ye.id, We, wt, ye.tags))
                        }
                    }
                }
                return Re.length ? Re : null
            }
            function Kt(Te, Y, F, $, ie) {
                for (var ue = 0; ue < Te.length; ue += 3) {
                    var Ee = Te[ue + ie];
                    Ee >= F && Ee <= $ && (Y.push(Te[ue]),
                    Y.push(Te[ue + 1]),
                    Y.push(Te[ue + 2]))
                }
            }
            function Ge(Te, Y, F, $, ie, ue, Ee) {
                for (var He, Re, Ze = Wt(Te), ye = ie === 0 ? Ft : nn, et = Te.start, We = 0; We < Te.length - 3; We += 3) {
                    var ze = Te[We]
                      , Rt = Te[We + 1]
                      , wt = Te[We + 2]
                      , fn = Te[We + 3]
                      , Mn = Te[We + 4]
                      , Nn = ie === 0 ? ze : Rt
                      , jt = ie === 0 ? fn : Mn
                      , qn = !1;
                    Ee && (He = Math.sqrt(Math.pow(ze - fn, 2) + Math.pow(Rt - Mn, 2))),
                    Nn < F ? jt > F && (Re = ye(Ze, ze, Rt, fn, Mn, F),
                    Ee && (Ze.start = et + He * Re)) : Nn > $ ? jt < $ && (Re = ye(Ze, ze, Rt, fn, Mn, $),
                    Ee && (Ze.start = et + He * Re)) : _n(Ze, ze, Rt, wt),
                    jt < F && Nn >= F && (Re = ye(Ze, ze, Rt, fn, Mn, F),
                    qn = !0),
                    jt > $ && Nn <= $ && (Re = ye(Ze, ze, Rt, fn, Mn, $),
                    qn = !0),
                    !ue && qn && (Ee && (Ze.end = et + He * Re),
                    Y.push(Ze),
                    Ze = Wt(Te)),
                    Ee && (et += He)
                }
                var On = Te.length - 3;
                ze = Te[On],
                Rt = Te[On + 1],
                wt = Te[On + 2],
                (Nn = ie === 0 ? ze : Rt) >= F && Nn <= $ && _n(Ze, ze, Rt, wt),
                On = Ze.length - 3,
                ue && On >= 3 && (Ze[On] !== Ze[0] || Ze[On + 1] !== Ze[1]) && _n(Ze, Ze[0], Ze[1], Ze[2]),
                Ze.length && Y.push(Ze)
            }
            function Wt(Te) {
                var Y = [];
                return Y.size = Te.size,
                Y.start = Te.start,
                Y.end = Te.end,
                Y
            }
            function Ut(Te, Y, F, $, ie, ue) {
                for (var Ee = 0; Ee < Te.length; Ee++)
                    Ge(Te[Ee], Y, F, $, ie, ue, !1)
            }
            function _n(Te, Y, F, $) {
                Te.push(Y),
                Te.push(F),
                Te.push($)
            }
            function Ft(Te, Y, F, $, ie, ue) {
                var Ee = (ue - Y) / ($ - Y);
                return Te.push(ue),
                Te.push(F + (ie - F) * Ee),
                Te.push(1),
                Ee
            }
            function nn(Te, Y, F, $, ie, ue) {
                var Ee = (ue - F) / (ie - F);
                return Te.push(Y + ($ - Y) * Ee),
                Te.push(ue),
                Te.push(1),
                Ee
            }
            function Jt(Te, Y) {
                for (var F = [], $ = 0; $ < Te.length; $++) {
                    var ie, ue = Te[$], Ee = ue.type;
                    if (Ee === "Point" || Ee === "MultiPoint" || Ee === "LineString")
                        ie = Ln(ue.geometry, Y);
                    else if (Ee === "MultiLineString" || Ee === "Polygon") {
                        ie = [];
                        for (var He = 0; He < ue.geometry.length; He++)
                            ie.push(Ln(ue.geometry[He], Y))
                    } else if (Ee === "MultiPolygon")
                        for (ie = [],
                        He = 0; He < ue.geometry.length; He++) {
                            for (var Re = [], Ze = 0; Ze < ue.geometry[He].length; Ze++)
                                Re.push(Ln(ue.geometry[He][Ze], Y));
                            ie.push(Re)
                        }
                    F.push(he(ue.id, Ee, ie, ue.tags))
                }
                return F
            }
            function Ln(Te, Y) {
                var F = [];
                F.size = Te.size,
                Te.start !== void 0 && (F.start = Te.start,
                F.end = Te.end);
                for (var $ = 0; $ < Te.length; $ += 3)
                    F.push(Te[$] + Y, Te[$ + 1], Te[$ + 2]);
                return F
            }
            function Zn(Te, Y) {
                if (Te.transformed)
                    return Te;
                var F, $, ie, ue = 1 << Te.z, Ee = Te.x, He = Te.y;
                for (F = 0; F < Te.features.length; F++) {
                    var Re = Te.features[F]
                      , Ze = Re.geometry
                      , ye = Re.type;
                    if (Re.geometry = [],
                    ye === 1)
                        for ($ = 0; $ < Ze.length; $ += 2)
                            Re.geometry.push(Vn(Ze[$], Ze[$ + 1], Y, ue, Ee, He));
                    else
                        for ($ = 0; $ < Ze.length; $++) {
                            var et = [];
                            for (ie = 0; ie < Ze[$].length; ie += 2)
                                et.push(Vn(Ze[$][ie], Ze[$][ie + 1], Y, ue, Ee, He));
                            Re.geometry.push(et)
                        }
                }
                return Te.transformed = !0,
                Te
            }
            function Vn(Te, Y, F, $, ie, ue) {
                return [Math.round(F * (Te * $ - ie)), Math.round(F * (Y * $ - ue))]
            }
            function Tr(Te, Y, F, $, ie) {
                for (var ue = Y === ie.maxZoom ? 0 : ie.tolerance / ((1 << Y) * ie.extent), Ee = {
                    features: [],
                    numPoints: 0,
                    numSimplified: 0,
                    numFeatures: 0,
                    source: null,
                    x: F,
                    y: $,
                    z: Y,
                    transformed: !1,
                    minX: 2,
                    minY: 1,
                    maxX: -1,
                    maxY: 0
                }, He = 0; He < Te.length; He++) {
                    Ee.numFeatures++,
                    fr(Ee, Te[He], ue, ie);
                    var Re = Te[He].minX
                      , Ze = Te[He].minY
                      , ye = Te[He].maxX
                      , et = Te[He].maxY;
                    Re < Ee.minX && (Ee.minX = Re),
                    Ze < Ee.minY && (Ee.minY = Ze),
                    ye > Ee.maxX && (Ee.maxX = ye),
                    et > Ee.maxY && (Ee.maxY = et)
                }
                return Ee
            }
            function fr(Te, Y, F, $) {
                var ie = Y.geometry
                  , ue = Y.type
                  , Ee = [];
                if (ue === "Point" || ue === "MultiPoint")
                    for (var He = 0; He < ie.length; He += 3)
                        Ee.push(ie[He]),
                        Ee.push(ie[He + 1]),
                        Te.numPoints++,
                        Te.numSimplified++;
                else if (ue === "LineString")
                    Rs(Ee, ie, Te, F, !1, !1);
                else if (ue === "MultiLineString" || ue === "Polygon")
                    for (He = 0; He < ie.length; He++)
                        Rs(Ee, ie[He], Te, F, ue === "Polygon", He === 0);
                else if (ue === "MultiPolygon")
                    for (var Re = 0; Re < ie.length; Re++) {
                        var Ze = ie[Re];
                        for (He = 0; He < Ze.length; He++)
                            Rs(Ee, Ze[He], Te, F, !0, He === 0)
                    }
                if (Ee.length) {
                    var ye = Y.tags || null;
                    if (ue === "LineString" && $.lineMetrics) {
                        for (var et in ye = {},
                        Y.tags)
                            ye[et] = Y.tags[et];
                        ye.mapbox_clip_start = ie.start / ie.size,
                        ye.mapbox_clip_end = ie.end / ie.size
                    }
                    var We = {
                        geometry: Ee,
                        type: ue === "Polygon" || ue === "MultiPolygon" ? 3 : ue === "LineString" || ue === "MultiLineString" ? 2 : 1,
                        tags: ye
                    };
                    Y.id !== null && (We.id = Y.id),
                    Te.features.push(We)
                }
            }
            function Rs(Te, Y, F, $, ie, ue) {
                var Ee = $ * $;
                if ($ > 0 && Y.size < (ie ? Ee : $))
                    F.numPoints += Y.length / 3;
                else {
                    for (var He = [], Re = 0; Re < Y.length; Re += 3)
                        ($ === 0 || Y[Re + 2] > Ee) && (F.numSimplified++,
                        He.push(Y[Re]),
                        He.push(Y[Re + 1])),
                        F.numPoints++;
                    ie && function(Ze, ye) {
                        for (var et = 0, We = 0, ze = Ze.length, Rt = ze - 2; We < ze; Rt = We,
                        We += 2)
                            et += (Ze[We] - Ze[Rt]) * (Ze[We + 1] + Ze[Rt + 1]);
                        if (et > 0 === ye)
                            for (We = 0,
                            ze = Ze.length; We < ze / 2; We += 2) {
                                var wt = Ze[We]
                                  , fn = Ze[We + 1];
                                Ze[We] = Ze[ze - 2 - We],
                                Ze[We + 1] = Ze[ze - 1 - We],
                                Ze[ze - 2 - We] = wt,
                                Ze[ze - 1 - We] = fn
                            }
                    }(He, ue),
                    Te.push(He)
                }
            }
            function Cr(Te, Y) {
                var F = (Y = this.options = function(ie, ue) {
                    for (var Ee in ue)
                        ie[Ee] = ue[Ee];
                    return ie
                }(Object.create(this.options), Y)).debug;
                if (F && console.time("preprocess data"),
                Y.maxZoom < 0 || Y.maxZoom > 24)
                    throw new Error("maxZoom should be in the 0-24 range");
                if (Y.promoteId && Y.generateId)
                    throw new Error("promoteId and generateId cannot be used together.");
                var $ = function(ie, ue) {
                    var Ee = [];
                    if (ie.type === "FeatureCollection")
                        for (var He = 0; He < ie.features.length; He++)
                            ft(Ee, ie.features[He], ue, He);
                    else
                        ft(Ee, ie.type === "Feature" ? ie : {
                            geometry: ie
                        }, ue);
                    return Ee
                }(Te, Y);
                this.tiles = {},
                this.tileCoords = [],
                F && (console.timeEnd("preprocess data"),
                console.log("index: maxZoom: %d, maxPoints: %d", Y.indexMaxZoom, Y.indexMaxPoints),
                console.time("generate tiles"),
                this.stats = {},
                this.total = 0),
                $ = function(ie, ue) {
                    var Ee = ue.buffer / ue.extent
                      , He = ie
                      , Re = ln(ie, 1, -1 - Ee, Ee, 0, -1, 2, ue)
                      , Ze = ln(ie, 1, 1 - Ee, 2 + Ee, 0, -1, 2, ue);
                    return (Re || Ze) && (He = ln(ie, 1, -Ee, 1 + Ee, 0, -1, 2, ue) || [],
                    Re && (He = Jt(Re, 1).concat(He)),
                    Ze && (He = He.concat(Jt(Ze, -1)))),
                    He
                }($, Y),
                $.length && this.splitTile($, 0, 0, 0),
                F && ($.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints),
                console.timeEnd("generate tiles"),
                console.log("tiles generated:", this.total, JSON.stringify(this.stats)))
            }
            function Vr(Te, Y, F) {
                return 32 * ((1 << Te) * F + Y) + Te
            }
            function Gr(Te, Y) {
                let F = Te.tileID.canonical;
                if (!this._geoJSONIndex)
                    return Y(null, null);
                let $ = this._geoJSONIndex.getTile(F.z, F.x, F.y);
                if (!$)
                    return Y(null, null);
                let ie = new U($.features)
                  , ue = Z(ie);
                ue.byteOffset === 0 && ue.byteLength === ue.buffer.byteLength || (ue = new Uint8Array(ue)),
                Y(null, {
                    vectorTile: ie,
                    rawData: ue.buffer
                })
            }
            Cr.prototype.options = {
                maxZoom: 14,
                indexMaxZoom: 5,
                indexMaxPoints: 1e5,
                tolerance: 3,
                extent: 4096,
                buffer: 64,
                lineMetrics: !1,
                promoteId: null,
                generateId: !1,
                debug: 0
            },
            Cr.prototype.splitTile = function(Te, Y, F, $, ie, ue, Ee) {
                for (var He = [Te, Y, F, $], Re = this.options, Ze = Re.debug; He.length; ) {
                    $ = He.pop(),
                    F = He.pop(),
                    Y = He.pop(),
                    Te = He.pop();
                    var ye = 1 << Y
                      , et = Vr(Y, F, $)
                      , We = this.tiles[et];
                    if (!We && (Ze > 1 && console.time("creation"),
                    We = this.tiles[et] = Tr(Te, Y, F, $, Re),
                    this.tileCoords.push({
                        z: Y,
                        x: F,
                        y: $
                    }),
                    Ze)) {
                        Ze > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", Y, F, $, We.numFeatures, We.numPoints, We.numSimplified),
                        console.timeEnd("creation"));
                        var ze = "z" + Y;
                        this.stats[ze] = (this.stats[ze] || 0) + 1,
                        this.total++
                    }
                    if (We.source = Te,
                    ie) {
                        if (Y === Re.maxZoom || Y === ie)
                            continue;
                        var Rt = 1 << ie - Y;
                        if (F !== Math.floor(ue / Rt) || $ !== Math.floor(Ee / Rt))
                            continue
                    } else if (Y === Re.indexMaxZoom || We.numPoints <= Re.indexMaxPoints)
                        continue;
                    if (We.source = null,
                    Te.length !== 0) {
                        Ze > 1 && console.time("clipping");
                        var wt, fn, Mn, Nn, jt, qn, On = .5 * Re.buffer / Re.extent, ar = .5 - On, pr = .5 + On, ht = 1 + On;
                        wt = fn = Mn = Nn = null,
                        jt = ln(Te, ye, F - On, F + pr, 0, We.minX, We.maxX, Re),
                        qn = ln(Te, ye, F + ar, F + ht, 0, We.minX, We.maxX, Re),
                        Te = null,
                        jt && (wt = ln(jt, ye, $ - On, $ + pr, 1, We.minY, We.maxY, Re),
                        fn = ln(jt, ye, $ + ar, $ + ht, 1, We.minY, We.maxY, Re),
                        jt = null),
                        qn && (Mn = ln(qn, ye, $ - On, $ + pr, 1, We.minY, We.maxY, Re),
                        Nn = ln(qn, ye, $ + ar, $ + ht, 1, We.minY, We.maxY, Re),
                        qn = null),
                        Ze > 1 && console.timeEnd("clipping"),
                        He.push(wt || [], Y + 1, 2 * F, 2 * $),
                        He.push(fn || [], Y + 1, 2 * F, 2 * $ + 1),
                        He.push(Mn || [], Y + 1, 2 * F + 1, 2 * $),
                        He.push(Nn || [], Y + 1, 2 * F + 1, 2 * $ + 1)
                    }
                }
            }
            ,
            Cr.prototype.getTile = function(Te, Y, F) {
                var $ = this.options
                  , ie = $.extent
                  , ue = $.debug;
                if (Te < 0 || Te > 24)
                    return null;
                var Ee = 1 << Te
                  , He = Vr(Te, Y = (Y % Ee + Ee) % Ee, F);
                if (this.tiles[He])
                    return Zn(this.tiles[He], ie);
                ue > 1 && console.log("drilling down to z%d-%d-%d", Te, Y, F);
                for (var Re, Ze = Te, ye = Y, et = F; !Re && Ze > 0; )
                    Ze--,
                    ye = Math.floor(ye / 2),
                    et = Math.floor(et / 2),
                    Re = this.tiles[Vr(Ze, ye, et)];
                return Re && Re.source ? (ue > 1 && console.log("found parent tile z%d-%d-%d", Ze, ye, et),
                ue > 1 && console.time("drilling down"),
                this.splitTile(Re.source, Ze, ye, et, Te, Y, F),
                ue > 1 && console.timeEnd("drilling down"),
                this.tiles[He] ? Zn(this.tiles[He], ie) : null) : null
            }
            ;
            class Ps extends i.VectorTileWorkerSource {
                constructor(Y, F, $, ie, ue) {
                    super(Y, F, $, ie, Gr),
                    ue && (this.loadGeoJSON = ue)
                }
                loadData(Y, F) {
                    let $ = Y && Y.request
                      , ie = $ && $.collectResourceTiming;
                    this.loadGeoJSON(Y, (ue,Ee)=>{
                        if (ue || !Ee)
                            return F(ue);
                        if (typeof Ee != "object")
                            return F(new Error(`Input data given to '${Y.source}' is not a valid GeoJSON object.`));
                        {
                            C(Ee, !0);
                            try {
                                if (Y.filter) {
                                    let Re = i.createExpression(Y.filter, {
                                        type: "boolean",
                                        "property-type": "data-driven",
                                        overridable: !1,
                                        transition: !1
                                    });
                                    if (Re.result === "error")
                                        throw new Error(Re.value.map(ye=>`${ye.key}: ${ye.message}`).join(", "));
                                    let Ze = Ee.features.filter(ye=>Re.value.evaluate({
                                        zoom: 0
                                    }, ye));
                                    Ee = {
                                        type: "FeatureCollection",
                                        features: Ze
                                    }
                                }
                                this._geoJSONIndex = Y.cluster ? new Bt(function({superclusterOptions: Re, clusterProperties: Ze}) {
                                    if (!Ze || !Re)
                                        return Re;
                                    let ye = {}
                                      , et = {}
                                      , We = {
                                        accumulated: null,
                                        zoom: 0
                                    }
                                      , ze = {
                                        properties: null
                                    }
                                      , Rt = Object.keys(Ze);
                                    for (let wt of Rt) {
                                        let[fn,Mn] = Ze[wt]
                                          , Nn = i.createExpression(Mn)
                                          , jt = i.createExpression(typeof fn == "string" ? [fn, ["accumulated"], ["get", wt]] : fn);
                                        ye[wt] = Nn.value,
                                        et[wt] = jt.value
                                    }
                                    return Re.map = wt=>{
                                        ze.properties = wt;
                                        let fn = {};
                                        for (let Mn of Rt)
                                            fn[Mn] = ye[Mn].evaluate(We, ze);
                                        return fn
                                    }
                                    ,
                                    Re.reduce = (wt,fn)=>{
                                        ze.properties = fn;
                                        for (let Mn of Rt)
                                            We.accumulated = wt[Mn],
                                            wt[Mn] = et[Mn].evaluate(We, ze)
                                    }
                                    ,
                                    Re
                                }(Y)).load(Ee.features) : function(Re, Ze) {
                                    return new Cr(Re,Ze)
                                }(Ee, Y.geojsonVtOptions)
                            } catch (Re) {
                                return F(Re)
                            }
                            this.loaded = {};
                            let He = {};
                            if (ie) {
                                let Re = i.getPerformanceMeasurement($);
                                Re && (He.resourceTiming = {},
                                He.resourceTiming[Y.source] = JSON.parse(JSON.stringify(Re)))
                            }
                            F(null, He)
                        }
                    }
                    )
                }
                reloadTile(Y, F) {
                    let $ = this.loaded;
                    return $ && $[Y.uid] ? super.reloadTile(Y, F) : this.loadTile(Y, F)
                }
                loadGeoJSON(Y, F) {
                    if (Y.request)
                        i.getJSON(Y.request, F);
                    else {
                        if (typeof Y.data != "string")
                            return F(new Error(`Input data given to '${Y.source}' is not a valid GeoJSON object.`));
                        try {
                            return F(null, JSON.parse(Y.data))
                        } catch ($) {
                            return F(new Error(`Input data given to '${Y.source}' is not a valid GeoJSON object.`))
                        }
                    }
                }
                getClusterExpansionZoom(Y, F) {
                    try {
                        F(null, this._geoJSONIndex.getClusterExpansionZoom(Y.clusterId))
                    } catch ($) {
                        F($)
                    }
                }
                getClusterChildren(Y, F) {
                    try {
                        F(null, this._geoJSONIndex.getChildren(Y.clusterId))
                    } catch ($) {
                        F($)
                    }
                }
                getClusterLeaves(Y, F) {
                    try {
                        F(null, this._geoJSONIndex.getLeaves(Y.clusterId, Y.limit, Y.offset))
                    } catch ($) {
                        F($)
                    }
                }
            }
            class ds {
                constructor(Y) {
                    this.self = Y,
                    this.actor = new i.Actor(Y,this),
                    this.layerIndexes = {},
                    this.availableImages = {},
                    this.isSpriteLoaded = {},
                    this.projections = {},
                    this.defaultProjection = i.getProjection({
                        name: "mercator"
                    }),
                    this.workerSourceTypes = {
                        vector: i.VectorTileWorkerSource,
                        geojson: Ps
                    },
                    this.workerSources = {},
                    this.demWorkerSources = {},
                    this.self.registerWorkerSource = (F,$)=>{
                        if (this.workerSourceTypes[F])
                            throw new Error(`Worker source with name "${F}" already registered.`);
                        this.workerSourceTypes[F] = $
                    }
                    ,
                    this.self.registerRTLTextPlugin = F=>{
                        if (i.plugin.isParsed())
                            throw new Error("RTL text plugin already registered.");
                        i.plugin.applyArabicShaping = F.applyArabicShaping,
                        i.plugin.processBidirectionalText = F.processBidirectionalText,
                        i.plugin.processStyledBidirectionalText = F.processStyledBidirectionalText
                    }
                }
                clearCaches(Y, F, $) {
                    delete this.layerIndexes[Y],
                    delete this.availableImages[Y],
                    delete this.workerSources[Y],
                    delete this.demWorkerSources[Y],
                    $()
                }
                checkIfReady(Y, F, $) {
                    $()
                }
                setReferrer(Y, F) {
                    this.referrer = F
                }
                spriteLoaded(Y, F) {
                    this.isSpriteLoaded[Y] = F;
                    for (let $ in this.workerSources[Y]) {
                        let ie = this.workerSources[Y][$];
                        for (let ue in ie)
                            ie[ue]instanceof i.VectorTileWorkerSource && (ie[ue].isSpriteLoaded = F,
                            ie[ue].fire(new i.Event("isSpriteLoaded")))
                    }
                }
                setImages(Y, F, $) {
                    this.availableImages[Y] = F;
                    for (let ie in this.workerSources[Y]) {
                        let ue = this.workerSources[Y][ie];
                        for (let Ee in ue)
                            ue[Ee].availableImages = F
                    }
                    $()
                }
                enableTerrain(Y, F, $) {
                    this.terrain = F,
                    $()
                }
                setProjection(Y, F) {
                    this.projections[Y] = i.getProjection(F)
                }
                setLayers(Y, F, $) {
                    this.getLayerIndex(Y).replace(F),
                    $()
                }
                updateLayers(Y, F, $) {
                    this.getLayerIndex(Y).update(F.layers, F.removedIds),
                    $()
                }
                loadTile(Y, F, $) {
                    let ie = this.enableTerrain ? i.extend({
                        enableTerrain: this.terrain
                    }, F) : F;
                    ie.projection = this.projections[Y] || this.defaultProjection,
                    this.getWorkerSource(Y, F.type, F.source).loadTile(ie, $)
                }
                loadDEMTile(Y, F, $) {
                    let ie = this.enableTerrain ? i.extend({
                        buildQuadTree: this.terrain
                    }, F) : F;
                    this.getDEMWorkerSource(Y, F.source).loadTile(ie, $)
                }
                reloadTile(Y, F, $) {
                    let ie = this.enableTerrain ? i.extend({
                        enableTerrain: this.terrain
                    }, F) : F;
                    ie.projection = this.projections[Y] || this.defaultProjection,
                    this.getWorkerSource(Y, F.type, F.source).reloadTile(ie, $)
                }
                abortTile(Y, F, $) {
                    this.getWorkerSource(Y, F.type, F.source).abortTile(F, $)
                }
                removeTile(Y, F, $) {
                    this.getWorkerSource(Y, F.type, F.source).removeTile(F, $)
                }
                removeSource(Y, F, $) {
                    if (!this.workerSources[Y] || !this.workerSources[Y][F.type] || !this.workerSources[Y][F.type][F.source])
                        return;
                    let ie = this.workerSources[Y][F.type][F.source];
                    delete this.workerSources[Y][F.type][F.source],
                    ie.removeSource !== void 0 ? ie.removeSource(F, $) : $()
                }
                loadWorkerSource(Y, F, $) {
                    try {
                        this.self.importScripts(F.url),
                        $()
                    } catch (ie) {
                        $(ie.toString())
                    }
                }
                syncRTLPluginState(Y, F, $) {
                    try {
                        i.plugin.setState(F);
                        let ie = i.plugin.getPluginURL();
                        if (i.plugin.isLoaded() && !i.plugin.isParsed() && ie != null) {
                            this.self.importScripts(ie);
                            let ue = i.plugin.isParsed();
                            $(ue ? void 0 : new Error(`RTL Text Plugin failed to import scripts from ${ie}`), ue)
                        }
                    } catch (ie) {
                        $(ie.toString())
                    }
                }
                getAvailableImages(Y) {
                    let F = this.availableImages[Y];
                    return F || (F = []),
                    F
                }
                getLayerIndex(Y) {
                    let F = this.layerIndexes[Y];
                    return F || (F = this.layerIndexes[Y] = new E),
                    F
                }
                getWorkerSource(Y, F, $) {
                    if (this.workerSources[Y] || (this.workerSources[Y] = {}),
                    this.workerSources[Y][F] || (this.workerSources[Y][F] = {}),
                    !this.workerSources[Y][F][$]) {
                        let ie = {
                            send: (ue,Ee,He,Re,Ze,ye)=>{
                                this.actor.send(ue, Ee, He, Y, Ze, ye)
                            }
                            ,
                            scheduler: this.actor.scheduler
                        };
                        this.workerSources[Y][F][$] = new this.workerSourceTypes[F](ie,this.getLayerIndex(Y),this.getAvailableImages(Y),this.isSpriteLoaded[Y])
                    }
                    return this.workerSources[Y][F][$]
                }
                getDEMWorkerSource(Y, F) {
                    return this.demWorkerSources[Y] || (this.demWorkerSources[Y] = {}),
                    this.demWorkerSources[Y][F] || (this.demWorkerSources[Y][F] = new A),
                    this.demWorkerSources[Y][F]
                }
                enforceCacheSizeLimit(Y, F) {
                    i.enforceCacheSizeLimit(F)
                }
                getWorkerPerformanceMetrics(Y, F, $) {
                    $(void 0, void 0)
                }
            }
            return typeof WorkerGlobalScope != "undefined" && typeof self != "undefined" && self instanceof WorkerGlobalScope && (self.worker = new ds(self)),
            ds
        }),
        d(["./shared"], function(i) {
            function v(m, l) {
                if (Array.isArray(m)) {
                    if (!Array.isArray(l) || m.length !== l.length)
                        return !1;
                    for (let h = 0; h < m.length; h++)
                        if (!v(m[h], l[h]))
                            return !1;
                    return !0
                }
                if (typeof m == "object" && m !== null && l !== null) {
                    if (typeof l != "object" || Object.keys(m).length !== Object.keys(l).length)
                        return !1;
                    for (let h in m)
                        if (!v(m[h], l[h]))
                            return !1;
                    return !0
                }
                return m === l
            }
            var x = E;
            function E(m) {
                return !function(l) {
                    return typeof window == "undefined" || typeof document == "undefined" ? "not a browser" : Array.prototype && Array.prototype.every && Array.prototype.filter && Array.prototype.forEach && Array.prototype.indexOf && Array.prototype.lastIndexOf && Array.prototype.map && Array.prototype.some && Array.prototype.reduce && Array.prototype.reduceRight && Array.isArray ? Function.prototype && Function.prototype.bind ? Object.keys && Object.create && Object.getPrototypeOf && Object.getOwnPropertyNames && Object.isSealed && Object.isFrozen && Object.isExtensible && Object.getOwnPropertyDescriptor && Object.defineProperty && Object.defineProperties && Object.seal && Object.freeze && Object.preventExtensions ? "JSON"in window && "parse"in JSON && "stringify"in JSON ? function() {
                        if (!("Worker"in window && "Blob"in window && "URL"in window))
                            return !1;
                        var _, b, T = new Blob([""],{
                            type: "text/javascript"
                        }), L = URL.createObjectURL(T);
                        try {
                            b = new Worker(L),
                            _ = !0
                        } catch (R) {
                            _ = !1
                        }
                        return b && b.terminate(),
                        URL.revokeObjectURL(L),
                        _
                    }() ? "Uint8ClampedArray"in window ? ArrayBuffer.isView ? function() {
                        var _ = document.createElement("canvas");
                        _.width = _.height = 1;
                        var b = _.getContext("2d");
                        if (!b)
                            return !1;
                        var T = b.getImageData(0, 0, 1, 1);
                        return T && T.width === _.width
                    }() ? (A[h = l && l.failIfMajorPerformanceCaveat] === void 0 && (A[h] = function(_) {
                        var b, T = function(L) {
                            var R = document.createElement("canvas")
                              , O = Object.create(E.webGLContextAttributes);
                            return O.failIfMajorPerformanceCaveat = L,
                            R.getContext("webgl", O) || R.getContext("experimental-webgl", O)
                        }(_);
                        if (!T)
                            return !1;
                        try {
                            b = T.createShader(T.VERTEX_SHADER)
                        } catch (L) {
                            return !1
                        }
                        return !(!b || T.isContextLost()) && (T.shaderSource(b, "void main() {}"),
                        T.compileShader(b),
                        T.getShaderParameter(b, T.COMPILE_STATUS) === !0)
                    }(h)),
                    A[h] ? document.documentMode ? "insufficient ECMAScript 6 support" : void 0 : "insufficient WebGL support") : "insufficient Canvas/getImageData support" : "insufficient ArrayBuffer support" : "insufficient Uint8ClampedArray support" : "insufficient worker support" : "insufficient JSON support" : "insufficient Object support" : "insufficient Function support" : "insufficent Array support";
                    var h
                }(m)
            }
            var A = {};
            function C(m, l, h) {
                let _ = i.window.document.createElement(m);
                return l !== void 0 && (_.className = l),
                h && h.appendChild(_),
                _
            }
            function I(m, l, h) {
                let _ = i.window.document.createElementNS("http://www.w3.org/2000/svg", m);
                for (let b of Object.keys(l))
                    _.setAttributeNS(null, b, l[b]);
                return h && h.appendChild(_),
                _
            }
            E.webGLContextAttributes = {
                antialias: !1,
                alpha: !0,
                stencil: !0,
                depth: !0
            };
            let D = i.window.document && i.window.document.documentElement.style, P = D && D.userSelect !== void 0 ? "userSelect" : "WebkitUserSelect", k;
            function U() {
                D && P && (k = D[P],
                D[P] = "none")
            }
            function Z() {
                D && P && (D[P] = k)
            }
            function K(m) {
                m.preventDefault(),
                m.stopPropagation(),
                i.window.removeEventListener("click", K, !0)
            }
            function X() {
                i.window.addEventListener("click", K, !0),
                i.window.setTimeout(()=>{
                    i.window.removeEventListener("click", K, !0)
                }
                , 0)
            }
            function W(m, l) {
                let h = m.getBoundingClientRect();
                return _e(m, h, l)
            }
            function fe(m, l) {
                let h = m.getBoundingClientRect()
                  , _ = [];
                for (let b = 0; b < l.length; b++)
                    _.push(_e(m, h, l[b]));
                return _
            }
            function ce(m) {
                return i.window.InstallTrigger !== void 0 && m.button === 2 && m.ctrlKey && i.window.navigator.platform.toUpperCase().indexOf("MAC") >= 0 ? 0 : m.button
            }
            function _e(m, l, h) {
                let _ = m.offsetWidth === l.width ? 1 : m.offsetWidth / l.width;
                return new i.pointGeometry((h.clientX - l.left) * _,(h.clientY - l.top) * _)
            }
            function oe(m, l) {
                var h = l[0]
                  , _ = l[1]
                  , b = l[2]
                  , T = l[3]
                  , L = h * T - b * _;
                return L ? (m[0] = T * (L = 1 / L),
                m[1] = -_ * L,
                m[2] = -b * L,
                m[3] = h * L,
                m) : null
            }
            function ee(m) {
                let {userImage: l} = m;
                return !!(l && l.render && l.render()) && (m.data.replace(new Uint8Array(l.data.buffer)),
                !0)
            }
            class j extends i.Evented {
                constructor() {
                    super(),
                    this.images = {},
                    this.updatedImages = {},
                    this.callbackDispatchedThisFrame = {},
                    this.loaded = !1,
                    this.requestors = [],
                    this.patterns = {},
                    this.atlasImage = new i.RGBAImage({
                        width: 1,
                        height: 1
                    }),
                    this.dirty = !0
                }
                isLoaded() {
                    return this.loaded
                }
                setLoaded(l) {
                    if (this.loaded !== l && (this.loaded = l,
                    l)) {
                        for (let {ids: h, callback: _} of this.requestors)
                            this._notify(h, _);
                        this.requestors = []
                    }
                }
                hasImage(l) {
                    return !!this.getImage(l)
                }
                getImage(l) {
                    return this.images[l]
                }
                addImage(l, h) {
                    this._validate(l, h) && (this.images[l] = h)
                }
                _validate(l, h) {
                    let _ = !0;
                    return this._validateStretch(h.stretchX, h.data && h.data.width) || (this.fire(new i.ErrorEvent(new Error(`Image "${l}" has invalid "stretchX" value`))),
                    _ = !1),
                    this._validateStretch(h.stretchY, h.data && h.data.height) || (this.fire(new i.ErrorEvent(new Error(`Image "${l}" has invalid "stretchY" value`))),
                    _ = !1),
                    this._validateContent(h.content, h) || (this.fire(new i.ErrorEvent(new Error(`Image "${l}" has invalid "content" value`))),
                    _ = !1),
                    _
                }
                _validateStretch(l, h) {
                    if (!l)
                        return !0;
                    let _ = 0;
                    for (let b of l) {
                        if (b[0] < _ || b[1] < b[0] || h < b[1])
                            return !1;
                        _ = b[1]
                    }
                    return !0
                }
                _validateContent(l, h) {
                    return !(l && (l.length !== 4 || l[0] < 0 || h.data.width < l[0] || l[1] < 0 || h.data.height < l[1] || l[2] < 0 || h.data.width < l[2] || l[3] < 0 || h.data.height < l[3] || l[2] < l[0] || l[3] < l[1]))
                }
                updateImage(l, h) {
                    h.version = this.images[l].version + 1,
                    this.images[l] = h,
                    this.updatedImages[l] = !0
                }
                removeImage(l) {
                    let h = this.images[l];
                    delete this.images[l],
                    delete this.patterns[l],
                    h.userImage && h.userImage.onRemove && h.userImage.onRemove()
                }
                listImages() {
                    return Object.keys(this.images)
                }
                getImages(l, h) {
                    let _ = !0;
                    if (!this.isLoaded())
                        for (let b of l)
                            this.images[b] || (_ = !1);
                    this.isLoaded() || _ ? this._notify(l, h) : this.requestors.push({
                        ids: l,
                        callback: h
                    })
                }
                _notify(l, h) {
                    let _ = {};
                    for (let b of l) {
                        this.images[b] || this.fire(new i.Event("styleimagemissing",{
                            id: b
                        }));
                        let T = this.images[b];
                        T ? _[b] = {
                            data: T.data.clone(),
                            pixelRatio: T.pixelRatio,
                            sdf: T.sdf,
                            version: T.version,
                            stretchX: T.stretchX,
                            stretchY: T.stretchY,
                            content: T.content,
                            hasRenderCallback: Boolean(T.userImage && T.userImage.render)
                        } : i.warnOnce(`Image "${b}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`)
                    }
                    h(null, _)
                }
                getPixelSize() {
                    let {width: l, height: h} = this.atlasImage;
                    return {
                        width: l,
                        height: h
                    }
                }
                getPattern(l) {
                    let h = this.patterns[l]
                      , _ = this.getImage(l);
                    if (!_)
                        return null;
                    if (h && h.position.version === _.version)
                        return h.position;
                    if (h)
                        h.position.version = _.version;
                    else {
                        let b = {
                            w: _.data.width + 2,
                            h: _.data.height + 2,
                            x: 0,
                            y: 0
                        }
                          , T = new i.ImagePosition(b,_);
                        this.patterns[l] = {
                            bin: b,
                            position: T
                        }
                    }
                    return this._updatePatternAtlas(),
                    this.patterns[l].position
                }
                bind(l) {
                    let h = l.gl;
                    this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage),
                    this.dirty = !1) : this.atlasTexture = new i.Texture(l,this.atlasImage,h.RGBA),
                    this.atlasTexture.bind(h.LINEAR, h.CLAMP_TO_EDGE)
                }
                _updatePatternAtlas() {
                    let l = [];
                    for (let T in this.patterns)
                        l.push(this.patterns[T].bin);
                    let {w: h, h: _} = i.potpack(l)
                      , b = this.atlasImage;
                    b.resize({
                        width: h || 1,
                        height: _ || 1
                    });
                    for (let T in this.patterns) {
                        let {bin: L} = this.patterns[T]
                          , R = L.x + 1
                          , O = L.y + 1
                          , V = this.images[T].data
                          , G = V.width
                          , J = V.height;
                        i.RGBAImage.copy(V, b, {
                            x: 0,
                            y: 0
                        }, {
                            x: R,
                            y: O
                        }, {
                            width: G,
                            height: J
                        }),
                        i.RGBAImage.copy(V, b, {
                            x: 0,
                            y: J - 1
                        }, {
                            x: R,
                            y: O - 1
                        }, {
                            width: G,
                            height: 1
                        }),
                        i.RGBAImage.copy(V, b, {
                            x: 0,
                            y: 0
                        }, {
                            x: R,
                            y: O + J
                        }, {
                            width: G,
                            height: 1
                        }),
                        i.RGBAImage.copy(V, b, {
                            x: G - 1,
                            y: 0
                        }, {
                            x: R - 1,
                            y: O
                        }, {
                            width: 1,
                            height: J
                        }),
                        i.RGBAImage.copy(V, b, {
                            x: 0,
                            y: 0
                        }, {
                            x: R + G,
                            y: O
                        }, {
                            width: 1,
                            height: J
                        })
                    }
                    this.dirty = !0
                }
                beginFrame() {
                    this.callbackDispatchedThisFrame = {}
                }
                dispatchRenderCallbacks(l) {
                    for (let h of l) {
                        if (this.callbackDispatchedThisFrame[h])
                            continue;
                        this.callbackDispatchedThisFrame[h] = !0;
                        let _ = this.images[h];
                        ee(_) && this.updateImage(h, _)
                    }
                }
            }
            let ne = new i.Properties({
                anchor: new i.DataConstantProperty(i.spec.light.anchor),
                position: new class {
                    constructor() {
                        this.specification = i.spec.light.position
                    }
                    possiblyEvaluate(m, l) {
                        return function([h,_,b]) {
                            let T = i.degToRad(_ + 90)
                              , L = i.degToRad(b);
                            return {
                                x: h * Math.cos(T) * Math.sin(L),
                                y: h * Math.sin(T) * Math.sin(L),
                                z: h * Math.cos(L),
                                azimuthal: _,
                                polar: b
                            }
                        }(m.expression.evaluate(l))
                    }
                    interpolate(m, l, h) {
                        return {
                            x: i.number(m.x, l.x, h),
                            y: i.number(m.y, l.y, h),
                            z: i.number(m.z, l.z, h),
                            azimuthal: i.number(m.azimuthal, l.azimuthal, h),
                            polar: i.number(m.polar, l.polar, h)
                        }
                    }
                }
                ,
                color: new i.DataConstantProperty(i.spec.light.color),
                intensity: new i.DataConstantProperty(i.spec.light.intensity)
            })
              , be = "-transition";
            class te extends i.Evented {
                constructor(l) {
                    super(),
                    this._transitionable = new i.Transitionable(ne),
                    this.setLight(l),
                    this._transitioning = this._transitionable.untransitioned()
                }
                getLight() {
                    return this._transitionable.serialize()
                }
                setLight(l, h={}) {
                    if (!this._validate(i.validateLight, l, h))
                        for (let _ in l) {
                            let b = l[_];
                            i.endsWith(_, be) ? this._transitionable.setTransition(_.slice(0, -be.length), b) : this._transitionable.setValue(_, b)
                        }
                }
                updateTransitions(l) {
                    this._transitioning = this._transitionable.transitioned(l, this._transitioning)
                }
                hasTransition() {
                    return this._transitioning.hasTransition()
                }
                recalculate(l) {
                    this.properties = this._transitioning.possiblyEvaluate(l)
                }
                _validate(l, h, _) {
                    return (!_ || _.validate !== !1) && i.emitValidationErrors(this, l.call(i.validateStyle, i.extend({
                        value: h,
                        style: {
                            glyphs: !0,
                            sprite: !0
                        },
                        styleSpec: i.spec
                    })))
                }
            }
            let ae = new i.Properties({
                source: new i.DataConstantProperty(i.spec.terrain.source),
                exaggeration: new i.DataConstantProperty(i.spec.terrain.exaggeration)
            })
              , se = "-transition";
            class ke extends i.Evented {
                constructor(l, h) {
                    super(),
                    this._transitionable = new i.Transitionable(ae),
                    this.set(l),
                    this._transitioning = this._transitionable.untransitioned(),
                    this.drapeRenderMode = h
                }
                get() {
                    return this._transitionable.serialize()
                }
                set(l) {
                    for (let h in l) {
                        let _ = l[h];
                        i.endsWith(h, se) ? this._transitionable.setTransition(h.slice(0, -se.length), _) : this._transitionable.setValue(h, _)
                    }
                }
                updateTransitions(l) {
                    this._transitioning = this._transitionable.transitioned(l, this._transitioning)
                }
                hasTransition() {
                    return this._transitioning.hasTransition()
                }
                recalculate(l) {
                    this.properties = this._transitioning.possiblyEvaluate(l)
                }
            }
            function Be(m, l, h, _) {
                let b = i.smoothstep(45, 65, h)
                  , [T,L] = tt(m, _)
                  , R = i.length(l)
                  , O = 1 - Math.min(1, Math.exp((R - T) / (L - T) * -6));
                return O *= O * O,
                O = Math.min(1, 1.00747 * O),
                O * b * m.alpha
            }
            function tt(m, l) {
                let h = .5 / Math.tan(.5 * l);
                return [m.range[0] + h, m.range[1] + h]
            }
            let Ke = new i.Properties({
                range: new i.DataConstantProperty(i.spec.fog.range),
                color: new i.DataConstantProperty(i.spec.fog.color),
                "high-color": new i.DataConstantProperty(i.spec.fog["high-color"]),
                "space-color": new i.DataConstantProperty(i.spec.fog["space-color"]),
                "horizon-blend": new i.DataConstantProperty(i.spec.fog["horizon-blend"]),
                "star-intensity": new i.DataConstantProperty(i.spec.fog["star-intensity"])
            })
              , bt = "-transition";
            class Et extends i.Evented {
                constructor(l, h) {
                    super(),
                    this._transitionable = new i.Transitionable(Ke),
                    this.set(l),
                    this._transitioning = this._transitionable.untransitioned(),
                    this._transform = h
                }
                get state() {
                    let l = this._transform
                      , h = l.projection.name === "globe"
                      , _ = i.globeToMercatorTransition(l.zoom)
                      , b = this.properties.get("range")
                      , T = [.5, 3];
                    return {
                        range: h ? [i.number(T[0], b[0], _), i.number(T[1], b[1], _)] : b,
                        horizonBlend: this.properties.get("horizon-blend"),
                        alpha: this.properties.get("color").a
                    }
                }
                get() {
                    return this._transitionable.serialize()
                }
                set(l, h={}) {
                    if (!this._validate(i.validateFog, l, h)) {
                        for (let _ of Object.keys(i.spec.fog))
                            l && l[_] === void 0 && (l[_] = i.spec.fog[_].default);
                        for (let _ in l) {
                            let b = l[_];
                            i.endsWith(_, bt) ? this._transitionable.setTransition(_.slice(0, -bt.length), b) : this._transitionable.setValue(_, b)
                        }
                    }
                }
                getOpacity(l) {
                    if (!this._transform.projection.supportsFog)
                        return 0;
                    let h = this.properties && this.properties.get("color") || 1;
                    return (this._transform.projection.name === "globe" ? 1 : i.smoothstep(45, 65, l)) * h.a
                }
                getOpacityAtLatLng(l, h) {
                    return this._transform.projection.supportsFog ? function(_, b, T) {
                        let L = i.MercatorCoordinate.fromLngLat(b)
                          , R = T.elevation ? T.elevation.getAtPointOrZero(L) : 0
                          , O = [L.x, L.y, R];
                        return i.transformMat4(O, O, T.mercatorFogMatrix),
                        Be(_, O, T.pitch, T._fov)
                    }(this.state, l, h) : 0
                }
                getFovAdjustedRange(l) {
                    return this._transform.projection.supportsFog ? tt(this.state, l) : [0, 1]
                }
                updateTransitions(l) {
                    this._transitioning = this._transitionable.transitioned(l, this._transitioning)
                }
                hasTransition() {
                    return this._transitioning.hasTransition()
                }
                recalculate(l) {
                    this.properties = this._transitioning.possiblyEvaluate(l)
                }
                _validate(l, h, _) {
                    return (!_ || _.validate !== !1) && i.emitValidationErrors(this, l.call(i.validateStyle, i.extend({
                        value: h,
                        style: {
                            glyphs: !0,
                            sprite: !0
                        },
                        styleSpec: i.spec
                    })))
                }
            }
            class Gt {
                constructor(l, h) {
                    this.workerPool = l,
                    this.actors = [],
                    this.currentActor = 0,
                    this.id = i.uniqueId();
                    let _ = this.workerPool.acquire(this.id);
                    for (let b = 0; b < _.length; b++) {
                        let T = new Gt.Actor(_[b],h,this.id);
                        T.name = `Worker ${b}`,
                        this.actors.push(T)
                    }
                    this.ready = !1,
                    this.broadcast("checkIfReady", null, ()=>{
                        this.ready = !0
                    }
                    )
                }
                broadcast(l, h, _) {
                    i.asyncAll(this.actors, (b,T)=>{
                        b.send(l, h, T)
                    }
                    , _ = _ || function() {}
                    )
                }
                getActor() {
                    return this.currentActor = (this.currentActor + 1) % this.actors.length,
                    this.actors[this.currentActor]
                }
                remove() {
                    this.actors.forEach(l=>{
                        l.remove()
                    }
                    ),
                    this.actors = [],
                    this.workerPool.release(this.id)
                }
            }
            function Ye(m, l, h) {
                return l * (i.EXTENT / (m.tileSize * Math.pow(2, h - m.tileID.overscaledZ)))
            }
            Gt.Actor = i.Actor;
            class gn {
                constructor(l, h, _, b) {
                    this.screenBounds = l,
                    this.cameraPoint = h,
                    this._screenRaycastCache = {},
                    this._cameraRaycastCache = {},
                    this.isAboveHorizon = _,
                    this.screenGeometry = this.bufferedScreenGeometry(0),
                    this.screenGeometryMercator = this._bufferedScreenMercator(0, b)
                }
                static createFromScreenPoints(l, h) {
                    let _, b;
                    if (l instanceof i.pointGeometry || typeof l[0] == "number") {
                        let T = i.pointGeometry.convert(l);
                        _ = [T],
                        b = h.isPointAboveHorizon(T)
                    } else {
                        let T = i.pointGeometry.convert(l[0])
                          , L = i.pointGeometry.convert(l[1]);
                        _ = [T, L],
                        b = i.polygonizeBounds(T, L).every(R=>h.isPointAboveHorizon(R))
                    }
                    return new gn(_,h.getCameraPoint(),b,h)
                }
                isPointQuery() {
                    return this.screenBounds.length === 1
                }
                bufferedScreenGeometry(l) {
                    return i.polygonizeBounds(this.screenBounds[0], this.screenBounds.length === 1 ? this.screenBounds[0] : this.screenBounds[1], l)
                }
                bufferedCameraGeometry(l) {
                    let h = this.screenBounds[0]
                      , _ = this.screenBounds.length === 1 ? this.screenBounds[0].add(new i.pointGeometry(1,1)) : this.screenBounds[1]
                      , b = i.polygonizeBounds(h, _, 0, !1);
                    return this.cameraPoint.y > _.y && (this.cameraPoint.x > h.x && this.cameraPoint.x < _.x ? b.splice(3, 0, this.cameraPoint) : this.cameraPoint.x >= _.x ? b[2] = this.cameraPoint : this.cameraPoint.x <= h.x && (b[3] = this.cameraPoint)),
                    i.bufferConvexPolygon(b, l)
                }
                bufferedCameraGeometryGlobe(l) {
                    let h = this.screenBounds[0]
                      , _ = this.screenBounds.length === 1 ? this.screenBounds[0].add(new i.pointGeometry(1,1)) : this.screenBounds[1]
                      , b = i.polygonizeBounds(h, _, l)
                      , T = this.cameraPoint.clone();
                    switch (3 * ((T.y > h.y) + (T.y > _.y)) + ((T.x > h.x) + (T.x > _.x))) {
                    case 0:
                        b[0] = T,
                        b[4] = T.clone();
                        break;
                    case 1:
                        b.splice(1, 0, T);
                        break;
                    case 2:
                        b[1] = T;
                        break;
                    case 3:
                        b.splice(4, 0, T);
                        break;
                    case 5:
                        b.splice(2, 0, T);
                        break;
                    case 6:
                        b[3] = T;
                        break;
                    case 7:
                        b.splice(3, 0, T);
                        break;
                    case 8:
                        b[2] = T
                    }
                    return b
                }
                containsTile(l, h, _, b=0) {
                    let T = l.queryPadding / h._pixelsPerMercatorPixel + 1
                      , L = _ ? this._bufferedCameraMercator(T, h) : this._bufferedScreenMercator(T, h)
                      , R = l.tileID.wrap + (L.unwrapped ? b : 0)
                      , O = L.polygon.map(ve=>i.getTilePoint(l.tileTransform, ve, R));
                    if (!i.polygonIntersectsBox(O, 0, 0, i.EXTENT, i.EXTENT))
                        return;
                    R = l.tileID.wrap + (this.screenGeometryMercator.unwrapped ? b : 0);
                    let V = this.screenGeometryMercator.polygon.map(ve=>i.getTileVec3(l.tileTransform, ve, R))
                      , G = V.map(ve=>new i.pointGeometry(ve[0],ve[1]))
                      , J = h.getFreeCameraOptions().position || new i.MercatorCoordinate(0,0,0)
                      , le = i.getTileVec3(l.tileTransform, J, R)
                      , me = V.map(ve=>{
                        let re = i.sub(ve, ve, le);
                        return i.normalize(re, re),
                        new i.Ray(le,re)
                    }
                    )
                      , pe = Ye(l, 1, h.zoom) * h._pixelsPerMercatorPixel;
                    return {
                        queryGeometry: this,
                        tilespaceGeometry: G,
                        tilespaceRays: me,
                        bufferedTilespaceGeometry: O,
                        bufferedTilespaceBounds: (ge = i.getBounds(O),
                        ge.min.x = i.clamp(ge.min.x, 0, i.EXTENT),
                        ge.min.y = i.clamp(ge.min.y, 0, i.EXTENT),
                        ge.max.x = i.clamp(ge.max.x, 0, i.EXTENT),
                        ge.max.y = i.clamp(ge.max.y, 0, i.EXTENT),
                        ge),
                        tile: l,
                        tileID: l.tileID,
                        pixelToTileUnitsFactor: pe
                    };
                    var ge
                }
                _bufferedScreenMercator(l, h) {
                    let _ = xn(l);
                    if (this._screenRaycastCache[_])
                        return this._screenRaycastCache[_];
                    {
                        let b;
                        return b = h.projection.name === "globe" ? this._projectAndResample(this.bufferedScreenGeometry(l), h) : {
                            polygon: this.bufferedScreenGeometry(l).map(T=>h.pointCoordinate3D(T)),
                            unwrapped: !0
                        },
                        this._screenRaycastCache[_] = b,
                        b
                    }
                }
                _bufferedCameraMercator(l, h) {
                    let _ = xn(l);
                    if (this._cameraRaycastCache[_])
                        return this._cameraRaycastCache[_];
                    {
                        let b;
                        return b = h.projection.name === "globe" ? this._projectAndResample(this.bufferedCameraGeometryGlobe(l), h) : {
                            polygon: this.bufferedCameraGeometry(l).map(T=>h.pointCoordinate3D(T)),
                            unwrapped: !0
                        },
                        this._cameraRaycastCache[_] = b,
                        b
                    }
                }
                _projectAndResample(l, h) {
                    let _ = function(T, L) {
                        let R = i.multiply([], L.pixelMatrix, L.globeMatrix)
                          , O = [0, -i.GLOBE_RADIUS, 0, 1]
                          , V = [0, i.GLOBE_RADIUS, 0, 1]
                          , G = [0, 0, 0, 1];
                        i.transformMat4$1(O, O, R),
                        i.transformMat4$1(V, V, R),
                        i.transformMat4$1(G, G, R);
                        let J = new i.pointGeometry(O[0] / O[3],O[1] / O[3])
                          , le = new i.pointGeometry(V[0] / V[3],V[1] / V[3])
                          , me = i.polygonContainsPoint(T, J) && O[3] < G[3]
                          , pe = i.polygonContainsPoint(T, le) && V[3] < G[3];
                        if (!me && !pe)
                            return null;
                        let ge = function(Xe, $e, rt) {
                            for (let lt = 1; lt < Xe.length; lt++) {
                                let Vt = Tn($e.pointCoordinate3D(Xe[lt - 1]).x)
                                  , nt = Tn($e.pointCoordinate3D(Xe[lt]).x);
                                if (rt < 0) {
                                    if (Vt < nt)
                                        return {
                                            idx: lt,
                                            t: -Vt / (nt - 1 - Vt)
                                        }
                                } else if (nt < Vt)
                                    return {
                                        idx: lt,
                                        t: (1 - Vt) / (nt + 1 - Vt)
                                    }
                            }
                            return null
                        }(T, L, me ? -1 : 1);
                        if (!ge)
                            return null;
                        let {idx: ve, t: re} = ge
                          , Ce = ve > 1 ? gt(T.slice(0, ve), L) : []
                          , Ae = ve < T.length ? gt(T.slice(ve), L) : [];
                        Ce = Ce.map(Xe=>new i.pointGeometry(Tn(Xe.x),Xe.y)),
                        Ae = Ae.map(Xe=>new i.pointGeometry(Tn(Xe.x),Xe.y));
                        let De = [...Ce];
                        De.length === 0 && De.push(Ae[Ae.length - 1]);
                        let Ve = i.number(De[De.length - 1].y, (Ae.length === 0 ? Ce[0] : Ae[0]).y, re), Fe;
                        return Fe = me ? [new i.pointGeometry(0,Ve), new i.pointGeometry(0,0), new i.pointGeometry(1,0), new i.pointGeometry(1,Ve)] : [new i.pointGeometry(1,Ve), new i.pointGeometry(1,1), new i.pointGeometry(0,1), new i.pointGeometry(0,Ve)],
                        De.push(...Fe),
                        Ae.length === 0 ? De.push(Ce[0]) : De.push(...Ae),
                        {
                            polygon: De.map(Xe=>new i.MercatorCoordinate(Xe.x,Xe.y)),
                            unwrapped: !1
                        }
                    }(l, h);
                    if (_)
                        return _;
                    let b = function(T, L) {
                        let R = !1
                          , O = -1 / 0
                          , V = 0;
                        for (let J = 0; J < T.length - 1; J++)
                            T[J].x > O && (O = T[J].x,
                            V = J);
                        for (let J = 0; J < T.length - 1; J++) {
                            let le = (V + J) % (T.length - 1)
                              , me = T[le]
                              , pe = T[le + 1];
                            Math.abs(me.x - pe.x) > .5 && (me.x < pe.x ? (me.x += 1,
                            le === 0 && (T[T.length - 1].x += 1)) : (pe.x += 1,
                            le + 1 === T.length - 1 && (T[0].x += 1)),
                            R = !0)
                        }
                        let G = i.mercatorXfromLng(L.center.lng);
                        return R && G < Math.abs(G - 1) && T.forEach(J=>{
                            J.x -= 1
                        }
                        ),
                        {
                            polygon: T,
                            unwrapped: R
                        }
                    }(gt(l, h).map(T=>new i.pointGeometry(Tn(T.x),T.y)), h);
                    return {
                        polygon: b.polygon.map(T=>new i.MercatorCoordinate(T.x,T.y)),
                        unwrapped: b.unwrapped
                    }
                }
            }
            function gt(m, l) {
                return i.resample(m, h=>{
                    let _ = l.pointCoordinate3D(h);
                    h.x = _.x,
                    h.y = _.y
                }
                , 1 / 256)
            }
            function Tn(m) {
                return m < 0 ? 1 + m % 1 : m % 1
            }
            function xn(m) {
                return 100 * m | 0
            }
            function Dn(m, l, h, _, b) {
                let T = function(L, R) {
                    if (L)
                        return b(L);
                    if (R) {
                        m.url && R.tiles && m.tiles && delete m.tiles;
                        let O = i.pick(i.extend(R, m), ["tiles", "minzoom", "maxzoom", "attribution", "mapbox_logo", "bounds", "scheme", "tileSize", "encoding"]);
                        R.vector_layers && (O.vectorLayers = R.vector_layers,
                        O.vectorLayerIds = O.vectorLayers.map(V=>V.id)),
                        O.tiles = l.canonicalizeTileset(O, m.url),
                        b(null, O)
                    }
                };
                return m.url ? i.getJSON(l.transformRequest(l.normalizeSourceURL(m.url, null, h, _), i.ResourceType.Source), T) : i.exported.frame(()=>T(null, m))
            }
            class Bt {
                constructor(l, h, _) {
                    this.bounds = i.LngLatBounds.convert(this.validateBounds(l)),
                    this.minzoom = h || 0,
                    this.maxzoom = _ || 24
                }
                validateBounds(l) {
                    return Array.isArray(l) && l.length === 4 ? [Math.max(-180, l[0]), Math.max(-90, l[1]), Math.min(180, l[2]), Math.min(90, l[3])] : [-180, -90, 180, 90]
                }
                contains(l) {
                    let h = Math.pow(2, l.z)
                      , _ = Math.floor(i.mercatorXfromLng(this.bounds.getWest()) * h)
                      , b = Math.floor(i.mercatorYfromLat(this.bounds.getNorth()) * h)
                      , T = Math.ceil(i.mercatorXfromLng(this.bounds.getEast()) * h)
                      , L = Math.ceil(i.mercatorYfromLat(this.bounds.getSouth()) * h);
                    return l.x >= _ && l.x < T && l.y >= b && l.y < L
                }
            }
            class An {
                constructor(l, h, _) {
                    this.context = l;
                    let b = l.gl;
                    this.buffer = b.createBuffer(),
                    this.dynamicDraw = Boolean(_),
                    this.context.unbindVAO(),
                    l.bindElementBuffer.set(this.buffer),
                    b.bufferData(b.ELEMENT_ARRAY_BUFFER, h.arrayBuffer, this.dynamicDraw ? b.DYNAMIC_DRAW : b.STATIC_DRAW),
                    this.dynamicDraw || h.destroy()
                }
                bind() {
                    this.context.bindElementBuffer.set(this.buffer)
                }
                updateData(l) {
                    let h = this.context.gl;
                    this.context.unbindVAO(),
                    this.bind(),
                    h.bufferSubData(h.ELEMENT_ARRAY_BUFFER, 0, l.arrayBuffer)
                }
                destroy() {
                    this.buffer && (this.context.gl.deleteBuffer(this.buffer),
                    delete this.buffer)
                }
            }
            let ut = {
                Int8: "BYTE",
                Uint8: "UNSIGNED_BYTE",
                Int16: "SHORT",
                Uint16: "UNSIGNED_SHORT",
                Int32: "INT",
                Uint32: "UNSIGNED_INT",
                Float32: "FLOAT"
            };
            class ot {
                constructor(l, h, _, b) {
                    this.length = h.length,
                    this.attributes = _,
                    this.itemSize = h.bytesPerElement,
                    this.dynamicDraw = b,
                    this.context = l;
                    let T = l.gl;
                    this.buffer = T.createBuffer(),
                    l.bindVertexBuffer.set(this.buffer),
                    T.bufferData(T.ARRAY_BUFFER, h.arrayBuffer, this.dynamicDraw ? T.DYNAMIC_DRAW : T.STATIC_DRAW),
                    this.dynamicDraw || h.destroy()
                }
                bind() {
                    this.context.bindVertexBuffer.set(this.buffer)
                }
                updateData(l) {
                    let h = this.context.gl;
                    this.bind(),
                    h.bufferSubData(h.ARRAY_BUFFER, 0, l.arrayBuffer)
                }
                enableAttributes(l, h) {
                    for (let _ = 0; _ < this.attributes.length; _++) {
                        let b = h.attributes[this.attributes[_].name];
                        b !== void 0 && l.enableVertexAttribArray(b)
                    }
                }
                setVertexAttribPointers(l, h, _) {
                    for (let b = 0; b < this.attributes.length; b++) {
                        let T = this.attributes[b]
                          , L = h.attributes[T.name];
                        L !== void 0 && l.vertexAttribPointer(L, T.components, l[ut[T.type]], !1, this.itemSize, T.offset + this.itemSize * (_ || 0))
                    }
                }
                destroy() {
                    this.buffer && (this.context.gl.deleteBuffer(this.buffer),
                    delete this.buffer)
                }
            }
            class xt {
                constructor(l) {
                    this.gl = l.gl,
                    this.default = this.getDefault(),
                    this.current = this.default,
                    this.dirty = !1
                }
                get() {
                    return this.current
                }
                set(l) {}
                getDefault() {
                    return this.default
                }
                setDefault() {
                    this.set(this.default)
                }
            }
            class on extends xt {
                getDefault() {
                    return i.Color.transparent
                }
                set(l) {
                    let h = this.current;
                    (l.r !== h.r || l.g !== h.g || l.b !== h.b || l.a !== h.a || this.dirty) && (this.gl.clearColor(l.r, l.g, l.b, l.a),
                    this.current = l,
                    this.dirty = !1)
                }
            }
            class $t extends xt {
                getDefault() {
                    return 1
                }
                set(l) {
                    (l !== this.current || this.dirty) && (this.gl.clearDepth(l),
                    this.current = l,
                    this.dirty = !1)
                }
            }
            class Pn extends xt {
                getDefault() {
                    return 0
                }
                set(l) {
                    (l !== this.current || this.dirty) && (this.gl.clearStencil(l),
                    this.current = l,
                    this.dirty = !1)
                }
            }
            class kt extends xt {
                getDefault() {
                    return [!0, !0, !0, !0]
                }
                set(l) {
                    let h = this.current;
                    (l[0] !== h[0] || l[1] !== h[1] || l[2] !== h[2] || l[3] !== h[3] || this.dirty) && (this.gl.colorMask(l[0], l[1], l[2], l[3]),
                    this.current = l,
                    this.dirty = !1)
                }
            }
            class Zt extends xt {
                getDefault() {
                    return !0
                }
                set(l) {
                    (l !== this.current || this.dirty) && (this.gl.depthMask(l),
                    this.current = l,
                    this.dirty = !1)
                }
            }
            class zn extends xt {
                getDefault() {
                    return 255
                }
                set(l) {
                    (l !== this.current || this.dirty) && (this.gl.stencilMask(l),
                    this.current = l,
                    this.dirty = !1)
                }
            }
            class Qt extends xt {
                getDefault() {
                    return {
                        func: this.gl.ALWAYS,
                        ref: 0,
                        mask: 255
                    }
                }
                set(l) {
                    let h = this.current;
                    (l.func !== h.func || l.ref !== h.ref || l.mask !== h.mask || this.dirty) && (this.gl.stencilFunc(l.func, l.ref, l.mask),
                    this.current = l,
                    this.dirty = !1)
                }
            }
            class xe extends xt {
                getDefault() {
                    let l = this.gl;
                    return [l.KEEP, l.KEEP, l.KEEP]
                }
                set(l) {
                    let h = this.current;
                    (l[0] !== h[0] || l[1] !== h[1] || l[2] !== h[2] || this.dirty) && (this.gl.stencilOp(l[0], l[1], l[2]),
                    this.current = l,
                    this.dirty = !1)
                }
            }
            class he extends xt {
                getDefault() {
                    return !1
                }
                set(l) {
                    if (l === this.current && !this.dirty)
                        return;
                    let h = this.gl;
                    l ? h.enable(h.STENCIL_TEST) : h.disable(h.STENCIL_TEST),
                    this.current = l,
                    this.dirty = !1
                }
            }
            class Qe extends xt {
                getDefault() {
                    return [0, 1]
                }
                set(l) {
                    let h = this.current;
                    (l[0] !== h[0] || l[1] !== h[1] || this.dirty) && (this.gl.depthRange(l[0], l[1]),
                    this.current = l,
                    this.dirty = !1)
                }
            }
            class ft extends xt {
                getDefault() {
                    return !1
                }
                set(l) {
                    if (l === this.current && !this.dirty)
                        return;
                    let h = this.gl;
                    l ? h.enable(h.DEPTH_TEST) : h.disable(h.DEPTH_TEST),
                    this.current = l,
                    this.dirty = !1
                }
            }
            class St extends xt {
                getDefault() {
                    return this.gl.LESS
                }
                set(l) {
                    (l !== this.current || this.dirty) && (this.gl.depthFunc(l),
                    this.current = l,
                    this.dirty = !1)
                }
            }
            class Mt extends xt {
                getDefault() {
                    return !1
                }
                set(l) {
                    if (l === this.current && !this.dirty)
                        return;
                    let h = this.gl;
                    l ? h.enable(h.BLEND) : h.disable(h.BLEND),
                    this.current = l,
                    this.dirty = !1
                }
            }
            class an extends xt {
                getDefault() {
                    let l = this.gl;
                    return [l.ONE, l.ZERO]
                }
                set(l) {
                    let h = this.current;
                    (l[0] !== h[0] || l[1] !== h[1] || this.dirty) && (this.gl.blendFunc(l[0], l[1]),
                    this.current = l,
                    this.dirty = !1)
                }
            }
            class Ie extends xt {
                getDefault() {
                    return i.Color.transparent
                }
                set(l) {
                    let h = this.current;
                    (l.r !== h.r || l.g !== h.g || l.b !== h.b || l.a !== h.a || this.dirty) && (this.gl.blendColor(l.r, l.g, l.b, l.a),
                    this.current = l,
                    this.dirty = !1)
                }
            }
            class Ct extends xt {
                getDefault() {
                    return this.gl.FUNC_ADD
                }
                set(l) {
                    (l !== this.current || this.dirty) && (this.gl.blendEquation(l),
                    this.current = l,
                    this.dirty = !1)
                }
            }
            class ln extends xt {
                getDefault() {
                    return !1
                }
                set(l) {
                    if (l === this.current && !this.dirty)
                        return;
                    let h = this.gl;
                    l ? h.enable(h.CULL_FACE) : h.disable(h.CULL_FACE),
                    this.current = l,
                    this.dirty = !1
                }
            }
            class Kt extends xt {
                getDefault() {
                    return this.gl.BACK
                }
                set(l) {
                    (l !== this.current || this.dirty) && (this.gl.cullFace(l),
                    this.current = l,
                    this.dirty = !1)
                }
            }
            class Ge extends xt {
                getDefault() {
                    return this.gl.CCW
                }
                set(l) {
                    (l !== this.current || this.dirty) && (this.gl.frontFace(l),
                    this.current = l,
                    this.dirty = !1)
                }
            }
            class Wt extends xt {
                getDefault() {
                    return null
                }
                set(l) {
                    (l !== this.current || this.dirty) && (this.gl.useProgram(l),
                    this.current = l,
                    this.dirty = !1)
                }
            }
            class Ut extends xt {
                getDefault() {
                    return this.gl.TEXTURE0
                }
                set(l) {
                    (l !== this.current || this.dirty) && (this.gl.activeTexture(l),
                    this.current = l,
                    this.dirty = !1)
                }
            }
            class _n extends xt {
                getDefault() {
                    let l = this.gl;
                    return [0, 0, l.drawingBufferWidth, l.drawingBufferHeight]
                }
                set(l) {
                    let h = this.current;
                    (l[0] !== h[0] || l[1] !== h[1] || l[2] !== h[2] || l[3] !== h[3] || this.dirty) && (this.gl.viewport(l[0], l[1], l[2], l[3]),
                    this.current = l,
                    this.dirty = !1)
                }
            }
            class Ft extends xt {
                getDefault() {
                    return null
                }
                set(l) {
                    if (l === this.current && !this.dirty)
                        return;
                    let h = this.gl;
                    h.bindFramebuffer(h.FRAMEBUFFER, l),
                    this.current = l,
                    this.dirty = !1
                }
            }
            class nn extends xt {
                getDefault() {
                    return null
                }
                set(l) {
                    if (l === this.current && !this.dirty)
                        return;
                    let h = this.gl;
                    h.bindRenderbuffer(h.RENDERBUFFER, l),
                    this.current = l,
                    this.dirty = !1
                }
            }
            class Jt extends xt {
                getDefault() {
                    return null
                }
                set(l) {
                    if (l === this.current && !this.dirty)
                        return;
                    let h = this.gl;
                    h.bindTexture(h.TEXTURE_2D, l),
                    this.current = l,
                    this.dirty = !1
                }
            }
            class Ln extends xt {
                getDefault() {
                    return null
                }
                set(l) {
                    if (l === this.current && !this.dirty)
                        return;
                    let h = this.gl;
                    h.bindBuffer(h.ARRAY_BUFFER, l),
                    this.current = l,
                    this.dirty = !1
                }
            }
            class Zn extends xt {
                getDefault() {
                    return null
                }
                set(l) {
                    let h = this.gl;
                    h.bindBuffer(h.ELEMENT_ARRAY_BUFFER, l),
                    this.current = l,
                    this.dirty = !1
                }
            }
            class Vn extends xt {
                constructor(l) {
                    super(l),
                    this.vao = l.extVertexArrayObject
                }
                getDefault() {
                    return null
                }
                set(l) {
                    this.vao && (l !== this.current || this.dirty) && (this.vao.bindVertexArrayOES(l),
                    this.current = l,
                    this.dirty = !1)
                }
            }
            class Tr extends xt {
                getDefault() {
                    return 4
                }
                set(l) {
                    if (l === this.current && !this.dirty)
                        return;
                    let h = this.gl;
                    h.pixelStorei(h.UNPACK_ALIGNMENT, l),
                    this.current = l,
                    this.dirty = !1
                }
            }
            class fr extends xt {
                getDefault() {
                    return !1
                }
                set(l) {
                    if (l === this.current && !this.dirty)
                        return;
                    let h = this.gl;
                    h.pixelStorei(h.UNPACK_PREMULTIPLY_ALPHA_WEBGL, l),
                    this.current = l,
                    this.dirty = !1
                }
            }
            class Rs extends xt {
                getDefault() {
                    return !1
                }
                set(l) {
                    if (l === this.current && !this.dirty)
                        return;
                    let h = this.gl;
                    h.pixelStorei(h.UNPACK_FLIP_Y_WEBGL, l),
                    this.current = l,
                    this.dirty = !1
                }
            }
            class Cr extends xt {
                constructor(l, h) {
                    super(l),
                    this.context = l,
                    this.parent = h
                }
                getDefault() {
                    return null
                }
            }
            class Vr extends Cr {
                setDirty() {
                    this.dirty = !0
                }
                set(l) {
                    if (l === this.current && !this.dirty)
                        return;
                    this.context.bindFramebuffer.set(this.parent);
                    let h = this.gl;
                    h.framebufferTexture2D(h.FRAMEBUFFER, h.COLOR_ATTACHMENT0, h.TEXTURE_2D, l, 0),
                    this.current = l,
                    this.dirty = !1
                }
            }
            class Gr extends Cr {
                attachment() {
                    return this.gl.DEPTH_ATTACHMENT
                }
                set(l) {
                    if (l === this.current && !this.dirty)
                        return;
                    this.context.bindFramebuffer.set(this.parent);
                    let h = this.gl;
                    h.framebufferRenderbuffer(h.FRAMEBUFFER, this.attachment(), h.RENDERBUFFER, l),
                    this.current = l,
                    this.dirty = !1
                }
            }
            class Ps extends Gr {
                attachment() {
                    return this.gl.DEPTH_STENCIL_ATTACHMENT
                }
            }
            class ds {
                constructor(l, h, _, b) {
                    this.context = l,
                    this.width = h,
                    this.height = _;
                    let T = this.framebuffer = l.gl.createFramebuffer();
                    this.colorAttachment = new Vr(l,T),
                    b && (this.depthAttachment = new Gr(l,T))
                }
                destroy() {
                    let l = this.context.gl
                      , h = this.colorAttachment.get();
                    if (h && l.deleteTexture(h),
                    this.depthAttachment) {
                        let _ = this.depthAttachment.get();
                        _ && l.deleteRenderbuffer(_)
                    }
                    l.deleteFramebuffer(this.framebuffer)
                }
            }
            class Te {
                constructor(l, h=!1) {
                    if (this.gl = l,
                    this.isWebGL2 = h,
                    this.extVertexArrayObject = this.gl.getExtension("OES_vertex_array_object"),
                    h) {
                        let _ = l;
                        this.extVertexArrayObject = {
                            createVertexArrayOES: _.createVertexArray.bind(l),
                            deleteVertexArrayOES: _.deleteVertexArray.bind(l),
                            bindVertexArrayOES: _.bindVertexArray.bind(l)
                        }
                    }
                    this.clearColor = new on(this),
                    this.clearDepth = new $t(this),
                    this.clearStencil = new Pn(this),
                    this.colorMask = new kt(this),
                    this.depthMask = new Zt(this),
                    this.stencilMask = new zn(this),
                    this.stencilFunc = new Qt(this),
                    this.stencilOp = new xe(this),
                    this.stencilTest = new he(this),
                    this.depthRange = new Qe(this),
                    this.depthTest = new ft(this),
                    this.depthFunc = new St(this),
                    this.blend = new Mt(this),
                    this.blendFunc = new an(this),
                    this.blendColor = new Ie(this),
                    this.blendEquation = new Ct(this),
                    this.cullFace = new ln(this),
                    this.cullFaceSide = new Kt(this),
                    this.frontFace = new Ge(this),
                    this.program = new Wt(this),
                    this.activeTexture = new Ut(this),
                    this.viewport = new _n(this),
                    this.bindFramebuffer = new Ft(this),
                    this.bindRenderbuffer = new nn(this),
                    this.bindTexture = new Jt(this),
                    this.bindVertexBuffer = new Ln(this),
                    this.bindElementBuffer = new Zn(this),
                    this.bindVertexArrayOES = this.extVertexArrayObject && new Vn(this),
                    this.pixelStoreUnpack = new Tr(this),
                    this.pixelStoreUnpackPremultiplyAlpha = new fr(this),
                    this.pixelStoreUnpackFlipY = new Rs(this),
                    this.extTextureFilterAnisotropic = l.getExtension("EXT_texture_filter_anisotropic") || l.getExtension("MOZ_EXT_texture_filter_anisotropic") || l.getExtension("WEBKIT_EXT_texture_filter_anisotropic"),
                    this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = l.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)),
                    this.extTextureFilterAnisotropicForceOff = !1,
                    this.extStandardDerivativesForceOff = !1,
                    this.extDebugRendererInfo = l.getExtension("WEBGL_debug_renderer_info"),
                    this.extDebugRendererInfo && (this.renderer = l.getParameter(this.extDebugRendererInfo.UNMASKED_RENDERER_WEBGL),
                    this.vendor = l.getParameter(this.extDebugRendererInfo.UNMASKED_VENDOR_WEBGL)),
                    h || (this.extTextureHalfFloat = l.getExtension("OES_texture_half_float")),
                    (h || this.extTextureHalfFloat && l.getExtension("OES_texture_half_float_linear")) && (this.extRenderToTextureHalfFloat = l.getExtension("EXT_color_buffer_half_float")),
                    this.extStandardDerivatives = h || l.getExtension("OES_standard_derivatives"),
                    this.extTimerQuery = l.getExtension("EXT_disjoint_timer_query"),
                    this.maxTextureSize = l.getParameter(l.MAX_TEXTURE_SIZE)
                }
                setDefault() {
                    this.unbindVAO(),
                    this.clearColor.setDefault(),
                    this.clearDepth.setDefault(),
                    this.clearStencil.setDefault(),
                    this.colorMask.setDefault(),
                    this.depthMask.setDefault(),
                    this.stencilMask.setDefault(),
                    this.stencilFunc.setDefault(),
                    this.stencilOp.setDefault(),
                    this.stencilTest.setDefault(),
                    this.depthRange.setDefault(),
                    this.depthTest.setDefault(),
                    this.depthFunc.setDefault(),
                    this.blend.setDefault(),
                    this.blendFunc.setDefault(),
                    this.blendColor.setDefault(),
                    this.blendEquation.setDefault(),
                    this.cullFace.setDefault(),
                    this.cullFaceSide.setDefault(),
                    this.frontFace.setDefault(),
                    this.program.setDefault(),
                    this.activeTexture.setDefault(),
                    this.bindFramebuffer.setDefault(),
                    this.pixelStoreUnpack.setDefault(),
                    this.pixelStoreUnpackPremultiplyAlpha.setDefault(),
                    this.pixelStoreUnpackFlipY.setDefault()
                }
                setDirty() {
                    this.clearColor.dirty = !0,
                    this.clearDepth.dirty = !0,
                    this.clearStencil.dirty = !0,
                    this.colorMask.dirty = !0,
                    this.depthMask.dirty = !0,
                    this.stencilMask.dirty = !0,
                    this.stencilFunc.dirty = !0,
                    this.stencilOp.dirty = !0,
                    this.stencilTest.dirty = !0,
                    this.depthRange.dirty = !0,
                    this.depthTest.dirty = !0,
                    this.depthFunc.dirty = !0,
                    this.blend.dirty = !0,
                    this.blendFunc.dirty = !0,
                    this.blendColor.dirty = !0,
                    this.blendEquation.dirty = !0,
                    this.cullFace.dirty = !0,
                    this.cullFaceSide.dirty = !0,
                    this.frontFace.dirty = !0,
                    this.program.dirty = !0,
                    this.activeTexture.dirty = !0,
                    this.viewport.dirty = !0,
                    this.bindFramebuffer.dirty = !0,
                    this.bindRenderbuffer.dirty = !0,
                    this.bindTexture.dirty = !0,
                    this.bindVertexBuffer.dirty = !0,
                    this.bindElementBuffer.dirty = !0,
                    this.extVertexArrayObject && (this.bindVertexArrayOES.dirty = !0),
                    this.pixelStoreUnpack.dirty = !0,
                    this.pixelStoreUnpackPremultiplyAlpha.dirty = !0,
                    this.pixelStoreUnpackFlipY.dirty = !0
                }
                createIndexBuffer(l, h) {
                    return new An(this,l,h)
                }
                createVertexBuffer(l, h, _) {
                    return new ot(this,l,h,_)
                }
                createRenderbuffer(l, h, _) {
                    let b = this.gl
                      , T = b.createRenderbuffer();
                    return this.bindRenderbuffer.set(T),
                    b.renderbufferStorage(b.RENDERBUFFER, l, h, _),
                    this.bindRenderbuffer.set(null),
                    T
                }
                createFramebuffer(l, h, _) {
                    return new ds(this,l,h,_)
                }
                clear({color: l, depth: h, stencil: _}) {
                    let b = this.gl
                      , T = 0;
                    l && (T |= b.COLOR_BUFFER_BIT,
                    this.clearColor.set(l),
                    this.colorMask.set([!0, !0, !0, !0])),
                    h !== void 0 && (T |= b.DEPTH_BUFFER_BIT,
                    this.depthRange.set([0, 1]),
                    this.clearDepth.set(h),
                    this.depthMask.set(!0)),
                    _ !== void 0 && (T |= b.STENCIL_BUFFER_BIT,
                    this.clearStencil.set(_),
                    this.stencilMask.set(255)),
                    b.clear(T)
                }
                setCullFace(l) {
                    l.enable === !1 ? this.cullFace.set(!1) : (this.cullFace.set(!0),
                    this.cullFaceSide.set(l.mode),
                    this.frontFace.set(l.frontFace))
                }
                setDepthMode(l) {
                    l.func !== this.gl.ALWAYS || l.mask ? (this.depthTest.set(!0),
                    this.depthFunc.set(l.func),
                    this.depthMask.set(l.mask),
                    this.depthRange.set(l.range)) : this.depthTest.set(!1)
                }
                setStencilMode(l) {
                    l.test.func !== this.gl.ALWAYS || l.mask ? (this.stencilTest.set(!0),
                    this.stencilMask.set(l.mask),
                    this.stencilOp.set([l.fail, l.depthFail, l.pass]),
                    this.stencilFunc.set({
                        func: l.test.func,
                        ref: l.ref,
                        mask: l.test.mask
                    })) : this.stencilTest.set(!1)
                }
                setColorMode(l) {
                    v(l.blendFunction, i.ColorMode.Replace) ? this.blend.set(!1) : (this.blend.set(!0),
                    this.blendFunc.set(l.blendFunction),
                    this.blendColor.set(l.blendColor)),
                    this.colorMask.set(l.mask)
                }
                unbindVAO() {
                    this.extVertexArrayObject && this.bindVertexArrayOES.set(null)
                }
            }
            class Y extends i.Evented {
                constructor(l, h, _, b) {
                    if (super(),
                    this.id = l,
                    this.dispatcher = _,
                    this.type = "vector",
                    this.minzoom = 0,
                    this.maxzoom = 22,
                    this.scheme = "xyz",
                    this.tileSize = 512,
                    this.reparseOverscaled = !0,
                    this.isTileClipped = !0,
                    this._loaded = !1,
                    i.extend(this, i.pick(h, ["url", "scheme", "tileSize", "promoteId"])),
                    this._options = i.extend({
                        type: "vector"
                    }, h),
                    this._collectResourceTiming = h.collectResourceTiming,
                    this.tileSize !== 512)
                        throw new Error("vector tile sources must have a tileSize of 512");
                    this.setEventedParent(b),
                    this._tileWorkers = {},
                    this._deduped = new i.DedupedRequest
                }
                load(l) {
                    this._loaded = !1,
                    this.fire(new i.Event("dataloading",{
                        dataType: "source"
                    }));
                    let h = Array.isArray(this.map._language) ? this.map._language.join() : this.map._language
                      , _ = this.map._worldview;
                    this._tileJSONRequest = Dn(this._options, this.map._requestManager, h, _, (b,T)=>{
                        this._tileJSONRequest = null,
                        this._loaded = !0,
                        b ? (h && console.warn(`Ensure that your requested language string is a valid BCP-47 code or list of codes. Found: ${h}`),
                        _ && _.length !== 2 && console.warn(`Requested worldview strings must be a valid ISO alpha-2 code. Found: ${_}`),
                        this.fire(new i.ErrorEvent(b))) : T && (i.extend(this, T),
                        T.bounds && (this.tileBounds = new Bt(T.bounds,this.minzoom,this.maxzoom)),
                        i.postTurnstileEvent(T.tiles, this.map._requestManager._customAccessToken),
                        this.fire(new i.Event("data",{
                            dataType: "source",
                            sourceDataType: "metadata"
                        })),
                        this.fire(new i.Event("data",{
                            dataType: "source",
                            sourceDataType: "content"
                        }))),
                        l && l(b)
                    }
                    )
                }
                loaded() {
                    return this._loaded
                }
                hasTile(l) {
                    return !this.tileBounds || this.tileBounds.contains(l.canonical)
                }
                onAdd(l) {
                    this.map = l,
                    this.load()
                }
                reload() {
                    this.cancelTileJSONRequest(),
                    this.load(()=>this.map.style._clearSource(this.id))
                }
                setTiles(l) {
                    return this._options.tiles = l,
                    this.reload(),
                    this
                }
                setUrl(l) {
                    return this.url = l,
                    this._options.url = l,
                    this.reload(),
                    this
                }
                onRemove() {
                    this.cancelTileJSONRequest()
                }
                serialize() {
                    return i.extend({}, this._options)
                }
                loadTile(l, h) {
                    let _ = this.map._requestManager.normalizeTileURL(l.tileID.canonical.url(this.tiles, this.scheme))
                      , b = {
                        request: this.map._requestManager.transformRequest(_, i.ResourceType.Tile),
                        data: void 0,
                        uid: l.uid,
                        tileID: l.tileID,
                        tileZoom: l.tileZoom,
                        zoom: l.tileID.overscaledZ,
                        tileSize: this.tileSize * l.tileID.overscaleFactor(),
                        type: this.type,
                        source: this.id,
                        pixelRatio: i.exported.devicePixelRatio,
                        showCollisionBoxes: this.map.showCollisionBoxes,
                        promoteId: this.promoteId,
                        isSymbolTile: l.isSymbolTile
                    };
                    if (b.request.collectResourceTiming = this._collectResourceTiming,
                    l.actor && l.state !== "expired")
                        l.state === "loading" ? l.reloadCallback = h : l.request = l.actor.send("reloadTile", b, T.bind(this));
                    else if (l.actor = this._tileWorkers[_] = this._tileWorkers[_] || this.dispatcher.getActor(),
                    this.dispatcher.ready)
                        l.request = l.actor.send("loadTile", b, T.bind(this), void 0, !0);
                    else {
                        let L = i.loadVectorTile.call({
                            deduped: this._deduped
                        }, b, (R,O)=>{
                            R || !O ? T.call(this, R) : (b.data = {
                                cacheControl: O.cacheControl,
                                expires: O.expires,
                                rawData: O.rawData.slice(0)
                            },
                            l.actor && l.actor.send("loadTile", b, T.bind(this), void 0, !0))
                        }
                        , !0);
                        l.request = {
                            cancel: L
                        }
                    }
                    function T(L, R) {
                        return delete l.request,
                        l.aborted ? h(null) : L && L.status !== 404 ? h(L) : (R && R.resourceTiming && (l.resourceTiming = R.resourceTiming),
                        this.map._refreshExpiredTiles && R && l.setExpiryData(R),
                        l.loadVectorData(R, this.map.painter),
                        i.cacheEntryPossiblyAdded(this.dispatcher),
                        h(null),
                        void (l.reloadCallback && (this.loadTile(l, l.reloadCallback),
                        l.reloadCallback = null)))
                    }
                }
                abortTile(l) {
                    l.request && (l.request.cancel(),
                    delete l.request),
                    l.actor && l.actor.send("abortTile", {
                        uid: l.uid,
                        type: this.type,
                        source: this.id
                    })
                }
                unloadTile(l) {
                    l.unloadVectorData(),
                    l.actor && l.actor.send("removeTile", {
                        uid: l.uid,
                        type: this.type,
                        source: this.id
                    })
                }
                hasTransition() {
                    return !1
                }
                afterUpdate() {
                    this._tileWorkers = {}
                }
                cancelTileJSONRequest() {
                    this._tileJSONRequest && (this._tileJSONRequest.cancel(),
                    this._tileJSONRequest = null)
                }
            }
            class F extends i.Evented {
                constructor(l, h, _, b) {
                    super(),
                    this.id = l,
                    this.dispatcher = _,
                    this.setEventedParent(b),
                    this.type = "raster",
                    this.minzoom = 0,
                    this.maxzoom = 22,
                    this.roundZoom = !0,
                    this.scheme = "xyz",
                    this.tileSize = 512,
                    this._loaded = !1,
                    this._options = i.extend({
                        type: "raster"
                    }, h),
                    i.extend(this, i.pick(h, ["url", "scheme", "tileSize"]))
                }
                load(l) {
                    this._loaded = !1,
                    this.fire(new i.Event("dataloading",{
                        dataType: "source"
                    })),
                    this._tileJSONRequest = Dn(this._options, this.map._requestManager, null, null, (h,_)=>{
                        this._tileJSONRequest = null,
                        this._loaded = !0,
                        h ? this.fire(new i.ErrorEvent(h)) : _ && (i.extend(this, _),
                        _.bounds && (this.tileBounds = new Bt(_.bounds,this.minzoom,this.maxzoom)),
                        i.postTurnstileEvent(_.tiles),
                        this.fire(new i.Event("data",{
                            dataType: "source",
                            sourceDataType: "metadata"
                        })),
                        this.fire(new i.Event("data",{
                            dataType: "source",
                            sourceDataType: "content"
                        }))),
                        l && l(h)
                    }
                    )
                }
                loaded() {
                    return this._loaded
                }
                onAdd(l) {
                    this.map = l,
                    this.load()
                }
                reload() {
                    this.cancelTileJSONRequest(),
                    this.load(()=>this.map.style._clearSource(this.id))
                }
                setTiles(l) {
                    return this._options.tiles = l,
                    this.reload(),
                    this
                }
                setUrl(l) {
                    return this.url = l,
                    this._options.url = l,
                    this.reload(),
                    this
                }
                onRemove() {
                    this.cancelTileJSONRequest()
                }
                serialize() {
                    return i.extend({}, this._options)
                }
                hasTile(l) {
                    return !this.tileBounds || this.tileBounds.contains(l.canonical)
                }
                loadTile(l, h) {
                    let _ = i.exported.devicePixelRatio >= 2
                      , b = this.map._requestManager.normalizeTileURL(l.tileID.canonical.url(this.tiles, this.scheme), _, this.tileSize);
                    l.request = i.getImage(this.map._requestManager.transformRequest(b, i.ResourceType.Tile), (T,L,R,O)=>(delete l.request,
                    l.aborted ? (l.state = "unloaded",
                    h(null)) : T ? (l.state = "errored",
                    h(T)) : L ? (this.map._refreshExpiredTiles && l.setExpiryData({
                        cacheControl: R,
                        expires: O
                    }),
                    l.setTexture(L, this.map.painter),
                    l.state = "loaded",
                    i.cacheEntryPossiblyAdded(this.dispatcher),
                    void h(null)) : h(null)))
                }
                static loadTileData(l, h, _) {
                    l.setTexture(h, _)
                }
                static unloadTileData(l, h) {
                    l.texture && h.saveTileTexture(l.texture)
                }
                abortTile(l, h) {
                    l.request && (l.request.cancel(),
                    delete l.request),
                    h()
                }
                unloadTile(l, h) {
                    l.texture && this.map.painter.saveTileTexture(l.texture),
                    h()
                }
                hasTransition() {
                    return !1
                }
                cancelTileJSONRequest() {
                    this._tileJSONRequest && (this._tileJSONRequest.cancel(),
                    this._tileJSONRequest = null)
                }
            }
            let $;
            function ie(m, l, h, _, b, T, L, R) {
                let O = [m, h, b, l, _, T, 1, 1, 1]
                  , V = [L, R, 1]
                  , G = i.adjoint([], O)
                  , [J,le,me] = i.transformMat3(V, V, i.transpose(G, G));
                return i.multiply$1(O, [J, 0, 0, 0, le, 0, 0, 0, me], O)
            }
            class ue extends i.Evented {
                constructor(l, h, _, b) {
                    super(),
                    this.id = l,
                    this.dispatcher = _,
                    this.coordinates = h.coordinates,
                    this.type = "image",
                    this.minzoom = 0,
                    this.maxzoom = 22,
                    this.tileSize = 512,
                    this.tiles = {},
                    this._loaded = !1,
                    this.setEventedParent(b),
                    this.options = h,
                    this._dirty = !1
                }
                load(l, h) {
                    this._loaded = h || !1,
                    this.fire(new i.Event("dataloading",{
                        dataType: "source"
                    })),
                    this.url = this.options.url,
                    this._imageRequest = i.getImage(this.map._requestManager.transformRequest(this.url, i.ResourceType.Image), (_,b)=>{
                        if (this._imageRequest = null,
                        this._loaded = !0,
                        _)
                            this.fire(new i.ErrorEvent(_));
                        else if (b) {
                            let {HTMLImageElement: T} = i.window;
                            this.image = b instanceof T ? i.exported.getImageData(b) : b,
                            this._dirty = !0,
                            this.width = this.image.width,
                            this.height = this.image.height,
                            l && (this.coordinates = l),
                            this._finishLoading()
                        }
                    }
                    )
                }
                loaded() {
                    return this._loaded
                }
                updateImage(l) {
                    return this.image && l.url ? (this._imageRequest && l.url !== this.options.url && (this._imageRequest.cancel(),
                    this._imageRequest = null),
                    this.options.url = l.url,
                    this.load(l.coordinates, this._loaded),
                    this) : this
                }
                _finishLoading() {
                    this.map && (this.setCoordinates(this.coordinates),
                    this.fire(new i.Event("data",{
                        dataType: "source",
                        sourceDataType: "metadata"
                    })))
                }
                onAdd(l) {
                    this.map = l,
                    this.load()
                }
                onRemove() {
                    this._imageRequest && (this._imageRequest.cancel(),
                    this._imageRequest = null),
                    this.texture && this.texture.destroy()
                }
                setCoordinates(l) {
                    this.coordinates = l,
                    this._boundsArray = void 0;
                    let h = l.map(i.MercatorCoordinate.fromLngLat);
                    return this.tileID = function(_) {
                        let b = 1 / 0
                          , T = 1 / 0
                          , L = -1 / 0
                          , R = -1 / 0;
                        for (let J of _)
                            b = Math.min(b, J.x),
                            T = Math.min(T, J.y),
                            L = Math.max(L, J.x),
                            R = Math.max(R, J.y);
                        let O = Math.max(L - b, R - T)
                          , V = Math.max(0, Math.floor(-Math.log(O) / Math.LN2))
                          , G = Math.pow(2, V);
                        return new i.CanonicalTileID(V,Math.floor((b + L) / 2 * G),Math.floor((T + R) / 2 * G))
                    }(h),
                    this.minzoom = this.maxzoom = this.tileID.z,
                    this.fire(new i.Event("data",{
                        dataType: "source",
                        sourceDataType: "content"
                    })),
                    this
                }
                _clear() {
                    this._boundsArray = void 0
                }
                _prepareData(l) {
                    for (let O in this.tiles) {
                        let V = this.tiles[O];
                        V.state !== "loaded" && (V.state = "loaded",
                        V.texture = this.texture)
                    }
                    if (this._boundsArray)
                        return;
                    let h = i.tileTransform(this.tileID, this.map.transform.projection)
                      , [_,b,T,L] = this.coordinates.map(O=>{
                        let V = h.projection.project(O[0], O[1]);
                        return i.getTilePoint(h, V)._round()
                    }
                    );
                    this.perspectiveTransform = function(O, V, G, J, le, me, pe, ge, ve, re) {
                        let Ce = ie(0, 0, O, 0, 0, V, O, V)
                          , Ae = ie(G, J, le, me, pe, ge, ve, re);
                        return i.multiply$1(Ae, i.adjoint(Ce, Ce), Ae),
                        [Ae[6] / Ae[8] * O / i.EXTENT, Ae[7] / Ae[8] * V / i.EXTENT]
                    }(this.width, this.height, _.x, _.y, b.x, b.y, L.x, L.y, T.x, T.y);
                    let R = this._boundsArray = new i.StructArrayLayout4i8;
                    R.emplaceBack(_.x, _.y, 0, 0),
                    R.emplaceBack(b.x, b.y, i.EXTENT, 0),
                    R.emplaceBack(L.x, L.y, 0, i.EXTENT),
                    R.emplaceBack(T.x, T.y, i.EXTENT, i.EXTENT),
                    this.boundsBuffer && this.boundsBuffer.destroy(),
                    this.boundsBuffer = l.createVertexBuffer(R, i.boundsAttributes.members),
                    this.boundsSegments = i.SegmentVector.simpleSegment(0, 0, 4, 2)
                }
                prepare() {
                    if (Object.keys(this.tiles).length === 0 || !this.image)
                        return;
                    let l = this.map.painter.context
                      , h = l.gl;
                    this._dirty && (this.texture ? this.texture.update(this.image) : (this.texture = new i.Texture(l,this.image,h.RGBA),
                    this.texture.bind(h.LINEAR, h.CLAMP_TO_EDGE)),
                    this._dirty = !1),
                    this._prepareData(l)
                }
                loadTile(l, h) {
                    this.tileID && this.tileID.equals(l.tileID.canonical) ? (this.tiles[String(l.tileID.wrap)] = l,
                    l.buckets = {},
                    h(null)) : (l.state = "errored",
                    h(null))
                }
                serialize() {
                    return {
                        type: "image",
                        url: this.options.url,
                        coordinates: this.coordinates
                    }
                }
                hasTransition() {
                    return !1
                }
            }
            let Ee = {
                vector: Y,
                raster: F,
                "raster-dem": class extends F {
                    constructor(m, l, h, _) {
                        super(m, l, h, _),
                        this.type = "raster-dem",
                        this.maxzoom = 22,
                        this._options = i.extend({
                            type: "raster-dem"
                        }, l),
                        this.encoding = l.encoding || "mapbox"
                    }
                    loadTile(m, l) {
                        let h = this.map._requestManager.normalizeTileURL(m.tileID.canonical.url(this.tiles, this.scheme), !1, this.tileSize);
                        function _(b, T) {
                            b && (m.state = "errored",
                            l(b)),
                            T && (m.dem = T,
                            m.dem.onDeserialize(),
                            m.needsHillshadePrepare = !0,
                            m.needsDEMTextureUpload = !0,
                            m.state = "loaded",
                            l(null))
                        }
                        m.request = i.getImage(this.map._requestManager.transformRequest(h, i.ResourceType.Tile), function(b, T, L, R) {
                            if (delete m.request,
                            m.aborted)
                                m.state = "unloaded",
                                l(null);
                            else if (b)
                                m.state = "errored",
                                l(b);
                            else if (T) {
                                this.map._refreshExpiredTiles && m.setExpiryData({
                                    cacheControl: L,
                                    expires: R
                                });
                                let O = i.window.ImageBitmap && T instanceof i.window.ImageBitmap && ($ == null && ($ = i.window.OffscreenCanvas && new i.window.OffscreenCanvas(1,1).getContext("2d") && typeof i.window.createImageBitmap == "function"),
                                $)
                                  , V = 1 - (T.width - i.prevPowerOfTwo(T.width)) / 2;
                                V < 1 || m.neighboringTiles || (m.neighboringTiles = this._getNeighboringTiles(m.tileID));
                                let G = O ? T : i.exported.getImageData(T, V)
                                  , J = {
                                    uid: m.uid,
                                    coord: m.tileID,
                                    source: this.id,
                                    rawImageData: G,
                                    encoding: this.encoding,
                                    padding: V
                                };
                                m.actor && m.state !== "expired" || (m.actor = this.dispatcher.getActor(),
                                m.actor.send("loadDEMTile", J, _.bind(this), void 0, !0))
                            }
                        }
                        .bind(this))
                    }
                    _getNeighboringTiles(m) {
                        let l = m.canonical
                          , h = Math.pow(2, l.z)
                          , _ = (l.x - 1 + h) % h
                          , b = l.x === 0 ? m.wrap - 1 : m.wrap
                          , T = (l.x + 1 + h) % h
                          , L = l.x + 1 === h ? m.wrap + 1 : m.wrap
                          , R = {};
                        return R[new i.OverscaledTileID(m.overscaledZ,b,l.z,_,l.y).key] = {
                            backfilled: !1
                        },
                        R[new i.OverscaledTileID(m.overscaledZ,L,l.z,T,l.y).key] = {
                            backfilled: !1
                        },
                        l.y > 0 && (R[new i.OverscaledTileID(m.overscaledZ,b,l.z,_,l.y - 1).key] = {
                            backfilled: !1
                        },
                        R[new i.OverscaledTileID(m.overscaledZ,m.wrap,l.z,l.x,l.y - 1).key] = {
                            backfilled: !1
                        },
                        R[new i.OverscaledTileID(m.overscaledZ,L,l.z,T,l.y - 1).key] = {
                            backfilled: !1
                        }),
                        l.y + 1 < h && (R[new i.OverscaledTileID(m.overscaledZ,b,l.z,_,l.y + 1).key] = {
                            backfilled: !1
                        },
                        R[new i.OverscaledTileID(m.overscaledZ,m.wrap,l.z,l.x,l.y + 1).key] = {
                            backfilled: !1
                        },
                        R[new i.OverscaledTileID(m.overscaledZ,L,l.z,T,l.y + 1).key] = {
                            backfilled: !1
                        }),
                        R
                    }
                    unloadTile(m) {
                        m.demTexture && this.map.painter.saveTileTexture(m.demTexture),
                        m.fbo && (m.fbo.destroy(),
                        delete m.fbo),
                        m.dem && delete m.dem,
                        delete m.neighboringTiles,
                        m.state = "unloaded"
                    }
                }
                ,
                geojson: class extends i.Evented {
                    constructor(m, l, h, _) {
                        super(),
                        this.id = m,
                        this.type = "geojson",
                        this.minzoom = 0,
                        this.maxzoom = 18,
                        this.tileSize = 512,
                        this.isTileClipped = !0,
                        this.reparseOverscaled = !0,
                        this._loaded = !1,
                        this.actor = h.getActor(),
                        this.setEventedParent(_),
                        this._data = l.data,
                        this._options = i.extend({}, l),
                        this._collectResourceTiming = l.collectResourceTiming,
                        l.maxzoom !== void 0 && (this.maxzoom = l.maxzoom),
                        l.type && (this.type = l.type),
                        l.attribution && (this.attribution = l.attribution),
                        this.promoteId = l.promoteId;
                        let b = i.EXTENT / this.tileSize;
                        this.workerOptions = i.extend({
                            source: this.id,
                            cluster: l.cluster || !1,
                            geojsonVtOptions: {
                                buffer: (l.buffer !== void 0 ? l.buffer : 128) * b,
                                tolerance: (l.tolerance !== void 0 ? l.tolerance : .375) * b,
                                extent: i.EXTENT,
                                maxZoom: this.maxzoom,
                                lineMetrics: l.lineMetrics || !1,
                                generateId: l.generateId || !1
                            },
                            superclusterOptions: {
                                maxZoom: l.clusterMaxZoom !== void 0 ? l.clusterMaxZoom : this.maxzoom - 1,
                                minPoints: Math.max(2, l.clusterMinPoints || 2),
                                extent: i.EXTENT,
                                radius: (l.clusterRadius !== void 0 ? l.clusterRadius : 50) * b,
                                log: !1,
                                generateId: l.generateId || !1
                            },
                            clusterProperties: l.clusterProperties,
                            filter: l.filter
                        }, l.workerOptions)
                    }
                    onAdd(m) {
                        this.map = m,
                        this.setData(this._data)
                    }
                    setData(m) {
                        return this._data = m,
                        this._updateWorkerData(),
                        this
                    }
                    getClusterExpansionZoom(m, l) {
                        return this.actor.send("geojson.getClusterExpansionZoom", {
                            clusterId: m,
                            source: this.id
                        }, l),
                        this
                    }
                    getClusterChildren(m, l) {
                        return this.actor.send("geojson.getClusterChildren", {
                            clusterId: m,
                            source: this.id
                        }, l),
                        this
                    }
                    getClusterLeaves(m, l, h, _) {
                        return this.actor.send("geojson.getClusterLeaves", {
                            source: this.id,
                            clusterId: m,
                            limit: l,
                            offset: h
                        }, _),
                        this
                    }
                    _updateWorkerData() {
                        if (this._pendingLoad)
                            return void (this._coalesce = !0);
                        this.fire(new i.Event("dataloading",{
                            dataType: "source"
                        })),
                        this._loaded = !1;
                        let m = i.extend({}, this.workerOptions)
                          , l = this._data;
                        typeof l == "string" ? (m.request = this.map._requestManager.transformRequest(i.exported.resolveURL(l), i.ResourceType.Source),
                        m.request.collectResourceTiming = this._collectResourceTiming) : m.data = JSON.stringify(l),
                        this._pendingLoad = this.actor.send(`${this.type}.loadData`, m, (h,_)=>{
                            if (this._loaded = !0,
                            this._pendingLoad = null,
                            h)
                                this.fire(new i.ErrorEvent(h));
                            else {
                                let b = {
                                    dataType: "source",
                                    sourceDataType: this._metadataFired ? "content" : "metadata"
                                };
                                this._collectResourceTiming && _ && _.resourceTiming && _.resourceTiming[this.id] && (b.resourceTiming = _.resourceTiming[this.id]),
                                this.fire(new i.Event("data",b)),
                                this._metadataFired = !0
                            }
                            this._coalesce && (this._updateWorkerData(),
                            this._coalesce = !1)
                        }
                        )
                    }
                    loaded() {
                        return this._loaded
                    }
                    loadTile(m, l) {
                        let h = m.actor ? "reloadTile" : "loadTile";
                        m.actor = this.actor,
                        m.request = this.actor.send(h, {
                            type: this.type,
                            uid: m.uid,
                            tileID: m.tileID,
                            tileZoom: m.tileZoom,
                            zoom: m.tileID.overscaledZ,
                            maxZoom: this.maxzoom,
                            tileSize: this.tileSize,
                            source: this.id,
                            pixelRatio: i.exported.devicePixelRatio,
                            showCollisionBoxes: this.map.showCollisionBoxes,
                            promoteId: this.promoteId
                        }, (_,b)=>(delete m.request,
                        m.unloadVectorData(),
                        m.aborted ? l(null) : _ ? l(_) : (m.loadVectorData(b, this.map.painter, h === "reloadTile"),
                        l(null))), void 0, h === "loadTile")
                    }
                    abortTile(m) {
                        m.request && (m.request.cancel(),
                        delete m.request),
                        m.aborted = !0
                    }
                    unloadTile(m) {
                        m.unloadVectorData(),
                        this.actor.send("removeTile", {
                            uid: m.uid,
                            type: this.type,
                            source: this.id
                        })
                    }
                    onRemove() {
                        this._pendingLoad && this._pendingLoad.cancel()
                    }
                    serialize() {
                        return i.extend({}, this._options, {
                            type: this.type,
                            data: this._data
                        })
                    }
                    hasTransition() {
                        return !1
                    }
                }
                ,
                video: class extends ue {
                    constructor(m, l, h, _) {
                        super(m, l, h, _),
                        this.roundZoom = !0,
                        this.type = "video",
                        this.options = l
                    }
                    load() {
                        this._loaded = !1;
                        let m = this.options;
                        this.urls = [];
                        for (let l of m.urls)
                            this.urls.push(this.map._requestManager.transformRequest(l, i.ResourceType.Source).url);
                        i.getVideo(this.urls, (l,h)=>{
                            this._loaded = !0,
                            l ? this.fire(new i.ErrorEvent(l)) : h && (this.video = h,
                            this.video.loop = !0,
                            this.video.setAttribute("playsinline", ""),
                            this.video.addEventListener("playing", ()=>{
                                this.map.triggerRepaint()
                            }
                            ),
                            this.map && this.video.play(),
                            this._finishLoading())
                        }
                        )
                    }
                    pause() {
                        this.video && this.video.pause()
                    }
                    play() {
                        this.video && this.video.play()
                    }
                    seek(m) {
                        if (this.video) {
                            let l = this.video.seekable;
                            m < l.start(0) || m > l.end(0) ? this.fire(new i.ErrorEvent(new i.ValidationError(`sources.${this.id}`,null,`Playback for this video can be set only between the ${l.start(0)} and ${l.end(0)}-second mark.`))) : this.video.currentTime = m
                        }
                    }
                    getVideo() {
                        return this.video
                    }
                    onAdd(m) {
                        this.map || (this.map = m,
                        this.load(),
                        this.video && (this.video.play(),
                        this.setCoordinates(this.coordinates)))
                    }
                    prepare() {
                        if (Object.keys(this.tiles).length === 0 || this.video.readyState < 2)
                            return;
                        let m = this.map.painter.context
                          , l = m.gl;
                        this.texture ? this.video.paused || (this.texture.bind(l.LINEAR, l.CLAMP_TO_EDGE),
                        l.texSubImage2D(l.TEXTURE_2D, 0, 0, 0, l.RGBA, l.UNSIGNED_BYTE, this.video)) : (this.texture = new i.Texture(m,this.video,l.RGBA),
                        this.texture.bind(l.LINEAR, l.CLAMP_TO_EDGE),
                        this.width = this.video.videoWidth,
                        this.height = this.video.videoHeight),
                        this._prepareData(m)
                    }
                    serialize() {
                        return {
                            type: "video",
                            urls: this.urls,
                            coordinates: this.coordinates
                        }
                    }
                    hasTransition() {
                        return this.video && !this.video.paused
                    }
                }
                ,
                image: ue,
                canvas: class extends ue {
                    constructor(m, l, h, _) {
                        super(m, l, h, _),
                        l.coordinates ? Array.isArray(l.coordinates) && l.coordinates.length === 4 && !l.coordinates.some(b=>!Array.isArray(b) || b.length !== 2 || b.some(T=>typeof T != "number")) || this.fire(new i.ErrorEvent(new i.ValidationError(`sources.${m}`,null,'"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new i.ErrorEvent(new i.ValidationError(`sources.${m}`,null,'missing required property "coordinates"'))),
                        l.animate && typeof l.animate != "boolean" && this.fire(new i.ErrorEvent(new i.ValidationError(`sources.${m}`,null,'optional "animate" property must be a boolean value'))),
                        l.canvas ? typeof l.canvas == "string" || l.canvas instanceof i.window.HTMLCanvasElement || this.fire(new i.ErrorEvent(new i.ValidationError(`sources.${m}`,null,'"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new i.ErrorEvent(new i.ValidationError(`sources.${m}`,null,'missing required property "canvas"'))),
                        this.options = l,
                        this.animate = l.animate === void 0 || l.animate
                    }
                    load() {
                        this._loaded = !0,
                        this.canvas || (this.canvas = this.options.canvas instanceof i.window.HTMLCanvasElement ? this.options.canvas : i.window.document.getElementById(this.options.canvas)),
                        this.width = this.canvas.width,
                        this.height = this.canvas.height,
                        this._hasInvalidDimensions() ? this.fire(new i.ErrorEvent(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
                            this._playing = !0,
                            this.map.triggerRepaint()
                        }
                        ,
                        this.pause = function() {
                            this._playing && (this.prepare(),
                            this._playing = !1)
                        }
                        ,
                        this._finishLoading())
                    }
                    getCanvas() {
                        return this.canvas
                    }
                    onAdd(m) {
                        this.map = m,
                        this.load(),
                        this.canvas && this.animate && this.play()
                    }
                    onRemove() {
                        this.pause()
                    }
                    prepare() {
                        let m = !1;
                        if (this.canvas.width !== this.width && (this.width = this.canvas.width,
                        m = !0),
                        this.canvas.height !== this.height && (this.height = this.canvas.height,
                        m = !0),
                        this._hasInvalidDimensions() || Object.keys(this.tiles).length === 0)
                            return;
                        let l = this.map.painter.context;
                        this.texture ? (m || this._playing) && this.texture.update(this.canvas, {
                            premultiply: !0
                        }) : this.texture = new i.Texture(l,this.canvas,l.gl.RGBA,{
                            premultiply: !0
                        }),
                        this._prepareData(l)
                    }
                    serialize() {
                        return {
                            type: "canvas",
                            coordinates: this.coordinates
                        }
                    }
                    hasTransition() {
                        return this._playing
                    }
                    _hasInvalidDimensions() {
                        for (let m of [this.canvas.width, this.canvas.height])
                            if (isNaN(m) || m <= 0)
                                return !0;
                        return !1
                    }
                }
                ,
                custom: class extends i.Evented {
                    constructor(m, l, h, _) {
                        super(),
                        this.id = m,
                        this.type = "custom",
                        this._dataType = "raster",
                        this._dispatcher = h,
                        this._implementation = l,
                        this.setEventedParent(_),
                        this.scheme = "xyz",
                        this.minzoom = 0,
                        this.maxzoom = 22,
                        this.tileSize = 512,
                        this._loaded = !1,
                        this.roundZoom = !0,
                        this._implementation || this.fire(new i.ErrorEvent(new Error(`Missing implementation for ${this.id} custom source`))),
                        this._implementation.loadTile || this.fire(new i.ErrorEvent(new Error(`Missing loadTile implementation for ${this.id} custom source`))),
                        this._implementation.bounds && (this.tileBounds = new Bt(this._implementation.bounds,this.minzoom,this.maxzoom)),
                        l.update = this._update.bind(this),
                        l.clearTiles = this._clearTiles.bind(this),
                        l.coveringTiles = this._coveringTiles.bind(this),
                        i.extend(this, i.pick(l, ["dataType", "scheme", "minzoom", "maxzoom", "tileSize", "attribution", "minTileCacheSize", "maxTileCacheSize"]))
                    }
                    serialize() {
                        return i.pick(this, ["type", "scheme", "minzoom", "maxzoom", "tileSize", "attribution"])
                    }
                    load() {
                        this._loaded = !0,
                        this.fire(new i.Event("data",{
                            dataType: "source",
                            sourceDataType: "metadata"
                        })),
                        this.fire(new i.Event("data",{
                            dataType: "source",
                            sourceDataType: "content"
                        }))
                    }
                    loaded() {
                        return this._loaded
                    }
                    onAdd(m) {
                        this._map = m,
                        this._loaded = !1,
                        this.fire(new i.Event("dataloading",{
                            dataType: "source"
                        })),
                        this._implementation.onAdd && this._implementation.onAdd(m),
                        this.load()
                    }
                    onRemove(m) {
                        this._implementation.onRemove && this._implementation.onRemove(m)
                    }
                    hasTile(m) {
                        if (this._implementation.hasTile) {
                            let {x: l, y: h, z: _} = m.canonical;
                            return this._implementation.hasTile({
                                x: l,
                                y: h,
                                z: _
                            })
                        }
                        return !this.tileBounds || this.tileBounds.contains(m.canonical)
                    }
                    loadTile(m, l) {
                        let {x: h, y: _, z: b} = m.tileID.canonical
                          , T = new i.window.AbortController;
                        m.request = Promise.resolve(this._implementation.loadTile({
                            x: h,
                            y: _,
                            z: b
                        }, {
                            signal: T.signal
                        })).then(function(L) {
                            return delete m.request,
                            m.aborted ? (m.state = "unloaded",
                            l(null)) : L === void 0 ? (m.state = "errored",
                            l(null)) : L === null ? (this.loadTileData(m, {
                                width: this.tileSize,
                                height: this.tileSize,
                                data: null
                            }),
                            m.state = "loaded",
                            l(null)) : function(R) {
                                return R instanceof i.window.ImageData || R instanceof i.window.HTMLCanvasElement || R instanceof i.window.ImageBitmap || R instanceof i.window.HTMLImageElement
                            }(L) ? (this.loadTileData(m, L),
                            m.state = "loaded",
                            void l(null)) : (m.state = "errored",
                            l(new Error(`Can't infer data type for ${this.id}, only raster data supported at the moment`)))
                        }
                        .bind(this)).catch(L=>{
                            L.code !== 20 && (m.state = "errored",
                            l(L))
                        }
                        ),
                        m.request.cancel = ()=>T.abort()
                    }
                    loadTileData(m, l) {
                        F.loadTileData(m, l, this._map.painter)
                    }
                    unloadTileData(m) {
                        F.unloadTileData(m, this._map.painter)
                    }
                    unloadTile(m, l) {
                        if (this.unloadTileData(m),
                        this._implementation.unloadTile) {
                            let {x: h, y: _, z: b} = m.tileID.canonical;
                            this._implementation.unloadTile({
                                x: h,
                                y: _,
                                z: b
                            })
                        }
                        l()
                    }
                    abortTile(m, l) {
                        m.request && m.request.cancel && (m.request.cancel(),
                        delete m.request),
                        l()
                    }
                    hasTransition() {
                        return !1
                    }
                    _coveringTiles() {
                        return this._map.transform.coveringTiles({
                            tileSize: this.tileSize,
                            minzoom: this.minzoom,
                            maxzoom: this.maxzoom,
                            roundZoom: this.roundZoom
                        }).map(m=>({
                            x: m.canonical.x,
                            y: m.canonical.y,
                            z: m.canonical.z
                        }))
                    }
                    _clearTiles() {
                        this._map.style._clearSource(this.id)
                    }
                    _update() {
                        this.fire(new i.Event("data",{
                            dataType: "source",
                            sourceDataType: "content"
                        }))
                    }
                }
            }
              , He = function(m, l, h, _) {
                let b = new Ee[l.type](m,l,h,_);
                if (b.id !== m)
                    throw new Error(`Expected Source id to be ${m} instead of ${b.id}`);
                return i.bindAll(["load", "abort", "unload", "serialize", "prepare"], b),
                b
            };
            function Re(m, l) {
                let h = i.identity([]);
                return i.scale(h, h, [.5 * m.width, .5 * -m.height, 1]),
                i.translate(h, h, [1, -1, 0]),
                i.multiply(h, h, m.calculateProjMatrix(l.toUnwrapped())),
                Float32Array.from(h)
            }
            function Ze(m, l, h, _, b, T, L, R=!1) {
                let O = m.tilesIn(_, L, R);
                O.sort(et);
                let V = [];
                for (let J of O)
                    V.push({
                        wrappedTileID: J.tile.tileID.wrapped().key,
                        queryResults: J.tile.queryRenderedFeatures(l, h, m._state, J, b, T, Re(m.transform, J.tile.tileID), R)
                    });
                let G = function(J) {
                    let le = {}
                      , me = {};
                    for (let pe of J) {
                        let ge = pe.queryResults
                          , ve = pe.wrappedTileID
                          , re = me[ve] = me[ve] || {};
                        for (let Ce in ge) {
                            let Ae = ge[Ce]
                              , De = re[Ce] = re[Ce] || {}
                              , Ve = le[Ce] = le[Ce] || [];
                            for (let Fe of Ae)
                                De[Fe.featureIndex] || (De[Fe.featureIndex] = !0,
                                Ve.push(Fe))
                        }
                    }
                    return le
                }(V);
                for (let J in G)
                    G[J].forEach(le=>{
                        let me = le.feature
                          , pe = me.layer;
                        pe && pe.type !== "background" && pe.type !== "sky" && (me.source = pe.source,
                        pe["source-layer"] && (me.sourceLayer = pe["source-layer"]),
                        me.state = me.id !== void 0 ? m.getFeatureState(pe["source-layer"], me.id) : {})
                    }
                    );
                return G
            }
            function ye(m, l) {
                let h = m.getRenderableIds().map(T=>m.getTileByID(T))
                  , _ = []
                  , b = {};
                for (let T = 0; T < h.length; T++) {
                    let L = h[T]
                      , R = L.tileID.canonical.key;
                    b[R] || (b[R] = !0,
                    L.querySourceFeatures(_, l))
                }
                return _
            }
            function et(m, l) {
                let h = m.tileID
                  , _ = l.tileID;
                return h.overscaledZ - _.overscaledZ || h.canonical.y - _.canonical.y || h.wrap - _.wrap || h.canonical.x - _.canonical.x
            }
            function We() {
                return ru.workerClass != null ? new ru.workerClass : new i.window.Worker(ru.workerUrl)
            }
            let ze = "mapboxgl_preloaded_worker_pool";
            class Rt {
                constructor() {
                    this.active = {}
                }
                acquire(l) {
                    if (!this.workers)
                        for (this.workers = []; this.workers.length < Rt.workerCount; )
                            this.workers.push(new We);
                    return this.active[l] = !0,
                    this.workers.slice()
                }
                release(l) {
                    delete this.active[l],
                    this.numActive() === 0 && (this.workers.forEach(h=>{
                        h.terminate()
                    }
                    ),
                    this.workers = null)
                }
                isPreloaded() {
                    return !!this.active[ze]
                }
                numActive() {
                    return Object.keys(this.active).length
                }
            }
            let wt;
            function fn() {
                return wt || (wt = new Rt),
                wt
            }
            function Mn(m, l) {
                let h = {};
                for (let _ in m)
                    _ !== "ref" && (h[_] = m[_]);
                return i.refProperties.forEach(_=>{
                    _ in l && (h[_] = l[_])
                }
                ),
                h
            }
            function Nn(m) {
                m = m.slice();
                let l = Object.create(null);
                for (let h = 0; h < m.length; h++)
                    l[m[h].id] = m[h];
                for (let h = 0; h < m.length; h++)
                    "ref"in m[h] && (m[h] = Mn(m[h], l[m[h].ref]));
                return m
            }
            Rt.workerCount = 2;
            let jt = {
                setStyle: "setStyle",
                addLayer: "addLayer",
                removeLayer: "removeLayer",
                setPaintProperty: "setPaintProperty",
                setLayoutProperty: "setLayoutProperty",
                setFilter: "setFilter",
                addSource: "addSource",
                removeSource: "removeSource",
                setGeoJSONSourceData: "setGeoJSONSourceData",
                setLayerZoomRange: "setLayerZoomRange",
                setLayerProperty: "setLayerProperty",
                setCenter: "setCenter",
                setZoom: "setZoom",
                setBearing: "setBearing",
                setPitch: "setPitch",
                setSprite: "setSprite",
                setGlyphs: "setGlyphs",
                setTransition: "setTransition",
                setLight: "setLight",
                setTerrain: "setTerrain",
                setFog: "setFog",
                setProjection: "setProjection"
            };
            function qn(m, l, h) {
                h.push({
                    command: jt.addSource,
                    args: [m, l[m]]
                })
            }
            function On(m, l, h) {
                l.push({
                    command: jt.removeSource,
                    args: [m]
                }),
                h[m] = !0
            }
            function ar(m, l, h, _) {
                On(m, h, _),
                qn(m, l, h)
            }
            function pr(m, l, h) {
                let _;
                for (_ in m[h])
                    if (m[h].hasOwnProperty(_) && _ !== "data" && !v(m[h][_], l[h][_]))
                        return !1;
                for (_ in l[h])
                    if (l[h].hasOwnProperty(_) && _ !== "data" && !v(m[h][_], l[h][_]))
                        return !1;
                return !0
            }
            function ht(m, l, h, _, b, T) {
                let L;
                for (L in l = l || {},
                m = m || {})
                    m.hasOwnProperty(L) && (v(m[L], l[L]) || h.push({
                        command: T,
                        args: [_, L, l[L], b]
                    }));
                for (L in l)
                    l.hasOwnProperty(L) && !m.hasOwnProperty(L) && (v(m[L], l[L]) || h.push({
                        command: T,
                        args: [_, L, l[L], b]
                    }))
            }
            function mr(m) {
                return m.id
            }
            function jn(m, l) {
                return m[l.id] = l,
                m
            }
            class vr {
                constructor(l, h) {
                    this.reset(l, h)
                }
                reset(l, h) {
                    this.points = l || [],
                    this._distances = [0];
                    for (let _ = 1; _ < this.points.length; _++)
                        this._distances[_] = this._distances[_ - 1] + this.points[_].dist(this.points[_ - 1]);
                    this.length = this._distances[this._distances.length - 1],
                    this.padding = Math.min(h || 0, .5 * this.length),
                    this.paddedLength = this.length - 2 * this.padding
                }
                lerp(l) {
                    if (this.points.length === 1)
                        return this.points[0];
                    l = i.clamp(l, 0, 1);
                    let h = 1
                      , _ = this._distances[h]
                      , b = l * this.paddedLength + this.padding;
                    for (; _ < b && h < this._distances.length; )
                        _ = this._distances[++h];
                    let T = h - 1
                      , L = this._distances[T]
                      , R = _ - L
                      , O = R > 0 ? (b - L) / R : 0;
                    return this.points[T].mult(1 - O).add(this.points[h].mult(O))
                }
            }
            class ao {
                constructor(l, h, _) {
                    let b = this.boxCells = []
                      , T = this.circleCells = [];
                    this.xCellCount = Math.ceil(l / _),
                    this.yCellCount = Math.ceil(h / _);
                    for (let L = 0; L < this.xCellCount * this.yCellCount; L++)
                        b.push([]),
                        T.push([]);
                    this.circleKeys = [],
                    this.boxKeys = [],
                    this.bboxes = [],
                    this.circles = [],
                    this.width = l,
                    this.height = h,
                    this.xScale = this.xCellCount / l,
                    this.yScale = this.yCellCount / h,
                    this.boxUid = 0,
                    this.circleUid = 0
                }
                keysLength() {
                    return this.boxKeys.length + this.circleKeys.length
                }
                insert(l, h, _, b, T) {
                    this._forEachCell(h, _, b, T, this._insertBoxCell, this.boxUid++),
                    this.boxKeys.push(l),
                    this.bboxes.push(h),
                    this.bboxes.push(_),
                    this.bboxes.push(b),
                    this.bboxes.push(T)
                }
                insertCircle(l, h, _, b) {
                    this._forEachCell(h - b, _ - b, h + b, _ + b, this._insertCircleCell, this.circleUid++),
                    this.circleKeys.push(l),
                    this.circles.push(h),
                    this.circles.push(_),
                    this.circles.push(b)
                }
                _insertBoxCell(l, h, _, b, T, L) {
                    this.boxCells[T].push(L)
                }
                _insertCircleCell(l, h, _, b, T, L) {
                    this.circleCells[T].push(L)
                }
                _query(l, h, _, b, T, L) {
                    if (_ < 0 || l > this.width || b < 0 || h > this.height)
                        return !T && [];
                    let R = [];
                    if (l <= 0 && h <= 0 && this.width <= _ && this.height <= b) {
                        if (T)
                            return !0;
                        for (let O = 0; O < this.boxKeys.length; O++)
                            R.push({
                                key: this.boxKeys[O],
                                x1: this.bboxes[4 * O],
                                y1: this.bboxes[4 * O + 1],
                                x2: this.bboxes[4 * O + 2],
                                y2: this.bboxes[4 * O + 3]
                            });
                        for (let O = 0; O < this.circleKeys.length; O++) {
                            let V = this.circles[3 * O]
                              , G = this.circles[3 * O + 1]
                              , J = this.circles[3 * O + 2];
                            R.push({
                                key: this.circleKeys[O],
                                x1: V - J,
                                y1: G - J,
                                x2: V + J,
                                y2: G + J
                            })
                        }
                        return L ? R.filter(L) : R
                    }
                    return this._forEachCell(l, h, _, b, this._queryCell, R, {
                        hitTest: T,
                        seenUids: {
                            box: {},
                            circle: {}
                        }
                    }, L),
                    T ? R.length > 0 : R
                }
                _queryCircle(l, h, _, b, T) {
                    let L = l - _
                      , R = l + _
                      , O = h - _
                      , V = h + _;
                    if (R < 0 || L > this.width || V < 0 || O > this.height)
                        return !b && [];
                    let G = [];
                    return this._forEachCell(L, O, R, V, this._queryCellCircle, G, {
                        hitTest: b,
                        circle: {
                            x: l,
                            y: h,
                            radius: _
                        },
                        seenUids: {
                            box: {},
                            circle: {}
                        }
                    }, T),
                    b ? G.length > 0 : G
                }
                query(l, h, _, b, T) {
                    return this._query(l, h, _, b, !1, T)
                }
                hitTest(l, h, _, b, T) {
                    return this._query(l, h, _, b, !0, T)
                }
                hitTestCircle(l, h, _, b) {
                    return this._queryCircle(l, h, _, !0, b)
                }
                _queryCell(l, h, _, b, T, L, R, O) {
                    let V = R.seenUids
                      , G = this.boxCells[T];
                    if (G !== null) {
                        let le = this.bboxes;
                        for (let me of G)
                            if (!V.box[me]) {
                                V.box[me] = !0;
                                let pe = 4 * me;
                                if (l <= le[pe + 2] && h <= le[pe + 3] && _ >= le[pe + 0] && b >= le[pe + 1] && (!O || O(this.boxKeys[me]))) {
                                    if (R.hitTest)
                                        return L.push(!0),
                                        !0;
                                    L.push({
                                        key: this.boxKeys[me],
                                        x1: le[pe],
                                        y1: le[pe + 1],
                                        x2: le[pe + 2],
                                        y2: le[pe + 3]
                                    })
                                }
                            }
                    }
                    let J = this.circleCells[T];
                    if (J !== null) {
                        let le = this.circles;
                        for (let me of J)
                            if (!V.circle[me]) {
                                V.circle[me] = !0;
                                let pe = 3 * me;
                                if (this._circleAndRectCollide(le[pe], le[pe + 1], le[pe + 2], l, h, _, b) && (!O || O(this.circleKeys[me]))) {
                                    if (R.hitTest)
                                        return L.push(!0),
                                        !0;
                                    {
                                        let ge = le[pe]
                                          , ve = le[pe + 1]
                                          , re = le[pe + 2];
                                        L.push({
                                            key: this.circleKeys[me],
                                            x1: ge - re,
                                            y1: ve - re,
                                            x2: ge + re,
                                            y2: ve + re
                                        })
                                    }
                                }
                            }
                    }
                }
                _queryCellCircle(l, h, _, b, T, L, R, O) {
                    let V = R.circle
                      , G = R.seenUids
                      , J = this.boxCells[T];
                    if (J !== null) {
                        let me = this.bboxes;
                        for (let pe of J)
                            if (!G.box[pe]) {
                                G.box[pe] = !0;
                                let ge = 4 * pe;
                                if (this._circleAndRectCollide(V.x, V.y, V.radius, me[ge + 0], me[ge + 1], me[ge + 2], me[ge + 3]) && (!O || O(this.boxKeys[pe])))
                                    return L.push(!0),
                                    !0
                            }
                    }
                    let le = this.circleCells[T];
                    if (le !== null) {
                        let me = this.circles;
                        for (let pe of le)
                            if (!G.circle[pe]) {
                                G.circle[pe] = !0;
                                let ge = 3 * pe;
                                if (this._circlesCollide(me[ge], me[ge + 1], me[ge + 2], V.x, V.y, V.radius) && (!O || O(this.circleKeys[pe])))
                                    return L.push(!0),
                                    !0
                            }
                    }
                }
                _forEachCell(l, h, _, b, T, L, R, O) {
                    let V = this._convertToXCellCoord(l)
                      , G = this._convertToYCellCoord(h)
                      , J = this._convertToXCellCoord(_)
                      , le = this._convertToYCellCoord(b);
                    for (let me = V; me <= J; me++)
                        for (let pe = G; pe <= le; pe++)
                            if (T.call(this, l, h, _, b, this.xCellCount * pe + me, L, R, O))
                                return
                }
                _convertToXCellCoord(l) {
                    return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(l * this.xScale)))
                }
                _convertToYCellCoord(l) {
                    return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(l * this.yScale)))
                }
                _circlesCollide(l, h, _, b, T, L) {
                    let R = b - l
                      , O = T - h
                      , V = _ + L;
                    return V * V > R * R + O * O
                }
                _circleAndRectCollide(l, h, _, b, T, L, R) {
                    let O = (L - b) / 2
                      , V = Math.abs(l - (b + O));
                    if (V > O + _)
                        return !1;
                    let G = (R - T) / 2
                      , J = Math.abs(h - (T + G));
                    if (J > G + _)
                        return !1;
                    if (V <= O || J <= G)
                        return !0;
                    let le = V - O
                      , me = J - G;
                    return le * le + me * me <= _ * _
                }
            }
            let Zi = Math.tan(85 * Math.PI / 180);
            function Xo(m, l, h, _, b, T, L) {
                let R = i.create();
                if (h)
                    if (T.name === "globe") {
                        let O = i.calculateGlobeLabelMatrix(b, l);
                        i.multiply(R, R, O)
                    } else {
                        let O = oe([], L);
                        R[0] = O[0],
                        R[1] = O[1],
                        R[4] = O[2],
                        R[5] = O[3],
                        _ || i.rotateZ(R, R, b.angle)
                    }
                else
                    i.multiply(R, b.labelPlaneMatrix, m);
                return R
            }
            function hh(m, l, h, _, b, T, L) {
                let R = Xo(m, l, h, _, b, T, L);
                return T.name === "globe" && h || (R[2] = R[6] = R[10] = R[14] = 0),
                R
            }
            function Zo(m, l, h, _, b, T, L) {
                if (h) {
                    if (T.name === "globe") {
                        let R = Xo(m, l, h, _, b, T, L);
                        return i.invert(R, R),
                        i.multiply(R, m, R),
                        R
                    }
                    {
                        let R = i.clone(m)
                          , O = i.identity([]);
                        return O[0] = L[0],
                        O[1] = L[1],
                        O[4] = L[2],
                        O[5] = L[3],
                        i.multiply(R, R, O),
                        _ || i.rotateZ(R, R, -b.angle),
                        R
                    }
                }
                return b.glCoordMatrix
            }
            function Xt(m, l, h, _) {
                let b = [m, l, h, 1];
                h ? i.transformMat4$1(b, b, _) : cg(b, b, _);
                let T = b[3];
                return b[0] /= T,
                b[1] /= T,
                b[2] /= T,
                b
            }
            function ni(m, l) {
                return Math.min(.5 + m / l * .5, 1.5)
            }
            function $n(m, l) {
                let h = m[0] / m[3]
                  , _ = m[1] / m[3];
                return h >= -l[0] && h <= l[0] && _ >= -l[1] && _ <= l[1]
            }
            function lo(m, l, h, _, b, T, L, R, O, V) {
                let G = h.transform
                  , J = _ ? m.textSizeData : m.iconSizeData
                  , le = i.evaluateSizeForZoom(J, h.transform.zoom)
                  , me = G.projection.name === "globe"
                  , pe = [256 / h.width * 2 + 1, 256 / h.height * 2 + 1]
                  , ge = _ ? m.text.dynamicLayoutVertexArray : m.icon.dynamicLayoutVertexArray;
                ge.clear();
                let ve = null;
                me && (ve = _ ? m.text.globeExtVertexArray : m.icon.globeExtVertexArray);
                let re = m.lineVertexArray, Ce = _ ? m.text.placedSymbolArray : m.icon.placedSymbolArray, Ae = h.transform.width / h.transform.height, De, Ve = !1;
                for (let Fe = 0; Fe < Ce.length; Fe++) {
                    let Xe = Ce.get(Fe)
                      , {numGlyphs: $e, writingMode: rt} = Xe;
                    if (rt !== i.WritingMode.vertical || Ve || De === i.WritingMode.horizontal || (Ve = !0),
                    De = rt,
                    (Xe.hidden || rt === i.WritingMode.vertical) && !Ve) {
                        Li($e, ge);
                        continue
                    }
                    Ve = !1;
                    let lt = new i.pointGeometry(Xe.tileAnchorX,Xe.tileAnchorY)
                      , {x: Vt, y: nt, z: vt} = G.projection.projectTilePoint(lt.x, lt.y, V.canonical);
                    if (O) {
                        let[Xn,un,sn] = O(lt);
                        Vt += Xn,
                        nt += un,
                        vt += sn
                    }
                    let pt = [Vt, nt, vt, 1];
                    if (i.transformMat4$1(pt, pt, l),
                    !$n(pt, pe)) {
                        Li($e, ge);
                        continue
                    }
                    let Dt = ni(h.transform.cameraToCenterDistance, pt[3])
                      , st = i.evaluateSizeForFeature(J, le, Xe)
                      , Je = L ? st / Dt : st * Dt
                      , ct = Xt(Vt, nt, vt, b);
                    if (ct[3] <= 0) {
                        Li($e, ge);
                        continue
                    }
                    let At = {}
                      , Pt = L ? null : O
                      , pn = Cc(Xe, Je, !1, R, l, b, T, m.glyphOffsetArray, re, ge, ve, ct, lt, At, Ae, Pt, G.projection, V, L);
                    Ve = pn.useVertical,
                    Pt && pn.needsFlipping && (At = {}),
                    (pn.notEnoughRoom || Ve || pn.needsFlipping && Cc(Xe, Je, !0, R, l, b, T, m.glyphOffsetArray, re, ge, ve, ct, lt, At, Ae, Pt, G.projection, V, L).notEnoughRoom) && Li($e, ge)
                }
                _ ? (m.text.dynamicLayoutVertexBuffer.updateData(ge),
                ve && m.text.globeExtVertexBuffer.updateData(ve)) : (m.icon.dynamicLayoutVertexBuffer.updateData(ge),
                ve && m.icon.globeExtVertexBuffer.updateData(ve))
            }
            function Aa(m, l, h, _, b, T, L, R, O, V, G, J, le, me, pe, ge) {
                let {lineStartIndex: ve, glyphStartIndex: re, segment: Ce} = R
                  , Ae = re + R.numGlyphs
                  , De = ve + R.lineLength
                  , Ve = l.getoffsetX(re)
                  , Fe = l.getoffsetX(Ae - 1)
                  , Xe = as(m * Ve, h, _, b, T, L, Ce, ve, De, O, V, G, J, le, !0, me, pe, ge);
                if (!Xe)
                    return null;
                let $e = as(m * Fe, h, _, b, T, L, Ce, ve, De, O, V, G, J, le, !0, me, pe, ge);
                return $e ? {
                    first: Xe,
                    last: $e
                } : null
            }
            function Yn(m, l, h, _) {
                return m === i.WritingMode.horizontal && Math.abs(_) > Math.abs(h) ? {
                    useVertical: !0
                } : m === i.WritingMode.vertical ? _ > 0 ? {
                    needsFlipping: !0
                } : null : l !== 0 && function(b, T) {
                    return b === 0 || Math.abs(T / b) > Zi
                }(h, _) ? l === 1 ? {
                    needsFlipping: !0
                } : null : h < 0 ? {
                    needsFlipping: !0
                } : null
            }
            function Cc(m, l, h, _, b, T, L, R, O, V, G, J, le, me, pe, ge, ve, re, Ce) {
                let Ae = l / 24
                  , De = m.lineOffsetX * Ae
                  , Ve = m.lineOffsetY * Ae
                  , {lineStartIndex: Fe, glyphStartIndex: Xe, numGlyphs: $e, segment: rt, writingMode: lt, flipState: Vt} = m
                  , nt = Fe + m.lineLength
                  , vt = pt=>{
                    if (G) {
                        let[ct,At,Pt] = pt.up
                          , pn = V.length;
                        i.updateGlobeVertexNormal(G, pn + 0, ct, At, Pt),
                        i.updateGlobeVertexNormal(G, pn + 1, ct, At, Pt),
                        i.updateGlobeVertexNormal(G, pn + 2, ct, At, Pt),
                        i.updateGlobeVertexNormal(G, pn + 3, ct, At, Pt)
                    }
                    let[Dt,st,Je] = pt.point;
                    i.addDynamicAttributes(V, Dt, st, Je, pt.angle)
                }
                ;
                if ($e > 1) {
                    let pt = Aa(Ae, R, De, Ve, h, J, le, m, O, T, me, ge, !1, ve, re, Ce);
                    if (!pt)
                        return {
                            notEnoughRoom: !0
                        };
                    if (_ && !h) {
                        let[Dt,st,Je] = pt.first.point
                          , [ct,At,Pt] = pt.last.point;
                        [Dt,st] = Xt(Dt, st, Je, L),
                        [ct,At] = Xt(ct, At, Pt, L);
                        let pn = Yn(lt, Vt, (ct - Dt) * pe, At - st);
                        if (m.flipState = pn && pn.needsFlipping ? 1 : 2,
                        pn)
                            return pn
                    }
                    vt(pt.first);
                    for (let Dt = Xe + 1; Dt < Xe + $e - 1; Dt++) {
                        let st = as(Ae * R.getoffsetX(Dt), De, Ve, h, J, le, rt, Fe, nt, O, T, me, ge, !1, !1, ve, re, Ce);
                        if (!st)
                            return V.length -= 4 * (Dt - Xe),
                            {
                                notEnoughRoom: !0
                            };
                        vt(st)
                    }
                    vt(pt.last)
                } else {
                    if (_ && !h) {
                        let Dt = Xt(le.x, le.y, 0, b)
                          , st = Fe + rt + 1
                          , Je = new i.pointGeometry(O.getx(st),O.gety(st))
                          , ct = Xt(Je.x, Je.y, 0, b)
                          , At = ct[3] > 0 ? ct : ml(le, Je, Dt, 1, b, void 0, ve, re.canonical)
                          , Pt = Yn(lt, Vt, (At[0] - Dt[0]) * pe, At[1] - Dt[1]);
                        if (m.flipState = Pt && Pt.needsFlipping ? 1 : 2,
                        Pt)
                            return Pt
                    }
                    let pt = as(Ae * R.getoffsetX(Xe), De, Ve, h, J, le, rt, Fe, nt, O, T, me, ge, !1, !1, ve, re, Ce);
                    if (!pt)
                        return {
                            notEnoughRoom: !0
                        };
                    vt(pt)
                }
                return {}
            }
            function pl(m, l, h, _, b) {
                let {x: T, y: L, z: R} = _.projectTilePoint(m.x, m.y, l);
                if (!b)
                    return Xt(T, L, R, h);
                let[O,V,G] = b(m);
                return Xt(T + O, L + V, R + G, h)
            }
            function ml(m, l, h, _, b, T, L, R) {
                let O = pl(m.sub(l)._unit()._add(m), R, b, L, T);
                return i.sub(O, h, O),
                i.normalize(O, O),
                i.scaleAndAdd(O, h, O, _)
            }
            function as(m, l, h, _, b, T, L, R, O, V, G, J, le, me, pe, ge, ve, re) {
                let Ce = _ ? m - l : m + l
                  , Ae = Ce > 0 ? 1 : -1
                  , De = 0;
                _ && (Ae *= -1,
                De = Math.PI),
                Ae < 0 && (De += Math.PI);
                let Ve = R + L + (Ae > 0 ? 0 : 1) | 0
                  , Fe = b
                  , Xe = b
                  , $e = 0
                  , rt = 0
                  , lt = Math.abs(Ce)
                  , Vt = []
                  , nt = []
                  , vt = T
                  , pt = vt
                  , Dt = ()=>ml(pt, vt, Xe, lt - $e + 1, G, le, ge, ve.canonical);
                for (; $e + rt <= lt; ) {
                    if (Ve += Ae,
                    Ve < R || Ve >= O)
                        return null;
                    if (Xe = Fe,
                    pt = vt,
                    Vt.push(Xe),
                    me && nt.push(pt),
                    vt = new i.pointGeometry(V.getx(Ve),V.gety(Ve)),
                    Fe = J[Ve],
                    !Fe) {
                        let sn = pl(vt, ve.canonical, G, ge, le);
                        Fe = sn[3] > 0 ? J[Ve] = sn : Dt()
                    }
                    $e += rt,
                    rt = i.distance(Xe, Fe)
                }
                pe && le && (J[Ve] && (Fe = Dt(),
                rt = i.distance(Xe, Fe)),
                J[Ve] = Fe);
                let st = (lt - $e) / rt
                  , Je = vt.sub(pt)._mult(st)._add(pt)
                  , ct = i.sub([], Fe, Xe)
                  , At = i.scaleAndAdd([], Xe, ct, st)
                  , Pt = [0, 0, 1]
                  , pn = ct[0]
                  , Xn = ct[1];
                if (re && (Pt = ge.upVector(ve.canonical, Je.x, Je.y),
                Pt[0] !== 0 || Pt[1] !== 0 || Pt[2] !== 1)) {
                    let sn = [Pt[2], 0, -Pt[0]]
                      , vn = i.cross([], Pt, sn);
                    i.normalize(sn, sn),
                    i.normalize(vn, vn),
                    pn = i.dot(ct, sn),
                    Xn = i.dot(ct, vn)
                }
                if (h) {
                    let sn = i.cross([], Pt, ct);
                    i.normalize(sn, sn),
                    i.scaleAndAdd(At, At, sn, h * Ae)
                }
                let un = De + Math.atan2(Xn, pn);
                return Vt.push(At),
                me && nt.push(Je),
                {
                    point: At,
                    angle: un,
                    path: Vt,
                    tilePath: nt,
                    up: Pt
                }
            }
            function Li(m, l) {
                let h = l.length
                  , _ = h + 4 * m;
                l.resize(_),
                l.float32.fill(-1 / 0, 4 * h, 4 * _)
            }
            function cg(m, l, h) {
                let _ = l[0]
                  , b = l[1];
                return m[0] = h[0] * _ + h[4] * b + h[12],
                m[1] = h[1] * _ + h[5] * b + h[13],
                m[3] = h[3] * _ + h[7] * b + h[15],
                m
            }
            let fs = 100;
            class mf {
                constructor(l, h, _=new ao(l.width + 200,l.height + 200,25), b=new ao(l.width + 200,l.height + 200,25)) {
                    this.transform = l,
                    this.grid = _,
                    this.ignoredGrid = b,
                    this.pitchfactor = Math.cos(l._pitch) * l.cameraToCenterDistance,
                    this.screenRightBoundary = l.width + fs,
                    this.screenBottomBoundary = l.height + fs,
                    this.gridRightBoundary = l.width + 200,
                    this.gridBottomBoundary = l.height + 200,
                    this.fogState = h
                }
                placeCollisionBox(l, h, _, b, T, L, R, O) {
                    let V = _.projectedAnchorX
                      , G = _.projectedAnchorY
                      , J = _.projectedAnchorZ
                      , le = _.elevation
                      , me = _.tileID
                      , pe = l.getProjection();
                    if (le && me) {
                        let[Fe,Xe,$e] = pe.upVector(me.canonical, _.tileAnchorX, _.tileAnchorY)
                          , rt = pe.upVectorScale(me.canonical, this.transform.center.lat, this.transform.worldSize).metersToTile;
                        V += Fe * le * rt,
                        G += Xe * le * rt,
                        J += $e * le * rt
                    }
                    let ge = this.projectAndGetPerspectiveRatio(R, V, G, J, _.tileID, pe.name === "globe" || !!le || this.transform.pitch > 0, pe)
                      , ve = L * ge.perspectiveRatio
                      , re = (_.x1 * h + b.x - _.padding) * ve + ge.point.x
                      , Ce = (_.y1 * h + b.y - _.padding) * ve + ge.point.y
                      , Ae = (_.x2 * h + b.x + _.padding) * ve + ge.point.x
                      , De = (_.y2 * h + b.y + _.padding) * ve + ge.point.y
                      , Ve = ge.perspectiveRatio <= .55 || ge.occluded;
                    return !this.isInsideGrid(re, Ce, Ae, De) || !T && this.grid.hitTest(re, Ce, Ae, De, O) || Ve ? {
                        box: [],
                        offscreen: !1,
                        occluded: ge.occluded
                    } : {
                        box: [re, Ce, Ae, De],
                        offscreen: this.isOffscreen(re, Ce, Ae, De),
                        occluded: !1
                    }
                }
                placeCollisionCircles(l, h, _, b, T, L, R, O, V, G, J, le, me, pe, ge) {
                    let ve = []
                      , re = this.transform.elevation
                      , Ce = l.getProjection()
                      , Ae = re ? re.getAtTileOffsetFunc(ge, this.transform.center.lat, this.transform.worldSize, Ce) : null
                      , De = new i.pointGeometry(_.tileAnchorX,_.tileAnchorY)
                      , {x: Ve, y: Fe, z: Xe} = Ce.projectTilePoint(De.x, De.y, ge.canonical);
                    if (Ae) {
                        let[Je,ct,At] = Ae(De);
                        Ve += Je,
                        Fe += ct,
                        Xe += At
                    }
                    let $e = Ce.name === "globe"
                      , rt = this.projectAndGetPerspectiveRatio(R, Ve, Fe, Xe, ge, $e || !!re || this.transform.pitch > 0, Ce)
                      , {perspectiveRatio: lt} = rt
                      , Vt = (J ? L / lt : L * lt) / i.ONE_EM
                      , nt = Xt(Ve, Fe, Xe, O)
                      , vt = rt.signedDistanceFromCamera > 0 ? Aa(Vt, T, _.lineOffsetX * Vt, _.lineOffsetY * Vt, !1, nt, De, _, b, O, {}, re && !J ? Ae : null, J && !!re, Ce, ge, J) : null
                      , pt = !1
                      , Dt = !1
                      , st = !0;
                    if (vt && !rt.occluded) {
                        let Je = .5 * me * lt + pe
                          , ct = new i.pointGeometry(-100,-100)
                          , At = new i.pointGeometry(this.screenRightBoundary,this.screenBottomBoundary)
                          , Pt = new vr
                          , {first: pn, last: Xn} = vt
                          , un = pn.path.length
                          , sn = [];
                        for (let En = un - 1; En >= 1; En--)
                            sn.push(pn.path[En]);
                        for (let En = 1; En < Xn.path.length; En++)
                            sn.push(Xn.path[En]);
                        let vn = 2.5 * Je;
                        V && (sn = sn.map(([En,pi,Ti],Ri)=>(Ae && !$e && (Ti = Ae(Ri < un - 1 ? pn.tilePath[un - 1 - Ri] : Xn.tilePath[Ri - un + 2])[2]),
                        Xt(En, pi, Ti, V))),
                        sn.some(En=>En[3] <= 0) && (sn = []));
                        let Qn = [];
                        if (sn.length > 0) {
                            let En = 1 / 0
                              , pi = -1 / 0
                              , Ti = 1 / 0
                              , Ri = -1 / 0;
                            for (let Mi of sn)
                                En = Math.min(En, Mi[0]),
                                Ti = Math.min(Ti, Mi[1]),
                                pi = Math.max(pi, Mi[0]),
                                Ri = Math.max(Ri, Mi[1]);
                            pi >= ct.x && En <= At.x && Ri >= ct.y && Ti <= At.y && (Qn = [sn.map(Mi=>new i.pointGeometry(Mi[0],Mi[1]))],
                            (En < ct.x || pi > At.x || Ti < ct.y || Ri > At.y) && (Qn = i.clipLine(Qn, ct.x, ct.y, At.x, At.y)))
                        }
                        for (let En of Qn) {
                            Pt.reset(En, .25 * Je);
                            let pi = 0;
                            pi = Pt.length <= .5 * Je ? 1 : Math.ceil(Pt.paddedLength / vn) + 1;
                            for (let Ti = 0; Ti < pi; Ti++) {
                                let Ri = Ti / Math.max(pi - 1, 1)
                                  , Mi = Pt.lerp(Ri)
                                  , lr = Mi.x + fs
                                  , gs = Mi.y + fs;
                                ve.push(lr, gs, Je, 0);
                                let Ks = lr - Je
                                  , Co = gs - Je
                                  , Gi = lr + Je
                                  , Ii = gs + Je;
                                if (st = st && this.isOffscreen(Ks, Co, Gi, Ii),
                                Dt = Dt || this.isInsideGrid(Ks, Co, Gi, Ii),
                                !h && this.grid.hitTestCircle(lr, gs, Je, le) && (pt = !0,
                                !G))
                                    return {
                                        circles: [],
                                        offscreen: !1,
                                        collisionDetected: pt,
                                        occluded: !1
                                    }
                            }
                        }
                    }
                    return {
                        circles: !G && pt || !Dt ? [] : ve,
                        offscreen: st,
                        collisionDetected: pt,
                        occluded: rt.occluded
                    }
                }
                queryRenderedSymbols(l) {
                    if (l.length === 0 || this.grid.keysLength() === 0 && this.ignoredGrid.keysLength() === 0)
                        return {};
                    let h = []
                      , _ = 1 / 0
                      , b = 1 / 0
                      , T = -1 / 0
                      , L = -1 / 0;
                    for (let G of l) {
                        let J = new i.pointGeometry(G.x + fs,G.y + fs);
                        _ = Math.min(_, J.x),
                        b = Math.min(b, J.y),
                        T = Math.max(T, J.x),
                        L = Math.max(L, J.y),
                        h.push(J)
                    }
                    let R = this.grid.query(_, b, T, L).concat(this.ignoredGrid.query(_, b, T, L))
                      , O = {}
                      , V = {};
                    for (let G of R) {
                        let J = G.key;
                        if (O[J.bucketInstanceId] === void 0 && (O[J.bucketInstanceId] = {}),
                        O[J.bucketInstanceId][J.featureIndex])
                            continue;
                        let le = [new i.pointGeometry(G.x1,G.y1), new i.pointGeometry(G.x2,G.y1), new i.pointGeometry(G.x2,G.y2), new i.pointGeometry(G.x1,G.y2)];
                        i.polygonIntersectsPolygon(h, le) && (O[J.bucketInstanceId][J.featureIndex] = !0,
                        V[J.bucketInstanceId] === void 0 && (V[J.bucketInstanceId] = []),
                        V[J.bucketInstanceId].push(J.featureIndex))
                    }
                    return V
                }
                insertCollisionBox(l, h, _, b, T) {
                    (h ? this.ignoredGrid : this.grid).insert({
                        bucketInstanceId: _,
                        featureIndex: b,
                        collisionGroupID: T
                    }, l[0], l[1], l[2], l[3])
                }
                insertCollisionCircles(l, h, _, b, T) {
                    let L = h ? this.ignoredGrid : this.grid
                      , R = {
                        bucketInstanceId: _,
                        featureIndex: b,
                        collisionGroupID: T
                    };
                    for (let O = 0; O < l.length; O += 4)
                        L.insertCircle(R, l[O], l[O + 1], l[O + 2])
                }
                projectAndGetPerspectiveRatio(l, h, _, b, T, L, R) {
                    let O = [h, _, b, 1]
                      , V = !1;
                    if (b || this.transform.pitch > 0) {
                        i.transformMat4$1(O, O, l);
                        let J = R.name === "globe";
                        this.fogState && T && !J && (V = function(me, pe, ge, ve, re, Ce) {
                            let Ae = Ce.calculateFogTileMatrix(re)
                              , De = [pe, ge, ve];
                            return i.transformMat4(De, De, Ae),
                            Be(me, De, Ce.pitch, Ce._fov)
                        }(this.fogState, h, _, b, T.toUnwrapped(), this.transform) > .9)
                    } else
                        cg(O, O, l);
                    let G = O[3];
                    return {
                        point: new i.pointGeometry((O[0] / G + 1) / 2 * this.transform.width + fs,(-O[1] / G + 1) / 2 * this.transform.height + fs),
                        perspectiveRatio: Math.min(.5 + this.transform.getCameraToCenterDistance(R) / G * .5, 1.5),
                        signedDistanceFromCamera: G,
                        occluded: L && O[2] > G || V
                    }
                }
                isOffscreen(l, h, _, b) {
                    return _ < fs || l >= this.screenRightBoundary || b < fs || h > this.screenBottomBoundary
                }
                isInsideGrid(l, h, _, b) {
                    return _ >= 0 && l < this.gridRightBoundary && b >= 0 && h < this.gridBottomBoundary
                }
                getViewportMatrix() {
                    let l = i.identity([]);
                    return i.translate(l, l, [-100, -100, 0]),
                    l
                }
            }
            function Ma(m, l, h) {
                let _ = l.createTileMatrix(m, m.worldSize, h.toUnwrapped());
                return i.multiply(new Float32Array(16), m.projMatrix, _)
            }
            function gf(m, l, h) {
                if (l.projection.name === h.projection.name)
                    return m.projMatrix;
                let _ = h.clone();
                return _.setProjection(l.projection),
                Ma(_, l.getProjection(), m)
            }
            function dh(m, l, h) {
                return l.name === h.projection.name ? m.projMatrix : Ma(h, l, m)
            }
            class Dc {
                constructor(l, h, _, b) {
                    this.opacity = l ? Math.max(0, Math.min(1, l.opacity + (l.placed ? h : -h))) : b && _ ? 1 : 0,
                    this.placed = _
                }
                isHidden() {
                    return this.opacity === 0 && !this.placed
                }
            }
            class Ia {
                constructor(l, h, _, b, T, L=!1) {
                    this.text = new Dc(l ? l.text : null,h,_,T),
                    this.icon = new Dc(l ? l.icon : null,h,b,T),
                    this.clipped = L
                }
                isHidden() {
                    return this.text.isHidden() && this.icon.isHidden()
                }
            }
            class gl {
                constructor(l, h, _, b=!1) {
                    this.text = l,
                    this.icon = h,
                    this.skipFade = _,
                    this.clipped = b
                }
            }
            class _f {
                constructor() {
                    this.invProjMatrix = i.create(),
                    this.viewportMatrix = i.create(),
                    this.circles = []
                }
            }
            class ps {
                constructor(l, h, _, b, T) {
                    this.bucketInstanceId = l,
                    this.featureIndex = h,
                    this.sourceLayerIndex = _,
                    this.bucketIndex = b,
                    this.tileID = T
                }
            }
            class nr {
                constructor(l) {
                    this.crossSourceCollisions = l,
                    this.maxGroupID = 0,
                    this.collisionGroups = {}
                }
                get(l) {
                    if (this.crossSourceCollisions)
                        return {
                            ID: 0,
                            predicate: null
                        };
                    if (!this.collisionGroups[l]) {
                        let h = ++this.maxGroupID;
                        this.collisionGroups[l] = {
                            ID: h,
                            predicate: _=>_.collisionGroupID === h
                        }
                    }
                    return this.collisionGroups[l]
                }
            }
            function fh(m, l, h, _, b) {
                let {horizontalAlign: T, verticalAlign: L} = i.getAnchorAlignment(m)
                  , R = -(T - .5) * l
                  , O = -(L - .5) * h
                  , V = i.evaluateVariableOffset(m, _);
                return new i.pointGeometry(R + V[0] * b,O + V[1] * b)
            }
            function Lc(m, l, h, _, b) {
                let T = new i.pointGeometry(m,l);
                return h && T._rotate(_ ? b : -b),
                T
            }
            class ms {
                constructor(l, h, _, b, T) {
                    this.transform = l.clone(),
                    this.projection = l.projection.name,
                    this.collisionIndex = new mf(this.transform,T),
                    this.placements = {},
                    this.opacities = {},
                    this.variableOffsets = {},
                    this.stale = !1,
                    this.commitTime = 0,
                    this.fadeDuration = h,
                    this.retainedQueryData = {},
                    this.collisionGroups = new nr(_),
                    this.collisionCircleArrays = {},
                    this.prevPlacement = b,
                    b && (b.prevPlacement = void 0),
                    this.placedOrientations = {}
                }
                getBucketParts(l, h, _, b) {
                    let T = _.getBucket(h)
                      , L = _.latestFeatureIndex;
                    if (!T || !L || h.id !== T.layerIds[0])
                        return;
                    let R = T.layers[0].layout
                      , O = _.collisionBoxArray
                      , V = Math.pow(2, this.transform.zoom - _.tileID.overscaledZ)
                      , G = _.tileSize / i.EXTENT
                      , J = _.tileID.toUnwrapped();
                    this.transform.setProjection(T.projection);
                    let le = (me = _.tileID,
                    pe = T.getProjection(),
                    ge = this.transform,
                    pe.name === this.projection ? ge.calculateProjMatrix(me.toUnwrapped()) : Ma(ge, pe, me));
                    var me, pe, ge;
                    let ve = R.get("text-pitch-alignment") === "map"
                      , re = R.get("text-rotation-alignment") === "map";
                    h.compileFilter();
                    let Ce = h.dynamicFilter()
                      , Ae = h.dynamicFilterNeedsFeature()
                      , De = this.transform.calculatePixelsToTileUnitsMatrix(_)
                      , Ve = hh(le, _.tileID.canonical, ve, re, this.transform, T.getProjection(), De)
                      , Fe = null;
                    if (ve) {
                        let rt = Zo(le, _.tileID.canonical, ve, re, this.transform, T.getProjection(), De);
                        Fe = i.multiply([], this.transform.labelPlaneMatrix, rt)
                    }
                    let Xe = null;
                    Ce && _.latestFeatureIndex && (Xe = {
                        unwrappedTileID: J,
                        dynamicFilter: Ce,
                        dynamicFilterNeedsFeature: Ae,
                        featureIndex: _.latestFeatureIndex
                    }),
                    this.retainedQueryData[T.bucketInstanceId] = new ps(T.bucketInstanceId,L,T.sourceLayerIndex,T.index,_.tileID);
                    let $e = {
                        bucket: T,
                        layout: R,
                        posMatrix: le,
                        textLabelPlaneMatrix: Ve,
                        labelToScreenMatrix: Fe,
                        clippingData: Xe,
                        scale: V,
                        textPixelRatio: G,
                        holdingForFade: _.holdingForFade(),
                        collisionBoxArray: O,
                        partiallyEvaluatedTextSize: i.evaluateSizeForZoom(T.textSizeData, this.transform.zoom),
                        partiallyEvaluatedIconSize: i.evaluateSizeForZoom(T.iconSizeData, this.transform.zoom),
                        collisionGroup: this.collisionGroups.get(T.sourceID)
                    };
                    if (b)
                        for (let rt of T.sortKeyRanges) {
                            let {sortKey: lt, symbolInstanceStart: Vt, symbolInstanceEnd: nt} = rt;
                            l.push({
                                sortKey: lt,
                                symbolInstanceStart: Vt,
                                symbolInstanceEnd: nt,
                                parameters: $e
                            })
                        }
                    else
                        l.push({
                            symbolInstanceStart: 0,
                            symbolInstanceEnd: T.symbolInstances.length,
                            parameters: $e
                        })
                }
                attemptAnchorPlacement(l, h, _, b, T, L, R, O, V, G, J, le, me, pe, ge, ve, re, Ce) {
                    let {textOffset0: Ae, textOffset1: De, crossTileID: Ve} = le
                      , Fe = [Ae, De]
                      , Xe = fh(l, _, b, Fe, T)
                      , $e = this.collisionIndex.placeCollisionBox(pe, T, h, Lc(Xe.x, Xe.y, L, R, this.transform.angle), J, O, V, G.predicate);
                    if (ve) {
                        let rt = pe.getSymbolInstanceIconSize(Ce, this.transform.zoom, le.placedIconSymbolIndex);
                        if (this.collisionIndex.placeCollisionBox(pe, rt, ve, Lc(Xe.x, Xe.y, L, R, this.transform.angle), J, O, V, G.predicate).box.length === 0)
                            return
                    }
                    if ($e.box.length > 0) {
                        let rt;
                        return this.prevPlacement && this.prevPlacement.variableOffsets[Ve] && this.prevPlacement.placements[Ve] && this.prevPlacement.placements[Ve].text && (rt = this.prevPlacement.variableOffsets[Ve].anchor),
                        this.variableOffsets[Ve] = {
                            textOffset: Fe,
                            width: _,
                            height: b,
                            anchor: l,
                            textScale: T,
                            prevAnchor: rt
                        },
                        this.markUsedJustification(pe, l, le, ge),
                        pe.allowVerticalPlacement && (this.markUsedOrientation(pe, ge, le),
                        this.placedOrientations[Ve] = ge),
                        {
                            shift: Xe,
                            placedGlyphBoxes: $e
                        }
                    }
                }
                placeLayerBucketPart(l, h, _, b) {
                    let {bucket: T, layout: L, posMatrix: R, textLabelPlaneMatrix: O, labelToScreenMatrix: V, clippingData: G, textPixelRatio: J, holdingForFade: le, collisionBoxArray: me, partiallyEvaluatedTextSize: pe, partiallyEvaluatedIconSize: ge, collisionGroup: ve} = l.parameters
                      , re = L.get("text-optional")
                      , Ce = L.get("icon-optional")
                      , Ae = L.get("text-allow-overlap")
                      , De = L.get("icon-allow-overlap")
                      , Ve = L.get("text-rotation-alignment") === "map"
                      , Fe = L.get("text-pitch-alignment") === "map"
                      , Xe = L.get("icon-text-fit") !== "none"
                      , $e = L.get("symbol-z-order") === "viewport-y";
                    this.transform.setProjection(T.projection);
                    let rt = Ae && (De || !T.hasIconData() || Ce)
                      , lt = De && (Ae || !T.hasTextData() || re);
                    !T.collisionArrays && me && T.deserializeCollisionBoxes(me),
                    _ && b && T.updateCollisionDebugBuffers(this.transform.zoom, me);
                    let Vt = (nt,vt,pt)=>{
                        let {crossTileID: Dt, numVerticalGlyphVertices: st} = nt;
                        if (G) {
                            let Gi = {
                                zoom: this.transform.zoom,
                                pitch: this.transform.pitch
                            }
                              , Ii = null;
                            if (G.dynamicFilterNeedsFeature) {
                                let li = this.retainedQueryData[T.bucketInstanceId];
                                Ii = G.featureIndex.loadFeature({
                                    featureIndex: nt.featureIndex,
                                    bucketIndex: li.bucketIndex,
                                    sourceLayerIndex: li.sourceLayerIndex,
                                    layoutVertexArrayOffset: 0
                                })
                            }
                            if (!(0,
                            G.dynamicFilter)(Gi, Ii, this.retainedQueryData[T.bucketInstanceId].tileID.canonical, new i.pointGeometry(nt.tileAnchorX,nt.tileAnchorY), this.transform.calculateDistanceTileData(G.unwrappedTileID)))
                                return this.placements[Dt] = new gl(!1,!1,!1,!0),
                                void (h[Dt] = !0)
                        }
                        if (h[Dt])
                            return;
                        if (le)
                            return void (this.placements[Dt] = new gl(!1,!1,!1));
                        let Je = !1
                          , ct = !1
                          , At = !0
                          , Pt = !1
                          , pn = !1
                          , Xn = null
                          , un = {
                            box: null,
                            offscreen: null,
                            occluded: null
                        }
                          , sn = {
                            box: null,
                            offscreen: null,
                            occluded: null
                        }
                          , vn = null
                          , Qn = null
                          , En = null
                          , pi = 0
                          , Ti = 0
                          , Ri = 0;
                        pt.textFeatureIndex ? pi = pt.textFeatureIndex : nt.useRuntimeCollisionCircles && (pi = nt.featureIndex),
                        pt.verticalTextFeatureIndex && (Ti = pt.verticalTextFeatureIndex);
                        let Mi = Gi=>{
                            Gi.tileID = this.retainedQueryData[T.bucketInstanceId].tileID;
                            let Ii = this.transform.elevation;
                            (Ii || Gi.elevation) && (Gi.elevation = Ii ? Ii.getAtTileOffset(Gi.tileID, Gi.tileAnchorX, Gi.tileAnchorY) : 0)
                        }
                          , lr = pt.textBox;
                        if (lr) {
                            Mi(lr);
                            let Gi = li=>{
                                let Ji = i.WritingMode.horizontal;
                                if (T.allowVerticalPlacement && !li && this.prevPlacement) {
                                    let Wr = this.prevPlacement.placedOrientations[Dt];
                                    Wr && (this.placedOrientations[Dt] = Wr,
                                    Ji = Wr,
                                    this.markUsedOrientation(T, Ji, nt))
                                }
                                return Ji
                            }
                              , Ii = (li,Ji)=>{
                                if (T.allowVerticalPlacement && st > 0 && pt.verticalTextBox) {
                                    for (let Wr of T.writingModes)
                                        if (Wr === i.WritingMode.vertical ? (un = Ji(),
                                        sn = un) : un = li(),
                                        un && un.box && un.box.length)
                                            break
                                } else
                                    un = li()
                            }
                            ;
                            if (L.get("text-variable-anchor")) {
                                let li = L.get("text-variable-anchor");
                                if (this.prevPlacement && this.prevPlacement.variableOffsets[Dt]) {
                                    let Oi = this.prevPlacement.variableOffsets[Dt];
                                    li.indexOf(Oi.anchor) > 0 && (li = li.filter(jr=>jr !== Oi.anchor),
                                    li.unshift(Oi.anchor))
                                }
                                let Ji = (Oi,jr,Xr)=>{
                                    let $o = T.getSymbolInstanceTextSize(pe, nt, this.transform.zoom, vt)
                                      , Rl = (Oi.x2 - Oi.x1) * $o + 2 * Oi.padding
                                      , Ss = (Oi.y2 - Oi.y1) * $o + 2 * Oi.padding
                                      , Os = Xe && !De ? jr : null;
                                    Os && Mi(Os);
                                    let Do = {
                                        box: [],
                                        offscreen: !1,
                                        occluded: !1
                                    }
                                      , Qo = Ae ? 2 * li.length : li.length;
                                    for (let ea = 0; ea < Qo; ++ea) {
                                        let Pl = this.attemptAnchorPlacement(li[ea % li.length], Oi, Rl, Ss, $o, Ve, Fe, J, R, ve, ea >= li.length, nt, vt, T, Xr, Os, pe, ge);
                                        if (Pl && (Do = Pl.placedGlyphBoxes,
                                        Do && Do.box && Do.box.length)) {
                                            Je = !0,
                                            Xn = Pl.shift;
                                            break
                                        }
                                    }
                                    return Do
                                }
                                ;
                                Ii(()=>Ji(lr, pt.iconBox, i.WritingMode.horizontal), ()=>{
                                    let Oi = pt.verticalTextBox;
                                    return Oi && Mi(Oi),
                                    T.allowVerticalPlacement && !(un && un.box && un.box.length) && st > 0 && Oi ? Ji(Oi, pt.verticalIconBox, i.WritingMode.vertical) : {
                                        box: null,
                                        offscreen: null,
                                        occluded: null
                                    }
                                }
                                ),
                                un && (Je = un.box,
                                At = un.offscreen,
                                Pt = un.occluded);
                                let Wr = Gi(un && un.box);
                                if (!Je && this.prevPlacement) {
                                    let Oi = this.prevPlacement.variableOffsets[Dt];
                                    Oi && (this.variableOffsets[Dt] = Oi,
                                    this.markUsedJustification(T, Oi.anchor, nt, Wr))
                                }
                            } else {
                                let li = (Ji,Wr)=>{
                                    let Oi = T.getSymbolInstanceTextSize(pe, nt, this.transform.zoom, vt)
                                      , jr = this.collisionIndex.placeCollisionBox(T, Oi, Ji, new i.pointGeometry(0,0), Ae, J, R, ve.predicate);
                                    return jr && jr.box && jr.box.length && (this.markUsedOrientation(T, Wr, nt),
                                    this.placedOrientations[Dt] = Wr),
                                    jr
                                }
                                ;
                                Ii(()=>li(lr, i.WritingMode.horizontal), ()=>{
                                    let Ji = pt.verticalTextBox;
                                    return T.allowVerticalPlacement && st > 0 && Ji ? (Mi(Ji),
                                    li(Ji, i.WritingMode.vertical)) : {
                                        box: null,
                                        offscreen: null,
                                        occluded: null
                                    }
                                }
                                ),
                                Gi(un && un.box && un.box.length)
                            }
                        }
                        if (vn = un,
                        Je = vn && vn.box && vn.box.length > 0,
                        At = vn && vn.offscreen,
                        Pt = vn && vn.occluded,
                        nt.useRuntimeCollisionCircles) {
                            let Gi = T.text.placedSymbolArray.get(nt.centerJustifiedTextSymbolIndex >= 0 ? nt.centerJustifiedTextSymbolIndex : nt.verticalPlacedTextSymbolIndex)
                              , Ii = i.evaluateSizeForFeature(T.textSizeData, pe, Gi)
                              , li = L.get("text-padding");
                            Qn = this.collisionIndex.placeCollisionCircles(T, Ae, Gi, T.lineVertexArray, T.glyphOffsetArray, Ii, R, O, V, _, Fe, ve.predicate, nt.collisionCircleDiameter * Ii / i.ONE_EM, li, this.retainedQueryData[T.bucketInstanceId].tileID),
                            Je = Ae || Qn.circles.length > 0 && !Qn.collisionDetected,
                            At = At && Qn.offscreen,
                            Pt = Qn.occluded
                        }
                        if (pt.iconFeatureIndex && (Ri = pt.iconFeatureIndex),
                        pt.iconBox) {
                            let Gi = Ii=>{
                                Mi(Ii);
                                let li = Xe && Xn ? Lc(Xn.x, Xn.y, Ve, Fe, this.transform.angle) : new i.pointGeometry(0,0)
                                  , Ji = T.getSymbolInstanceIconSize(ge, this.transform.zoom, nt.placedIconSymbolIndex);
                                return this.collisionIndex.placeCollisionBox(T, Ji, Ii, li, De, J, R, ve.predicate)
                            }
                            ;
                            sn && sn.box && sn.box.length && pt.verticalIconBox ? (En = Gi(pt.verticalIconBox),
                            ct = En.box.length > 0) : (En = Gi(pt.iconBox),
                            ct = En.box.length > 0),
                            At = At && En.offscreen,
                            pn = En.occluded
                        }
                        let gs = re || nt.numHorizontalGlyphVertices === 0 && st === 0
                          , Ks = Ce || nt.numIconVertices === 0;
                        if (gs || Ks ? Ks ? gs || (ct = ct && Je) : Je = ct && Je : ct = Je = ct && Je,
                        Je && vn && vn.box && this.collisionIndex.insertCollisionBox(vn.box, L.get("text-ignore-placement"), T.bucketInstanceId, sn && sn.box && Ti ? Ti : pi, ve.ID),
                        ct && En && this.collisionIndex.insertCollisionBox(En.box, L.get("icon-ignore-placement"), T.bucketInstanceId, Ri, ve.ID),
                        Qn && (Je && this.collisionIndex.insertCollisionCircles(Qn.circles, L.get("text-ignore-placement"), T.bucketInstanceId, pi, ve.ID),
                        _)) {
                            let Gi = T.bucketInstanceId
                              , Ii = this.collisionCircleArrays[Gi];
                            Ii === void 0 && (Ii = this.collisionCircleArrays[Gi] = new _f);
                            for (let li = 0; li < Qn.circles.length; li += 4)
                                Ii.circles.push(Qn.circles[li + 0]),
                                Ii.circles.push(Qn.circles[li + 1]),
                                Ii.circles.push(Qn.circles[li + 2]),
                                Ii.circles.push(Qn.collisionDetected ? 1 : 0)
                        }
                        let Co = T.projection.name !== "globe";
                        rt = rt && (Co || !Pt),
                        lt = lt && (Co || !pn),
                        this.placements[Dt] = new gl(Je || rt,ct || lt,At || T.justReloaded),
                        h[Dt] = !0
                    }
                    ;
                    if ($e) {
                        let nt = T.getSortedSymbolIndexes(this.transform.angle);
                        for (let vt = nt.length - 1; vt >= 0; --vt) {
                            let pt = nt[vt];
                            Vt(T.symbolInstances.get(pt), pt, T.collisionArrays[pt])
                        }
                    } else
                        for (let nt = l.symbolInstanceStart; nt < l.symbolInstanceEnd; nt++)
                            Vt(T.symbolInstances.get(nt), nt, T.collisionArrays[nt]);
                    if (_ && T.bucketInstanceId in this.collisionCircleArrays) {
                        let nt = this.collisionCircleArrays[T.bucketInstanceId];
                        i.invert(nt.invProjMatrix, R),
                        nt.viewportMatrix = this.collisionIndex.getViewportMatrix()
                    }
                    T.justReloaded = !1
                }
                markUsedJustification(l, h, _, b) {
                    let {leftJustifiedTextSymbolIndex: T, centerJustifiedTextSymbolIndex: L, rightJustifiedTextSymbolIndex: R, verticalPlacedTextSymbolIndex: O, crossTileID: V} = _
                      , G = i.getAnchorJustification(h)
                      , J = b === i.WritingMode.vertical ? O : G === "left" ? T : G === "center" ? L : G === "right" ? R : -1;
                    T >= 0 && (l.text.placedSymbolArray.get(T).crossTileID = J >= 0 && T !== J ? 0 : V),
                    L >= 0 && (l.text.placedSymbolArray.get(L).crossTileID = J >= 0 && L !== J ? 0 : V),
                    R >= 0 && (l.text.placedSymbolArray.get(R).crossTileID = J >= 0 && R !== J ? 0 : V),
                    O >= 0 && (l.text.placedSymbolArray.get(O).crossTileID = J >= 0 && O !== J ? 0 : V)
                }
                markUsedOrientation(l, h, _) {
                    let b = h === i.WritingMode.horizontal || h === i.WritingMode.horizontalOnly ? h : 0
                      , T = h === i.WritingMode.vertical ? h : 0
                      , {leftJustifiedTextSymbolIndex: L, centerJustifiedTextSymbolIndex: R, rightJustifiedTextSymbolIndex: O, verticalPlacedTextSymbolIndex: V} = _
                      , G = l.text.placedSymbolArray;
                    L >= 0 && (G.get(L).placedOrientation = b),
                    R >= 0 && (G.get(R).placedOrientation = b),
                    O >= 0 && (G.get(O).placedOrientation = b),
                    V >= 0 && (G.get(V).placedOrientation = T)
                }
                commit(l) {
                    this.commitTime = l,
                    this.zoomAtLastRecencyCheck = this.transform.zoom;
                    let h = this.prevPlacement
                      , _ = !1;
                    this.prevZoomAdjustment = h ? h.zoomAdjustment(this.transform.zoom) : 0;
                    let b = h ? h.symbolFadeChange(l) : 1
                      , T = h ? h.opacities : {}
                      , L = h ? h.variableOffsets : {}
                      , R = h ? h.placedOrientations : {};
                    for (let O in this.placements) {
                        let V = this.placements[O]
                          , G = T[O];
                        G ? (this.opacities[O] = new Ia(G,b,V.text,V.icon,null,V.clipped),
                        _ = _ || V.text !== G.text.placed || V.icon !== G.icon.placed) : (this.opacities[O] = new Ia(null,b,V.text,V.icon,V.skipFade,V.clipped),
                        _ = _ || V.text || V.icon)
                    }
                    for (let O in T) {
                        let V = T[O];
                        if (!this.opacities[O]) {
                            let G = new Ia(V,b,!1,!1);
                            G.isHidden() || (this.opacities[O] = G,
                            _ = _ || V.text.placed || V.icon.placed)
                        }
                    }
                    for (let O in L)
                        this.variableOffsets[O] || !this.opacities[O] || this.opacities[O].isHidden() || (this.variableOffsets[O] = L[O]);
                    for (let O in R)
                        this.placedOrientations[O] || !this.opacities[O] || this.opacities[O].isHidden() || (this.placedOrientations[O] = R[O]);
                    _ ? this.lastPlacementChangeTime = l : typeof this.lastPlacementChangeTime != "number" && (this.lastPlacementChangeTime = h ? h.lastPlacementChangeTime : l)
                }
                updateLayerOpacities(l, h) {
                    let _ = {};
                    for (let b of h) {
                        let T = b.getBucket(l);
                        T && b.latestFeatureIndex && l.id === T.layerIds[0] && this.updateBucketOpacities(T, _, b.collisionBoxArray)
                    }
                }
                updateBucketOpacities(l, h, _) {
                    l.hasTextData() && l.text.opacityVertexArray.clear(),
                    l.hasIconData() && l.icon.opacityVertexArray.clear(),
                    l.hasIconCollisionBoxData() && l.iconCollisionBox.collisionVertexArray.clear(),
                    l.hasTextCollisionBoxData() && l.textCollisionBox.collisionVertexArray.clear();
                    let b = l.layers[0].layout
                      , T = !!l.layers[0].dynamicFilter()
                      , L = new Ia(null,0,!1,!1,!0)
                      , R = b.get("text-allow-overlap")
                      , O = b.get("icon-allow-overlap")
                      , V = b.get("text-variable-anchor")
                      , G = b.get("text-rotation-alignment") === "map"
                      , J = b.get("text-pitch-alignment") === "map"
                      , le = b.get("icon-text-fit") !== "none"
                      , me = new Ia(null,0,R && (O || !l.hasIconData() || b.get("icon-optional")),O && (R || !l.hasTextData() || b.get("text-optional")),!0);
                    !l.collisionArrays && _ && (l.hasIconCollisionBoxData() || l.hasTextCollisionBoxData()) && l.deserializeCollisionBoxes(_);
                    let pe = (ve,re,Ce)=>{
                        for (let Ae = 0; Ae < re / 4; Ae++)
                            ve.opacityVertexArray.emplaceBack(Ce)
                    }
                      , ge = 0;
                    for (let ve = 0; ve < l.symbolInstances.length; ve++) {
                        let re = l.symbolInstances.get(ve)
                          , {numHorizontalGlyphVertices: Ce, numVerticalGlyphVertices: Ae, crossTileID: De, numIconVertices: Ve} = re
                          , Fe = this.opacities[De];
                        h[De] ? Fe = L : Fe || (Fe = me,
                        this.opacities[De] = Fe),
                        h[De] = !0;
                        let Xe = Ce > 0 || Ae > 0
                          , $e = Ve > 0
                          , rt = this.placedOrientations[De]
                          , lt = rt === i.WritingMode.vertical
                          , Vt = rt === i.WritingMode.horizontal || rt === i.WritingMode.horizontalOnly;
                        if (!Xe && !$e || Fe.isHidden() || ge++,
                        Xe) {
                            let nt = mh(Fe.text);
                            pe(l.text, Ce, lt ? _l : nt),
                            pe(l.text, Ae, Vt ? _l : nt);
                            let vt = Fe.text.isHidden()
                              , {leftJustifiedTextSymbolIndex: pt, centerJustifiedTextSymbolIndex: Dt, rightJustifiedTextSymbolIndex: st, verticalPlacedTextSymbolIndex: Je} = re
                              , ct = l.text.placedSymbolArray
                              , At = vt || lt ? 1 : 0;
                            pt >= 0 && (ct.get(pt).hidden = At),
                            Dt >= 0 && (ct.get(Dt).hidden = At),
                            st >= 0 && (ct.get(st).hidden = At),
                            Je >= 0 && (ct.get(Je).hidden = vt || Vt ? 1 : 0);
                            let Pt = this.variableOffsets[De];
                            Pt && this.markUsedJustification(l, Pt.anchor, re, rt);
                            let pn = this.placedOrientations[De];
                            pn && (this.markUsedJustification(l, "left", re, pn),
                            this.markUsedOrientation(l, pn, re))
                        }
                        if ($e) {
                            let nt = mh(Fe.icon)
                              , {placedIconSymbolIndex: vt, verticalPlacedIconSymbolIndex: pt} = re
                              , Dt = l.icon.placedSymbolArray
                              , st = Fe.icon.isHidden() ? 1 : 0;
                            vt >= 0 && (pe(l.icon, Ve, lt ? _l : nt),
                            Dt.get(vt).hidden = st),
                            pt >= 0 && (pe(l.icon, re.numVerticalIconVertices, Vt ? _l : nt),
                            Dt.get(pt).hidden = st)
                        }
                        if (l.hasIconCollisionBoxData() || l.hasTextCollisionBoxData()) {
                            let nt = l.collisionArrays[ve];
                            if (nt) {
                                let vt = new i.pointGeometry(0,0)
                                  , pt = !0;
                                if (nt.textBox || nt.verticalTextBox) {
                                    if (V) {
                                        let st = this.variableOffsets[De];
                                        st ? (vt = fh(st.anchor, st.width, st.height, st.textOffset, st.textScale),
                                        G && vt._rotate(J ? this.transform.angle : -this.transform.angle)) : pt = !1
                                    }
                                    T && (pt = !Fe.clipped),
                                    nt.textBox && ls(l.textCollisionBox.collisionVertexArray, Fe.text.placed, !pt || lt, vt.x, vt.y),
                                    nt.verticalTextBox && ls(l.textCollisionBox.collisionVertexArray, Fe.text.placed, !pt || Vt, vt.x, vt.y)
                                }
                                let Dt = pt && Boolean(!Vt && nt.verticalIconBox);
                                nt.iconBox && ls(l.iconCollisionBox.collisionVertexArray, Fe.icon.placed, Dt, le ? vt.x : 0, le ? vt.y : 0),
                                nt.verticalIconBox && ls(l.iconCollisionBox.collisionVertexArray, Fe.icon.placed, !Dt, le ? vt.x : 0, le ? vt.y : 0)
                            }
                        }
                    }
                    if (l.fullyClipped = ge === 0,
                    l.sortFeatures(this.transform.angle),
                    this.retainedQueryData[l.bucketInstanceId] && (this.retainedQueryData[l.bucketInstanceId].featureSortOrder = l.featureSortOrder),
                    l.hasTextData() && l.text.opacityVertexBuffer && l.text.opacityVertexBuffer.updateData(l.text.opacityVertexArray),
                    l.hasIconData() && l.icon.opacityVertexBuffer && l.icon.opacityVertexBuffer.updateData(l.icon.opacityVertexArray),
                    l.hasIconCollisionBoxData() && l.iconCollisionBox.collisionVertexBuffer && l.iconCollisionBox.collisionVertexBuffer.updateData(l.iconCollisionBox.collisionVertexArray),
                    l.hasTextCollisionBoxData() && l.textCollisionBox.collisionVertexBuffer && l.textCollisionBox.collisionVertexBuffer.updateData(l.textCollisionBox.collisionVertexArray),
                    l.bucketInstanceId in this.collisionCircleArrays) {
                        let ve = this.collisionCircleArrays[l.bucketInstanceId];
                        l.placementInvProjMatrix = ve.invProjMatrix,
                        l.placementViewportMatrix = ve.viewportMatrix,
                        l.collisionCircleArray = ve.circles,
                        delete this.collisionCircleArrays[l.bucketInstanceId]
                    }
                }
                symbolFadeChange(l) {
                    return this.fadeDuration === 0 ? 1 : (l - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment
                }
                zoomAdjustment(l) {
                    return Math.max(0, (this.transform.zoom - l) / 1.5)
                }
                hasTransitions(l) {
                    return this.stale || l - this.lastPlacementChangeTime < this.fadeDuration
                }
                stillRecent(l, h) {
                    let _ = this.zoomAtLastRecencyCheck === h ? 1 - this.zoomAdjustment(h) : 1;
                    return this.zoomAtLastRecencyCheck = h,
                    this.commitTime + this.fadeDuration * _ > l
                }
                setStale() {
                    this.stale = !0
                }
            }
            function ls(m, l, h, _, b) {
                m.emplaceBack(l ? 1 : 0, h ? 1 : 0, _ || 0, b || 0),
                m.emplaceBack(l ? 1 : 0, h ? 1 : 0, _ || 0, b || 0),
                m.emplaceBack(l ? 1 : 0, h ? 1 : 0, _ || 0, b || 0),
                m.emplaceBack(l ? 1 : 0, h ? 1 : 0, _ || 0, b || 0)
            }
            let ug = Math.pow(2, 25)
              , ph = Math.pow(2, 24)
              , gr = Math.pow(2, 17)
              , Rc = Math.pow(2, 16)
              , yf = Math.pow(2, 9)
              , Pc = Math.pow(2, 8)
              , Dr = Math.pow(2, 1);
            function mh(m) {
                if (m.opacity === 0 && !m.placed)
                    return 0;
                if (m.opacity === 1 && m.placed)
                    return 4294967295;
                let l = m.placed ? 1 : 0
                  , h = Math.floor(127 * m.opacity);
                return h * ug + l * ph + h * gr + l * Rc + h * yf + l * Pc + h * Dr + l
            }
            let _l = 0;
            class Ao {
                constructor(l) {
                    this._sortAcrossTiles = l.layout.get("symbol-z-order") !== "viewport-y" && l.layout.get("symbol-sort-key").constantOr(1) !== void 0,
                    this._currentTileIndex = 0,
                    this._currentPartIndex = 0,
                    this._seenCrossTileIDs = {},
                    this._bucketParts = []
                }
                continuePlacement(l, h, _, b, T) {
                    let L = this._bucketParts;
                    for (; this._currentTileIndex < l.length; )
                        if (h.getBucketParts(L, b, l[this._currentTileIndex], this._sortAcrossTiles),
                        this._currentTileIndex++,
                        T())
                            return !0;
                    for (this._sortAcrossTiles && (this._sortAcrossTiles = !1,
                    L.sort((R,O)=>R.sortKey - O.sortKey)); this._currentPartIndex < L.length; ) {
                        let R = L[this._currentPartIndex];
                        if (h.placeLayerBucketPart(R, this._seenCrossTileIDs, _, R.symbolInstanceStart === 0),
                        this._currentPartIndex++,
                        T())
                            return !0
                    }
                    return !1
                }
            }
            class kc {
                constructor(l, h, _, b, T, L, R, O) {
                    this.placement = new ms(l,T,L,R,O),
                    this._currentPlacementIndex = h.length - 1,
                    this._forceFullPlacement = _,
                    this._showCollisionBoxes = b,
                    this._done = !1
                }
                isDone() {
                    return this._done
                }
                continuePlacement(l, h, _) {
                    let b = i.exported.now()
                      , T = ()=>{
                        let L = i.exported.now() - b;
                        return !this._forceFullPlacement && L > 2
                    }
                    ;
                    for (; this._currentPlacementIndex >= 0; ) {
                        let L = h[l[this._currentPlacementIndex]]
                          , R = this.placement.collisionIndex.transform.zoom;
                        if (L.type === "symbol" && (!L.minzoom || L.minzoom <= R) && (!L.maxzoom || L.maxzoom > R)) {
                            if (this._inProgressLayer || (this._inProgressLayer = new Ao(L)),
                            this._inProgressLayer.continuePlacement(_[L.source], this.placement, this._showCollisionBoxes, L, T))
                                return;
                            delete this._inProgressLayer
                        }
                        this._currentPlacementIndex--
                    }
                    this._done = !0
                }
                commit(l) {
                    return this.placement.commit(l),
                    this.placement
                }
            }
            let gh = 512 / i.EXTENT / 2;
            class $0 {
                constructor(l, h, _) {
                    this.tileID = l,
                    this.indexedSymbolInstances = {},
                    this.bucketInstanceId = _;
                    for (let b = 0; b < h.length; b++) {
                        let T = h.get(b)
                          , L = T.key;
                        this.indexedSymbolInstances[L] || (this.indexedSymbolInstances[L] = []),
                        this.indexedSymbolInstances[L].push({
                            crossTileID: T.crossTileID,
                            coord: this.getScaledCoordinates(T, l)
                        })
                    }
                }
                getScaledCoordinates(l, h) {
                    let _ = gh / Math.pow(2, h.canonical.z - this.tileID.canonical.z);
                    return {
                        x: Math.floor((h.canonical.x * i.EXTENT + l.tileAnchorX) * _),
                        y: Math.floor((h.canonical.y * i.EXTENT + l.tileAnchorY) * _)
                    }
                }
                findMatches(l, h, _) {
                    let b = this.tileID.canonical.z < h.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - h.canonical.z);
                    for (let T = 0; T < l.length; T++) {
                        let L = l.get(T);
                        if (L.crossTileID)
                            continue;
                        let R = this.indexedSymbolInstances[L.key];
                        if (!R)
                            continue;
                        let O = this.getScaledCoordinates(L, h);
                        for (let V of R)
                            if (Math.abs(V.coord.x - O.x) <= b && Math.abs(V.coord.y - O.y) <= b && !_[V.crossTileID]) {
                                _[V.crossTileID] = !0,
                                L.crossTileID = V.crossTileID;
                                break
                            }
                    }
                }
            }
            class xf {
                constructor() {
                    this.maxCrossTileID = 0
                }
                generate() {
                    return ++this.maxCrossTileID
                }
            }
            class yl {
                constructor() {
                    this.indexes = {},
                    this.usedCrossTileIDs = {},
                    this.lng = 0
                }
                handleWrapJump(l) {
                    let h = Math.round((l - this.lng) / 360);
                    if (h !== 0)
                        for (let _ in this.indexes) {
                            let b = this.indexes[_]
                              , T = {};
                            for (let L in b) {
                                let R = b[L];
                                R.tileID = R.tileID.unwrapTo(R.tileID.wrap + h),
                                T[R.tileID.key] = R
                            }
                            this.indexes[_] = T
                        }
                    this.lng = l
                }
                addBucket(l, h, _) {
                    if (this.indexes[l.overscaledZ] && this.indexes[l.overscaledZ][l.key]) {
                        if (this.indexes[l.overscaledZ][l.key].bucketInstanceId === h.bucketInstanceId)
                            return !1;
                        this.removeBucketCrossTileIDs(l.overscaledZ, this.indexes[l.overscaledZ][l.key])
                    }
                    for (let T = 0; T < h.symbolInstances.length; T++)
                        h.symbolInstances.get(T).crossTileID = 0;
                    this.usedCrossTileIDs[l.overscaledZ] || (this.usedCrossTileIDs[l.overscaledZ] = {});
                    let b = this.usedCrossTileIDs[l.overscaledZ];
                    for (let T in this.indexes) {
                        let L = this.indexes[T];
                        if (Number(T) > l.overscaledZ)
                            for (let R in L) {
                                let O = L[R];
                                O.tileID.isChildOf(l) && O.findMatches(h.symbolInstances, l, b)
                            }
                        else {
                            let R = L[l.scaledTo(Number(T)).key];
                            R && R.findMatches(h.symbolInstances, l, b)
                        }
                    }
                    for (let T = 0; T < h.symbolInstances.length; T++) {
                        let L = h.symbolInstances.get(T);
                        L.crossTileID || (L.crossTileID = _.generate(),
                        b[L.crossTileID] = !0)
                    }
                    return this.indexes[l.overscaledZ] === void 0 && (this.indexes[l.overscaledZ] = {}),
                    this.indexes[l.overscaledZ][l.key] = new $0(l,h.symbolInstances,h.bucketInstanceId),
                    !0
                }
                removeBucketCrossTileIDs(l, h) {
                    for (let _ in h.indexedSymbolInstances)
                        for (let b of h.indexedSymbolInstances[_])
                            delete this.usedCrossTileIDs[l][b.crossTileID]
                }
                removeStaleBuckets(l) {
                    let h = !1;
                    for (let _ in this.indexes) {
                        let b = this.indexes[_];
                        for (let T in b)
                            l[b[T].bucketInstanceId] || (this.removeBucketCrossTileIDs(_, b[T]),
                            delete b[T],
                            h = !0)
                    }
                    return h
                }
            }
            class hg {
                constructor() {
                    this.layerIndexes = {},
                    this.crossTileIDs = new xf,
                    this.maxBucketInstanceId = 0,
                    this.bucketsInCurrentPlacement = {}
                }
                addLayer(l, h, _, b) {
                    let T = this.layerIndexes[l.id];
                    T === void 0 && (T = this.layerIndexes[l.id] = new yl);
                    let L = !1
                      , R = {};
                    b.name !== "globe" && T.handleWrapJump(_);
                    for (let O of h) {
                        let V = O.getBucket(l);
                        V && l.id === V.layerIds[0] && (V.bucketInstanceId || (V.bucketInstanceId = ++this.maxBucketInstanceId),
                        T.addBucket(O.tileID, V, this.crossTileIDs) && (L = !0),
                        R[V.bucketInstanceId] = !0)
                    }
                    return T.removeStaleBuckets(R) && (L = !0),
                    L
                }
                pruneUnusedLayers(l) {
                    let h = {};
                    l.forEach(_=>{
                        h[_] = !0
                    }
                    );
                    for (let _ in this.layerIndexes)
                        h[_] || delete this.layerIndexes[_]
                }
            }
            let zc = (m,l)=>i.emitValidationErrors(m, l && l.filter(h=>h.identifier !== "source.canvas"))
              , xl = i.pick(jt, ["addLayer", "removeLayer", "setPaintProperty", "setLayoutProperty", "setFilter", "addSource", "removeSource", "setLayerZoomRange", "setLight", "setTransition", "setGeoJSONSourceData", "setTerrain", "setFog", "setProjection"])
              , qo = i.pick(jt, ["setCenter", "setZoom", "setBearing", "setPitch"])
              , _h = {
                version: 8,
                layers: [],
                sources: {}
            }
              , Ko = {
                fill: !0,
                line: !0,
                background: !0,
                hillshade: !0,
                raster: !0
            };
            class ks extends i.Evented {
                constructor(l, h={}) {
                    super(),
                    this.map = l,
                    this.dispatcher = new Gt(fn(),this),
                    this.imageManager = new j,
                    this.imageManager.setEventedParent(this),
                    this.glyphManager = new i.GlyphManager(l._requestManager,h.localFontFamily ? i.LocalGlyphMode.all : h.localIdeographFontFamily ? i.LocalGlyphMode.ideographs : i.LocalGlyphMode.none,h.localFontFamily || h.localIdeographFontFamily),
                    this.crossTileSymbolIndex = new hg,
                    this._layers = {},
                    this._num3DLayers = 0,
                    this._numSymbolLayers = 0,
                    this._numCircleLayers = 0,
                    this._serializedLayers = {},
                    this._sourceCaches = {},
                    this._otherSourceCaches = {},
                    this._symbolSourceCaches = {},
                    this._loaded = !1,
                    this._availableImages = [],
                    this._order = [],
                    this._drapedFirstOrder = [],
                    this._markersNeedUpdate = !1,
                    this._resetUpdates(),
                    this.dispatcher.broadcast("setReferrer", i.getReferrer());
                    let _ = this;
                    this._rtlTextPluginCallback = ks.registerForPluginStateChange(b=>{
                        _.dispatcher.broadcast("syncRTLPluginState", {
                            pluginStatus: b.pluginStatus,
                            pluginURL: b.pluginURL
                        }, (T,L)=>{
                            if (i.triggerPluginCompletionEvent(T),
                            L && L.every(R=>R))
                                for (let R in _._sourceCaches) {
                                    let O = _._sourceCaches[R]
                                      , V = O.getSource().type;
                                    V !== "vector" && V !== "geojson" || O.reload()
                                }
                        }
                        )
                    }
                    ),
                    this.on("data", b=>{
                        if (b.dataType !== "source" || b.sourceDataType !== "metadata")
                            return;
                        let T = this.getSource(b.sourceId);
                        if (T && T.vectorLayerIds)
                            for (let L in this._layers) {
                                let R = this._layers[L];
                                R.source === T.id && this._validateLayer(R)
                            }
                    }
                    )
                }
                loadURL(l, h={}) {
                    this.fire(new i.Event("dataloading",{
                        dataType: "style"
                    }));
                    let _ = typeof h.validate == "boolean" ? h.validate : !i.isMapboxURL(l);
                    l = this.map._requestManager.normalizeStyleURL(l, h.accessToken);
                    let b = this.map._requestManager.transformRequest(l, i.ResourceType.Style);
                    this._request = i.getJSON(b, (T,L)=>{
                        this._request = null,
                        T ? this.fire(new i.ErrorEvent(T)) : L && this._load(L, _)
                    }
                    )
                }
                loadJSON(l, h={}) {
                    this.fire(new i.Event("dataloading",{
                        dataType: "style"
                    })),
                    this._request = i.exported.frame(()=>{
                        this._request = null,
                        this._load(l, h.validate !== !1)
                    }
                    )
                }
                loadEmpty() {
                    this.fire(new i.Event("dataloading",{
                        dataType: "style"
                    })),
                    this._load(_h, !1)
                }
                _updateLayerCount(l, h) {
                    let _ = h ? 1 : -1;
                    l.is3D() && (this._num3DLayers += _),
                    l.type === "circle" && (this._numCircleLayers += _),
                    l.type === "symbol" && (this._numSymbolLayers += _)
                }
                _load(l, h) {
                    if (h && zc(this, i.validateStyle(l)))
                        return;
                    this._loaded = !0,
                    this.stylesheet = i.clone$1(l),
                    this._updateMapProjection();
                    for (let b in l.sources)
                        this.addSource(b, l.sources[b], {
                            validate: !1
                        });
                    this._changed = !1,
                    l.sprite ? this._loadSprite(l.sprite) : (this.imageManager.setLoaded(!0),
                    this.dispatcher.broadcast("spriteLoaded", !0)),
                    this.glyphManager.setURL(l.glyphs);
                    let _ = Nn(this.stylesheet.layers);
                    this._order = _.map(b=>b.id),
                    this._layers = {},
                    this._serializedLayers = {};
                    for (let b of _)
                        b = i.createStyleLayer(b),
                        b.setEventedParent(this, {
                            layer: {
                                id: b.id
                            }
                        }),
                        this._layers[b.id] = b,
                        this._serializedLayers[b.id] = b.serialize(),
                        this._updateLayerCount(b, !0);
                    this.dispatcher.broadcast("setLayers", this._serializeLayers(this._order)),
                    this.light = new te(this.stylesheet.light),
                    this.stylesheet.terrain && !this.terrainSetForDrapingOnly() && this._createTerrain(this.stylesheet.terrain, 1),
                    this.stylesheet.fog && this._createFog(this.stylesheet.fog),
                    this._updateDrapeFirstLayers(),
                    this.fire(new i.Event("data",{
                        dataType: "style"
                    })),
                    this.fire(new i.Event("style.load"))
                }
                terrainSetForDrapingOnly() {
                    return !!this.terrain && this.terrain.drapeRenderMode === 0
                }
                setProjection(l) {
                    l ? this.stylesheet.projection = l : delete this.stylesheet.projection,
                    this._updateMapProjection()
                }
                applyProjectionUpdate() {
                    this._loaded && (this.dispatcher.broadcast("setProjection", this.map.transform.projectionOptions),
                    this.map.transform.projection.requiresDraping ? this.getTerrain() || this.stylesheet.terrain || this.setTerrainForDraping() : this.terrainSetForDrapingOnly() && this.setTerrain(null))
                }
                _updateMapProjection() {
                    this.map._useExplicitProjection ? this.applyProjectionUpdate() : this.map._prioritizeAndUpdateProjection(null, this.stylesheet.projection)
                }
                _loadSprite(l) {
                    this._spriteRequest = function(h, _, b) {
                        let T, L, R, O = i.exported.devicePixelRatio > 1 ? "@2x" : "", V = i.getJSON(_.transformRequest(_.normalizeSpriteURL(h, O, ".json"), i.ResourceType.SpriteJSON), (le,me)=>{
                            V = null,
                            R || (R = le,
                            T = me,
                            J())
                        }
                        ), G = i.getImage(_.transformRequest(_.normalizeSpriteURL(h, O, ".png"), i.ResourceType.SpriteImage), (le,me)=>{
                            G = null,
                            R || (R = le,
                            L = me,
                            J())
                        }
                        );
                        function J() {
                            if (R)
                                b(R);
                            else if (T && L) {
                                let le = i.exported.getImageData(L)
                                  , me = {};
                                for (let pe in T) {
                                    let {width: ge, height: ve, x: re, y: Ce, sdf: Ae, pixelRatio: De, stretchX: Ve, stretchY: Fe, content: Xe} = T[pe]
                                      , $e = new i.RGBAImage({
                                        width: ge,
                                        height: ve
                                    });
                                    i.RGBAImage.copy(le, $e, {
                                        x: re,
                                        y: Ce
                                    }, {
                                        x: 0,
                                        y: 0
                                    }, {
                                        width: ge,
                                        height: ve
                                    }),
                                    me[pe] = {
                                        data: $e,
                                        pixelRatio: De,
                                        sdf: Ae,
                                        stretchX: Ve,
                                        stretchY: Fe,
                                        content: Xe
                                    }
                                }
                                b(null, me)
                            }
                        }
                        return {
                            cancel() {
                                V && (V.cancel(),
                                V = null),
                                G && (G.cancel(),
                                G = null)
                            }
                        }
                    }(l, this.map._requestManager, (h,_)=>{
                        if (this._spriteRequest = null,
                        h)
                            this.fire(new i.ErrorEvent(h));
                        else if (_)
                            for (let b in _)
                                this.imageManager.addImage(b, _[b]);
                        this.imageManager.setLoaded(!0),
                        this._availableImages = this.imageManager.listImages(),
                        this.dispatcher.broadcast("setImages", this._availableImages),
                        this.dispatcher.broadcast("spriteLoaded", !0),
                        this.fire(new i.Event("data",{
                            dataType: "style"
                        }))
                    }
                    )
                }
                _validateLayer(l) {
                    let h = this.getSource(l.source);
                    if (!h)
                        return;
                    let _ = l.sourceLayer;
                    _ && (h.type === "geojson" || h.vectorLayerIds && h.vectorLayerIds.indexOf(_) === -1) && this.fire(new i.ErrorEvent(new Error(`Source layer "${_}" does not exist on source "${h.id}" as specified by style layer "${l.id}"`)))
                }
                loaded() {
                    if (!this._loaded || Object.keys(this._updatedSources).length)
                        return !1;
                    for (let l in this._sourceCaches)
                        if (!this._sourceCaches[l].loaded())
                            return !1;
                    return !!this.imageManager.isLoaded()
                }
                _serializeLayers(l) {
                    let h = [];
                    for (let _ of l) {
                        let b = this._layers[_];
                        b.type !== "custom" && h.push(b.serialize())
                    }
                    return h
                }
                hasTransitions() {
                    if (this.light && this.light.hasTransition() || this.fog && this.fog.hasTransition())
                        return !0;
                    for (let l in this._sourceCaches)
                        if (this._sourceCaches[l].hasTransition())
                            return !0;
                    for (let l in this._layers)
                        if (this._layers[l].hasTransition())
                            return !0;
                    return !1
                }
                get order() {
                    return this.map._optimizeForTerrain && this.terrain ? this._drapedFirstOrder : this._order
                }
                isLayerDraped(l) {
                    return !!this.terrain && (typeof l.isLayerDraped == "function" ? l.isLayerDraped() : Ko[l.type])
                }
                _checkLoaded() {
                    if (!this._loaded)
                        throw new Error("Style is not done loading")
                }
                update(l) {
                    if (!this._loaded)
                        return;
                    let h = this._changed;
                    if (this._changed) {
                        let b = Object.keys(this._updatedLayers)
                          , T = Object.keys(this._removedLayers);
                        (b.length || T.length) && this._updateWorkerLayers(b, T);
                        for (let L in this._updatedSources) {
                            let R = this._updatedSources[L];
                            R === "reload" ? this._reloadSource(L) : R === "clear" && this._clearSource(L)
                        }
                        this._updateTilesForChangedImages();
                        for (let L in this._updatedPaintProps)
                            this._layers[L].updateTransitions(l);
                        this.light.updateTransitions(l),
                        this.fog && this.fog.updateTransitions(l),
                        this._resetUpdates()
                    }
                    let _ = {};
                    for (let b in this._sourceCaches) {
                        let T = this._sourceCaches[b];
                        _[b] = T.used,
                        T.used = !1
                    }
                    for (let b of this._order) {
                        let T = this._layers[b];
                        if (T.recalculate(l, this._availableImages),
                        !T.isHidden(l.zoom)) {
                            let R = this._getLayerSourceCache(T);
                            R && (R.used = !0)
                        }
                        let L = this.map.painter;
                        if (L) {
                            let R = T.getProgramIds();
                            if (!R)
                                continue;
                            let O = T.getProgramConfiguration(l.zoom);
                            for (let V of R)
                                L.useProgram(V, O)
                        }
                    }
                    for (let b in _) {
                        let T = this._sourceCaches[b];
                        _[b] !== T.used && T.getSource().fire(new i.Event("data",{
                            sourceDataType: "visibility",
                            dataType: "source",
                            sourceId: T.getSource().id
                        }))
                    }
                    this.light.recalculate(l),
                    this.terrain && this.terrain.recalculate(l),
                    this.fog && this.fog.recalculate(l),
                    this.z = l.zoom,
                    this._markersNeedUpdate && (this._updateMarkersOpacity(),
                    this._markersNeedUpdate = !1),
                    h && this.fire(new i.Event("data",{
                        dataType: "style"
                    }))
                }
                _updateTilesForChangedImages() {
                    let l = Object.keys(this._changedImages);
                    if (l.length) {
                        for (let h in this._sourceCaches)
                            this._sourceCaches[h].reloadTilesForDependencies(["icons", "patterns"], l);
                        this._changedImages = {}
                    }
                }
                _updateWorkerLayers(l, h) {
                    this.dispatcher.broadcast("updateLayers", {
                        layers: this._serializeLayers(l),
                        removedIds: h
                    })
                }
                _resetUpdates() {
                    this._changed = !1,
                    this._updatedLayers = {},
                    this._removedLayers = {},
                    this._updatedSources = {},
                    this._updatedPaintProps = {},
                    this._changedImages = {}
                }
                setState(l) {
                    if (this._checkLoaded(),
                    zc(this, i.validateStyle(l)))
                        return !1;
                    (l = i.clone$1(l)).layers = Nn(l.layers);
                    let h = function(b, T) {
                        if (!b)
                            return [{
                                command: jt.setStyle,
                                args: [T]
                            }];
                        let L = [];
                        try {
                            if (!v(b.version, T.version))
                                return [{
                                    command: jt.setStyle,
                                    args: [T]
                                }];
                            v(b.center, T.center) || L.push({
                                command: jt.setCenter,
                                args: [T.center]
                            }),
                            v(b.zoom, T.zoom) || L.push({
                                command: jt.setZoom,
                                args: [T.zoom]
                            }),
                            v(b.bearing, T.bearing) || L.push({
                                command: jt.setBearing,
                                args: [T.bearing]
                            }),
                            v(b.pitch, T.pitch) || L.push({
                                command: jt.setPitch,
                                args: [T.pitch]
                            }),
                            v(b.sprite, T.sprite) || L.push({
                                command: jt.setSprite,
                                args: [T.sprite]
                            }),
                            v(b.glyphs, T.glyphs) || L.push({
                                command: jt.setGlyphs,
                                args: [T.glyphs]
                            }),
                            v(b.transition, T.transition) || L.push({
                                command: jt.setTransition,
                                args: [T.transition]
                            }),
                            v(b.light, T.light) || L.push({
                                command: jt.setLight,
                                args: [T.light]
                            }),
                            v(b.fog, T.fog) || L.push({
                                command: jt.setFog,
                                args: [T.fog]
                            }),
                            v(b.projection, T.projection) || L.push({
                                command: jt.setProjection,
                                args: [T.projection]
                            });
                            let R = {}
                              , O = [];
                            (function(J, le, me, pe) {
                                let ge;
                                for (ge in le = le || {},
                                J = J || {})
                                    J.hasOwnProperty(ge) && (le.hasOwnProperty(ge) || On(ge, me, pe));
                                for (ge in le)
                                    le.hasOwnProperty(ge) && (J.hasOwnProperty(ge) ? v(J[ge], le[ge]) || (J[ge].type === "geojson" && le[ge].type === "geojson" && pr(J, le, ge) ? me.push({
                                        command: jt.setGeoJSONSourceData,
                                        args: [ge, le[ge].data]
                                    }) : ar(ge, le, me, pe)) : qn(ge, le, me))
                            }
                            )(b.sources, T.sources, O, R);
                            let V = [];
                            b.layers && b.layers.forEach(J=>{
                                J.source && R[J.source] ? L.push({
                                    command: jt.removeLayer,
                                    args: [J.id]
                                }) : V.push(J)
                            }
                            );
                            let G = b.terrain;
                            G && R[G.source] && (L.push({
                                command: jt.setTerrain,
                                args: [void 0]
                            }),
                            G = void 0),
                            L = L.concat(O),
                            v(G, T.terrain) || L.push({
                                command: jt.setTerrain,
                                args: [T.terrain]
                            }),
                            function(J, le, me) {
                                le = le || [];
                                let pe = (J = J || []).map(mr), ge = le.map(mr), ve = J.reduce(jn, {}), re = le.reduce(jn, {}), Ce = pe.slice(), Ae = Object.create(null), De, Ve, Fe, Xe, $e, rt, lt;
                                for (De = 0,
                                Ve = 0; De < pe.length; De++)
                                    Fe = pe[De],
                                    re.hasOwnProperty(Fe) ? Ve++ : (me.push({
                                        command: jt.removeLayer,
                                        args: [Fe]
                                    }),
                                    Ce.splice(Ce.indexOf(Fe, Ve), 1));
                                for (De = 0,
                                Ve = 0; De < ge.length; De++)
                                    Fe = ge[ge.length - 1 - De],
                                    Ce[Ce.length - 1 - De] !== Fe && (ve.hasOwnProperty(Fe) ? (me.push({
                                        command: jt.removeLayer,
                                        args: [Fe]
                                    }),
                                    Ce.splice(Ce.lastIndexOf(Fe, Ce.length - Ve), 1)) : Ve++,
                                    rt = Ce[Ce.length - De],
                                    me.push({
                                        command: jt.addLayer,
                                        args: [re[Fe], rt]
                                    }),
                                    Ce.splice(Ce.length - De, 0, Fe),
                                    Ae[Fe] = !0);
                                for (De = 0; De < ge.length; De++)
                                    if (Fe = ge[De],
                                    Xe = ve[Fe],
                                    $e = re[Fe],
                                    !Ae[Fe] && !v(Xe, $e))
                                        if (v(Xe.source, $e.source) && v(Xe["source-layer"], $e["source-layer"]) && v(Xe.type, $e.type)) {
                                            for (lt in ht(Xe.layout, $e.layout, me, Fe, null, jt.setLayoutProperty),
                                            ht(Xe.paint, $e.paint, me, Fe, null, jt.setPaintProperty),
                                            v(Xe.filter, $e.filter) || me.push({
                                                command: jt.setFilter,
                                                args: [Fe, $e.filter]
                                            }),
                                            v(Xe.minzoom, $e.minzoom) && v(Xe.maxzoom, $e.maxzoom) || me.push({
                                                command: jt.setLayerZoomRange,
                                                args: [Fe, $e.minzoom, $e.maxzoom]
                                            }),
                                            Xe)
                                                Xe.hasOwnProperty(lt) && lt !== "layout" && lt !== "paint" && lt !== "filter" && lt !== "metadata" && lt !== "minzoom" && lt !== "maxzoom" && (lt.indexOf("paint.") === 0 ? ht(Xe[lt], $e[lt], me, Fe, lt.slice(6), jt.setPaintProperty) : v(Xe[lt], $e[lt]) || me.push({
                                                    command: jt.setLayerProperty,
                                                    args: [Fe, lt, $e[lt]]
                                                }));
                                            for (lt in $e)
                                                $e.hasOwnProperty(lt) && !Xe.hasOwnProperty(lt) && lt !== "layout" && lt !== "paint" && lt !== "filter" && lt !== "metadata" && lt !== "minzoom" && lt !== "maxzoom" && (lt.indexOf("paint.") === 0 ? ht(Xe[lt], $e[lt], me, Fe, lt.slice(6), jt.setPaintProperty) : v(Xe[lt], $e[lt]) || me.push({
                                                    command: jt.setLayerProperty,
                                                    args: [Fe, lt, $e[lt]]
                                                }))
                                        } else
                                            me.push({
                                                command: jt.removeLayer,
                                                args: [Fe]
                                            }),
                                            rt = Ce[Ce.lastIndexOf(Fe) + 1],
                                            me.push({
                                                command: jt.addLayer,
                                                args: [$e, rt]
                                            })
                            }(V, T.layers, L)
                        } catch (R) {
                            console.warn("Unable to compute style diff:", R),
                            L = [{
                                command: jt.setStyle,
                                args: [T]
                            }]
                        }
                        return L
                    }(this.serialize(), l).filter(b=>!(b.command in qo));
                    if (h.length === 0)
                        return !1;
                    let _ = h.filter(b=>!(b.command in xl));
                    if (_.length > 0)
                        throw new Error(`Unimplemented: ${_.map(b=>b.command).join(", ")}.`);
                    return h.forEach(b=>{
                        b.command !== "setTransition" && b.command !== "setProjection" && this[b.command].apply(this, b.args)
                    }
                    ),
                    this.stylesheet = l,
                    this._updateMapProjection(),
                    !0
                }
                addImage(l, h) {
                    return this.getImage(l) ? this.fire(new i.ErrorEvent(new Error("An image with this name already exists."))) : (this.imageManager.addImage(l, h),
                    this._afterImageUpdated(l),
                    this)
                }
                updateImage(l, h) {
                    this.imageManager.updateImage(l, h)
                }
                getImage(l) {
                    return this.imageManager.getImage(l)
                }
                removeImage(l) {
                    return this.getImage(l) ? (this.imageManager.removeImage(l),
                    this._afterImageUpdated(l),
                    this) : this.fire(new i.ErrorEvent(new Error("No image with this name exists.")))
                }
                _afterImageUpdated(l) {
                    this._availableImages = this.imageManager.listImages(),
                    this._changedImages[l] = !0,
                    this._changed = !0,
                    this.dispatcher.broadcast("setImages", this._availableImages),
                    this.fire(new i.Event("data",{
                        dataType: "style"
                    }))
                }
                listImages() {
                    return this._checkLoaded(),
                    this._availableImages.slice()
                }
                addSource(l, h, _={}) {
                    if (this._checkLoaded(),
                    this.getSource(l) !== void 0)
                        throw new Error("There is already a source with this ID");
                    if (!h.type)
                        throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(h).join(", ")}.`);
                    if (["vector", "raster", "geojson", "video", "image"].indexOf(h.type) >= 0 && this._validate(i.validateSource, `sources.${l}`, h, null, _))
                        return;
                    this.map && this.map._collectResourceTiming && (h.collectResourceTiming = !0);
                    let b = He(l, h, this.dispatcher, this);
                    b.setEventedParent(this, ()=>({
                        isSourceLoaded: this._isSourceCacheLoaded(l),
                        source: b.serialize(),
                        sourceId: l
                    }));
                    let T = L=>{
                        let R = (L ? "symbol:" : "other:") + l
                          , O = this._sourceCaches[R] = new i.SourceCache(R,b,L);
                        (L ? this._symbolSourceCaches : this._otherSourceCaches)[l] = O,
                        O.style = this,
                        O.onAdd(this.map)
                    }
                    ;
                    T(!1),
                    h.type !== "vector" && h.type !== "geojson" || T(!0),
                    b.onAdd && b.onAdd(this.map),
                    this._changed = !0
                }
                removeSource(l) {
                    this._checkLoaded();
                    let h = this.getSource(l);
                    if (!h)
                        throw new Error("There is no source with this ID");
                    for (let b in this._layers)
                        if (this._layers[b].source === l)
                            return this.fire(new i.ErrorEvent(new Error(`Source "${l}" cannot be removed while layer "${b}" is using it.`)));
                    if (this.terrain && this.terrain.get().source === l)
                        return this.fire(new i.ErrorEvent(new Error(`Source "${l}" cannot be removed while terrain is using it.`)));
                    let _ = this._getSourceCaches(l);
                    for (let b of _)
                        delete this._sourceCaches[b.id],
                        delete this._updatedSources[b.id],
                        b.fire(new i.Event("data",{
                            sourceDataType: "metadata",
                            dataType: "source",
                            sourceId: b.getSource().id
                        })),
                        b.setEventedParent(null),
                        b.clearTiles();
                    return delete this._otherSourceCaches[l],
                    delete this._symbolSourceCaches[l],
                    h.setEventedParent(null),
                    h.onRemove && h.onRemove(this.map),
                    this._changed = !0,
                    this
                }
                setGeoJSONSourceData(l, h) {
                    this._checkLoaded(),
                    this.getSource(l).setData(h),
                    this._changed = !0
                }
                getSource(l) {
                    let h = this._getSourceCache(l);
                    return h && h.getSource()
                }
                _getSources() {
                    let l = [];
                    for (let h in this._otherSourceCaches) {
                        let _ = this._getSourceCache(h);
                        _ && l.push(_.getSource())
                    }
                    return l
                }
                addLayer(l, h, _={}) {
                    this._checkLoaded();
                    let b = l.id;
                    if (this.getLayer(b))
                        return void this.fire(new i.ErrorEvent(new Error(`Layer with id "${b}" already exists on this map`)));
                    let T;
                    if (l.type === "custom") {
                        if (zc(this, i.validateCustomStyleLayer(l)))
                            return;
                        T = i.createStyleLayer(l)
                    } else {
                        if (typeof l.source == "object" && (this.addSource(b, l.source),
                        l = i.clone$1(l),
                        l = i.extend(l, {
                            source: b
                        })),
                        this._validate(i.validateLayer, `layers.${b}`, l, {
                            arrayIndex: -1
                        }, _))
                            return;
                        T = i.createStyleLayer(l),
                        this._validateLayer(T),
                        T.setEventedParent(this, {
                            layer: {
                                id: b
                            }
                        }),
                        this._serializedLayers[T.id] = T.serialize(),
                        this._updateLayerCount(T, !0)
                    }
                    let L = h ? this._order.indexOf(h) : this._order.length;
                    if (h && L === -1)
                        return void this.fire(new i.ErrorEvent(new Error(`Layer with id "${h}" does not exist on this map.`)));
                    this._order.splice(L, 0, b),
                    this._layerOrderChanged = !0,
                    this._layers[b] = T;
                    let R = this._getLayerSourceCache(T);
                    if (this._removedLayers[b] && T.source && R && T.type !== "custom") {
                        let O = this._removedLayers[b];
                        delete this._removedLayers[b],
                        O.type !== T.type ? this._updatedSources[T.source] = "clear" : (this._updatedSources[T.source] = "reload",
                        R.pause())
                    }
                    this._updateLayer(T),
                    T.onAdd && T.onAdd(this.map),
                    this._updateDrapeFirstLayers()
                }
                moveLayer(l, h) {
                    if (this._checkLoaded(),
                    this._changed = !0,
                    !this._layers[l])
                        return void this.fire(new i.ErrorEvent(new Error(`The layer '${l}' does not exist in the map's style and cannot be moved.`)));
                    if (l === h)
                        return;
                    let _ = this._order.indexOf(l);
                    this._order.splice(_, 1);
                    let b = h ? this._order.indexOf(h) : this._order.length;
                    h && b === -1 ? this.fire(new i.ErrorEvent(new Error(`Layer with id "${h}" does not exist on this map.`))) : (this._order.splice(b, 0, l),
                    this._layerOrderChanged = !0,
                    this._updateDrapeFirstLayers())
                }
                removeLayer(l) {
                    this._checkLoaded();
                    let h = this._layers[l];
                    if (!h)
                        return void this.fire(new i.ErrorEvent(new Error(`The layer '${l}' does not exist in the map's style and cannot be removed.`)));
                    h.setEventedParent(null),
                    this._updateLayerCount(h, !1);
                    let _ = this._order.indexOf(l);
                    this._order.splice(_, 1),
                    this._layerOrderChanged = !0,
                    this._changed = !0,
                    this._removedLayers[l] = h,
                    delete this._layers[l],
                    delete this._serializedLayers[l],
                    delete this._updatedLayers[l],
                    delete this._updatedPaintProps[l],
                    h.onRemove && h.onRemove(this.map),
                    this._updateDrapeFirstLayers()
                }
                getLayer(l) {
                    return this._layers[l]
                }
                hasLayer(l) {
                    return l in this._layers
                }
                hasLayerType(l) {
                    for (let h in this._layers)
                        if (this._layers[h].type === l)
                            return !0;
                    return !1
                }
                setLayerZoomRange(l, h, _) {
                    this._checkLoaded();
                    let b = this.getLayer(l);
                    b ? b.minzoom === h && b.maxzoom === _ || (h != null && (b.minzoom = h),
                    _ != null && (b.maxzoom = _),
                    this._updateLayer(b)) : this.fire(new i.ErrorEvent(new Error(`The layer '${l}' does not exist in the map's style and cannot have zoom extent.`)))
                }
                setFilter(l, h, _={}) {
                    this._checkLoaded();
                    let b = this.getLayer(l);
                    if (b) {
                        if (!v(b.filter, h))
                            return h == null ? (b.filter = void 0,
                            void this._updateLayer(b)) : void (this._validate(i.validateFilter, `layers.${b.id}.filter`, h, {
                                layerType: b.type
                            }, _) || (b.filter = i.clone$1(h),
                            this._updateLayer(b)))
                    } else
                        this.fire(new i.ErrorEvent(new Error(`The layer '${l}' does not exist in the map's style and cannot be filtered.`)))
                }
                getFilter(l) {
                    let h = this.getLayer(l);
                    return h && i.clone$1(h.filter)
                }
                setLayoutProperty(l, h, _, b={}) {
                    this._checkLoaded();
                    let T = this.getLayer(l);
                    T ? v(T.getLayoutProperty(h), _) || (T.setLayoutProperty(h, _, b),
                    this._updateLayer(T)) : this.fire(new i.ErrorEvent(new Error(`The layer '${l}' does not exist in the map's style and cannot be styled.`)))
                }
                getLayoutProperty(l, h) {
                    let _ = this.getLayer(l);
                    if (_)
                        return _.getLayoutProperty(h);
                    this.fire(new i.ErrorEvent(new Error(`The layer '${l}' does not exist in the map's style.`)))
                }
                setPaintProperty(l, h, _, b={}) {
                    this._checkLoaded();
                    let T = this.getLayer(l);
                    T ? v(T.getPaintProperty(h), _) || (T.setPaintProperty(h, _, b) && this._updateLayer(T),
                    this._changed = !0,
                    this._updatedPaintProps[l] = !0) : this.fire(new i.ErrorEvent(new Error(`The layer '${l}' does not exist in the map's style and cannot be styled.`)))
                }
                getPaintProperty(l, h) {
                    let _ = this.getLayer(l);
                    return _ && _.getPaintProperty(h)
                }
                setFeatureState(l, h) {
                    this._checkLoaded();
                    let _ = l.source
                      , b = l.sourceLayer
                      , T = this.getSource(_);
                    if (!T)
                        return void this.fire(new i.ErrorEvent(new Error(`The source '${_}' does not exist in the map's style.`)));
                    let L = T.type;
                    if (L === "geojson" && b)
                        return void this.fire(new i.ErrorEvent(new Error("GeoJSON sources cannot have a sourceLayer parameter.")));
                    if (L === "vector" && !b)
                        return void this.fire(new i.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
                    l.id === void 0 && this.fire(new i.ErrorEvent(new Error("The feature id parameter must be provided.")));
                    let R = this._getSourceCaches(_);
                    for (let O of R)
                        O.setFeatureState(b, l.id, h)
                }
                removeFeatureState(l, h) {
                    this._checkLoaded();
                    let _ = l.source
                      , b = this.getSource(_);
                    if (!b)
                        return void this.fire(new i.ErrorEvent(new Error(`The source '${_}' does not exist in the map's style.`)));
                    let T = b.type
                      , L = T === "vector" ? l.sourceLayer : void 0;
                    if (T === "vector" && !L)
                        return void this.fire(new i.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
                    if (h && typeof l.id != "string" && typeof l.id != "number")
                        return void this.fire(new i.ErrorEvent(new Error("A feature id is required to remove its specific state property.")));
                    let R = this._getSourceCaches(_);
                    for (let O of R)
                        O.removeFeatureState(L, l.id, h)
                }
                getFeatureState(l) {
                    this._checkLoaded();
                    let h = l.source
                      , _ = l.sourceLayer
                      , b = this.getSource(h);
                    if (b) {
                        if (b.type !== "vector" || _)
                            return l.id === void 0 && this.fire(new i.ErrorEvent(new Error("The feature id parameter must be provided."))),
                            this._getSourceCaches(h)[0].getFeatureState(_, l.id);
                        this.fire(new i.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")))
                    } else
                        this.fire(new i.ErrorEvent(new Error(`The source '${h}' does not exist in the map's style.`)))
                }
                getTransition() {
                    return i.extend({
                        duration: 300,
                        delay: 0
                    }, this.stylesheet && this.stylesheet.transition)
                }
                serialize() {
                    let l = {};
                    for (let h in this._sourceCaches) {
                        let _ = this._sourceCaches[h].getSource();
                        l[_.id] || (l[_.id] = _.serialize())
                    }
                    return i.filterObject({
                        version: this.stylesheet.version,
                        name: this.stylesheet.name,
                        metadata: this.stylesheet.metadata,
                        light: this.stylesheet.light,
                        terrain: this.getTerrain() || void 0,
                        fog: this.stylesheet.fog,
                        center: this.stylesheet.center,
                        zoom: this.stylesheet.zoom,
                        bearing: this.stylesheet.bearing,
                        pitch: this.stylesheet.pitch,
                        sprite: this.stylesheet.sprite,
                        glyphs: this.stylesheet.glyphs,
                        transition: this.stylesheet.transition,
                        projection: this.stylesheet.projection,
                        sources: l,
                        layers: this._serializeLayers(this._order)
                    }, h=>h !== void 0)
                }
                _updateLayer(l) {
                    this._updatedLayers[l.id] = !0;
                    let h = this._getLayerSourceCache(l);
                    l.source && !this._updatedSources[l.source] && h && h.getSource().type !== "raster" && (this._updatedSources[l.source] = "reload",
                    h.pause()),
                    this._changed = !0,
                    l.invalidateCompiledFilter()
                }
                _flattenAndSortRenderedFeatures(l) {
                    let h = L=>this._layers[L].type === "fill-extrusion"
                      , _ = {}
                      , b = [];
                    for (let L = this._order.length - 1; L >= 0; L--) {
                        let R = this._order[L];
                        if (h(R)) {
                            _[R] = L;
                            for (let O of l) {
                                let V = O[R];
                                if (V)
                                    for (let G of V)
                                        b.push(G)
                            }
                        }
                    }
                    b.sort((L,R)=>R.intersectionZ - L.intersectionZ);
                    let T = [];
                    for (let L = this._order.length - 1; L >= 0; L--) {
                        let R = this._order[L];
                        if (h(R))
                            for (let O = b.length - 1; O >= 0; O--) {
                                let V = b[O].feature;
                                if (_[V.layer.id] < L)
                                    break;
                                T.push(V),
                                b.pop()
                            }
                        else
                            for (let O of l) {
                                let V = O[R];
                                if (V)
                                    for (let G of V)
                                        T.push(G.feature)
                            }
                    }
                    return T
                }
                queryRenderedFeatures(l, h, _) {
                    h && h.filter && this._validate(i.validateFilter, "queryRenderedFeatures.filter", h.filter, null, h);
                    let b = {};
                    if (h && h.layers) {
                        if (!Array.isArray(h.layers))
                            return this.fire(new i.ErrorEvent(new Error("parameters.layers must be an Array."))),
                            [];
                        for (let O of h.layers) {
                            let V = this._layers[O];
                            if (!V)
                                return this.fire(new i.ErrorEvent(new Error(`The layer '${O}' does not exist in the map's style and cannot be queried for features.`))),
                                [];
                            b[V.source] = !0
                        }
                    }
                    let T = [];
                    h.availableImages = this._availableImages;
                    let L = h && h.layers ? h.layers.some(O=>{
                        let V = this.getLayer(O);
                        return V && V.is3D()
                    }
                    ) : this.has3DLayers()
                      , R = gn.createFromScreenPoints(l, _);
                    for (let O in this._sourceCaches) {
                        let V = this._sourceCaches[O].getSource().id;
                        h.layers && !b[V] || T.push(Ze(this._sourceCaches[O], this._layers, this._serializedLayers, R, h, _, L, !!this.map._showQueryGeometry))
                    }
                    return this.placement && T.push(function(O, V, G, J, le, me, pe) {
                        let ge = {}
                          , ve = me.queryRenderedSymbols(J)
                          , re = [];
                        for (let Ce of Object.keys(ve).map(Number))
                            re.push(pe[Ce]);
                        re.sort(et);
                        for (let Ce of re) {
                            let Ae = Ce.featureIndex.lookupSymbolFeatures(ve[Ce.bucketInstanceId], V, Ce.bucketIndex, Ce.sourceLayerIndex, le.filter, le.layers, le.availableImages, O);
                            for (let De in Ae) {
                                let Ve = ge[De] = ge[De] || []
                                  , Fe = Ae[De];
                                Fe.sort((Xe,$e)=>{
                                    let rt = Ce.featureSortOrder;
                                    if (rt) {
                                        let lt = rt.indexOf(Xe.featureIndex);
                                        return rt.indexOf($e.featureIndex) - lt
                                    }
                                    return $e.featureIndex - Xe.featureIndex
                                }
                                );
                                for (let Xe of Fe)
                                    Ve.push(Xe)
                            }
                        }
                        for (let Ce in ge)
                            ge[Ce].forEach(Ae=>{
                                let De = Ae.feature
                                  , Ve = G(O[Ce]).getFeatureState(De.layer["source-layer"], De.id);
                                De.source = De.layer.source,
                                De.layer["source-layer"] && (De.sourceLayer = De.layer["source-layer"]),
                                De.state = Ve
                            }
                            );
                        return ge
                    }(this._layers, this._serializedLayers, this._getLayerSourceCache.bind(this), R.screenGeometry, h, this.placement.collisionIndex, this.placement.retainedQueryData)),
                    this._flattenAndSortRenderedFeatures(T)
                }
                querySourceFeatures(l, h) {
                    h && h.filter && this._validate(i.validateFilter, "querySourceFeatures.filter", h.filter, null, h);
                    let _ = this._getSourceCaches(l)
                      , b = [];
                    for (let T of _)
                        b = b.concat(ye(T, h));
                    return b
                }
                addSourceType(l, h, _) {
                    return ks.getSourceType(l) ? _(new Error(`A source type called "${l}" already exists.`)) : (ks.setSourceType(l, h),
                    h.workerSourceURL ? void this.dispatcher.broadcast("loadWorkerSource", {
                        name: l,
                        url: h.workerSourceURL
                    }, _) : _(null, null))
                }
                getLight() {
                    return this.light.getLight()
                }
                setLight(l, h={}) {
                    this._checkLoaded();
                    let _ = this.light.getLight()
                      , b = !1;
                    for (let L in l)
                        if (!v(l[L], _[L])) {
                            b = !0;
                            break
                        }
                    if (!b)
                        return;
                    let T = this._setTransitionParameters({
                        duration: 300,
                        delay: 0
                    });
                    this.light.setLight(l, h),
                    this.light.updateTransitions(T)
                }
                getTerrain() {
                    return this.terrain && this.terrain.drapeRenderMode === 1 ? this.terrain.get() : null
                }
                setTerrainForDraping() {
                    this.setTerrain({
                        source: "",
                        exaggeration: 0
                    }, 0)
                }
                setTerrain(l, h=1) {
                    if (this._checkLoaded(),
                    !l)
                        return delete this.terrain,
                        delete this.stylesheet.terrain,
                        this.dispatcher.broadcast("enableTerrain", !1),
                        this._force3DLayerUpdate(),
                        void (this._markersNeedUpdate = !0);
                    if (h === 1) {
                        if (typeof l.source == "object") {
                            let _ = "terrain-dem-src";
                            this.addSource(_, l.source),
                            l = i.clone$1(l),
                            l = i.extend(l, {
                                source: _
                            })
                        }
                        if (this._validate(i.validateTerrain, "terrain", l))
                            return
                    }
                    if (!this.terrain || this.terrain && h !== this.terrain.drapeRenderMode)
                        this._createTerrain(l, h);
                    else {
                        let _ = this.terrain
                          , b = _.get();
                        for (let T of Object.keys(i.spec.terrain))
                            !l.hasOwnProperty(T) && i.spec.terrain[T].default && (l[T] = i.spec.terrain[T].default);
                        for (let T in l)
                            if (!v(l[T], b[T])) {
                                _.set(l),
                                this.stylesheet.terrain = l;
                                let L = this._setTransitionParameters({
                                    duration: 0
                                });
                                _.updateTransitions(L);
                                break
                            }
                    }
                    this._updateDrapeFirstLayers(),
                    this._markersNeedUpdate = !0
                }
                _createFog(l) {
                    let h = this.fog = new Et(l,this.map.transform);
                    this.stylesheet.fog = l;
                    let _ = this._setTransitionParameters({
                        duration: 0
                    });
                    h.updateTransitions(_)
                }
                _updateMarkersOpacity() {
                    this.map._markers.length !== 0 && this.map._requestDomTask(()=>{
                        for (let l of this.map._markers)
                            l._evaluateOpacity()
                    }
                    )
                }
                getFog() {
                    return this.fog ? this.fog.get() : null
                }
                setFog(l) {
                    if (this._checkLoaded(),
                    !l)
                        return delete this.fog,
                        delete this.stylesheet.fog,
                        void (this._markersNeedUpdate = !0);
                    if (this.fog) {
                        let h = this.fog
                          , _ = h.get();
                        Object.keys(l).length === 0 && h.set(l);
                        for (let b in l)
                            if (!v(l[b], _[b])) {
                                h.set(l),
                                this.stylesheet.fog = l;
                                let T = this._setTransitionParameters({
                                    duration: 0
                                });
                                h.updateTransitions(T);
                                break
                            }
                    } else
                        this._createFog(l);
                    this._markersNeedUpdate = !0
                }
                _setTransitionParameters(l) {
                    return {
                        now: i.exported.now(),
                        transition: i.extend(l, this.stylesheet.transition)
                    }
                }
                _updateDrapeFirstLayers() {
                    if (!this.map._optimizeForTerrain || !this.terrain)
                        return;
                    let l = this._order.filter(_=>this.isLayerDraped(this._layers[_]))
                      , h = this._order.filter(_=>!this.isLayerDraped(this._layers[_]));
                    this._drapedFirstOrder = [],
                    this._drapedFirstOrder.push(...l),
                    this._drapedFirstOrder.push(...h)
                }
                _createTerrain(l, h) {
                    let _ = this.terrain = new ke(l,h);
                    this.stylesheet.terrain = l,
                    this.dispatcher.broadcast("enableTerrain", !this.terrainSetForDrapingOnly()),
                    this._force3DLayerUpdate();
                    let b = this._setTransitionParameters({
                        duration: 0
                    });
                    _.updateTransitions(b)
                }
                _force3DLayerUpdate() {
                    for (let l in this._layers) {
                        let h = this._layers[l];
                        h.type === "fill-extrusion" && this._updateLayer(h)
                    }
                }
                _forceSymbolLayerUpdate() {
                    for (let l in this._layers) {
                        let h = this._layers[l];
                        h.type === "symbol" && this._updateLayer(h)
                    }
                }
                _validate(l, h, _, b, T={}) {
                    return (!T || T.validate !== !1) && zc(this, l.call(i.validateStyle, i.extend({
                        key: h,
                        style: this.serialize(),
                        value: _,
                        styleSpec: i.spec
                    }, b)))
                }
                _remove() {
                    this._request && (this._request.cancel(),
                    this._request = null),
                    this._spriteRequest && (this._spriteRequest.cancel(),
                    this._spriteRequest = null),
                    i.evented.off("pluginStateChange", this._rtlTextPluginCallback);
                    for (let l in this._layers)
                        this._layers[l].setEventedParent(null);
                    for (let l in this._sourceCaches)
                        this._sourceCaches[l].clearTiles(),
                        this._sourceCaches[l].setEventedParent(null);
                    this.imageManager.setEventedParent(null),
                    this.setEventedParent(null),
                    this.dispatcher.remove()
                }
                _clearSource(l) {
                    let h = this._getSourceCaches(l);
                    for (let _ of h)
                        _.clearTiles()
                }
                _reloadSource(l) {
                    let h = this._getSourceCaches(l);
                    for (let _ of h)
                        _.resume(),
                        _.reload()
                }
                _reloadSources() {
                    for (let l of this._getSources())
                        l.reload && l.reload()
                }
                _updateSources(l) {
                    for (let h in this._sourceCaches)
                        this._sourceCaches[h].update(l)
                }
                _generateCollisionBoxes() {
                    for (let l in this._sourceCaches) {
                        let h = this._sourceCaches[l];
                        h.resume(),
                        h.reload()
                    }
                }
                _updatePlacement(l, h, _, b, T=!1) {
                    let L = !1
                      , R = !1
                      , O = {};
                    for (let V of this._order) {
                        let G = this._layers[V];
                        if (G.type !== "symbol")
                            continue;
                        if (!O[G.source]) {
                            let le = this._getLayerSourceCache(G);
                            if (!le)
                                continue;
                            O[G.source] = le.getRenderableIds(!0).map(me=>le.getTileByID(me)).sort((me,pe)=>pe.tileID.overscaledZ - me.tileID.overscaledZ || (me.tileID.isLessThan(pe.tileID) ? -1 : 1))
                        }
                        let J = this.crossTileSymbolIndex.addLayer(G, O[G.source], l.center.lng, l.projection);
                        L = L || J
                    }
                    if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order),
                    T = T || this._layerOrderChanged || _ === 0,
                    this._layerOrderChanged && this.fire(new i.Event("neworder")),
                    (T || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(i.exported.now(), l.zoom)) && (this.pauseablePlacement = new kc(l,this._order,T,h,_,b,this.placement,this.fog && l.projection.supportsFog ? this.fog.state : null),
                    this._layerOrderChanged = !1),
                    this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, O),
                    this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(i.exported.now()),
                    R = !0),
                    L && this.pauseablePlacement.placement.setStale()),
                    R || L)
                        for (let V of this._order) {
                            let G = this._layers[V];
                            G.type === "symbol" && this.placement.updateLayerOpacities(G, O[G.source])
                        }
                    return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(i.exported.now())
                }
                _releaseSymbolFadeTiles() {
                    for (let l in this._sourceCaches)
                        this._sourceCaches[l].releaseSymbolFadeTiles()
                }
                getImages(l, h, _) {
                    this.imageManager.getImages(h.icons, _),
                    this._updateTilesForChangedImages();
                    let b = T=>{
                        T && T.setDependencies(h.tileID.key, h.type, h.icons)
                    }
                    ;
                    b(this._otherSourceCaches[h.source]),
                    b(this._symbolSourceCaches[h.source])
                }
                getGlyphs(l, h, _) {
                    this.glyphManager.getGlyphs(h.stacks, _)
                }
                getResource(l, h, _) {
                    return i.makeRequest(h, _)
                }
                _getSourceCache(l) {
                    return this._otherSourceCaches[l]
                }
                _getLayerSourceCache(l) {
                    return l.type === "symbol" ? this._symbolSourceCaches[l.source] : this._otherSourceCaches[l.source]
                }
                _getSourceCaches(l) {
                    let h = [];
                    return this._otherSourceCaches[l] && h.push(this._otherSourceCaches[l]),
                    this._symbolSourceCaches[l] && h.push(this._symbolSourceCaches[l]),
                    h
                }
                _isSourceCacheLoaded(l) {
                    let h = this._getSourceCaches(l);
                    return h.length === 0 ? (this.fire(new i.ErrorEvent(new Error(`There is no source with ID '${l}'`))),
                    !1) : h.every(_=>_.loaded())
                }
                has3DLayers() {
                    return this._num3DLayers > 0
                }
                hasSymbolLayers() {
                    return this._numSymbolLayers > 0
                }
                hasCircleLayers() {
                    return this._numCircleLayers > 0
                }
                _clearWorkerCaches() {
                    this.dispatcher.broadcast("clearCaches")
                }
                destroy() {
                    this._clearWorkerCaches(),
                    this.terrainSetForDrapingOnly() && (delete this.terrain,
                    delete this.stylesheet.terrain)
                }
            }
            ks.getSourceType = function(m) {
                return Ee[m]
            }
            ,
            ks.setSourceType = function(m, l) {
                Ee[m] = l
            }
            ,
            ks.registerForPluginStateChange = i.registerForPluginStateChange;
            var Oc = `
#define EPSILON 0.0000001
#define PI 3.141592653589793
#define EXTENT 8192.0
#define HALF_PI PI/2.0
#define QUARTER_PI PI/4.0
#define RAD_TO_DEG 180.0/PI
#define DEG_TO_RAD PI/180.0
#define GLOBE_RADIUS EXTENT/PI/2.0`
              , dg = "attribute highp vec3 a_pos_3f;uniform lowp mat4 u_matrix;varying highp vec3 v_uv;void main() {const mat3 half_neg_pi_around_x=mat3(1.0,0.0, 0.0,0.0,0.0,-1.0,0.0,1.0, 0.0);v_uv=half_neg_pi_around_x*a_pos_3f;vec4 pos=u_matrix*vec4(a_pos_3f,1.0);gl_Position=pos.xyww;}"
              , fg = `
#define ELEVATION_SCALE 7.0
#define ELEVATION_OFFSET 450.0
#ifdef PROJECTION_GLOBE_VIEW
uniform vec3 u_tile_tl_up;uniform vec3 u_tile_tr_up;uniform vec3 u_tile_br_up;uniform vec3 u_tile_bl_up;uniform float u_tile_up_scale;vec3 elevationVector(vec2 pos) {vec2 uv=pos/EXTENT;vec3 up=normalize(mix(
mix(u_tile_tl_up,u_tile_tr_up,uv.xxx),mix(u_tile_bl_up,u_tile_br_up,uv.xxx),uv.yyy));return up*u_tile_up_scale;}
#else
vec3 elevationVector(vec2 pos) { return vec3(0,0,1); }
#endif
const float skirtOffset=24575.0;vec3 decomposeToPosAndSkirt(vec2 posWithComposedSkirt)
{float skirt=float(posWithComposedSkirt.x >=skirtOffset);vec2 pos=posWithComposedSkirt-vec2(skirt*skirtOffset,0.0);return vec3(pos,skirt);}
#ifdef TERRAIN
#ifdef TERRAIN_DEM_FLOAT_FORMAT
uniform highp sampler2D u_dem;uniform highp sampler2D u_dem_prev;
#else
uniform sampler2D u_dem;uniform sampler2D u_dem_prev;
#endif
uniform vec4 u_dem_unpack;uniform vec2 u_dem_tl;uniform vec2 u_dem_tl_prev;uniform float u_dem_scale;uniform float u_dem_scale_prev;uniform float u_dem_size;uniform float u_dem_lerp;uniform float u_exaggeration;uniform float u_meter_to_dem;uniform mat4 u_label_plane_matrix_inv;uniform sampler2D u_depth;uniform vec2 u_depth_size_inv;vec4 tileUvToDemSample(vec2 uv,float dem_size,float dem_scale,vec2 dem_tl) {vec2 pos=dem_size*(uv*dem_scale+dem_tl)+1.0;vec2 f=fract(pos);return vec4((pos-f+0.5)/(dem_size+2.0),f);}float decodeElevation(vec4 v) {return dot(vec4(v.xyz*255.0,-1.0),u_dem_unpack);}float currentElevation(vec2 apos) {
#ifdef TERRAIN_DEM_FLOAT_FORMAT
vec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale+u_dem_tl)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture2D(u_dem,pos).a;
#else
float dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale,u_dem_tl);vec2 pos=r.xy;vec2 f=r.zw;float tl=decodeElevation(texture2D(u_dem,pos));
#ifdef TERRAIN_DEM_NEAREST_FILTER
return u_exaggeration*tl;
#endif
float tr=decodeElevation(texture2D(u_dem,pos+vec2(dd,0.0)));float bl=decodeElevation(texture2D(u_dem,pos+vec2(0.0,dd)));float br=decodeElevation(texture2D(u_dem,pos+vec2(dd,dd)));return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);
#endif
}float prevElevation(vec2 apos) {
#ifdef TERRAIN_DEM_FLOAT_FORMAT
vec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale_prev+u_dem_tl_prev)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture2D(u_dem_prev,pos).a;
#else
float dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale_prev,u_dem_tl_prev);vec2 pos=r.xy;vec2 f=r.zw;float tl=decodeElevation(texture2D(u_dem_prev,pos));float tr=decodeElevation(texture2D(u_dem_prev,pos+vec2(dd,0.0)));float bl=decodeElevation(texture2D(u_dem_prev,pos+vec2(0.0,dd)));float br=decodeElevation(texture2D(u_dem_prev,pos+vec2(dd,dd)));return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);
#endif
}
#ifdef TERRAIN_VERTEX_MORPHING
float elevation(vec2 apos) {
#ifdef ZERO_EXAGGERATION
return 0.0;
#endif
float nextElevation=currentElevation(apos);float prevElevation=prevElevation(apos);return mix(prevElevation,nextElevation,u_dem_lerp);}
#else
float elevation(vec2 apos) {
#ifdef ZERO_EXAGGERATION
return 0.0;
#endif
return currentElevation(apos);}
#endif
highp float unpack_depth(highp vec4 rgba_depth)
{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}bool isOccluded(vec4 frag) {vec3 coord=frag.xyz/frag.w;float depth=unpack_depth(texture2D(u_depth,(coord.xy+1.0)*0.5));return coord.z > depth+0.0005;}float occlusionFade(vec4 frag) {vec3 coord=frag.xyz/frag.w;vec3 df=vec3(5.0*u_depth_size_inv,0.0);vec2 uv=0.5*coord.xy+0.5;vec4 depth=vec4(
unpack_depth(texture2D(u_depth,uv-df.xz)),unpack_depth(texture2D(u_depth,uv+df.xz)),unpack_depth(texture2D(u_depth,uv-df.zy)),unpack_depth(texture2D(u_depth,uv+df.zy))
);return dot(vec4(0.25),vec4(1.0)-clamp(300.0*(vec4(coord.z-0.001)-depth),0.0,1.0));}vec4 fourSample(vec2 pos,vec2 off) {
#ifdef TERRAIN_DEM_FLOAT_FORMAT
float tl=texture2D(u_dem,pos).a;float tr=texture2D(u_dem,pos+vec2(off.x,0.0)).a;float bl=texture2D(u_dem,pos+vec2(0.0,off.y)).a;float br=texture2D(u_dem,pos+off).a;
#else
vec4 demtl=vec4(texture2D(u_dem,pos).xyz*255.0,-1.0);float tl=dot(demtl,u_dem_unpack);vec4 demtr=vec4(texture2D(u_dem,pos+vec2(off.x,0.0)).xyz*255.0,-1.0);float tr=dot(demtr,u_dem_unpack);vec4 dembl=vec4(texture2D(u_dem,pos+vec2(0.0,off.y)).xyz*255.0,-1.0);float bl=dot(dembl,u_dem_unpack);vec4 dembr=vec4(texture2D(u_dem,pos+off).xyz*255.0,-1.0);float br=dot(dembr,u_dem_unpack);
#endif
return vec4(tl,tr,bl,br);}float flatElevation(vec2 pack) {vec2 apos=floor(pack/8.0);vec2 span=10.0*(pack-apos*8.0);vec2 uvTex=(apos-vec2(1.0,1.0))/8190.0;float size=u_dem_size+2.0;float dd=1.0/size;vec2 pos=u_dem_size*(uvTex*u_dem_scale+u_dem_tl)+1.0;vec2 f=fract(pos);pos=(pos-f+0.5)*dd;vec4 h=fourSample(pos,vec2(dd));float z=mix(mix(h.x,h.y,f.x),mix(h.z,h.w,f.x),f.y);vec2 w=floor(0.5*(span*u_meter_to_dem-1.0));vec2 d=dd*w;h=fourSample(pos-d,2.0*d+vec2(dd));vec4 diff=abs(h.xzxy-h.ywzw);vec2 slope=min(vec2(0.25),u_meter_to_dem*0.5*(diff.xz+diff.yw)/(2.0*w+vec2(1.0)));vec2 fix=slope*span;float base=z+max(fix.x,fix.y);return u_exaggeration*base;}float elevationFromUint16(float word) {return u_exaggeration*(word/ELEVATION_SCALE-ELEVATION_OFFSET);}
#else
float elevation(vec2 pos) { return 0.0; }bool isOccluded(vec4 frag) { return false; }float occlusionFade(vec4 frag) { return 1.0; }
#endif`
              , yh = `#ifdef FOG
uniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump mat4 u_fog_matrix;varying vec3 v_fog_pos;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}vec3 fog_position(vec3 pos) {return (u_fog_matrix*vec4(pos,1.0)).xyz;}vec3 fog_position(vec2 pos) {return fog_position(vec3(pos,0.0));}float fog(vec3 pos) {float depth=length(pos);float opacity=fog_opacity(fog_range(depth));return opacity*fog_horizon_blending(pos/depth);}
#endif`
              , pg = `#ifdef FOG
uniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump float u_fog_temporal_offset;varying vec3 v_fog_pos;uniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform highp vec2 u_viewport;uniform float u_globe_transition;uniform int u_is_globe;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}float globe_glow_progress() {highp vec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(
mix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);highp vec3 dir=normalize(ray_dir);highp vec3 closest_point=dot(u_globe_pos,dir)*dir;highp float sdf=length(closest_point-u_globe_pos)/u_globe_radius;return sdf+PI*0.5;}float fog_opacity(vec3 pos) {float depth=length(pos);return fog_opacity(fog_range(depth));}vec3 fog_apply(vec3 color,vec3 pos) {float depth=length(pos);float opacity;if (u_is_globe==1) {float glow_progress=globe_glow_progress();float t=mix(glow_progress,depth,u_globe_transition);opacity=fog_opacity(fog_range(t));} else {opacity=fog_opacity(fog_range(depth));opacity*=fog_horizon_blending(pos/depth);}return mix(color,u_fog_color.rgb,opacity);}vec4 fog_apply_from_vert(vec4 color,float fog_opac) {float alpha=EPSILON+color.a;color.rgb=mix(color.rgb/alpha,u_fog_color.rgb,fog_opac)*alpha;return color;}vec3 fog_apply_sky_gradient(vec3 camera_ray,vec3 sky_color) {float horizon_blend=fog_horizon_blending(normalize(camera_ray));return mix(sky_color,u_fog_color.rgb,horizon_blend);}vec4 fog_apply_premultiplied(vec4 color,vec3 pos) {float alpha=EPSILON+color.a;color.rgb=fog_apply(color.rgb/alpha,pos)*alpha;return color;}vec3 fog_dither(vec3 color) {vec2 dither_seed=gl_FragCoord.xy+u_fog_temporal_offset;return dither(color,dither_seed);}vec4 fog_dither(vec4 color) {return vec4(fog_dither(color.rgb),color.a);}
#endif`;
            let vf = {}
              , bf = {}
              , vl = [];
            Ca(Oc, vl),
            Ca(fg, vl),
            Ca(yh, vl),
            Ca(pg, vl),
            vf = fi("", fg),
            bf = fi(pg, yh);
            let mg = fi(`
#if __VERSION__ >=300
#define varying in
#define gl_FragColor glFragColor
#define texture2D texture
#define textureCube texture
out vec4 glFragColor;
#endif
highp vec3 hash(highp vec2 p) {highp vec3 p3=fract(p.xyx*vec3(443.8975,397.2973,491.1871));p3+=dot(p3,p3.yxz+19.19);return fract((p3.xxy+p3.yzz)*p3.zyx);}vec3 dither(vec3 color,highp vec2 seed) {vec3 rnd=hash(seed)+hash(seed+0.59374)-0.5;return color+rnd/255.0;}highp float unpack_depth(highp vec4 rgba_depth)
{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}highp vec4 pack_depth(highp float ndc_z) {highp float depth=ndc_z*0.5+0.5;const highp vec4 bit_shift=vec4(255.0*255.0*255.0,255.0*255.0,255.0,1.0);const highp vec4 bit_mask =vec4(0.0,1.0/255.0,1.0/255.0,1.0/255.0);highp vec4 res=fract(depth*bit_shift);res-=res.xxyz*bit_mask;return res;}`, `
#if __VERSION__ >=300
#define attribute in
#define varying out
#define texture2D texture
#endif
float wrap(float n,float min,float max) {float d=max-min;float w=mod(mod(n-min,d)+d,d)+min;return (w==min) ? max : w;}
#ifdef PROJECTION_GLOBE_VIEW
vec3 mercator_tile_position(mat4 matrix,vec2 tile_anchor,vec3 tile_id,vec2 mercator_center) {
#ifndef PROJECTED_POS_ON_VIEWPORT
float tiles=tile_id.z;vec2 mercator=(tile_anchor/EXTENT+tile_id.xy)/tiles;mercator-=mercator_center;mercator.x=wrap(mercator.x,-0.5,0.5);vec4 mercator_tile=vec4(mercator.xy*EXTENT,EXTENT/(2.0*PI),1.0);mercator_tile=matrix*mercator_tile;return mercator_tile.xyz;
#else
return vec3(0.0);
#endif
}vec3 mix_globe_mercator(vec3 globe,vec3 mercator,float t) {return mix(globe,mercator,t);}mat3 globe_mercator_surface_vectors(vec3 pos_normal,vec3 up_dir,float zoom_transition) {vec3 normal=zoom_transition==0.0 ? pos_normal : normalize(mix(pos_normal,up_dir,zoom_transition));vec3 xAxis=normalize(vec3(normal.z,0.0,-normal.x));vec3 yAxis=normalize(cross(normal,xAxis));return mat3(xAxis,yAxis,normal);}
#endif
vec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(
unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0
);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}const vec4 AWAY=vec4(-1000.0,-1000.0,-1000.0,1);//Normalized device coordinate that is not rendered.`)
              , xh = Oc
              , vh = `
#ifdef GL_ES
precision mediump float;
#else

#if !defined(lowp)
#define lowp
#endif

#if !defined(mediump)
#define mediump
#endif

#if !defined(highp)
#define highp
#endif

#endif`;
            var wf = {
                background: fi(`uniform vec4 u_color;uniform float u_opacity;
#ifdef LIGHTING_3D_MODE
varying vec4 v_color;
#endif
void main() {vec4 out_color;
#ifdef LIGHTING_3D_MODE
out_color=v_color;
#else
out_color=u_color;
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
gl_FragColor=out_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec2 a_pos;uniform mat4 u_matrix;
#ifdef LIGHTING_3D_MODE
uniform vec4 u_color;varying vec4 v_color;
#endif
void main() {gl_Position=u_matrix*vec4(a_pos,0,1);
#ifdef LIGHTING_3D_MODE
v_color=apply_lighting(u_color);
#endif
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
}`),
                backgroundPattern: fi(`uniform vec2 u_pattern_tl;uniform vec2 u_pattern_br;uniform vec2 u_texsize;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos;void main() {vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(u_pattern_tl/u_texsize,u_pattern_br/u_texsize,imagecoord);vec4 out_color=texture2D(u_image,pos);
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting(out_color);
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
gl_FragColor=out_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec2 u_pattern_size;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_pattern_size,u_tile_units_to_pixels,a_pos);
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
}`),
                circle: fi(`varying vec3 v_data;varying float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(
antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width)
);vec4 out_color=mix(color*opacity,stroke_color*stroke_opacity,color_t);
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting(out_color);
#endif
#ifdef FOG
out_color=fog_apply_premultiplied(out_color,v_fog_pos);
#endif
gl_FragColor=out_color*(v_visibility*opacity_t);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `#define NUM_VISIBILITY_RINGS 2
#define INV_SQRT2 0.70710678
#define ELEVATION_BIAS 0.0001
#define NUM_SAMPLES_PER_RING 16
uniform mat4 u_matrix;uniform mat2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;
#ifdef PROJECTION_GLOBE_VIEW
attribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;
#endif
varying vec3 v_data;varying float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
vec2 calc_offset(vec2 extrusion,float radius,float stroke_width, float view_scale) {return extrusion*(radius+stroke_width)*u_extrude_scale*view_scale;}float cantilevered_elevation(vec2 pos,float radius,float stroke_width,float view_scale) {vec2 c1=pos+calc_offset(vec2(-1,-1),radius,stroke_width,view_scale);vec2 c2=pos+calc_offset(vec2(1,-1),radius,stroke_width,view_scale);vec2 c3=pos+calc_offset(vec2(1,1),radius,stroke_width,view_scale);vec2 c4=pos+calc_offset(vec2(-1,1),radius,stroke_width,view_scale);float h1=elevation(c1)+ELEVATION_BIAS;float h2=elevation(c2)+ELEVATION_BIAS;float h3=elevation(c3)+ELEVATION_BIAS;float h4=elevation(c4)+ELEVATION_BIAS;return max(h4,max(h3,max(h1,h2)));}float circle_elevation(vec2 pos) {
#if defined(TERRAIN)
return elevation(pos)+ELEVATION_BIAS;
#else
return 0.0;
#endif
}vec4 project_vertex(vec2 extrusion,vec4 world_center,vec4 projected_center,float radius,float stroke_width, float view_scale,mat3 surface_vectors) {vec2 sample_offset=calc_offset(extrusion,radius,stroke_width,view_scale);
#ifdef PITCH_WITH_MAP
#ifdef PROJECTION_GLOBE_VIEW
return u_matrix*( world_center+vec4(sample_offset.x*surface_vectors[0]+sample_offset.y*surface_vectors[1],0) );
#else
return u_matrix*( world_center+vec4(sample_offset,0,0) );
#endif
#else
return projected_center+vec4(sample_offset,0,0);
#endif
}float get_sample_step() {
#ifdef PITCH_WITH_MAP
return 2.0*PI/float(NUM_SAMPLES_PER_RING);
#else
return PI/float(NUM_SAMPLES_PER_RING);
#endif
}void main(void) {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);vec4 world_center;mat3 surface_vectors;
#ifdef PROJECTION_GLOBE_VIEW
vec3 pos_normal_3=a_pos_normal_3/16384.0;surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(circle_center)*circle_elevation(circle_center);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*circle_elevation(circle_center);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,circle_center,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;vec3 pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);world_center=vec4(pos,1);
#else 
surface_vectors=mat3(1.0);float height=circle_elevation(circle_center);world_center=vec4(circle_center,height,1);
#endif
vec4 projected_center=u_matrix*world_center;float view_scale=0.0;
#ifdef PITCH_WITH_MAP
#ifdef SCALE_WITH_MAP
view_scale=1.0;
#else
view_scale=projected_center.w/u_camera_to_center_distance;
#endif
#else
#ifdef SCALE_WITH_MAP
view_scale=u_camera_to_center_distance;
#else
view_scale=projected_center.w;
#endif
#endif
gl_Position=project_vertex(extrude,world_center,projected_center,radius,stroke_width,view_scale,surface_vectors);float visibility=0.0;
#ifdef TERRAIN
float step=get_sample_step();vec4 occlusion_world_center;vec4 occlusion_projected_center;
#ifdef PITCH_WITH_MAP
float cantilevered_height=cantilevered_elevation(circle_center,radius,stroke_width,view_scale);occlusion_world_center=vec4(circle_center,cantilevered_height,1);occlusion_projected_center=u_matrix*occlusion_world_center;
#else
occlusion_world_center=world_center;occlusion_projected_center=projected_center;
#endif
for(int ring=0; ring < NUM_VISIBILITY_RINGS; ring++) {float scale=(float(ring)+1.0)/float(NUM_VISIBILITY_RINGS);for(int i=0; i < NUM_SAMPLES_PER_RING; i++) {vec2 extrusion=vec2(cos(step*float(i)),-sin(step*float(i)))*scale;vec4 frag_pos=project_vertex(extrusion,occlusion_world_center,occlusion_projected_center,radius,stroke_width,view_scale,surface_vectors);visibility+=float(!isOccluded(frag_pos));}}visibility/=float(NUM_VISIBILITY_RINGS)*float(NUM_SAMPLES_PER_RING);
#else
visibility=1.0;
#endif
#ifdef PROJECTION_GLOBE_VIEW
visibility=1.0;
#endif
v_visibility=visibility;lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);
#ifdef FOG
v_fog_pos=fog_position(world_center.xyz);
#endif
}`),
                clippingMask: fi("void main() {gl_FragColor=vec4(1.0);}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"),
                heatmap: fi(`uniform highp float u_intensity;varying vec2 v_extrude;
#pragma mapbox: define highp float weight
#define GAUSS_COEF 0.3989422804014327
void main() {
#pragma mapbox: initialize highp float weight
float d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);
#ifdef FOG
if (u_is_globe==0) {gl_FragColor.r*=pow(1.0-fog_opacity(v_fog_pos),2.0);}
#endif
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;
#ifdef PROJECTION_GLOBE_VIEW
attribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;
#endif
varying vec2 v_extrude;
#pragma mapbox: define highp float weight
#pragma mapbox: define mediump float radius
const highp float ZERO=1.0/255.0/16.0;
#define GAUSS_COEF 0.3989422804014327
void main(void) {
#pragma mapbox: initialize highp float weight
#pragma mapbox: initialize mediump float radius
vec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 tilePos=floor(a_pos*0.5);vec3 pos;
#ifdef PROJECTION_GLOBE_VIEW
vec3 pos_normal_3=a_pos_normal_3/16384.0;mat3 surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(tilePos)*elevation(tilePos);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*elevation(tilePos);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,tilePos,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);
#else
pos=vec3(tilePos+extrude,elevation(tilePos));
#endif
gl_Position=u_matrix*vec4(pos,1);
#ifdef FOG
v_fog_pos=fog_position(pos);
#endif
}`),
                heatmapTexture: fi(`uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(0.0);
#endif
}`, "attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=vec4(a_pos,0,1);v_pos=a_pos*0.5+0.5;}"),
                collisionBox: fi("varying float v_placed;varying float v_notUsed;void main() {vec4 red =vec4(1.0,0.0,0.0,1.0);vec4 blue=vec4(0.0,0.0,1.0,0.5);gl_FragColor =mix(red,blue,step(0.5,v_placed))*0.5;gl_FragColor*=mix(1.0,0.1,step(0.5,v_notUsed));}", `attribute vec3 a_pos;attribute vec2 a_anchor_pos;attribute vec2 a_extrude;attribute vec2 a_placed;attribute vec2 a_shift;attribute float a_size_scale;attribute vec2 a_padding;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;varying float v_placed;varying float v_notUsed;void main() {vec4 projectedPoint=u_matrix*vec4(a_pos+elevationVector(a_anchor_pos)*elevation(a_anchor_pos),1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(
0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,1.5);gl_Position=projectedPoint;gl_Position.xy+=(a_extrude*a_size_scale+a_shift+a_padding)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}`),
                collisionCircle: fi("varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);gl_FragColor=color*alpha*opacity_t;}", `attribute vec2 a_pos_2f;attribute float a_radius;attribute vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos_2f;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(
mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(
0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}`),
                debug: fi("uniform highp vec4 u_color;uniform sampler2D u_overlay;varying vec2 v_uv;void main() {vec4 overlay_color=texture2D(u_overlay,v_uv);gl_FragColor=mix(u_color,overlay_color,overlay_color.a);}", `attribute vec2 a_pos;
#ifdef PROJECTION_GLOBE_VIEW
attribute vec3 a_pos_3;
#endif
varying vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {float h=elevation(a_pos);v_uv=a_pos/8192.0;
#ifdef PROJECTION_GLOBE_VIEW
gl_Position=u_matrix*vec4(a_pos_3+elevationVector(a_pos)*h,1);
#else
gl_Position=u_matrix*vec4(a_pos*u_overlay_scale,h,1);
#endif
}`),
                fill: fi(`#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
vec4 out_color=color;
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting(out_color);
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
gl_FragColor=out_color*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec2 a_pos;uniform mat4 u_matrix;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_Position=u_matrix*vec4(a_pos,0,1);
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
}`),
                fillOutline: fi(`varying vec2 v_pos;
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=outline_color;
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting(out_color);
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
gl_FragColor=out_color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
}`),
                fillOutlinePattern: fi(`uniform vec2 u_texsize;uniform sampler2D u_image;varying vec2 v_pos;varying vec2 v_pos_world;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern
vec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);float dist=length(v_pos_world-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=texture2D(u_image,pos);
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting(out_color);
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
gl_FragColor=out_color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos;varying vec2 v_pos_world;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern
#pragma mapbox: define lowp float pixel_ratio
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern
#pragma mapbox: initialize lowp float pixel_ratio
vec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);v_pos_world=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
}`),
                fillPattern: fi(`uniform vec2 u_texsize;uniform sampler2D u_image;varying vec2 v_pos;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern
vec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);vec4 out_color=texture2D(u_image,pos);
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting(out_color);
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
gl_FragColor=out_color*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern
#pragma mapbox: define lowp float pixel_ratio
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern
#pragma mapbox: initialize lowp float pixel_ratio
vec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
}`),
                fillExtrusion: fi(`varying vec4 v_color;
#ifdef RENDER_SHADOWS
varying highp vec4 v_pos_light_view_0;varying highp vec4 v_pos_light_view_1;varying float v_depth;
#endif
#ifdef FAUX_AO
uniform lowp vec2 u_ao;varying vec3 v_ao;
#endif
#ifdef ZERO_ROOF_RADIUS
varying vec4 v_roof_color;
#endif
#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)
varying highp vec3 v_normal;
#endif
void main() {
#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)
vec3 normal=v_normal;
#endif
float z;vec4 color;
#ifdef ZERO_ROOF_RADIUS
z=float(normal.z > 0.00001);color=mix(v_color,v_roof_color,z);
#else
color=v_color;
#endif
#ifdef FAUX_AO
float intensity=u_ao[0];float h=max(0.0,v_ao.z);float h_floors=h/u_ao[1];float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);float shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;
#ifdef ZERO_ROOF_RADIUS
concave*=(1.0-z);
#endif
float x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);shade*=mix(1.0,x_shade*x_shade*x_shade,concave);color.rgb=color.rgb*shade;
#endif
#ifdef RENDER_SHADOWS
#ifdef ZERO_ROOF_RADIUS
normal=mix(normal,vec3(0.0,0.0,1.0),z);
#endif
color.xyz=shadowed_color_normal(color.xyz,normalize(normal),v_pos_light_view_0,v_pos_light_view_1,v_depth);
#endif
#ifdef FOG
color=fog_dither(fog_apply_premultiplied(color,v_fog_pos));
#endif
gl_FragColor=color;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform float u_edge_radius;attribute vec4 a_pos_normal_ed;attribute vec2 a_centroid_pos;
#ifdef PROJECTION_GLOBE_VIEW
attribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;
#endif
varying vec4 v_color;
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;varying highp vec4 v_pos_light_view_0;varying highp vec4 v_pos_light_view_1;varying float v_depth;
#endif
#ifdef ZERO_ROOF_RADIUS
varying vec4 v_roof_color;
#endif
#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)
varying highp vec3 v_normal;
#endif
#ifdef FAUX_AO
uniform lowp vec2 u_ao;varying vec3 v_ao;
#endif
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
vec4 pos_nx=floor(a_pos_normal_ed*0.5);vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));
#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)
v_normal=normal;
#endif
base=max(0.0,base);height=max(0.0,top_up_ny.y==0.0 && top_up_ny.x==1.0 ? height-u_edge_radius : height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);
#if defined(HAS_CENTROID) || defined(TERRAIN)
centroid_pos=a_centroid_pos;
#endif
float ele=0.0;float h=0.0;float c_ele;vec3 pos;
#ifdef TERRAIN
bool flat_roof=centroid_pos.x !=0.0 && t > 0.0;ele=elevation(pos_nx.xy);c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);pos=vec3(pos_nx.xy,h);
#else
h=t > 0.0 ? height : base;pos=vec3(pos_nx.xy,h);
#endif
#ifdef PROJECTION_GLOBE_VIEW
float lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*h);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,pos.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*pos.z;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);
#endif
float hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);gl_Position=mix(u_matrix*vec4(pos,1),AWAY,hidden);
#ifdef RENDER_SHADOWS
v_pos_light_view_0=u_light_matrix_0*vec4(pos,1);v_pos_light_view_1=u_light_matrix_1*vec4(pos,1);v_depth=gl_Position.w;
#endif
float NdotL=0.0;float colorvalue=0.0;
#ifdef LIGHTING_3D_MODE
NdotL=calculate_NdotL(normal);
#else
colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;NdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),NdotL);
#endif
if (normal.y !=0.0) {float r=0.84;
#ifndef LIGHTING_3D_MODE
r=mix(0.7,0.98,1.0-u_lightintensity);
#endif
NdotL*=(
(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}v_color=vec4(0.0,0.0,0.0,1.0);
#ifdef FAUX_AO
float concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;
#ifdef TERRAIN
top_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);
#endif
v_ao=vec3(mix(concave,-concave,start),y_ground,h-ele);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);
#ifdef PROJECTION_GLOBE_VIEW
top_height+=u_height_lift;
#endif
gl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;
#endif
#ifdef LIGHTING_3D_MODE
v_color=apply_lighting(color,NdotL);
#else
v_color.rgb+=clamp(color.rgb*NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));
#endif
v_color*=u_opacity;
#ifdef ZERO_ROOF_RADIUS
v_roof_color=vec4(0.0,0.0,0.0,1.0);
#ifdef LIGHTING_3D_MODE
v_roof_color=apply_lighting(color,calculate_NdotL(vec3(0.0,0.0,1.0)));
#else
float roofNdotL=clamp(u_lightpos.z,0.0,1.0);roofNdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),roofNdotL);v_roof_color.rgb+=clamp(color.rgb*roofNdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));
#endif
v_roof_color*=u_opacity;
#endif
#ifdef FOG
v_fog_pos=fog_position(pos);
#endif
}`),
                fillExtrusionPattern: fi(`uniform vec2 u_texsize;uniform sampler2D u_image;
#ifdef FAUX_AO
uniform lowp vec2 u_ao;varying vec3 v_ao;
#endif
#ifdef LIGHTING_3D_MODE
varying float v_NdotL;
#endif
varying vec2 v_pos;varying vec4 v_lighting;uniform lowp float u_opacity;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern
#pragma mapbox: define lowp float pixel_ratio
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern
#pragma mapbox: initialize lowp float pixel_ratio
vec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);vec4 out_color=texture2D(u_image,pos);
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting(out_color,v_NdotL)*u_opacity;
#else
out_color=out_color*v_lighting;
#endif
#ifdef FAUX_AO
float intensity=u_ao[0];float h=max(0.0,v_ao.z);float h_floors=h/u_ao[1];float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);float shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;float x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);shade*=mix(1.0,x_shade*x_shade*x_shade,concave);out_color.rgb=out_color.rgb*shade;
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
gl_FragColor=out_color;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform float u_tile_units_to_pixels;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec4 a_pos_normal_ed;attribute vec2 a_centroid_pos;
#ifdef PROJECTION_GLOBE_VIEW
attribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;
#endif
varying vec2 v_pos;varying vec4 v_lighting;
#ifdef FAUX_AO
uniform lowp vec2 u_ao;varying vec3 v_ao;
#endif
#ifdef LIGHTING_3D_MODE
varying float v_NdotL;
#endif
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern
#pragma mapbox: define lowp float pixel_ratio
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern
#pragma mapbox: initialize lowp float pixel_ratio
vec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec4 pos_nx=floor(a_pos_normal_ed*0.5);mediump vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;mediump vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));float edgedistance=a_pos_normal_ed.w;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;base=max(0.0,base);height=max(0.0,height);float t=top_up_ny.x;float z=t > 0.0 ? height : base;vec2 centroid_pos=vec2(0.0);
#if defined(HAS_CENTROID) || defined(TERRAIN)
centroid_pos=a_centroid_pos;
#endif
float ele=0.0;float h=z;vec3 p;float c_ele;
#ifdef TERRAIN
bool flat_roof=centroid_pos.x !=0.0 && t > 0.0;ele=elevation(pos_nx.xy);c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);p=vec3(pos_nx.xy,h);
#else
p=vec3(pos_nx.xy,z);
#endif
#ifdef PROJECTION_GLOBE_VIEW
float lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*(p.z+lift));vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,p.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*p.z;p=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);
#endif
float hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);gl_Position=mix(u_matrix*vec4(p,1),AWAY,hidden);vec2 pos=normal.z==1.0
? pos_nx.xy
: vec2(edgedistance,z*u_height_factor);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float NdotL=0.0;
#ifdef LIGHTING_3D_MODE
NdotL=calculate_NdotL(normal);
#else
NdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),NdotL);
#endif
if (normal.y !=0.0) {float r=0.84;
#ifndef LIGHTING_3D_MODE
r=mix(0.7,0.98,1.0-u_lightintensity);
#endif
NdotL*=(
(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}
#ifdef FAUX_AO
float concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;
#ifdef TERRAIN
top_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);
#endif
v_ao=vec3(mix(concave,-concave,start),y_ground,h-ele);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);
#ifdef PROJECTION_GLOBE_VIEW
top_height+=u_height_lift;
#endif
gl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;
#endif
#ifdef LIGHTING_3D_MODE
v_NdotL=NdotL;
#else
v_lighting.rgb+=clamp(NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;
#endif 
#ifdef FOG
v_fog_pos=fog_position(p);
#endif
}`),
                hillshadePrepare: fi(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord) {
#ifdef TERRAIN_DEM_FLOAT_FORMAT
return texture2D(u_image,coord).a/4.0;
#else
vec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;
#endif
}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y));float b=getElevation(v_pos+vec2(0,-epsilon.y));float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y));float d=getElevation(v_pos+vec2(-epsilon.x,0));float e=getElevation(v_pos+vec2(epsilon.x,0));float f=getElevation(v_pos+vec2(-epsilon.x,epsilon.y));float g=getElevation(v_pos+vec2(0,epsilon.y));float h=getElevation(v_pos+vec2(epsilon.x,epsilon.y));float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2(
(c+e+e+h)-(a+d+d+f),(f+g+g+h)-(a+b+b+c)
)/pow(2.0,exaggeration+(19.2562-u_zoom));gl_FragColor=clamp(vec4(
deriv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"),
                hillshade: fi(`uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;void main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;
#ifdef LIGHTING_3D_MODE
gl_FragColor=apply_lighting(gl_FragColor);
#endif
#ifdef FOG
gl_FragColor=fog_dither(fog_apply_premultiplied(gl_FragColor,v_fog_pos));
#endif
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
}`),
                line: fi(`uniform lowp float u_device_pixel_ratio;uniform float u_alpha_discard_threshold;uniform highp vec2 u_trim_offset;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;varying highp vec4 v_uv;
#ifdef RENDER_LINE_DASH
uniform sampler2D u_dash_image;varying vec2 v_tex;
#endif
#ifdef RENDER_LINE_GRADIENT
uniform sampler2D u_gradient_image;
#endif
uniform float u_border_width;uniform vec4 u_border_color;float luminance(vec3 c) {return (c.r+c.r+c.b+c.g+c.g+c.g)*0.1667;}
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 dash
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
float linearstep(float edge0,float edge1,float x) {return  clamp((x-edge0)/(edge1-edge0),0.0,1.0);}void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize lowp vec4 dash
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);
#ifdef RENDER_LINE_DASH
float sdfdist=texture2D(u_dash_image,v_tex).a;float sdfgamma=1.0/(2.0*u_device_pixel_ratio)/dash.z;alpha*=linearstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);
#endif
highp vec4 out_color;
#ifdef RENDER_LINE_GRADIENT
out_color=texture2D(u_gradient_image,v_uv.xy);
#else
out_color=color;
#endif
float trimmed=1.0;
#ifdef RENDER_LINE_TRIM_OFFSET
highp float start=v_uv[2];highp float end=v_uv[3];highp float trim_start=u_trim_offset[0];highp float trim_end=u_trim_offset[1];highp float line_progress=(start+(v_uv.x)*(end-start));if (trim_end > trim_start) {if (line_progress <=trim_end && line_progress >=trim_start) {out_color=vec4(0,0,0,0);trimmed=0.0;}}
#endif
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting(out_color);
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
#ifdef RENDER_LINE_ALPHA_DISCARD
if (alpha < u_alpha_discard_threshold) {discard;}
#endif
#ifdef RENDER_LINE_BORDER
float edgeBlur=(u_border_width+1.0/u_device_pixel_ratio);float alpha2=clamp(min(dist-(v_width2.t-edgeBlur),v_width2.s-dist)/edgeBlur,0.0,1.0);if (alpha2 < 1.) {float smoothAlpha=smoothstep(0.6,1.0,alpha2);
#ifdef RENDER_LINE_BORDER_AUTO
float Y=(out_color.a > 0.01) ? luminance(out_color.rgb/out_color.a) : 1.;float adjustment=(Y > 0.) ? 0.5/Y : 0.45;if (out_color.a > 0.25 && Y < 0.25) {vec3 borderColor=(Y > 0.) ? out_color.rgb : vec3(1,1,1)*out_color.a;out_color.rgb=out_color.rgb+borderColor*(adjustment*(1.0-smoothAlpha));} else {out_color.rgb*=(0.6 +0.4*smoothAlpha);}
#else
out_color.rgb=mix(u_border_color.rgb*u_border_color.a*trimmed,out_color.rgb,smoothAlpha);
#endif
}
#endif
gl_FragColor=out_color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define EXTRUDE_SCALE 0.015873016
attribute vec2 a_pos_normal;attribute vec4 a_data;
#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)
attribute highp vec4 a_packed;
#endif
#ifdef RENDER_LINE_DASH
attribute float a_linesofar;
#endif
uniform mat4 u_matrix;uniform mat2 u_pixels_to_tile_units;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp vec4 v_uv;
#ifdef RENDER_LINE_DASH
uniform vec2 u_texsize;uniform float u_tile_units_to_pixels;varying vec2 v_tex;
#endif
#ifdef RENDER_LINE_GRADIENT
uniform float u_image_height;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 dash
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize lowp vec4 dash
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*EXTRUDE_SCALE;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*EXTRUDE_SCALE*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist*u_pixels_to_tile_units,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude;
#ifndef RENDER_TO_TEXTURE
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#else
v_gamma_scale=1.0;
#endif
#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)
float a_uv_x=a_packed[0];float a_split_index=a_packed[1];highp float a_clip_start=a_packed[2];highp float a_clip_end=a_packed[3];
#ifdef RENDER_LINE_GRADIENT
highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec4(a_uv_x,a_split_index*texel_height-half_texel_height,a_clip_start,a_clip_end);
#else
v_uv=vec4(a_uv_x,0.0,a_clip_start,a_clip_end);
#endif
#endif
#ifdef RENDER_LINE_DASH
float scale=dash.z==0.0 ? 0.0 : u_tile_units_to_pixels/dash.z;float height=dash.y;v_tex=vec2(a_linesofar*scale/floorwidth,(-normal.y*height+dash.x+0.5)/u_texsize.y);
#endif
v_width2=vec2(outset,inset);
#ifdef FOG
v_fog_pos=fog_position(pos);
#endif
}`),
                linePattern: fi(`uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_tile_units_to_pixels;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;
#pragma mapbox: define lowp vec4 pattern
#pragma mapbox: define lowp float pixel_ratio
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize mediump vec4 pattern
#pragma mapbox: initialize lowp float pixel_ratio
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
vec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;vec2 pattern_size=vec2(display_size.x/u_tile_units_to_pixels,display_size.y);float aspect=display_size.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x=mod(v_linesofar/pattern_size.x*aspect,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos=mix(pattern_tl*texel_size-texel_size,pattern_br*texel_size+texel_size,vec2(x,y));vec4 color=texture2D(u_image,pos);
#ifdef LIGHTING_3D_MODE
color=apply_lighting(color);
#endif
#ifdef FOG
color=fog_dither(fog_apply_premultiplied(color,v_fog_pos));
#endif
gl_FragColor=color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
attribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_linesofar;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mat2 u_pixels_to_tile_units;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 pattern
#pragma mapbox: define lowp float pixel_ratio
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 pattern
#pragma mapbox: initialize lowp float pixel_ratio
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist*u_pixels_to_tile_units,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude;
#ifndef RENDER_TO_TEXTURE
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#else
v_gamma_scale=1.0;
#endif
v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;
#ifdef FOG
v_fog_pos=fog_position(pos);
#endif
}`),
                raster: fi(`uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(
dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);vec3 out_color=mix(u_high_vec,u_low_vec,rgb);
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting(out_color);
#endif
#ifdef FOG
out_color=fog_dither(fog_apply(out_color,v_fog_pos));
#endif
gl_FragColor=vec4(out_color*color.a,color.a);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform vec2 u_perspective_transform;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main() {float w=1.0+dot(a_texture_pos,u_perspective_transform);gl_Position=u_matrix*vec4(a_pos*w,0,w);v_pos0=a_texture_pos/8192.0;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
}`),
                symbolIcon: fi(`uniform sampler2D u_texture;varying vec2 v_tex;varying float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
lowp float alpha=opacity*v_fade_opacity;gl_FragColor=texture2D(u_texture,v_tex)*alpha;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec4 a_pos_offset;attribute vec4 a_tex_size;attribute vec4 a_pixeloffset;attribute vec4 a_projected_pos;attribute float a_fade_opacity;
#ifdef PROJECTION_GLOBE_VIEW
attribute vec3 a_globe_anchor;attribute vec3 a_globe_normal;
#endif
uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform vec3 u_up_vector;
#ifdef PROJECTION_GLOBE_VIEW
uniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;
#endif
varying vec2 v_tex;varying float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_min_font_scale=a_pixeloffset.zw/256.0;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;vec3 h=elevationVector(tile_anchor)*elevation(tile_anchor);float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;
#ifdef PROJECTION_GLOBE_VIEW
mercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;
#else
world_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;
#endif
vec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(
0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjected_point;
#ifdef PROJECTION_GLOBE_VIEW
vec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);offsetProjected_point=u_matrix*vec4(a_globe_anchor+displacement,1);
#else
offsetProjected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);
#endif
vec2 a=projected_point.xy/projected_point.w;vec2 b=offsetProjected_point.xy/offsetProjected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;
#ifdef PROJECTION_GLOBE_VIEW
vec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);
#else
projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);
#endif
highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*max(a_min_font_scale,font_scale)+a_pxoffset/16.0);
#ifdef TERRAIN
#ifdef PITCH_WITH_MAP_TERRAIN
vec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);
#endif
#endif
float occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;
#ifdef PROJECTION_GLOBE_VIEW
vec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));
#else
gl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));
#endif
float projection_transition_fade=1.0;
#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)
projection_transition_fade=1.0-step(EPSILON,u_zoom_transition);
#endif
v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;v_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change))*projection_transition_fade;}`),
                symbolSDF: fi(`#define SDF_PX 8.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;varying vec2 v_data0;varying vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec4 a_pos_offset;attribute vec4 a_tex_size;attribute vec4 a_pixeloffset;attribute vec4 a_projected_pos;attribute float a_fade_opacity;
#ifdef PROJECTION_GLOBE_VIEW
attribute vec3 a_globe_anchor;attribute vec3 a_globe_normal;
#endif
uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_up_vector;
#ifdef PROJECTION_GLOBE_VIEW
uniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;
#endif
varying vec2 v_data0;varying vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;vec3 h=elevationVector(tile_anchor)*elevation(tile_anchor);float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;
#ifdef PROJECTION_GLOBE_VIEW
mercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;
#else
world_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;
#endif
vec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(
0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetprojected_point;
#ifdef PROJECTION_GLOBE_VIEW
vec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);offsetprojected_point=u_matrix*vec4(a_globe_anchor+displacement,1);
#else
offsetprojected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);
#endif
vec2 a=projected_point.xy/projected_point.w;vec2 b=offsetprojected_point.xy/offsetprojected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;
#ifdef PROJECTION_GLOBE_VIEW
vec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);
#else
projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);
#endif
highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset);
#ifdef TERRAIN
#ifdef PITCH_WITH_MAP_TERRAIN
vec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);
#endif
#endif
float occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;
#ifdef PROJECTION_GLOBE_VIEW
vec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));
#else
gl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));
#endif
float gamma_scale=gl_Position.w;float projection_transition_fade=1.0;
#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)
projection_transition_fade=1.0-step(EPSILON,u_zoom_transition);
#endif
vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity*projection_transition_fade);}`),
                symbolTextAndIcon: fi(`#define SDF_PX 8.0
#define SDF 1.0
#define ICON 0.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;varying vec4 v_data0;varying vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;gl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
return;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec4 a_pos_offset;attribute vec4 a_tex_size;attribute vec4 a_projected_pos;attribute float a_fade_opacity;
#ifdef PROJECTION_GLOBE_VIEW
attribute vec3 a_globe_anchor;attribute vec3 a_globe_normal;
#endif
uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_up_vector;uniform vec2 u_texsize_icon;
#ifdef PROJECTION_GLOBE_VIEW
uniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;
#endif
varying vec4 v_data0;varying vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;vec3 h=elevationVector(tile_anchor)*elevation(tile_anchor);float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;
#ifdef PROJECTION_GLOBE_VIEW
mercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;
#else
world_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;
#endif
vec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(
0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offset_projected_point=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projected_point.xy/projected_point.w;vec2 b=offset_projected_point.xy/offset_projected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;
#ifdef PROJECTION_GLOBE_VIEW
vec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);
#else
projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);
#endif
highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*font_scale);
#ifdef TERRAIN
#ifdef PITCH_WITH_MAP_TERRAIN
vec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);
#endif
#endif
float occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;
#ifdef PROJECTION_GLOBE_VIEW
vec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));
#else
gl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));
#endif
float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));float projection_transition_fade=1.0;
#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)
projection_transition_fade=1.0-step(EPSILON,u_zoom_transition);
#endif
v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity*projection_transition_fade,is_sdf);}`),
                terrainRaster: fi(`uniform sampler2D u_image0;varying vec2 v_pos0;
#ifdef FOG
varying float v_fog_opacity;
#endif
#ifdef RENDER_SHADOWS
varying vec4 v_pos_light_view_0;varying vec4 v_pos_light_view_1;varying float v_depth;
#endif
void main() {vec4 color=texture2D(u_image0,v_pos0);
#ifdef RENDER_SHADOWS
color.xyz=shadowed_color(color.xyz,v_pos_light_view_0,v_pos_light_view_1,v_depth);
#endif
#ifdef FOG
#ifdef ZERO_EXAGGERATION
color=fog_dither(fog_apply_premultiplied(color,v_fog_pos));
#else
color=fog_dither(fog_apply_from_vert(color,v_fog_opacity));
#endif
#endif
gl_FragColor=color;
#ifdef TERRAIN_WIREFRAME
gl_FragColor=vec4(1.0,0.0,0.0,0.8);
#endif
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform float u_skirt_height;attribute vec2 a_pos;varying vec2 v_pos0;
#ifdef FOG
varying float v_fog_opacity;
#endif
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;varying vec4 v_pos_light_view_0;varying vec4 v_pos_light_view_1;varying float v_depth;
#endif
const float wireframeOffset=0.00015;void main() {vec3 decomposedPosAndSkirt=decomposeToPosAndSkirt(a_pos);float skirt=decomposedPosAndSkirt.z;vec2 decodedPos=decomposedPosAndSkirt.xy;float elevation=elevation(decodedPos)-skirt*u_skirt_height;
#ifdef TERRAIN_WIREFRAME
elevation+=wireframeOffset;
#endif
v_pos0=decodedPos/8192.0;gl_Position=u_matrix*vec4(decodedPos,elevation,1.0);
#ifdef FOG
#ifdef ZERO_EXAGGERATION
v_fog_pos=fog_position(decodedPos);
#else
v_fog_opacity=fog(fog_position(vec3(decodedPos,elevation)));
#endif
#endif
#ifdef RENDER_SHADOWS
vec3 pos=vec3(decodedPos,elevation);v_pos_light_view_0=u_light_matrix_0*vec4(pos,1.);v_pos_light_view_1=u_light_matrix_1*vec4(pos,1.);v_depth=gl_Position.w;
#endif
}`),
                terrainDepth: fi(`#ifdef GL_ES
precision highp float;
#endif
varying float v_depth;void main() {gl_FragColor=pack_depth(v_depth);}`, "uniform mat4 u_matrix;attribute vec2 a_pos;varying float v_depth;void main() {float elevation=elevation(a_pos);gl_Position=u_matrix*vec4(a_pos,elevation,1.0);v_depth=gl_Position.z/gl_Position.w;}"),
                skybox: fi(`
varying lowp vec3 v_uv;uniform lowp samplerCube u_cubemap;uniform lowp float u_opacity;uniform highp float u_temporal_offset;uniform highp vec3 u_sun_direction;float sun_disk(highp vec3 ray_direction,highp vec3 sun_direction) {highp float cos_angle=dot(normalize(ray_direction),sun_direction);const highp float cos_sun_angular_diameter=0.99996192306;const highp float smoothstep_delta=1e-5;return smoothstep(
cos_sun_angular_diameter-smoothstep_delta,cos_sun_angular_diameter+smoothstep_delta,cos_angle);}float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec3 uv=v_uv;const float y_bias=0.015;uv.y+=y_bias;uv.y=pow(abs(uv.y),1.0/5.0);uv.y=map(uv.y,0.0,1.0,-1.0,1.0);vec3 sky_color=textureCube(u_cubemap,uv).rgb;
#ifdef FOG
sky_color=fog_apply_sky_gradient(v_uv.xzy,sky_color);
#endif
sky_color.rgb=dither(sky_color.rgb,gl_FragCoord.xy+u_temporal_offset);sky_color+=0.1*sun_disk(v_uv,u_sun_direction);gl_FragColor=vec4(sky_color*u_opacity,u_opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, dg),
                skyboxGradient: fi(`varying highp vec3 v_uv;uniform lowp sampler2D u_color_ramp;uniform highp vec3 u_center_direction;uniform lowp float u_radius;uniform lowp float u_opacity;uniform highp float u_temporal_offset;void main() {float progress=acos(dot(normalize(v_uv),u_center_direction))/u_radius;vec4 color=texture2D(u_color_ramp,vec2(progress,0.5));
#ifdef FOG
color.rgb=fog_apply_sky_gradient(v_uv.xzy,color.rgb/color.a)*color.a;
#endif
color*=u_opacity;color.rgb=dither(color.rgb,gl_FragCoord.xy+u_temporal_offset);gl_FragColor=color;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, dg),
                skyboxCapture: fi(`
varying highp vec3 v_position;uniform highp float u_sun_intensity;uniform highp float u_luminance;uniform lowp vec3 u_sun_direction;uniform highp vec4 u_color_tint_r;uniform highp vec4 u_color_tint_m;
#ifdef GL_ES
precision highp float;
#endif
#define BETA_R                  vec3(5.5e-6,13.0e-6,22.4e-6)
#define BETA_M                  vec3(21e-6,21e-6,21e-6)
#define MIE_G                   0.76
#define DENSITY_HEIGHT_SCALE_R  8000.0
#define DENSITY_HEIGHT_SCALE_M  1200.0
#define PLANET_RADIUS           6360e3
#define ATMOSPHERE_RADIUS       6420e3
#define SAMPLE_STEPS            10
#define DENSITY_STEPS           4
float ray_sphere_exit(vec3 orig,vec3 dir,float radius) {float a=dot(dir,dir);float b=2.0*dot(dir,orig);float c=dot(orig,orig)-radius*radius;float d=sqrt(b*b-4.0*a*c);return (-b+d)/(2.0*a);}vec3 extinction(vec2 density) {return exp(-vec3(BETA_R*u_color_tint_r.a*density.x+BETA_M*u_color_tint_m.a*density.y));}vec2 local_density(vec3 point) {float height=max(length(point)-PLANET_RADIUS,0.0);float exp_r=exp(-height/DENSITY_HEIGHT_SCALE_R);float exp_m=exp(-height/DENSITY_HEIGHT_SCALE_M);return vec2(exp_r,exp_m);}float phase_ray(float cos_angle) {return (3.0/(16.0*PI))*(1.0+cos_angle*cos_angle);}float phase_mie(float cos_angle) {return (3.0/(8.0*PI))*((1.0-MIE_G*MIE_G)*(1.0+cos_angle*cos_angle))/((2.0+MIE_G*MIE_G)*pow(1.0+MIE_G*MIE_G-2.0*MIE_G*cos_angle,1.5));}vec2 density_to_atmosphere(vec3 point,vec3 light_dir) {float ray_len=ray_sphere_exit(point,light_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(DENSITY_STEPS);vec2 density_point_to_atmosphere=vec2(0.0);for (int i=0; i < DENSITY_STEPS;++i) {vec3 point_on_ray=point+light_dir*((float(i)+0.5)*step_len);density_point_to_atmosphere+=local_density(point_on_ray)*step_len;;}return density_point_to_atmosphere;}vec3 atmosphere(vec3 ray_dir,vec3 sun_direction,float sun_intensity) {vec2 density_orig_to_point=vec2(0.0);vec3 scatter_r=vec3(0.0);vec3 scatter_m=vec3(0.0);vec3 origin=vec3(0.0,PLANET_RADIUS,0.0);float ray_len=ray_sphere_exit(origin,ray_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(SAMPLE_STEPS);for (int i=0; i < SAMPLE_STEPS;++i) {vec3 point_on_ray=origin+ray_dir*((float(i)+0.5)*step_len);vec2 density=local_density(point_on_ray)*step_len;density_orig_to_point+=density;vec2 density_point_to_atmosphere=density_to_atmosphere(point_on_ray,sun_direction);vec2 density_orig_to_atmosphere=density_orig_to_point+density_point_to_atmosphere;vec3 extinction=extinction(density_orig_to_atmosphere);scatter_r+=density.x*extinction;scatter_m+=density.y*extinction;}float cos_angle=dot(ray_dir,sun_direction);float phase_r=phase_ray(cos_angle);float phase_m=phase_mie(cos_angle);vec3 beta_r=BETA_R*u_color_tint_r.rgb*u_color_tint_r.a;vec3 beta_m=BETA_M*u_color_tint_m.rgb*u_color_tint_m.a;return (scatter_r*phase_r*beta_r+scatter_m*phase_m*beta_m)*sun_intensity;}const float A=0.15;const float B=0.50;const float C=0.10;const float D=0.20;const float E=0.02;const float F=0.30;vec3 uncharted2_tonemap(vec3 x) {return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;}void main() {vec3 ray_direction=v_position;ray_direction.y=pow(ray_direction.y,5.0);const float y_bias=0.015;ray_direction.y+=y_bias;vec3 color=atmosphere(normalize(ray_direction),u_sun_direction,u_sun_intensity);float white_scale=1.0748724675633854;color=uncharted2_tonemap((log2(2.0/pow(u_luminance,4.0)))*color)*white_scale;gl_FragColor=vec4(color,1.0);}`, "attribute highp vec3 a_pos_3f;uniform mat3 u_matrix_3f;varying highp vec3 v_position;float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec4 pos=vec4(u_matrix_3f*a_pos_3f,1.0);v_position=pos.xyz;v_position.y*=-1.0;v_position.y=map(v_position.y,-1.0,1.0,0.0,1.0);gl_Position=vec4(a_pos_3f.xy,0.0,1.0);}"),
                globeRaster: fi(`uniform sampler2D u_image0;varying vec2 v_pos0;
#ifndef FOG
uniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform vec2 u_viewport;
#endif
void main() {vec4 color;
#ifdef CUSTOM_ANTIALIASING
vec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(
mix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);vec3 dir=normalize(ray_dir);vec3 closest_point=dot(u_globe_pos,dir)*dir;float norm_dist_from_center=1.0-length(closest_point-u_globe_pos)/u_globe_radius;const float antialias_pixel=2.0;float antialias_factor=antialias_pixel*fwidth(norm_dist_from_center);float antialias=smoothstep(0.0,antialias_factor,norm_dist_from_center);vec4 raster=texture2D(u_image0,v_pos0);color=vec4(raster.rgb*antialias,raster.a*antialias);
#else
color=texture2D(u_image0,v_pos0);
#endif
#ifdef FOG
color=fog_dither(fog_apply_premultiplied(color,v_fog_pos));
#endif
gl_FragColor=color;
#ifdef TERRAIN_WIREFRAME
gl_FragColor=vec4(1.0,0.0,0.0,0.8);
#endif
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_proj_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform float u_zoom_transition;uniform vec2 u_merc_center;uniform mat3 u_grid_matrix;uniform float u_skirt_height;
#ifdef GLOBE_POLES
attribute vec3 a_globe_pos;attribute vec2 a_uv;
#else
attribute vec2 a_pos;
#endif
varying vec2 v_pos0;const float wireframeOffset=1e3;float mercatorXfromLng(float lng) {return (180.0+lng)/360.0;}float mercatorYfromLat(float lat) {return (180.0-(RAD_TO_DEG*log(tan(QUARTER_PI+lat/2.0*DEG_TO_RAD))))/360.0;}vec3 latLngToECEF(vec2 latLng) {latLng=DEG_TO_RAD*latLng;float cosLat=cos(latLng[0]);float sinLat=sin(latLng[0]);float cosLng=cos(latLng[1]);float sinLng=sin(latLng[1]);float sx=cosLat*sinLng*GLOBE_RADIUS;float sy=-sinLat*GLOBE_RADIUS;float sz=cosLat*cosLng*GLOBE_RADIUS;return vec3(sx,sy,sz);}void main() {
#ifdef GLOBE_POLES
vec3 globe_pos=a_globe_pos;vec2 uv=a_uv;
#else
float tiles=u_grid_matrix[0][2];float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];vec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);float mercatorY=mercatorYfromLat(latLng[0]);float uvY=mercatorY*tiles-idy;float mercatorX=mercatorXfromLng(latLng[1]);float uvX=mercatorX*tiles-idx;vec3 globe_pos=latLngToECEF(latLng.xy);vec2 merc_pos=vec2(mercatorX,mercatorY);vec2 uv=vec2(uvX,uvY);
#endif
v_pos0=uv;vec2 tile_pos=uv*EXTENT;vec3 globe_derived_up_vector=normalize(globe_pos)*u_tile_up_scale;
#ifdef GLOBE_POLES
vec3 up_vector=globe_derived_up_vector;
#else
vec3 up_vector=elevationVector(tile_pos);
#endif
float height=elevation(tile_pos);
#ifdef TERRAIN_WIREFRAME
height+=wireframeOffset;
#endif
globe_pos+=up_vector*height;
#ifndef GLOBE_POLES
globe_pos-=globe_derived_up_vector*u_skirt_height*decomposed_pos_and_skirt.z;
#endif
#ifdef GLOBE_POLES
vec4 interpolated_pos=u_globe_matrix*vec4(globe_pos,1.0);
#else
vec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);if (u_zoom_transition > 0.0) {merc_world_pos=vec4(merc_pos,height-u_skirt_height*decomposed_pos_and_skirt.z,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition),1.0);
#endif
gl_Position=u_proj_matrix*interpolated_pos;
#ifdef FOG
v_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);
#endif
}`),
                globeAtmosphere: fi(`uniform float u_transition;uniform highp float u_fadeout_range;uniform highp float u_temporal_offset;uniform vec3 u_start_color;uniform vec4 u_color;uniform vec4 u_space_color;uniform vec4 u_high_color;uniform float u_star_intensity;uniform float u_star_size;uniform float u_star_density;uniform float u_horizon_angle;uniform mat4 u_rotation_matrix;varying highp vec3 v_ray_dir;varying highp vec3 v_horizon_dir;highp float random(highp vec3 p) {p=fract(p*vec3(23.2342,97.1231,91.2342));p+=dot(p.zxy,p.yxz+123.1234);return fract(p.x*p.y);}float stars(vec3 p,float scale,vec2 offset) {vec2 uv_scale=(u_viewport/u_star_size)*scale;vec3 position=vec3(p.xy*uv_scale+offset*u_viewport,p.z);vec3 q=fract(position)-0.5;vec3 id=floor(position);float random_visibility=step(random(id),u_star_density);float circle=smoothstep(0.5+u_star_intensity,0.5,length(q));return circle*random_visibility;}void main() {highp vec3 dir=normalize(v_ray_dir);float globe_pos_dot_dir;
#ifdef PROJECTION_GLOBE_VIEW
globe_pos_dot_dir=dot(u_globe_pos,dir);highp vec3 closest_point_forward=abs(globe_pos_dot_dir)*dir;float norm_dist_from_center=length(closest_point_forward-u_globe_pos)/u_globe_radius;if (norm_dist_from_center < 0.98) {discard;return;}
#endif
highp vec3 horizon_dir=normalize(v_horizon_dir);float horizon_angle_mercator=dir.y < horizon_dir.y ?
0.0 : max(acos(dot(dir,horizon_dir)),0.0);float horizon_angle;
#ifdef PROJECTION_GLOBE_VIEW
highp vec3 closest_point=globe_pos_dot_dir*dir;float closest_point_to_center=length(closest_point-u_globe_pos);float theta=asin(clamp(closest_point_to_center/length(u_globe_pos),-1.0,1.0));horizon_angle=globe_pos_dot_dir < 0.0 ?
PI-theta-u_horizon_angle : theta-u_horizon_angle;float angle_t=pow(u_transition,10.0);horizon_angle=mix(horizon_angle,horizon_angle_mercator,angle_t);
#else
horizon_angle=horizon_angle_mercator;
#endif
horizon_angle/=PI;float t=exp(-horizon_angle/u_fadeout_range);float alpha_0=u_color.a;float alpha_1=u_high_color.a;float alpha_2=u_space_color.a;vec3 color_stop_0=u_color.rgb;vec3 color_stop_1=u_high_color.rgb;vec3 color_stop_2=u_space_color.rgb;vec3 c0=mix(color_stop_2,color_stop_1,alpha_1);vec3 c1=mix(c0,color_stop_0,alpha_0);vec3 c2=mix(c0,c1,t);vec3 c =mix(color_stop_2,c2,t);float a0=mix(alpha_2,1.0,alpha_1);float a1=mix(a0,1.0,alpha_0);float a2=mix(a0,a1,t);float a =mix(alpha_2,a2,t);vec2 uv=gl_FragCoord.xy/u_viewport-0.5;float aspect_ratio=u_viewport.x/u_viewport.y;vec4 uv_dir=vec4(normalize(vec3(uv.x*aspect_ratio,uv.y,1.0)),1.0);uv_dir=u_rotation_matrix*uv_dir;vec3 n=abs(uv_dir.xyz);vec2 uv_remap=(n.x > n.y && n.x > n.z) ? uv_dir.yz/uv_dir.x:
(n.y > n.x && n.y > n.z) ? uv_dir.zx/uv_dir.y:
uv_dir.xy/uv_dir.z;uv_remap.x/=aspect_ratio;vec3 D=vec3(uv_remap,1.0);highp float star_field=0.0;if (u_star_intensity > 0.0) {star_field+=stars(D,1.2,vec2(0.0,0.0));star_field+=stars(D,1.0,vec2(1.0,0.0));star_field+=stars(D,0.8,vec2(0.0,1.0));star_field+=stars(D,0.6,vec2(1.0,1.0));star_field*=(1.0-pow(t,0.25+(1.0-u_high_color.a)*0.75));c+=star_field*alpha_2;}c=dither(c,gl_FragCoord.xy+u_temporal_offset);gl_FragColor=vec4(c,a);}`, `attribute vec3 a_pos;attribute vec2 a_uv;uniform vec3 u_frustum_tl;uniform vec3 u_frustum_tr;uniform vec3 u_frustum_br;uniform vec3 u_frustum_bl;uniform float u_horizon;varying highp vec3 v_ray_dir;varying highp vec3 v_horizon_dir;void main() {v_ray_dir=mix(
mix(u_frustum_tl,u_frustum_tr,a_uv.x),mix(u_frustum_bl,u_frustum_br,a_uv.x),a_uv.y);v_horizon_dir=mix(
mix(u_frustum_tl,u_frustum_bl,u_horizon),mix(u_frustum_tr,u_frustum_br,u_horizon),a_uv.x);gl_Position=vec4(a_pos,1.0);}`)
            };
            function Ca(m, l) {
                let h = m.replace(/\s*\/\/[^\n]*\n/g, `
`).split(`
`);
                for (let _ of h)
                    if (_ = _.trim(),
                    _[0] === "#" && _.includes("if") && !_.includes("endif")) {
                        _ = _.replace("#", "").replace(/ifdef|ifndef|elif|if/g, "").replace(/!|defined|\(|\)|\|\||&&/g, "").replace(/\s+/g, " ").trim();
                        let b = _.split(" ");
                        for (let T of b)
                            l.includes(T) || l.push(T)
                    }
            }
            function fi(m, l) {
                let h = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g
                  , _ = l.match(/attribute (highp |mediump |lowp )?([\w]+) ([\w]+)/g)
                  , b = {}
                  , T = [...vl];
                return Ca(m, T),
                Ca(l, T),
                {
                    fragmentSource: m = m.replace(h, (L,R,O,V,G)=>(b[G] = !0,
                    R === "define" ? `
#ifndef HAS_UNIFORM_u_ ${G}
varying ${O} ${V} ${G};
#else
uniform ${O} ${V} u_ ${G};
#endif
` : `
#ifdef HAS_UNIFORM_u_ ${G}
    ${O} ${V} ${G} = u_ ${G};
#endif
`)),
                    vertexSource: l = l.replace(h, (L,R,O,V,G)=>{
                        let J = V === "float" ? "vec2" : "vec4"
                          , le = G.match(/color/) ? "color" : J;
                        return b[G] ? R === "define" ? `
#ifndef HAS_UNIFORM_u_ ${G}
uniform lowp float u_ ${G}_t;
attribute ${O} ${J} a_ ${G};
varying ${O} ${V} ${G};
#else
uniform ${O} ${V} u_ ${G};
#endif
` : le === "vec4" ? `
#ifndef HAS_UNIFORM_u_ ${G}
    ${G} = a_ ${G};
#else
    ${O} ${V} ${G} = u_ ${G};
#endif
` : `
#ifndef HAS_UNIFORM_u_ ${G}
    ${G} = unpack_mix_ ${le}(a_ ${G}, u_ ${G}_t);
#else
    ${O} ${V} ${G} = u_ ${G};
#endif
` : R === "define" ? `
#ifndef HAS_UNIFORM_u_ ${G}
uniform lowp float u_ ${G}_t;
attribute ${O} ${J} a_ ${G};
#else
uniform ${O} ${V} u_ ${G};
#endif
` : le === "vec4" ? `
#ifndef HAS_UNIFORM_u_ ${G}
    ${O} ${V} ${G} = a_ ${G};
#else
    ${O} ${V} ${G} = u_ ${G};
#endif
` : `
#ifndef HAS_UNIFORM_u_ ${G}
    ${O} ${V} ${G} = unpack_mix_ ${le}(a_ ${G}, u_ ${G}_t);
#else
    ${O} ${V} ${G} = u_ ${G};
#endif
`
                    }
                    ),
                    staticAttributes: _,
                    usedDefines: T
                }
            }
            class Nc {
                constructor() {
                    this.boundProgram = null,
                    this.boundLayoutVertexBuffer = null,
                    this.boundPaintVertexBuffers = [],
                    this.boundIndexBuffer = null,
                    this.boundVertexOffset = null,
                    this.boundDynamicVertexBuffers = [],
                    this.vao = null
                }
                bind(l, h, _, b, T, L, R) {
                    this.context = l;
                    let O = this.boundPaintVertexBuffers.length !== b.length;
                    for (let G = 0; !O && G < b.length; G++)
                        this.boundPaintVertexBuffers[G] !== b[G] && (O = !0);
                    let V = this.boundDynamicVertexBuffers.length !== R.length;
                    for (let G = 0; !V && G < R.length; G++)
                        this.boundDynamicVertexBuffers[G] !== R[G] && (V = !0);
                    if (!l.extVertexArrayObject || !this.vao || this.boundProgram !== h || this.boundLayoutVertexBuffer !== _ || O || V || this.boundIndexBuffer !== T || this.boundVertexOffset !== L)
                        this.freshBind(h, _, b, T, L, R);
                    else {
                        l.bindVertexArrayOES.set(this.vao);
                        for (let G of R)
                            G && G.bind();
                        T && T.dynamicDraw && T.bind()
                    }
                }
                freshBind(l, h, _, b, T, L) {
                    let R, O = l.numAttributes, V = this.context, G = V.gl;
                    if (V.extVertexArrayObject)
                        this.vao && this.destroy(),
                        this.vao = V.extVertexArrayObject.createVertexArrayOES(),
                        V.bindVertexArrayOES.set(this.vao),
                        R = 0,
                        this.boundProgram = l,
                        this.boundLayoutVertexBuffer = h,
                        this.boundPaintVertexBuffers = _,
                        this.boundIndexBuffer = b,
                        this.boundVertexOffset = T,
                        this.boundDynamicVertexBuffers = L;
                    else {
                        R = V.currentNumAttributes || 0;
                        for (let J = O; J < R; J++)
                            G.disableVertexAttribArray(J)
                    }
                    h.enableAttributes(G, l),
                    h.bind(),
                    h.setVertexAttribPointers(G, l, T);
                    for (let J of _)
                        J.enableAttributes(G, l),
                        J.bind(),
                        J.setVertexAttribPointers(G, l, T);
                    for (let J of L)
                        J && (J.enableAttributes(G, l),
                        J.bind(),
                        J.setVertexAttribPointers(G, l, T));
                    b && b.bind(),
                    V.currentNumAttributes = O
                }
                destroy() {
                    this.vao && (this.context.extVertexArrayObject.deleteVertexArrayOES(this.vao),
                    this.vao = null)
                }
            }
            function Tf(m, l) {
                let h = Math.pow(2, l.canonical.z)
                  , _ = l.canonical.y;
                return [new i.MercatorCoordinate(0,_ / h).toLngLat().lat, new i.MercatorCoordinate(0,(_ + 1) / h).toLngLat().lat]
            }
            function Fc(m, l, h, _, b, T, L) {
                let R = m.context
                  , O = R.gl
                  , V = h.fbo;
                if (!V)
                    return;
                m.prepareDrawTile();
                let G = m.useProgram("hillshade");
                R.activeTexture.set(O.TEXTURE0),
                O.bindTexture(O.TEXTURE_2D, V.colorAttachment.get());
                let J = ((ge,ve,re,Ce)=>{
                    let Ae = re.paint.get("hillshade-shadow-color")
                      , De = re.paint.get("hillshade-highlight-color")
                      , Ve = re.paint.get("hillshade-accent-color")
                      , Fe = re.paint.get("hillshade-illumination-direction") * (Math.PI / 180);
                    re.paint.get("hillshade-illumination-anchor") === "viewport" && (Fe -= ge.transform.angle);
                    let Xe = !ge.options.moving;
                    return {
                        u_matrix: Ce || ge.transform.calculateProjMatrix(ve.tileID.toUnwrapped(), Xe),
                        u_image: 0,
                        u_latrange: Tf(0, ve.tileID),
                        u_light: [re.paint.get("hillshade-exaggeration"), Fe],
                        u_shadow: Ae,
                        u_highlight: De,
                        u_accent: Ve
                    }
                }
                )(m, h, _, m.terrain ? l.projMatrix : null);
                m.prepareDrawProgram(R, G, l.toUnwrapped());
                let {tileBoundsBuffer: le, tileBoundsIndexBuffer: me, tileBoundsSegments: pe} = m.getTileBoundsBuffers(h);
                G.draw(R, O.TRIANGLES, b, T, L, i.CullFaceMode.disabled, J, _.id, le, me, pe)
            }
            function Bc(m, l, h) {
                if (!l.needsDEMTextureUpload)
                    return;
                let _ = m.context
                  , b = _.gl;
                _.pixelStoreUnpackPremultiplyAlpha.set(!1),
                l.demTexture = l.demTexture || m.getTileTexture(h.stride);
                let T = h.getPixels();
                l.demTexture ? l.demTexture.update(T, {
                    premultiply: !1
                }) : l.demTexture = new i.Texture(_,T,b.RGBA,{
                    premultiply: !1
                }),
                l.needsDEMTextureUpload = !1
            }
            function bh(m, l, h, _, b, T) {
                let L = m.context
                  , R = L.gl;
                if (!l.dem)
                    return;
                let O = l.dem;
                if (L.activeTexture.set(R.TEXTURE1),
                Bc(m, l, O),
                !l.demTexture)
                    return;
                l.demTexture.bind(R.NEAREST, R.CLAMP_TO_EDGE);
                let V = O.dim;
                L.activeTexture.set(R.TEXTURE0);
                let G = l.fbo;
                if (!G) {
                    let pe = new i.Texture(L,{
                        width: V,
                        height: V,
                        data: null
                    },R.RGBA);
                    pe.bind(R.LINEAR, R.CLAMP_TO_EDGE),
                    G = l.fbo = L.createFramebuffer(V, V, !0),
                    G.colorAttachment.set(pe.texture)
                }
                L.bindFramebuffer.set(G.framebuffer),
                L.viewport.set([0, 0, V, V]);
                let {tileBoundsBuffer: J, tileBoundsIndexBuffer: le, tileBoundsSegments: me} = m.getMercatorTileBoundsBuffers();
                m.useProgram("hillshadePrepare").draw(L, R.TRIANGLES, _, b, T, i.CullFaceMode.disabled, ((pe,ge)=>{
                    let ve = ge.stride
                      , re = i.create();
                    return i.ortho(re, 0, i.EXTENT, -i.EXTENT, 0, 0, 1),
                    i.translate(re, re, [0, -i.EXTENT, 0]),
                    {
                        u_matrix: re,
                        u_image: 1,
                        u_dimension: [ve, ve],
                        u_zoom: pe.overscaledZ,
                        u_unpack: ge.unpackVector
                    }
                }
                )(l.tileID, O), h.id, J, le, me),
                l.needsHillshadePrepare = !1
            }
            let wh = m=>({
                u_matrix: new i.UniformMatrix4f(m),
                u_image0: new i.Uniform1i(m),
                u_skirt_height: new i.Uniform1f(m)
            })
              , Ef = (m,l)=>({
                u_matrix: m,
                u_image0: 0,
                u_skirt_height: l
            })
              , Th = (m,l,h,_,b,T,L,R,O,V,G,J,le,me,pe)=>({
                u_proj_matrix: Float32Array.from(m),
                u_globe_matrix: l,
                u_normalize_matrix: Float32Array.from(_),
                u_merc_matrix: h,
                u_zoom_transition: b,
                u_merc_center: T,
                u_image0: 0,
                u_frustum_tl: L,
                u_frustum_tr: R,
                u_frustum_br: O,
                u_frustum_bl: V,
                u_globe_pos: G,
                u_globe_radius: J,
                u_viewport: le,
                u_grid_matrix: pe ? Float32Array.from(pe) : new Float32Array(9),
                u_skirt_height: me
            });
            function Sf(m, l) {
                return m != null && l != null && !(!m.hasData() || !l.hasData()) && m.demTexture != null && l.demTexture != null && m.tileID.key !== l.tileID.key
            }
            let Yo = new class {
                constructor() {
                    this.operations = {}
                }
                newMorphing(m, l, h, _, b) {
                    if (m in this.operations) {
                        let T = this.operations[m];
                        T.to.tileID.key !== h.tileID.key && (T.queued = h)
                    } else
                        this.operations[m] = {
                            startTime: _,
                            phase: 0,
                            duration: b,
                            from: l,
                            to: h,
                            queued: null
                        }
                }
                getMorphValuesForProxy(m) {
                    if (!(m in this.operations))
                        return null;
                    let l = this.operations[m];
                    return {
                        from: l.from,
                        to: l.to,
                        phase: l.phase
                    }
                }
                update(m) {
                    for (let l in this.operations) {
                        let h = this.operations[l];
                        for (h.phase = (m - h.startTime) / h.duration; h.phase >= 1 || !this._validOp(h); )
                            if (!this._nextOp(h, m)) {
                                delete this.operations[l];
                                break
                            }
                    }
                }
                _nextOp(m, l) {
                    return !!m.queued && (m.from = m.to,
                    m.to = m.queued,
                    m.queued = null,
                    m.phase = 0,
                    m.startTime = l,
                    !0)
                }
                _validOp(m) {
                    return m.from.hasData() && m.to.hasData()
                }
            }
              , Da = {
                0: null,
                1: "TERRAIN_VERTEX_MORPHING",
                2: "TERRAIN_WIREFRAME"
            };
            function Eh(m) {
                return 6 * Math.pow(1.5, 22 - m)
            }
            function Af(m, l) {
                let h = 1 << m.z;
                return !l && (m.x === 0 || m.x === h - 1) || m.y === 0 || m.y === h - 1
            }
            let si = m=>({
                u_matrix: m
            });
            function Uc(m, l, h, _, b) {
                if (b > 0) {
                    let T = i.exported.now()
                      , L = (T - m.timeAdded) / b
                      , R = l ? (T - l.timeAdded) / b : -1
                      , O = h.getSource()
                      , V = _.coveringZoomLevel({
                        tileSize: O.tileSize,
                        roundZoom: O.roundZoom
                    })
                      , G = !l || Math.abs(l.tileID.overscaledZ - V) > Math.abs(m.tileID.overscaledZ - V)
                      , J = G && m.refreshedUponExpiration ? 1 : i.clamp(G ? L : 1 - R, 0, 1);
                    return m.refreshedUponExpiration && L >= 1 && (m.refreshedUponExpiration = !1),
                    l ? {
                        opacity: 1,
                        mix: 1 - J
                    } : {
                        opacity: J,
                        mix: 0
                    }
                }
                return {
                    opacity: 1,
                    mix: 0
                }
            }
            class gg extends i.SourceCache {
                constructor(l) {
                    let h = {
                        type: "raster-dem",
                        maxzoom: l.transform.maxZoom
                    }
                      , _ = new Gt(fn(),null)
                      , b = He("mock-dem", h, _, l.style);
                    super("mock-dem", b, !1),
                    b.setEventedParent(this),
                    this._sourceLoaded = !0
                }
                _loadTile(l, h) {
                    l.state = "loaded",
                    h(null)
                }
            }
            class _g extends i.SourceCache {
                constructor(l) {
                    let h = He("proxy", {
                        type: "geojson",
                        maxzoom: l.transform.maxZoom
                    }, new Gt(fn(),null), l.style);
                    super("proxy", h, !1),
                    h.setEventedParent(this),
                    this.map = this.getSource().map = l,
                    this.used = this._sourceLoaded = !0,
                    this.renderCache = [],
                    this.renderCachePool = [],
                    this.proxyCachedFBO = {}
                }
                update(l, h, _) {
                    if (l.freezeTileCoverage)
                        return;
                    this.transform = l;
                    let b = l.coveringTiles({
                        tileSize: this._source.tileSize,
                        minzoom: this._source.minzoom,
                        maxzoom: this._source.maxzoom,
                        roundZoom: this._source.roundZoom,
                        reparseOverscaled: this._source.reparseOverscaled
                    }).reduce((T,L)=>{
                        if (T[L.key] = "",
                        !this._tiles[L.key]) {
                            let R = new i.Tile(L,this._source.tileSize * L.overscaleFactor(),l.tileZoom);
                            R.state = "loaded",
                            this._tiles[L.key] = R
                        }
                        return T
                    }
                    , {});
                    for (let T in this._tiles)
                        T in b || (this.freeFBO(T),
                        this._tiles[T].unloadVectorData(),
                        delete this._tiles[T])
                }
                freeFBO(l) {
                    let h = this.proxyCachedFBO[l];
                    if (h !== void 0) {
                        let _ = Object.values(h);
                        this.renderCachePool.push(..._),
                        delete this.proxyCachedFBO[l]
                    }
                }
                deallocRenderCache() {
                    this.renderCache.forEach(l=>l.fb.destroy()),
                    this.renderCache = [],
                    this.renderCachePool = [],
                    this.proxyCachedFBO = {}
                }
            }
            class Mf extends i.OverscaledTileID {
                constructor(l, h, _) {
                    super(l.overscaledZ, l.wrap, l.canonical.z, l.canonical.x, l.canonical.y),
                    this.proxyTileKey = h,
                    this.projMatrix = _
                }
            }
            class If extends i.Elevation {
                constructor(l, h) {
                    super(),
                    this.painter = l,
                    this.terrainTileForTile = {},
                    this.prevTerrainTileForTile = {};
                    let[_,b,T] = function(O) {
                        let V = new i.StructArrayLayout2i4
                          , G = new i.StructArrayLayout3ui6
                          , J = 131;
                        V.reserve(17161),
                        G.reserve(33800);
                        let le = i.EXTENT / 128
                          , me = i.EXTENT + le / 2
                          , pe = me + le;
                        for (let ve = -le; ve < pe; ve += le)
                            for (let re = -le; re < pe; re += le) {
                                let Ce = re < 0 || re > me || ve < 0 || ve > me ? 24575 : 0
                                  , Ae = i.clamp(Math.round(re), 0, i.EXTENT)
                                  , De = i.clamp(Math.round(ve), 0, i.EXTENT);
                                V.emplaceBack(Ae + Ce, De)
                            }
                        let ge = (ve,re)=>{
                            let Ce = re * J + ve;
                            G.emplaceBack(Ce + 1, Ce, Ce + J),
                            G.emplaceBack(Ce + J, Ce + J + 1, Ce + 1)
                        }
                        ;
                        for (let ve = 1; ve < 129; ve++)
                            for (let re = 1; re < 129; re++)
                                ge(re, ve);
                        return [0, 129].forEach(ve=>{
                            for (let re = 0; re < 130; re++)
                                ge(re, ve),
                                ge(ve, re)
                        }
                        ),
                        [V, G, 32768]
                    }()
                      , L = l.context;
                    this.gridBuffer = L.createVertexBuffer(_, i.posAttributes.members),
                    this.gridIndexBuffer = L.createIndexBuffer(b),
                    this.gridSegments = i.SegmentVector.simpleSegment(0, 0, _.length, b.length),
                    this.gridNoSkirtSegments = i.SegmentVector.simpleSegment(0, 0, _.length, T),
                    this.proxyCoords = [],
                    this.proxiedCoords = {},
                    this._visibleDemTiles = [],
                    this._drapedRenderBatches = [],
                    this._sourceTilesOverlap = {},
                    this.proxySourceCache = new _g(h.map),
                    this.orthoMatrix = i.create(),
                    i.ortho(this.orthoMatrix, this.painter.transform.projection.name === "globe" ? .015 : 0, i.EXTENT, 0, i.EXTENT, 0, 1);
                    let R = L.gl;
                    this._overlapStencilMode = new i.StencilMode({
                        func: R.GEQUAL,
                        mask: 255
                    },0,255,R.KEEP,R.KEEP,R.REPLACE),
                    this._previousZoom = l.transform.zoom,
                    this.pool = [],
                    this._findCoveringTileCache = {},
                    this._tilesDirty = {},
                    this.style = h,
                    this._useVertexMorphing = !0,
                    this._exaggeration = 1,
                    this._mockSourceCache = new gg(h.map)
                }
                set style(l) {
                    l.on("data", this._onStyleDataEvent.bind(this)),
                    l.on("neworder", this._checkRenderCacheEfficiency.bind(this)),
                    this._style = l,
                    this._checkRenderCacheEfficiency(),
                    this._style.map.on("moveend", ()=>{
                        this._clearLineLayersFromRenderCache()
                    }
                    )
                }
                update(l, h, _) {
                    if (l && l.terrain) {
                        this._style !== l && (this.style = l),
                        this.enabled = !0;
                        let b = l.terrain.properties;
                        this.sourceCache = l.terrain.drapeRenderMode === 0 ? this._mockSourceCache : l._getSourceCache(b.get("source")),
                        this._exaggeration = b.get("exaggeration");
                        let T = ()=>{
                            this.sourceCache.used && i.warnOnce(`Raster DEM source '${this.sourceCache.id}' is used both for terrain and as layer source.
This leads to lower resolution of hillshade. For full hillshade resolution but higher memory consumption, define another raster DEM source.`);
                            let L = this.getScaledDemTileSize();
                            this.sourceCache.update(h, L, !0),
                            this.resetTileLookupCache(this.sourceCache.id)
                        }
                        ;
                        this.sourceCache.usedForTerrain || (this.resetTileLookupCache(this.sourceCache.id),
                        this.sourceCache.usedForTerrain = !0,
                        T(),
                        this._initializing = !0),
                        T(),
                        h.updateElevation(!0, _),
                        this.resetTileLookupCache(this.proxySourceCache.id),
                        this.proxySourceCache.update(h),
                        this._emptyDEMTextureDirty = !0
                    } else
                        this._disable()
                }
                resetTileLookupCache(l) {
                    this._findCoveringTileCache[l] = {}
                }
                getScaledDemTileSize() {
                    return this.sourceCache.getSource().tileSize / 128 * this.proxySourceCache.getSource().tileSize
                }
                _checkRenderCacheEfficiency() {
                    let l = this.renderCacheEfficiency(this._style);
                    this._style.map._optimizeForTerrain || l.efficiency !== 100 && i.warnOnce(`Terrain render cache efficiency is not optimal (${l.efficiency}%) and performance
                may be affected negatively, consider placing all background, fill and line layers before layer
                with id '${l.firstUndrapedLayer}' or create a map using optimizeForTerrain: true option.`)
                }
                _onStyleDataEvent(l) {
                    l.coord && l.dataType === "source" ? this._clearRenderCacheForTile(l.sourceCacheId, l.coord) : l.dataType === "style" && (this._invalidateRenderCache = !0)
                }
                _disable() {
                    if (this.enabled && (this.enabled = !1,
                    this._sharedDepthStencil = void 0,
                    this.proxySourceCache.deallocRenderCache(),
                    this._style))
                        for (let l in this._style._sourceCaches)
                            this._style._sourceCaches[l].usedForTerrain = !1
                }
                destroy() {
                    this._disable(),
                    this._emptyDEMTexture && this._emptyDEMTexture.destroy(),
                    this._emptyDepthBufferTexture && this._emptyDepthBufferTexture.destroy(),
                    this.pool.forEach(l=>l.fb.destroy()),
                    this.pool = [],
                    this._depthFBO && (this._depthFBO.destroy(),
                    this._depthFBO = void 0,
                    this._depthTexture = void 0)
                }
                _source() {
                    return this.enabled ? this.sourceCache : null
                }
                isUsingMockSource() {
                    return this.sourceCache === this._mockSourceCache
                }
                exaggeration() {
                    return this._exaggeration
                }
                get visibleDemTiles() {
                    return this._visibleDemTiles
                }
                get drapeBufferSize() {
                    let l = 2 * this.proxySourceCache.getSource().tileSize;
                    return [l, l]
                }
                set useVertexMorphing(l) {
                    this._useVertexMorphing = l
                }
                updateTileBinding(l) {
                    if (!this.enabled)
                        return;
                    this.prevTerrainTileForTile = this.terrainTileForTile;
                    let h = this.proxySourceCache
                      , _ = this.painter.transform;
                    this._initializing && (this._initializing = _._centerAltitude === 0 && this.getAtPointOrZero(i.MercatorCoordinate.fromLngLat(_.center), -1) === -1,
                    this._emptyDEMTextureDirty = !this._initializing);
                    let b = this.proxyCoords = h.getIds().map(O=>{
                        let V = h.getTileByID(O).tileID;
                        return V.projMatrix = _.calculateProjMatrix(V.toUnwrapped()),
                        V
                    }
                    );
                    (function(O, V) {
                        let G = V.transform.pointCoordinate(V.transform.getCameraPoint())
                          , J = new i.pointGeometry(G.x,G.y);
                        O.sort((le,me)=>{
                            if (me.overscaledZ - le.overscaledZ)
                                return me.overscaledZ - le.overscaledZ;
                            let pe = new i.pointGeometry(le.canonical.x + (1 << le.canonical.z) * le.wrap,le.canonical.y)
                              , ge = new i.pointGeometry(me.canonical.x + (1 << me.canonical.z) * me.wrap,me.canonical.y)
                              , ve = J.mult(1 << le.canonical.z);
                            return ve.x -= .5,
                            ve.y -= .5,
                            ve.distSqr(pe) - ve.distSqr(ge)
                        }
                        )
                    }
                    )(b, this.painter),
                    this._previousZoom = _.zoom;
                    let T = this.proxyToSource || {};
                    this.proxyToSource = {},
                    b.forEach(O=>{
                        this.proxyToSource[O.key] = {}
                    }
                    ),
                    this.terrainTileForTile = {};
                    let L = this._style._sourceCaches;
                    for (let O in L) {
                        let V = L[O];
                        if (!V.used || (V !== this.sourceCache && this.resetTileLookupCache(V.id),
                        this._setupProxiedCoordsForOrtho(V, l[O], T),
                        V.usedForTerrain))
                            continue;
                        let G = l[O];
                        V.getSource().reparseOverscaled && this._assignTerrainTiles(G)
                    }
                    this.proxiedCoords[h.id] = b.map(O=>new Mf(O,O.key,this.orthoMatrix)),
                    this._assignTerrainTiles(b),
                    this._prepareDEMTextures(),
                    this._setupDrapedRenderBatches(),
                    this._initFBOPool(),
                    this._setupRenderCache(T),
                    this.renderingToTexture = !1,
                    this._updateTimestamp = i.exported.now();
                    let R = {};
                    this._visibleDemTiles = [];
                    for (let O of this.proxyCoords) {
                        let V = this.terrainTileForTile[O.key];
                        if (!V)
                            continue;
                        let G = V.tileID.key;
                        G in R || (this._visibleDemTiles.push(V),
                        R[G] = G)
                    }
                }
                _assignTerrainTiles(l) {
                    this._initializing || l.forEach(h=>{
                        if (this.terrainTileForTile[h.key])
                            return;
                        let _ = this._findTileCoveringTileID(h, this.sourceCache);
                        _ && (this.terrainTileForTile[h.key] = _)
                    }
                    )
                }
                _prepareDEMTextures() {
                    let l = this.painter.context
                      , h = l.gl;
                    for (let _ in this.terrainTileForTile) {
                        let b = this.terrainTileForTile[_]
                          , T = b.dem;
                        !T || b.demTexture && !b.needsDEMTextureUpload || (l.activeTexture.set(h.TEXTURE1),
                        Bc(this.painter, b, T))
                    }
                }
                _prepareDemTileUniforms(l, h, _, b) {
                    if (!h || h.demTexture == null)
                        return !1;
                    let T = l.tileID.canonical
                      , L = Math.pow(2, h.tileID.canonical.z - T.z)
                      , R = b || "";
                    return _[`u_dem_tl ${R}`] = [T.x * L % 1, T.y * L % 1],
                    _[`u_dem_scale ${R}`] = L,
                    !0
                }
                get emptyDEMTexture() {
                    return !this._emptyDEMTextureDirty && this._emptyDEMTexture ? this._emptyDEMTexture : this._updateEmptyDEMTexture()
                }
                get emptyDepthBufferTexture() {
                    let l = this.painter.context
                      , h = l.gl;
                    if (!this._emptyDepthBufferTexture) {
                        let _ = new i.RGBAImage({
                            width: 1,
                            height: 1
                        },Uint8Array.of(255, 255, 255, 255));
                        this._emptyDepthBufferTexture = new i.Texture(l,_,h.RGBA,{
                            premultiply: !1
                        })
                    }
                    return this._emptyDepthBufferTexture
                }
                _getLoadedAreaMinimum() {
                    let l = 0
                      , h = this._visibleDemTiles.reduce((_,b)=>{
                        if (!b.dem)
                            return _;
                        let T = b.dem.tree.minimums[0];
                        return T > 0 && l++,
                        _ + T
                    }
                    , 0);
                    return l ? h / l : 0
                }
                _updateEmptyDEMTexture() {
                    let l = this.painter.context
                      , h = l.gl;
                    l.activeTexture.set(h.TEXTURE2);
                    let _ = this._getLoadedAreaMinimum()
                      , b = new i.RGBAImage({
                        width: 1,
                        height: 1
                    },new Uint8Array(i.DEMData.pack(_, this.sourceCache.getSource().encoding)));
                    this._emptyDEMTextureDirty = !1;
                    let T = this._emptyDEMTexture;
                    return T ? T.update(b, {
                        premultiply: !1
                    }) : T = this._emptyDEMTexture = new i.Texture(l,b,h.RGBA,{
                        premultiply: !1
                    }),
                    T
                }
                setupElevationDraw(l, h, _) {
                    let b = this.painter.context
                      , T = b.gl
                      , L = (R = this.sourceCache.getSource().encoding,
                    {
                        u_dem: 2,
                        u_dem_prev: 4,
                        u_dem_unpack: i.DEMData.getUnpackVector(R),
                        u_dem_tl: [0, 0],
                        u_dem_tl_prev: [0, 0],
                        u_dem_scale: 0,
                        u_dem_scale_prev: 0,
                        u_dem_size: 0,
                        u_dem_lerp: 1,
                        u_depth: 3,
                        u_depth_size_inv: [0, 0],
                        u_exaggeration: 0
                    });
                    var R;
                    L.u_dem_size = this.sourceCache.getSource().tileSize,
                    L.u_exaggeration = this.exaggeration();
                    let O = null
                      , V = null
                      , G = 1;
                    if (_ && _.morphing && this._useVertexMorphing) {
                        let J = _.morphing.srcDemTile
                          , le = _.morphing.dstDemTile;
                        G = _.morphing.phase,
                        J && le && (this._prepareDemTileUniforms(l, J, L, "_prev") && (V = J),
                        this._prepareDemTileUniforms(l, le, L) && (O = le))
                    }
                    if (V && O ? (b.activeTexture.set(T.TEXTURE2),
                    O.demTexture.bind(T.NEAREST, T.CLAMP_TO_EDGE, T.NEAREST),
                    b.activeTexture.set(T.TEXTURE4),
                    V.demTexture.bind(T.NEAREST, T.CLAMP_TO_EDGE, T.NEAREST),
                    L.u_dem_lerp = G) : (O = this.terrainTileForTile[l.tileID.key],
                    b.activeTexture.set(T.TEXTURE2),
                    (this._prepareDemTileUniforms(l, O, L) ? O.demTexture : this.emptyDEMTexture).bind(T.NEAREST, T.CLAMP_TO_EDGE)),
                    b.activeTexture.set(T.TEXTURE3),
                    _ && _.useDepthForOcclusion ? (this._depthTexture && this._depthTexture.bind(T.NEAREST, T.CLAMP_TO_EDGE),
                    this._depthFBO && (L.u_depth_size_inv = [1 / this._depthFBO.width, 1 / this._depthFBO.height])) : (this.emptyDepthBufferTexture.bind(T.NEAREST, T.CLAMP_TO_EDGE),
                    L.u_depth_size_inv = [1, 1]),
                    _ && _.useMeterToDem && O) {
                        let J = (1 << O.tileID.canonical.z) * i.mercatorZfromAltitude(1, this.painter.transform.center.lat) * this.sourceCache.getSource().tileSize;
                        L.u_meter_to_dem = J
                    }
                    if (_ && _.labelPlaneMatrixInv && (L.u_label_plane_matrix_inv = _.labelPlaneMatrixInv),
                    h.setTerrainUniformValues(b, L),
                    this.painter.transform.projection.name === "globe") {
                        let J = this.globeUniformValues(this.painter.transform, l.tileID.canonical, _ && _.useDenormalizedUpVectorScale);
                        h.setGlobeUniformValues(b, J)
                    }
                }
                globeUniformValues(l, h, _) {
                    let b = l.projection;
                    return {
                        u_tile_tl_up: b.upVector(h, 0, 0),
                        u_tile_tr_up: b.upVector(h, i.EXTENT, 0),
                        u_tile_br_up: b.upVector(h, i.EXTENT, i.EXTENT),
                        u_tile_bl_up: b.upVector(h, 0, i.EXTENT),
                        u_tile_up_scale: _ ? i.globeMetersToEcef(1) : b.upVectorScale(h, l.center.lat, l.worldSize).metersToTile
                    }
                }
                renderToBackBuffer(l) {
                    let h = this.painter
                      , _ = this.painter.context;
                    l.length !== 0 && (_.bindFramebuffer.set(null),
                    _.viewport.set([0, 0, h.width, h.height]),
                    h.gpuTimingDeferredRenderStart(),
                    this.renderingToTexture = !1,
                    function(b, T, L, R, O) {
                        if (b.transform.projection.name === "globe")
                            (function(V, G, J, le, me) {
                                let pe = V.context, ge = pe.gl, ve, re, Ce = V.options.showTerrainWireframe ? 2 : 0, Ae = V.transform, De = i.globeUseCustomAntiAliasing(V, pe, Ae), Ve = (Dt,st)=>{
                                    if (re === Dt)
                                        return;
                                    let Je = [Da[Dt], "PROJECTION_GLOBE_VIEW"];
                                    De && Je.push("CUSTOM_ANTIALIASING"),
                                    st && Je.push(Da[Ce]),
                                    ve = V.useProgram("globeRaster", null, Je),
                                    re = Dt
                                }
                                , Fe = V.colorModeForRenderPass(), Xe = new i.DepthMode(ge.LEQUAL,i.DepthMode.ReadWrite,V.depthRangeFor3D);
                                Yo.update(me);
                                let $e = i.calculateGlobeMercatorMatrix(Ae)
                                  , rt = [i.mercatorXfromLng(Ae.center.lng), i.mercatorYfromLat(Ae.center.lat)]
                                  , lt = Ce ? [!1, !0] : [!1]
                                  , Vt = V.globeSharedBuffers
                                  , nt = [Ae.width * i.exported.devicePixelRatio, Ae.height * i.exported.devicePixelRatio]
                                  , vt = Float32Array.from(Ae.globeMatrix)
                                  , pt = {
                                    useDenormalizedUpVectorScale: !0
                                };
                                if (lt.forEach(Dt=>{
                                    let st = V.transform
                                      , Je = Eh(st.zoom) * G.exaggeration();
                                    re = -1;
                                    let ct = Dt ? ge.LINES : ge.TRIANGLES;
                                    for (let At of le) {
                                        let Pt = J.getTile(At)
                                          , pn = i.StencilMode.disabled
                                          , Xn = G.prevTerrainTileForTile[At.key]
                                          , un = G.terrainTileForTile[At.key];
                                        Sf(Xn, un) && Yo.newMorphing(At.key, Xn, un, me, 250),
                                        pe.activeTexture.set(ge.TEXTURE0),
                                        Pt.texture.bind(ge.LINEAR, ge.CLAMP_TO_EDGE);
                                        let sn = Yo.getMorphValuesForProxy(At.key)
                                          , vn = sn ? 1 : 0;
                                        sn && i.extend$1(pt, {
                                            morphing: {
                                                srcDemTile: sn.from,
                                                dstDemTile: sn.to,
                                                phase: i.easeCubicInOut(sn.phase)
                                            }
                                        });
                                        let Qn = i.tileCornersToBounds(At.canonical)
                                          , En = i.getLatitudinalLod(Qn.getCenter().lat)
                                          , pi = i.getGridMatrix(At.canonical, Qn, En, st.worldSize / st._pixelsPerMercatorPixel)
                                          , Ti = i.globeNormalizeECEF(i.globeTileBounds(At.canonical))
                                          , Ri = Th(st.projMatrix, vt, $e, Ti, i.globeToMercatorTransition(st.zoom), rt, st.frustumCorners.TL, st.frustumCorners.TR, st.frustumCorners.BR, st.frustumCorners.BL, st.globeCenterInViewSpace, st.globeRadius, nt, Je, pi);
                                        if (Ve(vn, Dt),
                                        G.setupElevationDraw(Pt, ve, pt),
                                        V.prepareDrawProgram(pe, ve, At.toUnwrapped()),
                                        Vt) {
                                            let[Mi,lr,gs] = Dt ? Vt.getWirefameBuffers(V.context, En) : Vt.getGridBuffers(En, Je !== 0);
                                            ve.draw(pe, ct, Xe, pn, Fe, i.CullFaceMode.backCCW, Ri, "globe_raster", Mi, lr, gs)
                                        }
                                    }
                                }
                                ),
                                Vt) {
                                    let Dt = ["GLOBE_POLES", "PROJECTION_GLOBE_VIEW"];
                                    De && Dt.push("CUSTOM_ANTIALIASING"),
                                    ve = V.useProgram("globeRaster", null, Dt);
                                    for (let st of le) {
                                        let {x: Je, y: ct, z: At} = st.canonical
                                          , Pt = ct === 0
                                          , pn = ct === (1 << At) - 1
                                          , [Xn,un,sn,vn] = Vt.getPoleBuffers(At);
                                        if (vn && (Pt || pn)) {
                                            let Qn = J.getTile(st);
                                            pe.activeTexture.set(ge.TEXTURE0),
                                            Qn.texture.bind(ge.LINEAR, ge.CLAMP_TO_EDGE);
                                            let En = i.globePoleMatrixForTile(At, Je, Ae)
                                              , pi = i.globeNormalizeECEF(i.globeTileBounds(st.canonical))
                                              , Ti = (Ri,Mi)=>Ri.draw(pe, ge.TRIANGLES, Xe, i.StencilMode.disabled, Fe, i.CullFaceMode.disabled, Th(Ae.projMatrix, En, En, pi, 0, rt, Ae.frustumCorners.TL, Ae.frustumCorners.TR, Ae.frustumCorners.BR, Ae.frustumCorners.BL, Ae.globeCenterInViewSpace, Ae.globeRadius, nt, 0), "globe_pole_raster", Mi, sn, vn);
                                            G.setupElevationDraw(Qn, ve, pt),
                                            V.prepareDrawProgram(pe, ve, st.toUnwrapped()),
                                            Pt && Ti(ve, Xn),
                                            pn && (En = i.scale(i.create(), En, [1, -1, 1]),
                                            Ti(ve, un))
                                        }
                                    }
                                }
                            }
                            )(b, T, L, R, O);
                        else {
                            let V = b.context, G = V.gl, J, le, me = b.options.showTerrainWireframe ? 2 : 0, pe = (Ae,De)=>{
                                if (le === Ae)
                                    return;
                                let Ve = [Da[Ae]];
                                De && Ve.push(Da[me]),
                                J = b.useProgram("terrainRaster", null, Ve),
                                le = Ae
                            }
                            , ge = b.colorModeForRenderPass(), ve = new i.DepthMode(G.LEQUAL,i.DepthMode.ReadWrite,b.depthRangeFor3D);
                            Yo.update(O);
                            let re = b.transform
                              , Ce = Eh(re.zoom) * T.exaggeration();
                            (me ? [!1, !0] : [!1]).forEach(Ae=>{
                                le = -1;
                                let De = Ae ? G.LINES : G.TRIANGLES
                                  , [Ve,Fe] = Ae ? T.getWirefameBuffer() : [T.gridIndexBuffer, T.gridSegments];
                                for (let Xe of R) {
                                    let $e = L.getTile(Xe)
                                      , rt = i.StencilMode.disabled
                                      , lt = T.prevTerrainTileForTile[Xe.key]
                                      , Vt = T.terrainTileForTile[Xe.key];
                                    Sf(lt, Vt) && Yo.newMorphing(Xe.key, lt, Vt, O, 250),
                                    V.activeTexture.set(G.TEXTURE0),
                                    $e.texture.bind(G.LINEAR, G.CLAMP_TO_EDGE, G.LINEAR_MIPMAP_NEAREST);
                                    let nt = Yo.getMorphValuesForProxy(Xe.key), vt = nt ? 1 : 0, pt;
                                    nt && (pt = {
                                        morphing: {
                                            srcDemTile: nt.from,
                                            dstDemTile: nt.to,
                                            phase: i.easeCubicInOut(nt.phase)
                                        }
                                    });
                                    let Dt = Ef(Xe.projMatrix, Af(Xe.canonical, re.renderWorldCopies) ? Ce / 10 : Ce);
                                    pe(vt, Ae),
                                    T.setupElevationDraw($e, J, pt),
                                    b.prepareDrawProgram(V, J, Xe.toUnwrapped()),
                                    J.draw(V, De, ve, rt, ge, i.CullFaceMode.backCCW, Dt, "terrain_raster", T.gridBuffer, Ve, Fe)
                                }
                            }
                            )
                        }
                    }(h, this, this.proxySourceCache, l, this._updateTimestamp),
                    this.renderingToTexture = !0,
                    h.gpuTimingDeferredRenderEnd(),
                    l.splice(0, l.length))
                }
                renderBatch(l) {
                    if (this._drapedRenderBatches.length === 0)
                        return l + 1;
                    this.renderingToTexture = !0;
                    let h = this.painter
                      , _ = this.painter.context
                      , b = this.proxySourceCache
                      , T = this.proxiedCoords[b.id]
                      , L = this._drapedRenderBatches.shift()
                      , R = []
                      , O = h.style.order
                      , V = 0;
                    for (let G of T) {
                        let J = b.getTileByID(G.proxyTileKey)
                          , le = b.proxyCachedFBO[G.key] ? b.proxyCachedFBO[G.key][l] : void 0
                          , me = le !== void 0 ? b.renderCache[le] : this.pool[V++]
                          , pe = le !== void 0;
                        if (J.texture = me.tex,
                        pe && !me.dirty) {
                            R.push(J.tileID);
                            continue
                        }
                        let ge;
                        _.bindFramebuffer.set(me.fb.framebuffer),
                        this.renderedToTile = !1,
                        me.dirty && (_.clear({
                            color: i.Color.transparent,
                            stencil: 0
                        }),
                        me.dirty = !1);
                        for (let ve = L.start; ve <= L.end; ++ve) {
                            let re = h.style._layers[O[ve]];
                            if (re.isHidden(h.transform.zoom))
                                continue;
                            let Ce = h.style._getLayerSourceCache(re)
                              , Ae = Ce ? this.proxyToSource[G.key][Ce.id] : [G];
                            if (!Ae)
                                continue;
                            let De = Ae;
                            _.viewport.set([0, 0, me.fb.width, me.fb.height]),
                            ge !== (Ce ? Ce.id : null) && (this._setupStencil(me, Ae, re, Ce),
                            ge = Ce ? Ce.id : null),
                            h.renderLayer(h, Ce, re, De)
                        }
                        this.renderedToTile ? (me.dirty = !0,
                        R.push(J.tileID)) : pe || --V,
                        V === 5 && (V = 0,
                        this.renderToBackBuffer(R))
                    }
                    return this.renderToBackBuffer(R),
                    this.renderingToTexture = !1,
                    _.bindFramebuffer.set(null),
                    _.viewport.set([0, 0, h.width, h.height]),
                    L.end + 1
                }
                postRender() {}
                renderCacheEfficiency(l) {
                    let h = l.order.length;
                    if (h === 0)
                        return {
                            efficiency: 100
                        };
                    let _, b = 0, T = 0, L = !1;
                    for (let R = 0; R < h; ++R) {
                        let O = l._layers[l.order[R]];
                        this._style.isLayerDraped(O) ? (L && ++b,
                        ++T) : L || (L = !0,
                        _ = O.id)
                    }
                    return T === 0 ? {
                        efficiency: 100
                    } : {
                        efficiency: 100 * (1 - b / T),
                        firstUndrapedLayer: _
                    }
                }
                getMinElevationBelowMSL() {
                    let l = 0;
                    return this._visibleDemTiles.filter(h=>h.dem).forEach(h=>{
                        l = Math.min(l, h.dem.tree.minimums[0])
                    }
                    ),
                    l === 0 ? l : (l - 30) * this._exaggeration
                }
                raycast(l, h, _) {
                    if (!this._visibleDemTiles)
                        return null;
                    let b = this._visibleDemTiles.filter(T=>T.dem).map(T=>{
                        let L = T.tileID
                          , R = 1 << L.overscaledZ
                          , {x: O, y: V} = L.canonical
                          , G = O / R
                          , J = (O + 1) / R
                          , le = V / R
                          , me = (V + 1) / R;
                        return {
                            minx: G,
                            miny: le,
                            maxx: J,
                            maxy: me,
                            t: T.dem.tree.raycastRoot(G, le, J, me, l, h, _),
                            tile: T
                        }
                    }
                    );
                    b.sort((T,L)=>(T.t !== null ? T.t : Number.MAX_VALUE) - (L.t !== null ? L.t : Number.MAX_VALUE));
                    for (let T of b) {
                        if (T.t == null)
                            return null;
                        let L = T.tile.dem.tree.raycast(T.minx, T.miny, T.maxx, T.maxy, l, h, _);
                        if (L != null)
                            return L
                    }
                    return null
                }
                _createFBO() {
                    let l = this.painter.context
                      , h = l.gl
                      , _ = this.drapeBufferSize;
                    l.activeTexture.set(h.TEXTURE0);
                    let b = new i.Texture(l,{
                        width: _[0],
                        height: _[1],
                        data: null
                    },h.RGBA);
                    b.bind(h.LINEAR, h.CLAMP_TO_EDGE);
                    let T = l.createFramebuffer(_[0], _[1], !1);
                    return T.colorAttachment.set(b.texture),
                    T.depthAttachment = new Ps(l,T.framebuffer),
                    this._sharedDepthStencil === void 0 ? (this._sharedDepthStencil = l.createRenderbuffer(l.gl.DEPTH_STENCIL, _[0], _[1]),
                    this._stencilRef = 0,
                    T.depthAttachment.set(this._sharedDepthStencil),
                    l.clear({
                        stencil: 0
                    })) : T.depthAttachment.set(this._sharedDepthStencil),
                    l.extTextureFilterAnisotropic && !l.extTextureFilterAnisotropicForceOff && h.texParameterf(h.TEXTURE_2D, l.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, l.extTextureFilterAnisotropicMax),
                    {
                        fb: T,
                        tex: b,
                        dirty: !1
                    }
                }
                _initFBOPool() {
                    for (; this.pool.length < Math.min(5, this.proxyCoords.length); )
                        this.pool.push(this._createFBO())
                }
                _shouldDisableRenderCache() {
                    if (this._style.light && this._style.light.hasTransition())
                        return !0;
                    for (let l in this._style._sourceCaches)
                        if (this._style._sourceCaches[l].hasTransition())
                            return !0;
                    return this._style.order.some(l=>{
                        let h = this._style._layers[l]
                          , _ = h.isHidden(this.painter.transform.zoom);
                        return h.type === "custom" ? !_ && h.shouldRedrape() : !_ && h.hasTransition()
                    }
                    )
                }
                _clearLineLayersFromRenderCache() {
                    let l = !1;
                    for (let _ of this._style._getSources())
                        if (_ instanceof Y) {
                            l = !0;
                            break
                        }
                    if (!l)
                        return;
                    let h = {};
                    for (let _ = 0; _ < this._style.order.length; ++_) {
                        let b = this._style._layers[this._style.order[_]]
                          , T = this._style._getLayerSourceCache(b);
                        if (T && !h[T.id] && !b.isHidden(this.painter.transform.zoom) && b.type === "line" && b.widthExpression()instanceof i.ZoomDependentExpression) {
                            h[T.id] = !0;
                            for (let L of this.proxyCoords) {
                                let R = this.proxyToSource[L.key][T.id];
                                if (R)
                                    for (let O of R)
                                        this._clearRenderCacheForTile(T.id, O)
                            }
                        }
                    }
                }
                _clearRasterLayersFromRenderCache() {
                    let l = !1;
                    for (let _ in this._style._sourceCaches)
                        if (this._style._sourceCaches[_]._source instanceof F) {
                            l = !0;
                            break
                        }
                    if (!l)
                        return;
                    let h = {};
                    for (let _ = 0; _ < this._style.order.length; ++_) {
                        let b = this._style._layers[this._style.order[_]]
                          , T = this._style._getLayerSourceCache(b);
                        if (!T || h[T.id] || b.isHidden(this.painter.transform.zoom) || b.type !== "raster")
                            continue;
                        let L = b.paint.get("raster-fade-duration");
                        for (let R of this.proxyCoords) {
                            let O = this.proxyToSource[R.key][T.id];
                            if (O)
                                for (let V of O) {
                                    let G = Uc(T.getTile(V), T.findLoadedParent(V, 0), T, this.painter.transform, L);
                                    (G.opacity !== 1 || G.mix !== 0) && this._clearRenderCacheForTile(T.id, V)
                                }
                        }
                    }
                }
                _setupDrapedRenderBatches() {
                    let l = this._style.order
                      , h = l.length;
                    if (h === 0)
                        return;
                    let _ = [], b, T = 0, L = this._style._layers[l[T]];
                    for (; !this._style.isLayerDraped(L) && L.isHidden(this.painter.transform.zoom) && ++T < h; )
                        L = this._style._layers[l[T]];
                    for (; T < h; ++T) {
                        let R = this._style._layers[l[T]];
                        R.isHidden(this.painter.transform.zoom) || (this._style.isLayerDraped(R) ? b === void 0 && (b = T) : b !== void 0 && (_.push({
                            start: b,
                            end: T - 1
                        }),
                        b = void 0))
                    }
                    b !== void 0 && _.push({
                        start: b,
                        end: T - 1
                    }),
                    this._drapedRenderBatches = _
                }
                _setupRenderCache(l) {
                    let h = this.proxySourceCache;
                    if (this._shouldDisableRenderCache() || this._invalidateRenderCache) {
                        if (this._invalidateRenderCache = !1,
                        h.renderCache.length > h.renderCachePool.length) {
                            let L = Object.values(h.proxyCachedFBO);
                            h.proxyCachedFBO = {};
                            for (let R = 0; R < L.length; ++R) {
                                let O = Object.values(L[R]);
                                h.renderCachePool.push(...O)
                            }
                        }
                        return
                    }
                    this._clearRasterLayersFromRenderCache();
                    let _ = this.proxyCoords
                      , b = this._tilesDirty;
                    for (let L = _.length - 1; L >= 0; L--) {
                        let R = _[L];
                        if (h.getTileByID(R.key),
                        h.proxyCachedFBO[R.key] !== void 0) {
                            let O = l[R.key]
                              , V = this.proxyToSource[R.key]
                              , G = 0;
                            for (let J in V) {
                                let le = V[J]
                                  , me = O[J];
                                if (!me || me.length !== le.length || le.some((pe,ge)=>pe !== me[ge] || b[J] && b[J].hasOwnProperty(pe.key))) {
                                    G = -1;
                                    break
                                }
                                ++G
                            }
                            for (let J in h.proxyCachedFBO[R.key])
                                h.renderCache[h.proxyCachedFBO[R.key][J]].dirty = G < 0 || G !== Object.values(O).length
                        }
                    }
                    let T = [...this._drapedRenderBatches];
                    T.sort((L,R)=>R.end - R.start - (L.end - L.start));
                    for (let L of T)
                        for (let R of _) {
                            if (h.proxyCachedFBO[R.key])
                                continue;
                            let O = h.renderCachePool.pop();
                            O === void 0 && h.renderCache.length < 50 && (O = h.renderCache.length,
                            h.renderCache.push(this._createFBO())),
                            O !== void 0 && (h.proxyCachedFBO[R.key] = {},
                            h.proxyCachedFBO[R.key][L.start] = O,
                            h.renderCache[O].dirty = !0)
                        }
                    this._tilesDirty = {}
                }
                _setupStencil(l, h, _, b) {
                    if (!b || !this._sourceTilesOverlap[b.id])
                        return void (this._overlapStencilType && (this._overlapStencilType = !1));
                    let T = this.painter.context
                      , L = T.gl;
                    if (h.length <= 1)
                        return void (this._overlapStencilType = !1);
                    let R;
                    if (_.isTileClipped())
                        R = h.length,
                        this._overlapStencilMode.test = {
                            func: L.EQUAL,
                            mask: 255
                        },
                        this._overlapStencilType = "Clip";
                    else {
                        if (!(h[0].overscaledZ > h[h.length - 1].overscaledZ))
                            return void (this._overlapStencilType = !1);
                        R = 1,
                        this._overlapStencilMode.test = {
                            func: L.GREATER,
                            mask: 255
                        },
                        this._overlapStencilType = "Mask"
                    }
                    this._stencilRef + R > 255 && (T.clear({
                        stencil: 0
                    }),
                    this._stencilRef = 0),
                    this._stencilRef += R,
                    this._overlapStencilMode.ref = this._stencilRef,
                    _.isTileClipped() && this._renderTileClippingMasks(h, this._overlapStencilMode.ref)
                }
                clipOrMaskOverlapStencilType() {
                    return this._overlapStencilType === "Clip" || this._overlapStencilType === "Mask"
                }
                stencilModeForRTTOverlap(l) {
                    return this.renderingToTexture && this._overlapStencilType ? (this._overlapStencilType === "Clip" && (this._overlapStencilMode.ref = this.painter._tileClippingMaskIDs[l.key]),
                    this._overlapStencilMode) : i.StencilMode.disabled
                }
                _renderTileClippingMasks(l, h) {
                    let _ = this.painter
                      , b = this.painter.context
                      , T = b.gl;
                    _._tileClippingMaskIDs = {},
                    b.setColorMode(i.ColorMode.disabled),
                    b.setDepthMode(i.DepthMode.disabled);
                    let L = _.useProgram("clippingMask");
                    for (let R of l) {
                        let O = _._tileClippingMaskIDs[R.key] = --h;
                        L.draw(b, T.TRIANGLES, i.DepthMode.disabled, new i.StencilMode({
                            func: T.ALWAYS,
                            mask: 0
                        },O,255,T.KEEP,T.KEEP,T.REPLACE), i.ColorMode.disabled, i.CullFaceMode.disabled, si(R.projMatrix), "$clipping", _.tileExtentBuffer, _.quadTriangleIndexBuffer, _.tileExtentSegments)
                    }
                }
                pointCoordinate(l) {
                    let h = this.painter.transform;
                    if (l.x < 0 || l.x > h.width || l.y < 0 || l.y > h.height)
                        return null;
                    let _ = [l.x, l.y, 1, 1];
                    i.transformMat4$1(_, _, h.pixelMatrixInverse),
                    i.scale$1(_, _, 1 / _[3]),
                    _[0] /= h.worldSize,
                    _[1] /= h.worldSize;
                    let b = h._camera.position
                      , T = i.mercatorZfromAltitude(1, h.center.lat)
                      , L = [b[0], b[1], b[2] / T, 0]
                      , R = i.subtract([], _.slice(0, 3), L);
                    i.normalize(R, R);
                    let O = this.raycast(L, R, this._exaggeration);
                    return O !== null && O ? (i.scaleAndAdd(L, L, R, O),
                    L[3] = L[2],
                    L[2] *= T,
                    L) : null
                }
                drawDepth() {
                    let l = this.painter
                      , h = l.context
                      , _ = this.proxySourceCache
                      , b = Math.ceil(l.width)
                      , T = Math.ceil(l.height);
                    if (!this._depthFBO || this._depthFBO.width === b && this._depthFBO.height === T || (this._depthFBO.destroy(),
                    this._depthFBO = void 0,
                    this._depthTexture = void 0),
                    !this._depthFBO) {
                        let L = h.gl
                          , R = h.createFramebuffer(b, T, !0);
                        h.activeTexture.set(L.TEXTURE0);
                        let O = new i.Texture(h,{
                            width: b,
                            height: T,
                            data: null
                        },L.RGBA);
                        O.bind(L.NEAREST, L.CLAMP_TO_EDGE),
                        R.colorAttachment.set(O.texture);
                        let V = h.createRenderbuffer(h.gl.DEPTH_COMPONENT16, b, T);
                        R.depthAttachment.set(V),
                        this._depthFBO = R,
                        this._depthTexture = O
                    }
                    h.bindFramebuffer.set(this._depthFBO.framebuffer),
                    h.viewport.set([0, 0, b, T]),
                    function(L, R, O, V) {
                        if (L.transform.projection.name === "globe")
                            return;
                        let G = L.context
                          , J = G.gl;
                        G.clear({
                            depth: 1
                        });
                        let le = L.useProgram("terrainDepth")
                          , me = new i.DepthMode(J.LESS,i.DepthMode.ReadWrite,L.depthRangeFor3D);
                        for (let pe of V) {
                            let ge = O.getTile(pe)
                              , ve = Ef(pe.projMatrix, 0);
                            R.setupElevationDraw(ge, le),
                            le.draw(G, J.TRIANGLES, me, i.StencilMode.disabled, i.ColorMode.unblended, i.CullFaceMode.backCCW, ve, "terrain_depth", R.gridBuffer, R.gridIndexBuffer, R.gridNoSkirtSegments)
                        }
                    }(l, this, _, this.proxyCoords)
                }
                _setupProxiedCoordsForOrtho(l, h, _) {
                    if (l.getSource()instanceof ue)
                        return this._setupProxiedCoordsForImageSource(l, h, _);
                    this._findCoveringTileCache[l.id] = this._findCoveringTileCache[l.id] || {};
                    let b = this.proxiedCoords[l.id] = []
                      , T = this.proxyCoords;
                    for (let R = 0; R < T.length; R++) {
                        let O = T[R]
                          , V = this._findTileCoveringTileID(O, l);
                        if (V) {
                            let G = this._createProxiedId(O, V, _[O.key] && _[O.key][l.id]);
                            b.push(G),
                            this.proxyToSource[O.key][l.id] = [G]
                        }
                    }
                    let L = !1;
                    for (let R = 0; R < h.length; R++) {
                        let O = l.getTile(h[R]);
                        if (!O || !O.hasData())
                            continue;
                        let V = this._findTileCoveringTileID(O.tileID, this.proxySourceCache);
                        if (V && V.tileID.canonical.z !== O.tileID.canonical.z) {
                            let G = this.proxyToSource[V.tileID.key][l.id]
                              , J = this._createProxiedId(V.tileID, O, _[V.tileID.key] && _[V.tileID.key][l.id]);
                            G ? G.splice(G.length - 1, 0, J) : this.proxyToSource[V.tileID.key][l.id] = [J],
                            b.push(J),
                            L = !0
                        }
                    }
                    this._sourceTilesOverlap[l.id] = L
                }
                _setupProxiedCoordsForImageSource(l, h, _) {
                    if (!l.getSource().loaded())
                        return;
                    let b = this.proxiedCoords[l.id] = []
                      , T = this.proxyCoords
                      , L = l.getSource()
                      , R = new i.pointGeometry(L.tileID.x,L.tileID.y)._div(1 << L.tileID.z)
                      , O = L.coordinates.map(i.MercatorCoordinate.fromLngLat).reduce((G,J)=>(G.min.x = Math.min(G.min.x, J.x - R.x),
                    G.min.y = Math.min(G.min.y, J.y - R.y),
                    G.max.x = Math.max(G.max.x, J.x - R.x),
                    G.max.y = Math.max(G.max.y, J.y - R.y),
                    G), {
                        min: new i.pointGeometry(Number.MAX_VALUE,Number.MAX_VALUE),
                        max: new i.pointGeometry(-Number.MAX_VALUE,-Number.MAX_VALUE)
                    })
                      , V = (G,J)=>{
                        let le = G.wrap + G.canonical.x / (1 << G.canonical.z)
                          , me = G.canonical.y / (1 << G.canonical.z)
                          , pe = i.EXTENT / (1 << G.canonical.z)
                          , ge = J.wrap + J.canonical.x / (1 << J.canonical.z)
                          , ve = J.canonical.y / (1 << J.canonical.z);
                        return le + pe < ge + O.min.x || le > ge + O.max.x || me + pe < ve + O.min.y || me > ve + O.max.y
                    }
                    ;
                    for (let G = 0; G < T.length; G++) {
                        let J = T[G];
                        for (let le = 0; le < h.length; le++) {
                            let me = l.getTile(h[le]);
                            if (!me || !me.hasData() || V(J, me.tileID))
                                continue;
                            let pe = this._createProxiedId(J, me, _[J.key] && _[J.key][l.id])
                              , ge = this.proxyToSource[J.key][l.id];
                            ge ? ge.push(pe) : this.proxyToSource[J.key][l.id] = [pe],
                            b.push(pe)
                        }
                    }
                }
                _createProxiedId(l, h, _) {
                    let b = this.orthoMatrix;
                    if (_) {
                        let T = _.find(L=>L.key === h.tileID.key);
                        if (T)
                            return T
                    }
                    if (h.tileID.key !== l.key) {
                        let T = l.canonical.z - h.tileID.canonical.z, L, R, O;
                        b = i.create();
                        let V = h.tileID.wrap - l.wrap << l.overscaledZ;
                        T > 0 ? (L = i.EXTENT >> T,
                        R = L * ((h.tileID.canonical.x << T) - l.canonical.x + V),
                        O = L * ((h.tileID.canonical.y << T) - l.canonical.y)) : (L = i.EXTENT << -T,
                        R = i.EXTENT * (h.tileID.canonical.x - (l.canonical.x + V << -T)),
                        O = i.EXTENT * (h.tileID.canonical.y - (l.canonical.y << -T))),
                        i.ortho(b, 0, L, 0, L, 0, 1),
                        i.translate(b, b, [R, O, 0])
                    }
                    return new Mf(h.tileID,l.key,b)
                }
                _findTileCoveringTileID(l, h) {
                    let _ = h.getTile(l);
                    if (_ && _.hasData())
                        return _;
                    let b = this._findCoveringTileCache[h.id]
                      , T = b[l.key];
                    if (_ = T ? h.getTileByID(T) : null,
                    _ && _.hasData() || T === null)
                        return _;
                    let L = _ ? _.tileID : l
                      , R = L.overscaledZ
                      , O = h.getSource().minzoom
                      , V = [];
                    if (!T) {
                        let J = h.getSource().maxzoom;
                        if (l.canonical.z >= J) {
                            let le = l.canonical.z - J;
                            h.getSource().reparseOverscaled ? (R = Math.max(l.canonical.z + 2, h.transform.tileZoom),
                            L = new i.OverscaledTileID(R,l.wrap,J,l.canonical.x >> le,l.canonical.y >> le)) : le !== 0 && (R = J,
                            L = new i.OverscaledTileID(R,l.wrap,J,l.canonical.x >> le,l.canonical.y >> le))
                        }
                        L.key !== l.key && (V.push(L.key),
                        _ = h.getTile(L))
                    }
                    let G = J=>{
                        V.forEach(le=>{
                            b[le] = J
                        }
                        ),
                        V.length = 0
                    }
                    ;
                    for (R -= 1; R >= O && (!_ || !_.hasData()); R--) {
                        _ && G(_.tileID.key);
                        let J = L.calculateScaledKey(R);
                        if (_ = h.getTileByID(J),
                        _ && _.hasData())
                            break;
                        let le = b[J];
                        if (le === null)
                            break;
                        le === void 0 ? V.push(J) : _ = h.getTileByID(le)
                    }
                    return G(_ ? _.tileID.key : null),
                    _ && _.hasData() ? _ : null
                }
                findDEMTileFor(l) {
                    return this.enabled ? this._findTileCoveringTileID(l, this.sourceCache) : null
                }
                prepareDrawTile() {
                    this.renderedToTile = !0
                }
                _clearRenderCacheForTile(l, h) {
                    let _ = this._tilesDirty[l];
                    _ || (_ = this._tilesDirty[l] = {}),
                    _[h.key] = !0
                }
                getWirefameBuffer() {
                    if (!this.wireframeSegments) {
                        let l = function(h) {
                            let _ = 0
                              , b = new i.StructArrayLayout2ui4
                              , T = 131;
                            for (let L = 1; L < 129; L++) {
                                for (let R = 1; R < 129; R++)
                                    _ = L * T + R,
                                    b.emplaceBack(_, _ + 1),
                                    b.emplaceBack(_, _ + T),
                                    b.emplaceBack(_ + 1, _ + T),
                                    L === 128 && b.emplaceBack(_ + T, _ + T + 1);
                                b.emplaceBack(_ + 1, _ + 1 + T)
                            }
                            return b
                        }();
                        this.wireframeIndexBuffer = this.painter.context.createIndexBuffer(l),
                        this.wireframeSegments = i.SegmentVector.simpleSegment(0, 0, this.gridBuffer.length, l.length)
                    }
                    return [this.wireframeIndexBuffer, this.wireframeSegments]
                }
            }
            class Cf {
                static cacheKey(l, h, _, b) {
                    let T = `${h}${b ? b.cacheKey : ""}`;
                    for (let L of _)
                        l.usedDefines.includes(L) && (T += `/${L}`);
                    return T
                }
                constructor(l, h, _, b, T, L) {
                    let R = l.gl;
                    this.program = R.createProgram();
                    let O = function(re) {
                        let Ce = [];
                        for (let Ae = 0; Ae < re.length; Ae++) {
                            if (re[Ae] === null)
                                continue;
                            let De = re[Ae].split(" ");
                            Ce.push(De.pop())
                        }
                        return Ce
                    }(_.staticAttributes)
                      , V = b ? b.getBinderAttributes() : []
                      , G = O.concat(V)
                      , J = b ? b.defines() : [];
                    J = J.concat(L.map(re=>`#define ${re}`));
                    let le = l.isWebGL2 ? `#version 300 es
` : ""
                      , me = le + J.concat(l.extStandardDerivatives && le.length === 0 ? `#extension GL_OES_standard_derivatives : enable
`.concat(vh) : vh, vh, xh, mg.fragmentSource, bf.fragmentSource, _.fragmentSource).join(`
`)
                      , pe = le + J.concat(`
#ifdef GL_ES
precision highp float;
#else

#if !defined(lowp)
#define lowp
#endif

#if !defined(mediump)
#define mediump
#endif

#if !defined(highp)
#define highp
#endif

#endif`, xh, mg.vertexSource, bf.vertexSource, vf.vertexSource, _.vertexSource).join(`
`)
                      , ge = R.createShader(R.FRAGMENT_SHADER);
                    if (R.isContextLost())
                        return void (this.failedToCreate = !0);
                    R.shaderSource(ge, me),
                    R.compileShader(ge),
                    R.attachShader(this.program, ge);
                    let ve = R.createShader(R.VERTEX_SHADER);
                    if (R.isContextLost())
                        this.failedToCreate = !0;
                    else {
                        R.shaderSource(ve, pe),
                        R.compileShader(ve),
                        R.attachShader(this.program, ve),
                        this.attributes = {},
                        this.numAttributes = G.length;
                        for (let re = 0; re < this.numAttributes; re++)
                            G[re] && (R.bindAttribLocation(this.program, re, G[re]),
                            this.attributes[G[re]] = re);
                        R.linkProgram(this.program),
                        R.deleteShader(ve),
                        R.deleteShader(ge),
                        this.fixedUniforms = T(l),
                        this.binderUniforms = b ? b.getUniforms(l) : [],
                        L.includes("TERRAIN") && (this.terrainUniforms = (re=>({
                            u_dem: new i.Uniform1i(re),
                            u_dem_prev: new i.Uniform1i(re),
                            u_dem_unpack: new i.Uniform4f(re),
                            u_dem_tl: new i.Uniform2f(re),
                            u_dem_scale: new i.Uniform1f(re),
                            u_dem_tl_prev: new i.Uniform2f(re),
                            u_dem_scale_prev: new i.Uniform1f(re),
                            u_dem_size: new i.Uniform1f(re),
                            u_dem_lerp: new i.Uniform1f(re),
                            u_exaggeration: new i.Uniform1f(re),
                            u_depth: new i.Uniform1i(re),
                            u_depth_size_inv: new i.Uniform2f(re),
                            u_meter_to_dem: new i.Uniform1f(re),
                            u_label_plane_matrix_inv: new i.UniformMatrix4f(re)
                        }))(l)),
                        L.includes("GLOBE") && (this.globeUniforms = (re=>({
                            u_tile_tl_up: new i.Uniform3f(re),
                            u_tile_tr_up: new i.Uniform3f(re),
                            u_tile_br_up: new i.Uniform3f(re),
                            u_tile_bl_up: new i.Uniform3f(re),
                            u_tile_up_scale: new i.Uniform1f(re)
                        }))(l)),
                        L.includes("FOG") && (this.fogUniforms = (re=>({
                            u_fog_matrix: new i.UniformMatrix4f(re),
                            u_fog_range: new i.Uniform2f(re),
                            u_fog_color: new i.Uniform4f(re),
                            u_fog_horizon_blend: new i.Uniform1f(re),
                            u_fog_temporal_offset: new i.Uniform1f(re),
                            u_frustum_tl: new i.Uniform3f(re),
                            u_frustum_tr: new i.Uniform3f(re),
                            u_frustum_br: new i.Uniform3f(re),
                            u_frustum_bl: new i.Uniform3f(re),
                            u_globe_pos: new i.Uniform3f(re),
                            u_globe_radius: new i.Uniform1f(re),
                            u_globe_transition: new i.Uniform1f(re),
                            u_is_globe: new i.Uniform1i(re),
                            u_viewport: new i.Uniform2f(re)
                        }))(l))
                    }
                }
                setTerrainUniformValues(l, h) {
                    if (!this.terrainUniforms)
                        return;
                    let _ = this.terrainUniforms;
                    if (!this.failedToCreate) {
                        l.program.set(this.program);
                        for (let b in h)
                            _[b] && _[b].set(this.program, b, h[b])
                    }
                }
                setGlobeUniformValues(l, h) {
                    if (!this.globeUniforms)
                        return;
                    let _ = this.globeUniforms;
                    if (!this.failedToCreate) {
                        l.program.set(this.program);
                        for (let b in h)
                            _[b] && _[b].set(this.program, b, h[b])
                    }
                }
                setFogUniformValues(l, h) {
                    if (!this.fogUniforms)
                        return;
                    let _ = this.fogUniforms;
                    if (!this.failedToCreate) {
                        l.program.set(this.program);
                        for (let b in h)
                            _[b].set(this.program, b, h[b])
                    }
                }
                draw(l, h, _, b, T, L, R, O, V, G, J, le, me, pe, ge) {
                    let ve = l.gl;
                    if (this.failedToCreate)
                        return;
                    l.program.set(this.program),
                    l.setDepthMode(_),
                    l.setStencilMode(b),
                    l.setColorMode(T),
                    l.setCullFace(L);
                    for (let Ce of Object.keys(this.fixedUniforms))
                        this.fixedUniforms[Ce].set(this.program, Ce, R[Ce]);
                    pe && pe.setUniforms(this.program, l, this.binderUniforms, le, {
                        zoom: me
                    });
                    let re = {
                        [ve.LINES]: 2,
                        [ve.TRIANGLES]: 3,
                        [ve.LINE_STRIP]: 1
                    }[h];
                    for (let Ce of J.get()) {
                        let Ae = Ce.vaos || (Ce.vaos = {});
                        (Ae[O] || (Ae[O] = new Nc)).bind(l, this, V, pe ? pe.getPaintVertexBuffers() : [], G, Ce.vertexOffset, ge || []),
                        ve.drawElements(h, Ce.primitiveLength * re, ve.UNSIGNED_SHORT, Ce.primitiveOffset * re * 2)
                    }
                }
            }
            function yg(m, l) {
                let h = Math.pow(2, l.tileID.overscaledZ)
                  , _ = l.tileSize * Math.pow(2, m.transform.tileZoom) / h
                  , b = _ * (l.tileID.canonical.x + l.tileID.wrap * h)
                  , T = _ * l.tileID.canonical.y;
                return {
                    u_image: 0,
                    u_texsize: l.imageAtlasTexture.size,
                    u_tile_units_to_pixels: 1 / Ye(l, 1, m.transform.tileZoom),
                    u_pixel_coord_upper: [b >> 16, T >> 16],
                    u_pixel_coord_lower: [65535 & b, 65535 & T]
                }
            }
            let Q0 = i.create()
              , Sh = (m,l,h,_,b,T,L,R,O,V,G)=>{
                let J = l.style.light
                  , le = J.properties.get("position")
                  , me = [le.x, le.y, le.z]
                  , pe = i.create$1();
                J.properties.get("anchor") === "viewport" && (i.fromRotation(pe, -l.transform.angle),
                i.transformMat3(me, me, pe));
                let ge = J.properties.get("color")
                  , ve = l.transform
                  , re = {
                    u_matrix: m,
                    u_lightpos: me,
                    u_lightintensity: J.properties.get("intensity"),
                    u_lightcolor: [ge.r, ge.g, ge.b],
                    u_vertical_gradient: +h,
                    u_opacity: _,
                    u_tile_id: [0, 0, 0],
                    u_zoom_transition: 0,
                    u_inv_rot_matrix: Q0,
                    u_merc_center: [0, 0],
                    u_up_dir: [0, 0, 0],
                    u_height_lift: 0,
                    u_ao: b,
                    u_edge_radius: T
                };
                return ve.projection.name === "globe" && (re.u_tile_id = [L.canonical.x, L.canonical.y, 1 << L.canonical.z],
                re.u_zoom_transition = O,
                re.u_inv_rot_matrix = G,
                re.u_merc_center = V,
                re.u_up_dir = ve.projection.upVector(new i.CanonicalTileID(0,0,0), V[0] * i.EXTENT, V[1] * i.EXTENT),
                re.u_height_lift = R),
                re
            }
              , Df = (m,l,h,_,b,T,L,R,O,V,G,J)=>{
                let le = Sh(m, l, h, _, b, T, L, O, V, G, J)
                  , me = {
                    u_height_factor: -Math.pow(2, L.overscaledZ) / R.tileSize / 8
                };
                return i.extend(le, yg(l, R), me)
            }
              , Ah = m=>({
                u_matrix: m
            })
              , Mh = (m,l,h)=>i.extend(Ah(m), yg(l, h))
              , xg = (m,l)=>({
                u_matrix: m,
                u_world: l
            })
              , vg = (m,l,h,_)=>i.extend(Mh(m, l, h), {
                u_world: _
            })
              , ex = i.create()
              , Vc = (m,l,h,_,b,T)=>{
                let L = m.transform, R = L.projection.name === "globe", O;
                if (T.paint.get("circle-pitch-alignment") === "map")
                    if (R) {
                        let G = i.globePixelsToTileUnits(L.zoom, l.canonical) * L._pixelsPerMercatorPixel;
                        O = Float32Array.from([G, 0, 0, G])
                    } else
                        O = L.calculatePixelsToTileUnitsMatrix(h);
                else
                    O = new Float32Array([L.pixelsToGLUnits[0], 0, 0, L.pixelsToGLUnits[1]]);
                let V = {
                    u_camera_to_center_distance: L.cameraToCenterDistance,
                    u_matrix: m.translatePosMatrix(l.projMatrix, h, T.paint.get("circle-translate"), T.paint.get("circle-translate-anchor")),
                    u_device_pixel_ratio: i.exported.devicePixelRatio,
                    u_extrude_scale: O,
                    u_inv_rot_matrix: ex,
                    u_merc_center: [0, 0],
                    u_tile_id: [0, 0, 0],
                    u_zoom_transition: 0,
                    u_up_dir: [0, 0, 0]
                };
                if (R) {
                    V.u_inv_rot_matrix = _,
                    V.u_merc_center = b,
                    V.u_tile_id = [l.canonical.x, l.canonical.y, 1 << l.canonical.z],
                    V.u_zoom_transition = i.globeToMercatorTransition(L.zoom);
                    let G = b[0] * i.EXTENT
                      , J = b[1] * i.EXTENT;
                    V.u_up_dir = L.projection.upVector(new i.CanonicalTileID(0,0,0), G, J)
                }
                return V
            }
              , Gc = m=>{
                let l = [];
                return m.paint.get("circle-pitch-alignment") === "map" && l.push("PITCH_WITH_MAP"),
                m.paint.get("circle-pitch-scale") === "map" && l.push("SCALE_WITH_MAP"),
                l
            }
              , bg = (m,l,h,_)=>{
                let b = i.EXTENT / h.tileSize;
                return {
                    u_matrix: m,
                    u_camera_to_center_distance: l.getCameraToCenterDistance(_),
                    u_extrude_scale: [l.pixelsToGLUnits[0] / b, l.pixelsToGLUnits[1] / b]
                }
            }
              , Hc = (m,l,h=1)=>({
                u_matrix: m,
                u_color: l,
                u_overlay: 0,
                u_overlay_scale: h
            })
              , Lf = i.create()
              , co = (m,l,h,_,b,T,L)=>{
                let R = m.transform
                  , O = R.projection.name === "globe"
                  , V = O ? i.globePixelsToTileUnits(R.zoom, l.canonical) * R._pixelsPerMercatorPixel : Ye(h, 1, T)
                  , G = {
                    u_matrix: l.projMatrix,
                    u_extrude_scale: V,
                    u_intensity: L,
                    u_inv_rot_matrix: Lf,
                    u_merc_center: [0, 0],
                    u_tile_id: [0, 0, 0],
                    u_zoom_transition: 0,
                    u_up_dir: [0, 0, 0]
                };
                if (O) {
                    G.u_inv_rot_matrix = _,
                    G.u_merc_center = b,
                    G.u_tile_id = [l.canonical.x, l.canonical.y, 1 << l.canonical.z],
                    G.u_zoom_transition = i.globeToMercatorTransition(R.zoom);
                    let J = b[0] * i.EXTENT
                      , le = b[1] * i.EXTENT;
                    G.u_up_dir = R.projection.upVector(new i.CanonicalTileID(0,0,0), J, le)
                }
                return G
            }
              , Rf = (m,l,h,_,b,T,L)=>{
                let R = m.transform
                  , O = R.calculatePixelsToTileUnitsMatrix(l);
                return {
                    u_matrix: Pf(m, l, h, _),
                    u_pixels_to_tile_units: O,
                    u_device_pixel_ratio: T,
                    u_units_to_pixels: [1 / R.pixelsToGLUnits[0], 1 / R.pixelsToGLUnits[1]],
                    u_dash_image: 0,
                    u_gradient_image: 1,
                    u_image_height: b,
                    u_texsize: Ch(h) ? l.lineAtlasTexture.size : [0, 0],
                    u_tile_units_to_pixels: Ih(l, m.transform),
                    u_alpha_discard_threshold: 0,
                    u_trim_offset: L
                }
            }
              , wg = (m,l,h,_,b)=>{
                let T = m.transform;
                return {
                    u_matrix: Pf(m, l, h, _),
                    u_texsize: l.imageAtlasTexture.size,
                    u_pixels_to_tile_units: T.calculatePixelsToTileUnitsMatrix(l),
                    u_device_pixel_ratio: b,
                    u_image: 0,
                    u_tile_units_to_pixels: Ih(l, T),
                    u_units_to_pixels: [1 / T.pixelsToGLUnits[0], 1 / T.pixelsToGLUnits[1]],
                    u_alpha_discard_threshold: 0
                }
            }
            ;
            function Ih(m, l) {
                return 1 / Ye(m, 1, l.tileZoom)
            }
            function Pf(m, l, h, _) {
                return m.translatePosMatrix(_ || l.tileID.projMatrix, l, h.paint.get("line-translate"), h.paint.get("line-translate-anchor"))
            }
            function Ch(m) {
                let l = m.paint.get("line-dasharray").value;
                return l.value || l.kind !== "constant"
            }
            let tx = (m,l,h,_,b,T)=>{
                return {
                    u_matrix: m,
                    u_tl_parent: l,
                    u_scale_parent: h,
                    u_fade_t: _.mix,
                    u_opacity: _.opacity * b.paint.get("raster-opacity"),
                    u_image0: 0,
                    u_image1: 1,
                    u_brightness_low: b.paint.get("raster-brightness-min"),
                    u_brightness_high: b.paint.get("raster-brightness-max"),
                    u_saturation_factor: (R = b.paint.get("raster-saturation"),
                    R > 0 ? 1 - 1 / (1.001 - R) : -R),
                    u_contrast_factor: (L = b.paint.get("raster-contrast"),
                    L > 0 ? 1 / (1 - L) : 1 + L),
                    u_spin_weights: kf(b.paint.get("raster-hue-rotate")),
                    u_perspective_transform: T
                };
                var L, R
            }
            ;
            function kf(m) {
                m *= Math.PI / 180;
                let l = Math.sin(m)
                  , h = Math.cos(m);
                return [(2 * h + 1) / 3, (-Math.sqrt(3) * l - h + 1) / 3, (Math.sqrt(3) * l - h + 1) / 3]
            }
            let Tg = i.create(), Wc = (m,l,h,_,b,T,L,R,O,V,G,J,le,me,pe,ge)=>{
                let ve = b.transform
                  , re = {
                    u_is_size_zoom_constant: +(m === "constant" || m === "source"),
                    u_is_size_feature_constant: +(m === "constant" || m === "camera"),
                    u_size_t: l ? l.uSizeT : 0,
                    u_size: l ? l.uSize : 0,
                    u_camera_to_center_distance: ve.cameraToCenterDistance,
                    u_rotate_symbol: +h,
                    u_aspect_ratio: ve.width / ve.height,
                    u_fade_change: b.options.fadeDuration ? b.symbolFadeChange : 1,
                    u_matrix: T,
                    u_label_plane_matrix: L,
                    u_coord_matrix: R,
                    u_is_text: +O,
                    u_pitch_with_map: +_,
                    u_texsize: V,
                    u_texture: 0,
                    u_tile_id: [0, 0, 0],
                    u_zoom_transition: 0,
                    u_inv_rot_matrix: Tg,
                    u_merc_center: [0, 0],
                    u_camera_forward: [0, 0, 0],
                    u_ecef_origin: [0, 0, 0],
                    u_tile_matrix: Tg,
                    u_up_vector: [0, -1, 0]
                };
                return ge.name === "globe" && (re.u_tile_id = [G.canonical.x, G.canonical.y, 1 << G.canonical.z],
                re.u_zoom_transition = J,
                re.u_inv_rot_matrix = me,
                re.u_merc_center = le,
                re.u_camera_forward = ve._camera.forward(),
                re.u_ecef_origin = i.globeECEFOrigin(ve.globeMatrix, G.toUnwrapped()),
                re.u_tile_matrix = Float32Array.from(ve.globeMatrix),
                re.u_up_vector = pe),
                re
            }
            , Eg = (m,l,h,_,b,T,L,R,O,V,G,J,le,me,pe,ge,ve)=>i.extend(Wc(m, l, h, _, b, T, L, R, O, V, J, le, me, pe, ge, ve), {
                u_gamma_scale: _ ? b.transform.cameraToCenterDistance * Math.cos(b.terrain ? 0 : b.transform._pitch) : 1,
                u_device_pixel_ratio: i.exported.devicePixelRatio,
                u_is_halo: +G
            }), zf = (m,l,h,_,b,T,L,R,O,V,G,J,le,me,pe,ge)=>i.extend(Eg(m, l, h, _, b, T, L, R, !0, O, !0, G, J, le, me, pe, ge), {
                u_texsize_icon: V,
                u_texture_icon: 1
            }), nx = (m,l,h)=>({
                u_matrix: m,
                u_opacity: l,
                u_color: h
            }), Of = (m,l,h,_,b)=>i.extend(function(T, L, R) {
                let O = L.imageManager.getPattern(T.toString())
                  , {width: V, height: G} = L.imageManager.getPixelSize()
                  , J = Math.pow(2, R.tileID.overscaledZ)
                  , le = R.tileSize * Math.pow(2, L.transform.tileZoom) / J
                  , me = le * (R.tileID.canonical.x + R.tileID.wrap * J)
                  , pe = le * R.tileID.canonical.y;
                return {
                    u_image: 0,
                    u_pattern_tl: O.tl,
                    u_pattern_br: O.br,
                    u_texsize: [V, G],
                    u_pattern_size: O.displaySize,
                    u_tile_units_to_pixels: 1 / Ye(R, 1, L.transform.tileZoom),
                    u_pixel_coord_upper: [me >> 16, pe >> 16],
                    u_pixel_coord_lower: [65535 & me, 65535 & pe]
                }
            }(_, h, b), {
                u_matrix: m,
                u_opacity: l
            }), ix = {
                fillExtrusion: m=>({
                    u_matrix: new i.UniformMatrix4f(m),
                    u_lightpos: new i.Uniform3f(m),
                    u_lightintensity: new i.Uniform1f(m),
                    u_lightcolor: new i.Uniform3f(m),
                    u_vertical_gradient: new i.Uniform1f(m),
                    u_opacity: new i.Uniform1f(m),
                    u_edge_radius: new i.Uniform1f(m),
                    u_ao: new i.Uniform2f(m),
                    u_tile_id: new i.Uniform3f(m),
                    u_zoom_transition: new i.Uniform1f(m),
                    u_inv_rot_matrix: new i.UniformMatrix4f(m),
                    u_merc_center: new i.Uniform2f(m),
                    u_up_dir: new i.Uniform3f(m),
                    u_height_lift: new i.Uniform1f(m)
                }),
                fillExtrusionPattern: m=>({
                    u_matrix: new i.UniformMatrix4f(m),
                    u_lightpos: new i.Uniform3f(m),
                    u_lightintensity: new i.Uniform1f(m),
                    u_lightcolor: new i.Uniform3f(m),
                    u_vertical_gradient: new i.Uniform1f(m),
                    u_height_factor: new i.Uniform1f(m),
                    u_edge_radius: new i.Uniform1f(m),
                    u_ao: new i.Uniform2f(m),
                    u_tile_id: new i.Uniform3f(m),
                    u_zoom_transition: new i.Uniform1f(m),
                    u_inv_rot_matrix: new i.UniformMatrix4f(m),
                    u_merc_center: new i.Uniform2f(m),
                    u_up_dir: new i.Uniform3f(m),
                    u_height_lift: new i.Uniform1f(m),
                    u_image: new i.Uniform1i(m),
                    u_texsize: new i.Uniform2f(m),
                    u_pixel_coord_upper: new i.Uniform2f(m),
                    u_pixel_coord_lower: new i.Uniform2f(m),
                    u_tile_units_to_pixels: new i.Uniform1f(m),
                    u_opacity: new i.Uniform1f(m)
                }),
                fill: m=>({
                    u_matrix: new i.UniformMatrix4f(m)
                }),
                fillPattern: m=>({
                    u_matrix: new i.UniformMatrix4f(m),
                    u_image: new i.Uniform1i(m),
                    u_texsize: new i.Uniform2f(m),
                    u_pixel_coord_upper: new i.Uniform2f(m),
                    u_pixel_coord_lower: new i.Uniform2f(m),
                    u_tile_units_to_pixels: new i.Uniform1f(m)
                }),
                fillOutline: m=>({
                    u_matrix: new i.UniformMatrix4f(m),
                    u_world: new i.Uniform2f(m)
                }),
                fillOutlinePattern: m=>({
                    u_matrix: new i.UniformMatrix4f(m),
                    u_world: new i.Uniform2f(m),
                    u_image: new i.Uniform1i(m),
                    u_texsize: new i.Uniform2f(m),
                    u_pixel_coord_upper: new i.Uniform2f(m),
                    u_pixel_coord_lower: new i.Uniform2f(m),
                    u_tile_units_to_pixels: new i.Uniform1f(m)
                }),
                circle: m=>({
                    u_camera_to_center_distance: new i.Uniform1f(m),
                    u_extrude_scale: new i.UniformMatrix2f(m),
                    u_device_pixel_ratio: new i.Uniform1f(m),
                    u_matrix: new i.UniformMatrix4f(m),
                    u_inv_rot_matrix: new i.UniformMatrix4f(m),
                    u_merc_center: new i.Uniform2f(m),
                    u_tile_id: new i.Uniform3f(m),
                    u_zoom_transition: new i.Uniform1f(m),
                    u_up_dir: new i.Uniform3f(m)
                }),
                collisionBox: m=>({
                    u_matrix: new i.UniformMatrix4f(m),
                    u_camera_to_center_distance: new i.Uniform1f(m),
                    u_extrude_scale: new i.Uniform2f(m)
                }),
                collisionCircle: m=>({
                    u_matrix: new i.UniformMatrix4f(m),
                    u_inv_matrix: new i.UniformMatrix4f(m),
                    u_camera_to_center_distance: new i.Uniform1f(m),
                    u_viewport_size: new i.Uniform2f(m)
                }),
                debug: m=>({
                    u_color: new i.UniformColor(m),
                    u_matrix: new i.UniformMatrix4f(m),
                    u_overlay: new i.Uniform1i(m),
                    u_overlay_scale: new i.Uniform1f(m)
                }),
                clippingMask: m=>({
                    u_matrix: new i.UniformMatrix4f(m)
                }),
                heatmap: m=>({
                    u_extrude_scale: new i.Uniform1f(m),
                    u_intensity: new i.Uniform1f(m),
                    u_matrix: new i.UniformMatrix4f(m),
                    u_inv_rot_matrix: new i.UniformMatrix4f(m),
                    u_merc_center: new i.Uniform2f(m),
                    u_tile_id: new i.Uniform3f(m),
                    u_zoom_transition: new i.Uniform1f(m),
                    u_up_dir: new i.Uniform3f(m)
                }),
                heatmapTexture: m=>({
                    u_image: new i.Uniform1i(m),
                    u_color_ramp: new i.Uniform1i(m),
                    u_opacity: new i.Uniform1f(m)
                }),
                hillshade: m=>({
                    u_matrix: new i.UniformMatrix4f(m),
                    u_image: new i.Uniform1i(m),
                    u_latrange: new i.Uniform2f(m),
                    u_light: new i.Uniform2f(m),
                    u_shadow: new i.UniformColor(m),
                    u_highlight: new i.UniformColor(m),
                    u_accent: new i.UniformColor(m)
                }),
                hillshadePrepare: m=>({
                    u_matrix: new i.UniformMatrix4f(m),
                    u_image: new i.Uniform1i(m),
                    u_dimension: new i.Uniform2f(m),
                    u_zoom: new i.Uniform1f(m),
                    u_unpack: new i.Uniform4f(m)
                }),
                line: m=>({
                    u_matrix: new i.UniformMatrix4f(m),
                    u_pixels_to_tile_units: new i.UniformMatrix2f(m),
                    u_device_pixel_ratio: new i.Uniform1f(m),
                    u_units_to_pixels: new i.Uniform2f(m),
                    u_dash_image: new i.Uniform1i(m),
                    u_gradient_image: new i.Uniform1i(m),
                    u_image_height: new i.Uniform1f(m),
                    u_texsize: new i.Uniform2f(m),
                    u_tile_units_to_pixels: new i.Uniform1f(m),
                    u_alpha_discard_threshold: new i.Uniform1f(m),
                    u_trim_offset: new i.Uniform2f(m)
                }),
                linePattern: m=>({
                    u_matrix: new i.UniformMatrix4f(m),
                    u_texsize: new i.Uniform2f(m),
                    u_pixels_to_tile_units: new i.UniformMatrix2f(m),
                    u_device_pixel_ratio: new i.Uniform1f(m),
                    u_image: new i.Uniform1i(m),
                    u_units_to_pixels: new i.Uniform2f(m),
                    u_tile_units_to_pixels: new i.Uniform1f(m),
                    u_alpha_discard_threshold: new i.Uniform1f(m)
                }),
                raster: m=>({
                    u_matrix: new i.UniformMatrix4f(m),
                    u_tl_parent: new i.Uniform2f(m),
                    u_scale_parent: new i.Uniform1f(m),
                    u_fade_t: new i.Uniform1f(m),
                    u_opacity: new i.Uniform1f(m),
                    u_image0: new i.Uniform1i(m),
                    u_image1: new i.Uniform1i(m),
                    u_brightness_low: new i.Uniform1f(m),
                    u_brightness_high: new i.Uniform1f(m),
                    u_saturation_factor: new i.Uniform1f(m),
                    u_contrast_factor: new i.Uniform1f(m),
                    u_spin_weights: new i.Uniform3f(m),
                    u_perspective_transform: new i.Uniform2f(m)
                }),
                symbolIcon: m=>({
                    u_is_size_zoom_constant: new i.Uniform1i(m),
                    u_is_size_feature_constant: new i.Uniform1i(m),
                    u_size_t: new i.Uniform1f(m),
                    u_size: new i.Uniform1f(m),
                    u_camera_to_center_distance: new i.Uniform1f(m),
                    u_rotate_symbol: new i.Uniform1i(m),
                    u_aspect_ratio: new i.Uniform1f(m),
                    u_fade_change: new i.Uniform1f(m),
                    u_matrix: new i.UniformMatrix4f(m),
                    u_label_plane_matrix: new i.UniformMatrix4f(m),
                    u_coord_matrix: new i.UniformMatrix4f(m),
                    u_is_text: new i.Uniform1i(m),
                    u_pitch_with_map: new i.Uniform1i(m),
                    u_texsize: new i.Uniform2f(m),
                    u_tile_id: new i.Uniform3f(m),
                    u_zoom_transition: new i.Uniform1f(m),
                    u_inv_rot_matrix: new i.UniformMatrix4f(m),
                    u_merc_center: new i.Uniform2f(m),
                    u_camera_forward: new i.Uniform3f(m),
                    u_tile_matrix: new i.UniformMatrix4f(m),
                    u_up_vector: new i.Uniform3f(m),
                    u_ecef_origin: new i.Uniform3f(m),
                    u_texture: new i.Uniform1i(m)
                }),
                symbolSDF: m=>({
                    u_is_size_zoom_constant: new i.Uniform1i(m),
                    u_is_size_feature_constant: new i.Uniform1i(m),
                    u_size_t: new i.Uniform1f(m),
                    u_size: new i.Uniform1f(m),
                    u_camera_to_center_distance: new i.Uniform1f(m),
                    u_rotate_symbol: new i.Uniform1i(m),
                    u_aspect_ratio: new i.Uniform1f(m),
                    u_fade_change: new i.Uniform1f(m),
                    u_matrix: new i.UniformMatrix4f(m),
                    u_label_plane_matrix: new i.UniformMatrix4f(m),
                    u_coord_matrix: new i.UniformMatrix4f(m),
                    u_is_text: new i.Uniform1i(m),
                    u_pitch_with_map: new i.Uniform1i(m),
                    u_texsize: new i.Uniform2f(m),
                    u_texture: new i.Uniform1i(m),
                    u_gamma_scale: new i.Uniform1f(m),
                    u_device_pixel_ratio: new i.Uniform1f(m),
                    u_tile_id: new i.Uniform3f(m),
                    u_zoom_transition: new i.Uniform1f(m),
                    u_inv_rot_matrix: new i.UniformMatrix4f(m),
                    u_merc_center: new i.Uniform2f(m),
                    u_camera_forward: new i.Uniform3f(m),
                    u_tile_matrix: new i.UniformMatrix4f(m),
                    u_up_vector: new i.Uniform3f(m),
                    u_ecef_origin: new i.Uniform3f(m),
                    u_is_halo: new i.Uniform1i(m)
                }),
                symbolTextAndIcon: m=>({
                    u_is_size_zoom_constant: new i.Uniform1i(m),
                    u_is_size_feature_constant: new i.Uniform1i(m),
                    u_size_t: new i.Uniform1f(m),
                    u_size: new i.Uniform1f(m),
                    u_camera_to_center_distance: new i.Uniform1f(m),
                    u_rotate_symbol: new i.Uniform1i(m),
                    u_aspect_ratio: new i.Uniform1f(m),
                    u_fade_change: new i.Uniform1f(m),
                    u_matrix: new i.UniformMatrix4f(m),
                    u_label_plane_matrix: new i.UniformMatrix4f(m),
                    u_coord_matrix: new i.UniformMatrix4f(m),
                    u_is_text: new i.Uniform1i(m),
                    u_pitch_with_map: new i.Uniform1i(m),
                    u_texsize: new i.Uniform2f(m),
                    u_texsize_icon: new i.Uniform2f(m),
                    u_texture: new i.Uniform1i(m),
                    u_texture_icon: new i.Uniform1i(m),
                    u_gamma_scale: new i.Uniform1f(m),
                    u_device_pixel_ratio: new i.Uniform1f(m),
                    u_is_halo: new i.Uniform1i(m)
                }),
                background: m=>({
                    u_matrix: new i.UniformMatrix4f(m),
                    u_opacity: new i.Uniform1f(m),
                    u_color: new i.UniformColor(m)
                }),
                backgroundPattern: m=>({
                    u_matrix: new i.UniformMatrix4f(m),
                    u_opacity: new i.Uniform1f(m),
                    u_image: new i.Uniform1i(m),
                    u_pattern_tl: new i.Uniform2f(m),
                    u_pattern_br: new i.Uniform2f(m),
                    u_texsize: new i.Uniform2f(m),
                    u_pattern_size: new i.Uniform2f(m),
                    u_pixel_coord_upper: new i.Uniform2f(m),
                    u_pixel_coord_lower: new i.Uniform2f(m),
                    u_tile_units_to_pixels: new i.Uniform1f(m)
                }),
                terrainRaster: wh,
                terrainDepth: wh,
                skybox: m=>({
                    u_matrix: new i.UniformMatrix4f(m),
                    u_sun_direction: new i.Uniform3f(m),
                    u_cubemap: new i.Uniform1i(m),
                    u_opacity: new i.Uniform1f(m),
                    u_temporal_offset: new i.Uniform1f(m)
                }),
                skyboxGradient: m=>({
                    u_matrix: new i.UniformMatrix4f(m),
                    u_color_ramp: new i.Uniform1i(m),
                    u_center_direction: new i.Uniform3f(m),
                    u_radius: new i.Uniform1f(m),
                    u_opacity: new i.Uniform1f(m),
                    u_temporal_offset: new i.Uniform1f(m)
                }),
                skyboxCapture: m=>({
                    u_matrix_3f: new i.UniformMatrix3f(m),
                    u_sun_direction: new i.Uniform3f(m),
                    u_sun_intensity: new i.Uniform1f(m),
                    u_color_tint_r: new i.Uniform4f(m),
                    u_color_tint_m: new i.Uniform4f(m),
                    u_luminance: new i.Uniform1f(m)
                }),
                globeRaster: m=>({
                    u_proj_matrix: new i.UniformMatrix4f(m),
                    u_globe_matrix: new i.UniformMatrix4f(m),
                    u_normalize_matrix: new i.UniformMatrix4f(m),
                    u_merc_matrix: new i.UniformMatrix4f(m),
                    u_zoom_transition: new i.Uniform1f(m),
                    u_merc_center: new i.Uniform2f(m),
                    u_image0: new i.Uniform1i(m),
                    u_grid_matrix: new i.UniformMatrix3f(m),
                    u_skirt_height: new i.Uniform1f(m),
                    u_frustum_tl: new i.Uniform3f(m),
                    u_frustum_tr: new i.Uniform3f(m),
                    u_frustum_br: new i.Uniform3f(m),
                    u_frustum_bl: new i.Uniform3f(m),
                    u_globe_pos: new i.Uniform3f(m),
                    u_globe_radius: new i.Uniform1f(m),
                    u_viewport: new i.Uniform2f(m)
                }),
                globeAtmosphere: m=>({
                    u_frustum_tl: new i.Uniform3f(m),
                    u_frustum_tr: new i.Uniform3f(m),
                    u_frustum_br: new i.Uniform3f(m),
                    u_frustum_bl: new i.Uniform3f(m),
                    u_horizon: new i.Uniform1f(m),
                    u_transition: new i.Uniform1f(m),
                    u_fadeout_range: new i.Uniform1f(m),
                    u_color: new i.Uniform4f(m),
                    u_high_color: new i.Uniform4f(m),
                    u_space_color: new i.Uniform4f(m),
                    u_star_intensity: new i.Uniform1f(m),
                    u_star_density: new i.Uniform1f(m),
                    u_star_size: new i.Uniform1f(m),
                    u_temporal_offset: new i.Uniform1f(m),
                    u_horizon_angle: new i.Uniform1f(m),
                    u_rotation_matrix: new i.UniformMatrix4f(m)
                })
            }, La;
            function Sg(m, l, h, _, b, T, L) {
                let R = m.context
                  , O = R.gl
                  , V = m.transform
                  , G = m.useProgram("collisionBox")
                  , J = []
                  , le = 0
                  , me = 0;
                for (let De = 0; De < _.length; De++) {
                    let Ve = _[De]
                      , Fe = l.getTile(Ve)
                      , Xe = Fe.getBucket(h);
                    if (!Xe)
                        continue;
                    let $e = gf(Ve, Xe, V)
                      , rt = $e;
                    b[0] === 0 && b[1] === 0 || (rt = m.translatePosMatrix($e, Fe, b, T));
                    let lt = L ? Xe.textCollisionBox : Xe.iconCollisionBox
                      , Vt = Xe.collisionCircleArray;
                    if (Vt.length > 0) {
                        let nt = i.create()
                          , vt = rt;
                        i.mul(nt, Xe.placementInvProjMatrix, V.glCoordMatrix),
                        i.mul(nt, nt, Xe.placementViewportMatrix),
                        J.push({
                            circleArray: Vt,
                            circleOffset: me,
                            transform: vt,
                            invTransform: nt,
                            projection: Xe.getProjection()
                        }),
                        le += Vt.length / 4,
                        me = le
                    }
                    lt && (m.terrain && m.terrain.setupElevationDraw(Fe, G),
                    G.draw(R, O.LINES, i.DepthMode.disabled, i.StencilMode.disabled, m.colorModeForRenderPass(), i.CullFaceMode.disabled, bg(rt, V, Fe, Xe.getProjection()), h.id, lt.layoutVertexBuffer, lt.indexBuffer, lt.segments, null, V.zoom, null, [lt.collisionVertexBuffer, lt.collisionVertexBufferExt]))
                }
                if (!L || !J.length)
                    return;
                let pe = m.useProgram("collisionCircle")
                  , ge = new i.StructArrayLayout2f1f2i16;
                ge.resize(4 * le),
                ge._trim();
                let ve = 0;
                for (let De of J)
                    for (let Ve = 0; Ve < De.circleArray.length / 4; Ve++) {
                        let Fe = 4 * Ve
                          , Xe = De.circleArray[Fe + 0]
                          , $e = De.circleArray[Fe + 1]
                          , rt = De.circleArray[Fe + 2]
                          , lt = De.circleArray[Fe + 3];
                        ge.emplace(ve++, Xe, $e, rt, lt, 0),
                        ge.emplace(ve++, Xe, $e, rt, lt, 1),
                        ge.emplace(ve++, Xe, $e, rt, lt, 2),
                        ge.emplace(ve++, Xe, $e, rt, lt, 3)
                    }
                (!La || La.length < 2 * le) && (La = function(De) {
                    let Ve = 2 * De
                      , Fe = new i.StructArrayLayout3ui6;
                    Fe.resize(Ve),
                    Fe._trim();
                    for (let Xe = 0; Xe < Ve; Xe++) {
                        let $e = 6 * Xe;
                        Fe.uint16[$e + 0] = 4 * Xe + 0,
                        Fe.uint16[$e + 1] = 4 * Xe + 1,
                        Fe.uint16[$e + 2] = 4 * Xe + 2,
                        Fe.uint16[$e + 3] = 4 * Xe + 2,
                        Fe.uint16[$e + 4] = 4 * Xe + 3,
                        Fe.uint16[$e + 5] = 4 * Xe + 0
                    }
                    return Fe
                }(le));
                let re = R.createIndexBuffer(La, !0)
                  , Ce = R.createVertexBuffer(ge, i.collisionCircleLayout.members, !0);
                for (let De of J) {
                    let Ve = {
                        u_matrix: De.transform,
                        u_inv_matrix: De.invTransform,
                        u_camera_to_center_distance: (Ae = V).getCameraToCenterDistance(De.projection),
                        u_viewport_size: [Ae.width, Ae.height]
                    };
                    pe.draw(R, O.TRIANGLES, i.DepthMode.disabled, i.StencilMode.disabled, m.colorModeForRenderPass(), i.CullFaceMode.disabled, Ve, h.id, Ce, re, i.SegmentVector.simpleSegment(0, 2 * De.circleOffset, De.circleArray.length, De.circleArray.length / 2), null, V.zoom)
                }
                var Ae;
                Ce.destroy(),
                re.destroy()
            }
            let Nf = i.create();
            function Ag({width: m, height: l, anchor: h, textOffset: _, textScale: b}, T) {
                let {horizontalAlign: L, verticalAlign: R} = i.getAnchorAlignment(h)
                  , O = -(L - .5) * m
                  , V = -(R - .5) * l
                  , G = i.evaluateVariableOffset(h, _);
                return new i.pointGeometry((O / b + G[0]) * T,(V / b + G[1]) * T)
            }
            function bl(m, l, h, _, b, T, L, R, O, V, G) {
                let J = m.text.placedSymbolArray
                  , le = m.text.dynamicLayoutVertexArray
                  , me = m.icon.dynamicLayoutVertexArray
                  , pe = {}
                  , ge = m.getProjection()
                  , ve = dh(R, ge, T)
                  , re = T.elevation
                  , Ce = ge.upVectorScale(R.canonical, T.center.lat, T.worldSize).metersToTile;
                le.clear();
                for (let Ae = 0; Ae < J.length; Ae++) {
                    let De = J.get(Ae)
                      , {tileAnchorX: Ve, tileAnchorY: Fe, numGlyphs: Xe} = De
                      , $e = m.allowVerticalPlacement && !De.placedOrientation
                      , rt = De.hidden || !De.crossTileID || $e ? null : _[De.crossTileID];
                    if (rt) {
                        let lt = 0
                          , Vt = 0
                          , nt = 0;
                        if (re) {
                            let pn = re ? re.getAtTileOffset(R, Ve, Fe) : 0
                              , [Xn,un,sn] = ge.upVector(R.canonical, Ve, Fe);
                            lt = pn * Xn * Ce,
                            Vt = pn * un * Ce,
                            nt = pn * sn * Ce
                        }
                        let[vt,pt,Dt,st] = Xt(De.projectedAnchorX + lt, De.projectedAnchorY + Vt, De.projectedAnchorZ + nt, h ? ve : L)
                          , Je = ni(T.getCameraToCenterDistance(ge), st)
                          , ct = b.evaluateSizeForFeature(m.textSizeData, V, De) * Je / i.ONE_EM;
                        h && (ct *= m.tilePixelRatio / O);
                        let At = Ag(rt, ct);
                        h ? ({x: vt, y: pt, z: Dt} = ge.projectTilePoint(Ve + At.x, Fe + At.y, R.canonical),
                        [vt,pt,Dt] = Xt(vt + lt, pt + Vt, Dt + nt, L)) : (l && At._rotate(-T.angle),
                        vt += At.x,
                        pt += At.y,
                        Dt = 0);
                        let Pt = m.allowVerticalPlacement && De.placedOrientation === i.WritingMode.vertical ? Math.PI / 2 : 0;
                        for (let pn = 0; pn < Xe; pn++)
                            i.addDynamicAttributes(le, vt, pt, Dt, Pt);
                        G && De.associatedIconIndex >= 0 && (pe[De.associatedIconIndex] = {
                            x: vt,
                            y: pt,
                            z: Dt,
                            angle: Pt
                        })
                    } else
                        Li(Xe, le)
                }
                if (G) {
                    me.clear();
                    let Ae = m.icon.placedSymbolArray;
                    for (let De = 0; De < Ae.length; De++) {
                        let Ve = Ae.get(De)
                          , {numGlyphs: Fe} = Ve
                          , Xe = pe[De];
                        if (Ve.hidden || !Xe)
                            Li(Fe, me);
                        else {
                            let {x: $e, y: rt, z: lt, angle: Vt} = Xe;
                            for (let nt = 0; nt < Fe; nt++)
                                i.addDynamicAttributes(me, $e, rt, lt, Vt)
                        }
                    }
                    m.icon.dynamicLayoutVertexBuffer.updateData(me)
                }
                m.text.dynamicLayoutVertexBuffer.updateData(le)
            }
            function rx(m, l, h) {
                return h.iconsInText && l ? "symbolTextAndIcon" : m ? "symbolSDF" : "symbolIcon"
            }
            function Mg(m, l, h, _, b, T, L, R, O, V, G, J) {
                let le = m.context
                  , me = le.gl
                  , pe = m.transform
                  , ge = R === "map"
                  , ve = O === "map"
                  , re = ge && h.layout.get("symbol-placement") !== "point"
                  , Ce = ge && !ve && !re
                  , Ae = h.layout.get("symbol-sort-key").constantOr(1) !== void 0
                  , De = !1
                  , Ve = m.depthModeForSublayer(0, i.DepthMode.ReadOnly)
                  , Fe = [i.mercatorXfromLng(pe.center.lng), i.mercatorYfromLat(pe.center.lat)]
                  , Xe = h.layout.get("text-variable-anchor")
                  , $e = pe.projection.name === "globe"
                  , rt = []
                  , lt = [0, -1, 0]
                  , Vt = lt;
                !$e && !pe.mercatorFromTransition || ge || (Vt = function(nt) {
                    let vt = nt._camera.getWorldToCamera(nt.worldSize, 1)
                      , pt = i.multiply([], vt, nt.globeMatrix);
                    i.invert(pt, pt);
                    let Dt = [0, 0, 0]
                      , st = [0, 1, 0, 0];
                    return i.transformMat4$1(st, st, pt),
                    Dt[0] = st[0],
                    Dt[1] = st[1],
                    Dt[2] = st[2],
                    i.normalize(Dt, Dt),
                    Dt
                }(pe));
                for (let nt of _) {
                    let vt = l.getTile(nt)
                      , pt = vt.getBucket(h);
                    if (!pt || pt.projection.name === "mercator" && $e)
                        continue;
                    let Dt = b ? pt.text : pt.icon;
                    if (!Dt || pt.fullyClipped || !Dt.segments.get().length)
                        continue;
                    let st = Dt.programConfigurations.get(h.id), Je = b || pt.sdfIcons, ct = b ? pt.textSizeData : pt.iconSizeData, At = ve || pe.pitch !== 0, Pt = i.evaluateSizeForZoom(ct, pe.zoom), pn, Xn, un, sn, vn = [0, 0], Qn = null;
                    if (b) {
                        if (Xn = vt.glyphAtlasTexture,
                        un = me.LINEAR,
                        pn = vt.glyphAtlasTexture.size,
                        pt.iconsInText) {
                            vn = vt.imageAtlasTexture.size,
                            Qn = vt.imageAtlasTexture;
                            let Ss = ct.kind === "composite" || ct.kind === "camera";
                            sn = At || m.options.rotating || m.options.zooming || Ss ? me.LINEAR : me.NEAREST
                        }
                    } else {
                        let Ss = h.layout.get("icon-size").constantOr(0) !== 1 || pt.iconsNeedLinear;
                        Xn = vt.imageAtlasTexture,
                        un = Je || m.options.rotating || m.options.zooming || Ss || At ? me.LINEAR : me.NEAREST,
                        pn = vt.imageAtlasTexture.size
                    }
                    let En = pt.projection.name === "globe"
                      , pi = En ? Vt : lt
                      , Ti = En ? i.globeToMercatorTransition(pe.zoom) : 0
                      , Ri = dh(nt, pt.getProjection(), pe)
                      , Mi = pe.calculatePixelsToTileUnitsMatrix(vt)
                      , lr = Xo(Ri, vt.tileID.canonical, ve, ge, pe, pt.getProjection(), Mi)
                      , gs = m.terrain && ve && re ? i.invert(i.create(), lr) : Nf
                      , Ks = Zo(Ri, vt.tileID.canonical, ve, ge, pe, pt.getProjection(), Mi)
                      , Co = Xe && pt.hasTextData()
                      , Gi = h.layout.get("icon-text-fit") !== "none" && Co && pt.hasIconData();
                    if (re) {
                        let Ss = pe.elevation
                          , Os = Ss ? Ss.getAtTileOffsetFunc(nt, pe.center.lat, pe.worldSize, pt.getProjection()) : null
                          , Do = hh(Ri, vt.tileID.canonical, ve, ge, pe, pt.getProjection(), Mi);
                        lo(pt, Ri, m, b, Do, Ks, ve, V, Os, nt)
                    }
                    let Ii = re || b && Xe || Gi
                      , li = m.translatePosMatrix(Ri, vt, T, L)
                      , Ji = Ii ? Nf : lr
                      , Wr = m.translatePosMatrix(Ks, vt, T, L, !0)
                      , Oi = pt.getProjection().createInversionMatrix(pe, nt.canonical)
                      , jr = [];
                    m.terrainRenderModeElevated() && ve && jr.push("PITCH_WITH_MAP_TERRAIN"),
                    En && jr.push("PROJECTION_GLOBE_VIEW"),
                    Ii && jr.push("PROJECTED_POS_ON_VIEWPORT");
                    let Xr = Je && h.paint.get(b ? "text-halo-width" : "icon-halo-width").constantOr(1) !== 0, $o;
                    $o = Je ? pt.iconsInText ? zf(ct.kind, Pt, Ce, ve, m, li, Ji, Wr, pn, vn, nt, Ti, Fe, Oi, pi, pt.getProjection()) : Eg(ct.kind, Pt, Ce, ve, m, li, Ji, Wr, b, pn, !0, nt, Ti, Fe, Oi, pi, pt.getProjection()) : Wc(ct.kind, Pt, Ce, ve, m, li, Ji, Wr, b, pn, nt, Ti, Fe, Oi, pi, pt.getProjection());
                    let Rl = {
                        program: m.useProgram(rx(Je, b, pt), st, jr),
                        buffers: Dt,
                        uniformValues: $o,
                        atlasTexture: Xn,
                        atlasTextureIcon: Qn,
                        atlasInterpolation: un,
                        atlasInterpolationIcon: sn,
                        isSDF: Je,
                        hasHalo: Xr,
                        tile: vt,
                        labelPlaneMatrixInv: gs
                    };
                    if (Ae && pt.canOverlap) {
                        De = !0;
                        let Ss = Dt.segments.get();
                        for (let Os of Ss)
                            rt.push({
                                segments: new i.SegmentVector([Os]),
                                sortKey: Os.sortKey,
                                state: Rl
                            })
                    } else
                        rt.push({
                            segments: Dt.segments,
                            sortKey: 0,
                            state: Rl
                        })
                }
                De && rt.sort((nt,vt)=>nt.sortKey - vt.sortKey);
                for (let nt of rt) {
                    let vt = nt.state;
                    if (m.terrain && m.terrain.setupElevationDraw(vt.tile, vt.program, {
                        useDepthForOcclusion: !$e,
                        labelPlaneMatrixInv: vt.labelPlaneMatrixInv
                    }),
                    le.activeTexture.set(me.TEXTURE0),
                    vt.atlasTexture.bind(vt.atlasInterpolation, me.CLAMP_TO_EDGE),
                    vt.atlasTextureIcon && (le.activeTexture.set(me.TEXTURE1),
                    vt.atlasTextureIcon && vt.atlasTextureIcon.bind(vt.atlasInterpolationIcon, me.CLAMP_TO_EDGE)),
                    vt.isSDF) {
                        let pt = vt.uniformValues;
                        vt.hasHalo && (pt.u_is_halo = 1,
                        Ig(vt.buffers, nt.segments, h, m, vt.program, Ve, G, J, pt)),
                        pt.u_is_halo = 0
                    }
                    Ig(vt.buffers, nt.segments, h, m, vt.program, Ve, G, J, vt.uniformValues)
                }
            }
            function Ig(m, l, h, _, b, T, L, R, O) {
                let V = _.context
                  , G = [m.dynamicLayoutVertexBuffer, m.opacityVertexBuffer, m.globeExtVertexBuffer];
                b.draw(V, V.gl.TRIANGLES, T, L, R, i.CullFaceMode.disabled, O, h.id, m.layoutVertexBuffer, m.indexBuffer, l, h.paint, _.transform.zoom, m.programConfigurations.get(h.id), G)
            }
            function Cg(m, l, h, _, b, T, L) {
                let R = m.context.gl, O = h.paint.get("fill-pattern"), V = O && O.constantOr(1), G, J, le, me, pe;
                L ? (J = V && !h.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline",
                G = R.LINES) : (J = V ? "fillPattern" : "fill",
                G = R.TRIANGLES);
                for (let ge of _) {
                    let ve = l.getTile(ge);
                    if (V && !ve.patternsLoaded())
                        continue;
                    let re = ve.getBucket(h);
                    if (!re)
                        continue;
                    m.prepareDrawTile();
                    let Ce = re.programConfigurations.get(h.id)
                      , Ae = m.useProgram(J, Ce);
                    V && (m.context.activeTexture.set(R.TEXTURE0),
                    ve.imageAtlasTexture.bind(R.LINEAR, R.CLAMP_TO_EDGE),
                    Ce.updatePaintBuffers());
                    let De = O.constantOr(null);
                    if (De && ve.imageAtlas) {
                        let Fe = ve.imageAtlas.patternPositions[De.toString()];
                        Fe && Ce.setConstantPatternPositions(Fe)
                    }
                    let Ve = m.translatePosMatrix(ge.projMatrix, ve, h.paint.get("fill-translate"), h.paint.get("fill-translate-anchor"));
                    if (L) {
                        me = re.indexBuffer2,
                        pe = re.segments2;
                        let Fe = m.terrain && m.terrain.renderingToTexture ? m.terrain.drapeBufferSize : [R.drawingBufferWidth, R.drawingBufferHeight];
                        le = J === "fillOutlinePattern" && V ? vg(Ve, m, ve, Fe) : xg(Ve, Fe)
                    } else
                        me = re.indexBuffer,
                        pe = re.segments,
                        le = V ? Mh(Ve, m, ve) : Ah(Ve);
                    m.prepareDrawProgram(m.context, Ae, ge.toUnwrapped()),
                    Ae.draw(m.context, G, b, m.stencilModeForClipping(ge), T, i.CullFaceMode.disabled, le, h.id, re.layoutVertexBuffer, me, pe, h.paint, m.transform.zoom, Ce)
                }
            }
            function Ff(m, l, h, _, b, T, L) {
                let R = m.context
                  , O = R.gl
                  , V = m.transform
                  , G = h.paint.get("fill-extrusion-pattern")
                  , J = G.constantOr(1)
                  , le = h.paint.get("fill-extrusion-opacity")
                  , me = [h.paint.get("fill-extrusion-ambient-occlusion-intensity"), h.paint.get("fill-extrusion-ambient-occlusion-radius")]
                  , pe = h.layout.get("fill-extrusion-edge-radius")
                  , ge = V.projection.name === "globe" ? i.fillExtrusionHeightLift() : 0
                  , ve = V.projection.name === "globe"
                  , re = ve ? i.globeToMercatorTransition(V.zoom) : 0
                  , Ce = [i.mercatorXfromLng(V.center.lng), i.mercatorYfromLat(V.center.lat)]
                  , Ae = [];
                ve && Ae.push("PROJECTION_GLOBE_VIEW"),
                me[0] > 0 && Ae.push("FAUX_AO");
                for (let De of _) {
                    let Ve = l.getTile(De)
                      , Fe = Ve.getBucket(h);
                    if (!Fe || Fe.projection.name !== V.projection.name)
                        continue;
                    let Xe = Fe.programConfigurations.get(h.id)
                      , $e = m.useProgram(J ? "fillExtrusionPattern" : "fillExtrusion", Xe, Ae);
                    if (m.terrain) {
                        let Dt = m.terrain;
                        if (m.style.terrainSetForDrapingOnly())
                            Dt.setupElevationDraw(Ve, $e, {
                                useMeterToDem: !0
                            });
                        else {
                            if (!Fe.enableTerrain)
                                continue;
                            if (Dt.setupElevationDraw(Ve, $e, {
                                useMeterToDem: !0
                            }),
                            sx(R, l, De, Fe, h, Dt),
                            !Fe.centroidVertexBuffer) {
                                let st = $e.attributes.a_centroid_pos;
                                st !== void 0 && O.vertexAttrib2f(st, 0, 0)
                            }
                        }
                    }
                    J && (m.context.activeTexture.set(O.TEXTURE0),
                    Ve.imageAtlasTexture.bind(O.LINEAR, O.CLAMP_TO_EDGE),
                    Xe.updatePaintBuffers());
                    let rt = G.constantOr(null);
                    if (rt && Ve.imageAtlas) {
                        let Dt = Ve.imageAtlas.patternPositions[rt.toString()];
                        Dt && Xe.setConstantPatternPositions(Dt)
                    }
                    let lt = m.translatePosMatrix(De.projMatrix, Ve, h.paint.get("fill-extrusion-translate"), h.paint.get("fill-extrusion-translate-anchor"))
                      , Vt = V.projection.createInversionMatrix(V, De.canonical)
                      , nt = h.paint.get("fill-extrusion-vertical-gradient")
                      , vt = J ? Df(lt, m, nt, le, me, pe, De, Ve, ge, re, Ce, Vt) : Sh(lt, m, nt, le, me, pe, De, ge, re, Ce, Vt);
                    m.prepareDrawProgram(R, $e, De.toUnwrapped());
                    let pt = [];
                    m.terrain && pt.push(Fe.centroidVertexBuffer),
                    ve && pt.push(Fe.layoutVertexExtBuffer),
                    $e.draw(R, R.gl.TRIANGLES, b, T, L, i.CullFaceMode.backCCW, vt, h.id, Fe.layoutVertexBuffer, Fe.indexBuffer, Fe.segments, h.paint, m.transform.zoom, Xe, pt)
                }
            }
            function sx(m, l, h, _, b, T) {
                let L = [re=>{
                    let Ce = re.canonical.x - 1
                      , Ae = re.wrap;
                    return Ce < 0 && (Ce = (1 << re.canonical.z) - 1,
                    Ae--),
                    new i.OverscaledTileID(re.overscaledZ,Ae,re.canonical.z,Ce,re.canonical.y)
                }
                , re=>{
                    let Ce = re.canonical.x + 1
                      , Ae = re.wrap;
                    return Ce === 1 << re.canonical.z && (Ce = 0,
                    Ae++),
                    new i.OverscaledTileID(re.overscaledZ,Ae,re.canonical.z,Ce,re.canonical.y)
                }
                , re=>new i.OverscaledTileID(re.overscaledZ,re.wrap,re.canonical.z,re.canonical.x,(re.canonical.y === 0 ? 1 << re.canonical.z : re.canonical.y) - 1), re=>new i.OverscaledTileID(re.overscaledZ,re.wrap,re.canonical.z,re.canonical.x,re.canonical.y === (1 << re.canonical.z) - 1 ? 0 : re.canonical.y + 1)], R = re=>{
                    let Ce = l.getSource().minzoom
                      , Ae = Ve=>{
                        let Fe = l.getTileByID(Ve);
                        if (Fe && Fe.hasData())
                            return Fe.getBucket(b)
                    }
                      , De = [0, -1, 1];
                    for (let Ve of De) {
                        if (re.overscaledZ + Ve < Ce)
                            continue;
                        let Fe = Ae(re.calculateScaledKey(re.overscaledZ + Ve));
                        if (Fe)
                            return Fe
                    }
                }
                , O = [0, 0, 0], V = (re,Ce)=>(O[0] = Math.min(re.min.y, Ce.min.y),
                O[1] = Math.max(re.max.y, Ce.max.y),
                O[2] = i.EXTENT - Ce.min.x > re.max.x ? Ce.min.x - i.EXTENT : re.max.x,
                O), G = (re,Ce)=>(O[0] = Math.min(re.min.x, Ce.min.x),
                O[1] = Math.max(re.max.x, Ce.max.x),
                O[2] = i.EXTENT - Ce.min.y > re.max.y ? Ce.min.y - i.EXTENT : re.max.y,
                O), J = [(re,Ce)=>V(re, Ce), (re,Ce)=>V(Ce, re), (re,Ce)=>G(re, Ce), (re,Ce)=>G(Ce, re)], le = new i.pointGeometry(0,0), me, pe, ge, ve = (re,Ce,Ae,De,Ve)=>{
                    let Fe = [[De ? Ae : re, De ? re : Ae, 0], [De ? Ae : Ce, De ? Ce : Ae, 0]]
                      , Xe = Ve < 0 ? i.EXTENT + Ve : Ve
                      , $e = [De ? Xe : (re + Ce) / 2, De ? (re + Ce) / 2 : Xe, 0];
                    return Ae === 0 && Ve < 0 || Ae !== 0 && Ve > 0 ? T.getForTilePoints(ge, [$e], !0, pe) : Fe.push($e),
                    T.getForTilePoints(h, Fe, !0, me),
                    Math.max(Fe[0][2], Fe[1][2], $e[2]) / T.exaggeration()
                }
                ;
                for (let re = 0; re < 4; re++) {
                    let Ce = (re < 2 ? 1 : 5) - re
                      , Ae = _.borders[re];
                    if (Ae.length === 0)
                        continue;
                    let De = ge = L[re](h)
                      , Ve = R(De);
                    if (!(Ve && Ve instanceof i.FillExtrusionBucket && Ve.enableTerrain) || _.borderDoneWithNeighborZ[re] === Ve.canonical.z && Ve.borderDoneWithNeighborZ[Ce] === _.canonical.z || (pe = T.findDEMTileFor(De),
                    !pe || !pe.dem))
                        continue;
                    if (!me) {
                        let rt = T.findDEMTileFor(h);
                        if (!rt || !rt.dem)
                            return;
                        me = rt
                    }
                    let Fe = Ve.borders[Ce]
                      , Xe = 0
                      , $e = Ve.borderDoneWithNeighborZ[Ce] !== _.canonical.z;
                    if (_.canonical.z === Ve.canonical.z) {
                        for (let rt = 0; rt < Ae.length; rt++) {
                            let lt = _.featuresOnBorder[Ae[rt]], Vt = lt.borders[re], nt;
                            for (; Xe < Fe.length && (nt = Ve.featuresOnBorder[Fe[Xe]],
                            !(nt.borders[Ce][1] > Vt[0] + 3)); )
                                $e && Ve.encodeCentroid(void 0, nt, !1),
                                Xe++;
                            if (nt && Xe < Fe.length) {
                                let vt = Xe
                                  , pt = 0;
                                for (; !(nt.borders[Ce][0] > Vt[1] - 3) && (pt++,
                                ++Xe !== Fe.length); )
                                    nt = Ve.featuresOnBorder[Fe[Xe]];
                                if (nt = Ve.featuresOnBorder[Fe[vt]],
                                lt.intersectsCount() > 1 || nt.intersectsCount() > 1 || pt !== 1) {
                                    pt !== 1 && (Xe = vt),
                                    _.encodeCentroid(void 0, lt, !1),
                                    $e && Ve.encodeCentroid(void 0, nt, !1);
                                    continue
                                }
                                let Dt = J[re](lt, nt)
                                  , st = re % 2 ? i.EXTENT - 1 : 0;
                                le.x = ve(Dt[0], Math.min(i.EXTENT - 1, Dt[1]), st, re < 2, Dt[2]),
                                le.y = 0,
                                _.encodeCentroid(le, lt, !1),
                                $e && Ve.encodeCentroid(le, nt, !1)
                            } else
                                _.encodeCentroid(void 0, lt, !1)
                        }
                        _.borderDoneWithNeighborZ[re] = Ve.canonical.z,
                        _.needsCentroidUpdate = !0,
                        $e && (Ve.borderDoneWithNeighborZ[Ce] = _.canonical.z,
                        Ve.needsCentroidUpdate = !0)
                    } else {
                        for (let rt of Ae)
                            _.encodeCentroid(void 0, _.featuresOnBorder[rt], !1);
                        if ($e) {
                            for (let rt of Fe)
                                Ve.encodeCentroid(void 0, Ve.featuresOnBorder[rt], !1);
                            Ve.borderDoneWithNeighborZ[Ce] = _.canonical.z,
                            Ve.needsCentroidUpdate = !0
                        }
                        _.borderDoneWithNeighborZ[re] = Ve.canonical.z,
                        _.needsCentroidUpdate = !0
                    }
                }
                (_.needsCentroidUpdate || !_.centroidVertexBuffer && _.centroidVertexArray.length !== 0) && _.uploadCentroid(m)
            }
            let Bf = new i.Color(1,0,0,1)
              , Uf = new i.Color(0,1,0,1)
              , Dg = new i.Color(0,0,1,1)
              , Lg = new i.Color(1,0,1,1)
              , Rg = new i.Color(0,1,1,1);
            function Vf(m, l, h) {
                let _ = m.context
                  , b = m.transform
                  , T = _.gl
                  , L = b.projection.name === "globe"
                  , R = L ? ["PROJECTION_GLOBE_VIEW"] : null
                  , O = h.projMatrix;
                if (L && i.globeToMercatorTransition(b.zoom) > 0) {
                    let lt = i.transitionTileAABBinECEF(h.canonical, b)
                      , Vt = i.globeDenormalizeECEF(lt);
                    O = i.multiply(new Float32Array(16), b.globeMatrix, Vt),
                    i.multiply(O, b.projMatrix, O)
                }
                let V = m.useProgram("debug", null, R)
                  , G = l.getTileByID(h.key);
                m.terrain && m.terrain.setupElevationDraw(G, V);
                let J = i.DepthMode.disabled
                  , le = i.StencilMode.disabled
                  , me = m.colorModeForRenderPass()
                  , pe = "$debug";
                _.activeTexture.set(T.TEXTURE0),
                m.emptyTexture.bind(T.LINEAR, T.CLAMP_TO_EDGE),
                L ? G._makeGlobeTileDebugBuffers(m.context, b) : G._makeDebugTileBoundsBuffers(m.context, b.projection);
                let ge = G._tileDebugBuffer || m.debugBuffer
                  , ve = G._tileDebugIndexBuffer || m.debugIndexBuffer
                  , re = G._tileDebugSegments || m.debugSegments;
                V.draw(_, T.LINE_STRIP, J, le, me, i.CullFaceMode.disabled, Hc(O, i.Color.red), pe, ge, ve, re, null, null, null, [G._globeTileDebugBorderBuffer]);
                let Ce = G.latestRawTileData
                  , Ae = Math.floor((Ce && Ce.byteLength || 0) / 1024)
                  , De = l.getTile(h).tileSize
                  , Ve = 512 / Math.min(De, 512) * (h.overscaledZ / b.zoom) * .5
                  , Fe = h.canonical.toString();
                h.overscaledZ !== h.canonical.z && (Fe += ` => ${h.overscaledZ}`),
                Fe += ` ${Ae}kb`,
                function(lt, Vt) {
                    lt.initDebugOverlayCanvas();
                    let nt = lt.debugOverlayCanvas
                      , vt = lt.context.gl
                      , pt = lt.debugOverlayCanvas.getContext("2d");
                    pt.clearRect(0, 0, nt.width, nt.height),
                    pt.shadowColor = "white",
                    pt.shadowBlur = 2,
                    pt.lineWidth = 1.5,
                    pt.strokeStyle = "white",
                    pt.textBaseline = "top",
                    pt.font = "bold 36px Open Sans, sans-serif",
                    pt.fillText(Vt, 5, 5),
                    pt.strokeText(Vt, 5, 5),
                    lt.debugOverlayTexture.update(nt),
                    lt.debugOverlayTexture.bind(vt.LINEAR, vt.CLAMP_TO_EDGE)
                }(m, Fe);
                let Xe = G._tileDebugTextBuffer || m.debugBuffer
                  , $e = G._tileDebugTextIndexBuffer || m.quadTriangleIndexBuffer
                  , rt = G._tileDebugTextSegments || m.debugSegments;
                V.draw(_, T.TRIANGLES, J, le, i.ColorMode.alphaBlended, i.CullFaceMode.disabled, Hc(O, i.Color.transparent, Ve), pe, Xe, $e, rt, null, null, null, [G._globeTileDebugTextBuffer])
            }
            function Jo(m, l, h, _) {
                jc(m, 0, l + h / 2, m.transform.width, h, _)
            }
            function wl(m, l, h, _) {
                jc(m, l - h / 2, 0, h, m.transform.height, _)
            }
            function jc(m, l, h, _, b, T) {
                let L = m.context
                  , R = L.gl;
                R.enable(R.SCISSOR_TEST),
                R.scissor(l * i.exported.devicePixelRatio, h * i.exported.devicePixelRatio, _ * i.exported.devicePixelRatio, b * i.exported.devicePixelRatio),
                L.clear({
                    color: T
                }),
                R.disable(R.SCISSOR_TEST)
            }
            let Tl = i.createLayout([{
                name: "a_pos_3f",
                components: 3,
                type: "Float32"
            }])
              , {members: El} = Tl;
            function Mo(m, l, h, _) {
                m.emplaceBack(l, h, _)
            }
            class Dh {
                constructor(l) {
                    this.vertexArray = new i.StructArrayLayout3f12,
                    this.indices = new i.StructArrayLayout3ui6,
                    Mo(this.vertexArray, -1, -1, 1),
                    Mo(this.vertexArray, 1, -1, 1),
                    Mo(this.vertexArray, -1, 1, 1),
                    Mo(this.vertexArray, 1, 1, 1),
                    Mo(this.vertexArray, -1, -1, -1),
                    Mo(this.vertexArray, 1, -1, -1),
                    Mo(this.vertexArray, -1, 1, -1),
                    Mo(this.vertexArray, 1, 1, -1),
                    this.indices.emplaceBack(5, 1, 3),
                    this.indices.emplaceBack(3, 7, 5),
                    this.indices.emplaceBack(6, 2, 0),
                    this.indices.emplaceBack(0, 4, 6),
                    this.indices.emplaceBack(2, 6, 7),
                    this.indices.emplaceBack(7, 3, 2),
                    this.indices.emplaceBack(5, 4, 0),
                    this.indices.emplaceBack(0, 1, 5),
                    this.indices.emplaceBack(0, 2, 3),
                    this.indices.emplaceBack(3, 1, 0),
                    this.indices.emplaceBack(7, 6, 4),
                    this.indices.emplaceBack(4, 5, 7),
                    this.vertexBuffer = l.createVertexBuffer(this.vertexArray, El),
                    this.indexBuffer = l.createIndexBuffer(this.indices),
                    this.segment = i.SegmentVector.simpleSegment(0, 0, 36, 12)
                }
            }
            function ii(m, l, h, _, b, T) {
                let L = m.gl
                  , R = l.paint.get("sky-atmosphere-color")
                  , O = l.paint.get("sky-atmosphere-halo-color")
                  , V = l.paint.get("sky-atmosphere-sun-intensity")
                  , G = ((J,le,me,pe,ge)=>({
                    u_matrix_3f: J,
                    u_sun_direction: le,
                    u_sun_intensity: me,
                    u_color_tint_r: [pe.r, pe.g, pe.b, pe.a],
                    u_color_tint_m: [ge.r, ge.g, ge.b, ge.a],
                    u_luminance: 5e-5
                }))(i.fromMat4(i.create$1(), _), b, V, R, O);
                L.framebufferTexture2D(L.FRAMEBUFFER, L.COLOR_ATTACHMENT0, L.TEXTURE_CUBE_MAP_POSITIVE_X + T, l.skyboxTexture, 0),
                h.draw(m, L.TRIANGLES, i.DepthMode.disabled, i.StencilMode.disabled, i.ColorMode.unblended, i.CullFaceMode.frontCW, G, "skyboxCapture", l.skyboxGeometry.vertexBuffer, l.skyboxGeometry.indexBuffer, l.skyboxGeometry.segment)
            }
            let Lh = i.createLayout([{
                type: "Float32",
                name: "a_pos",
                components: 3
            }, {
                type: "Float32",
                name: "a_uv",
                components: 2
            }]);
            class ox {
                constructor(l) {
                    let h = new i.StructArrayLayout5f20;
                    h.emplaceBack(-1, 1, 1, 0, 0),
                    h.emplaceBack(1, 1, 1, 1, 0),
                    h.emplaceBack(1, -1, 1, 1, 1),
                    h.emplaceBack(-1, -1, 1, 0, 1);
                    let _ = new i.StructArrayLayout3ui6;
                    _.emplaceBack(0, 1, 2),
                    _.emplaceBack(2, 3, 0),
                    this.vertexBuffer = l.createVertexBuffer(h, Lh.members),
                    this.indexBuffer = l.createIndexBuffer(_),
                    this.segments = i.SegmentVector.simpleSegment(0, 0, 4, 2)
                }
                destroy() {
                    this.vertexBuffer.destroy(),
                    this.indexBuffer.destroy(),
                    this.segments.destroy()
                }
            }
            let Gf = {
                symbol: function(m, l, h, _, b) {
                    if (m.renderPass !== "translucent")
                        return;
                    let T = i.StencilMode.disabled
                      , L = m.colorModeForRenderPass();
                    h.layout.get("text-variable-anchor") && function(R, O, V, G, J, le, me) {
                        let pe = O.transform
                          , ge = J === "map"
                          , ve = le === "map";
                        for (let re of R) {
                            let Ce = G.getTile(re)
                              , Ae = Ce.getBucket(V);
                            if (!Ae || !Ae.text || !Ae.text.segments.get().length)
                                continue;
                            let De = i.evaluateSizeForZoom(Ae.textSizeData, pe.zoom)
                              , Ve = dh(re, Ae.getProjection(), pe)
                              , Fe = pe.calculatePixelsToTileUnitsMatrix(Ce)
                              , Xe = Xo(Ve, Ce.tileID.canonical, ve, ge, pe, Ae.getProjection(), Fe)
                              , $e = V.layout.get("icon-text-fit") !== "none" && Ae.hasIconData();
                            if (De) {
                                let rt = Math.pow(2, pe.zoom - Ce.tileID.overscaledZ);
                                bl(Ae, ge, ve, me, i.symbolSize, pe, Xe, re, rt, De, $e)
                            }
                        }
                    }(_, m, h, l, h.layout.get("text-rotation-alignment"), h.layout.get("text-pitch-alignment"), b),
                    h.paint.get("icon-opacity").constantOr(1) !== 0 && Mg(m, l, h, _, !1, h.paint.get("icon-translate"), h.paint.get("icon-translate-anchor"), h.layout.get("icon-rotation-alignment"), h.layout.get("icon-pitch-alignment"), h.layout.get("icon-keep-upright"), T, L),
                    h.paint.get("text-opacity").constantOr(1) !== 0 && Mg(m, l, h, _, !0, h.paint.get("text-translate"), h.paint.get("text-translate-anchor"), h.layout.get("text-rotation-alignment"), h.layout.get("text-pitch-alignment"), h.layout.get("text-keep-upright"), T, L),
                    l.map.showCollisionBoxes && (Sg(m, l, h, _, h.paint.get("text-translate"), h.paint.get("text-translate-anchor"), !0),
                    Sg(m, l, h, _, h.paint.get("icon-translate"), h.paint.get("icon-translate-anchor"), !1))
                },
                circle: function(m, l, h, _) {
                    if (m.renderPass !== "translucent")
                        return;
                    let b = h.paint.get("circle-opacity")
                      , T = h.paint.get("circle-stroke-width")
                      , L = h.paint.get("circle-stroke-opacity")
                      , R = h.layout.get("circle-sort-key").constantOr(1) !== void 0;
                    if (b.constantOr(1) === 0 && (T.constantOr(1) === 0 || L.constantOr(1) === 0))
                        return;
                    let O = m.context
                      , V = O.gl
                      , G = m.transform
                      , J = m.depthModeForSublayer(0, i.DepthMode.ReadOnly)
                      , le = i.StencilMode.disabled
                      , me = m.colorModeForRenderPass()
                      , pe = G.projection.name === "globe"
                      , ge = [i.mercatorXfromLng(G.center.lng), i.mercatorYfromLat(G.center.lat)]
                      , ve = [];
                    for (let Ce = 0; Ce < _.length; Ce++) {
                        let Ae = _[Ce]
                          , De = l.getTile(Ae)
                          , Ve = De.getBucket(h);
                        if (!Ve || Ve.projection.name !== G.projection.name)
                            continue;
                        let Fe = Ve.programConfigurations.get(h.id)
                          , Xe = Gc(h);
                        pe && Xe.push("PROJECTION_GLOBE_VIEW");
                        let $e = m.useProgram("circle", Fe, Xe)
                          , rt = Ve.layoutVertexBuffer
                          , lt = Ve.globeExtVertexBuffer
                          , Vt = Ve.indexBuffer
                          , nt = G.projection.createInversionMatrix(G, Ae.canonical)
                          , vt = {
                            programConfiguration: Fe,
                            program: $e,
                            layoutVertexBuffer: rt,
                            globeExtVertexBuffer: lt,
                            indexBuffer: Vt,
                            uniformValues: Vc(m, Ae, De, nt, ge, h),
                            tile: De
                        };
                        if (R) {
                            let pt = Ve.segments.get();
                            for (let Dt of pt)
                                ve.push({
                                    segments: new i.SegmentVector([Dt]),
                                    sortKey: Dt.sortKey,
                                    state: vt
                                })
                        } else
                            ve.push({
                                segments: Ve.segments,
                                sortKey: 0,
                                state: vt
                            })
                    }
                    R && ve.sort((Ce,Ae)=>Ce.sortKey - Ae.sortKey);
                    let re = {
                        useDepthForOcclusion: !pe
                    };
                    for (let Ce of ve) {
                        let {programConfiguration: Ae, program: De, layoutVertexBuffer: Ve, globeExtVertexBuffer: Fe, indexBuffer: Xe, uniformValues: $e, tile: rt} = Ce.state
                          , lt = Ce.segments;
                        m.terrain && m.terrain.setupElevationDraw(rt, De, re),
                        m.prepareDrawProgram(O, De, rt.tileID.toUnwrapped()),
                        De.draw(O, V.TRIANGLES, J, le, me, i.CullFaceMode.disabled, $e, h.id, Ve, Xe, lt, h.paint, G.zoom, Ae, [Fe])
                    }
                },
                heatmap: function(m, l, h, _) {
                    if (h.paint.get("heatmap-opacity") !== 0)
                        if (m.renderPass === "offscreen") {
                            let b = m.context
                              , T = b.gl
                              , L = i.StencilMode.disabled
                              , R = new i.ColorMode([T.ONE, T.ONE],i.Color.transparent,[!0, !0, !0, !0]);
                            (function(me, pe, ge, ve) {
                                let re = me.gl
                                  , Ce = pe.width * ve
                                  , Ae = pe.height * ve;
                                me.activeTexture.set(re.TEXTURE1),
                                me.viewport.set([0, 0, Ce, Ae]);
                                let De = ge.heatmapFbo;
                                if (!De || De && (De.width !== Ce || De.height !== Ae)) {
                                    De && De.destroy();
                                    let Ve = re.createTexture();
                                    re.bindTexture(re.TEXTURE_2D, Ve),
                                    re.texParameteri(re.TEXTURE_2D, re.TEXTURE_WRAP_S, re.CLAMP_TO_EDGE),
                                    re.texParameteri(re.TEXTURE_2D, re.TEXTURE_WRAP_T, re.CLAMP_TO_EDGE),
                                    re.texParameteri(re.TEXTURE_2D, re.TEXTURE_MIN_FILTER, re.LINEAR),
                                    re.texParameteri(re.TEXTURE_2D, re.TEXTURE_MAG_FILTER, re.LINEAR),
                                    De = ge.heatmapFbo = me.createFramebuffer(Ce, Ae, !1),
                                    function(Fe, Xe, $e, rt, lt, Vt) {
                                        let nt = Fe.gl;
                                        nt.texImage2D(nt.TEXTURE_2D, 0, Fe.isWebGL2 && Fe.extRenderToTextureHalfFloat ? nt.RGBA16F : nt.RGBA, lt, Vt, 0, nt.RGBA, Fe.extRenderToTextureHalfFloat ? Fe.isWebGL2 ? nt.HALF_FLOAT : Fe.extTextureHalfFloat.HALF_FLOAT_OES : nt.UNSIGNED_BYTE, null),
                                        rt.colorAttachment.set($e)
                                    }(me, 0, Ve, De, Ce, Ae)
                                } else
                                    re.bindTexture(re.TEXTURE_2D, De.colorAttachment.get()),
                                    me.bindFramebuffer.set(De.framebuffer)
                            }
                            )(b, m, h, m.transform.projection.name === "globe" ? .5 : .25),
                            b.clear({
                                color: i.Color.transparent
                            });
                            let O = m.transform
                              , V = O.projection.name === "globe"
                              , G = V ? ["PROJECTION_GLOBE_VIEW"] : null
                              , J = V ? i.CullFaceMode.frontCCW : i.CullFaceMode.disabled
                              , le = [i.mercatorXfromLng(O.center.lng), i.mercatorYfromLat(O.center.lat)];
                            for (let me = 0; me < _.length; me++) {
                                let pe = _[me];
                                if (l.hasRenderableParent(pe))
                                    continue;
                                let ge = l.getTile(pe)
                                  , ve = ge.getBucket(h);
                                if (!ve || ve.projection.name !== O.projection.name)
                                    continue;
                                let re = ve.programConfigurations.get(h.id)
                                  , Ce = m.useProgram("heatmap", re, G)
                                  , {zoom: Ae} = m.transform;
                                m.terrain && m.terrain.setupElevationDraw(ge, Ce),
                                m.prepareDrawProgram(b, Ce, pe.toUnwrapped());
                                let De = O.projection.createInversionMatrix(O, pe.canonical);
                                Ce.draw(b, T.TRIANGLES, i.DepthMode.disabled, L, R, J, co(m, pe, ge, De, le, Ae, h.paint.get("heatmap-intensity")), h.id, ve.layoutVertexBuffer, ve.indexBuffer, ve.segments, h.paint, m.transform.zoom, re, V ? [ve.globeExtVertexBuffer] : null)
                            }
                            b.viewport.set([0, 0, m.width, m.height])
                        } else
                            m.renderPass === "translucent" && (m.context.setColorMode(m.colorModeForRenderPass()),
                            function(b, T) {
                                let L = b.context
                                  , R = L.gl
                                  , O = T.heatmapFbo;
                                if (!O)
                                    return;
                                L.activeTexture.set(R.TEXTURE0),
                                R.bindTexture(R.TEXTURE_2D, O.colorAttachment.get()),
                                L.activeTexture.set(R.TEXTURE1);
                                let V = T.colorRampTexture;
                                V || (V = T.colorRampTexture = new i.Texture(L,T.colorRamp,R.RGBA)),
                                V.bind(R.LINEAR, R.CLAMP_TO_EDGE),
                                b.useProgram("heatmapTexture").draw(L, R.TRIANGLES, i.DepthMode.disabled, i.StencilMode.disabled, b.colorModeForRenderPass(), i.CullFaceMode.disabled, ((G,J,le,me)=>({
                                    u_image: 0,
                                    u_color_ramp: 1,
                                    u_opacity: J.paint.get("heatmap-opacity")
                                }))(0, T), T.id, b.viewportBuffer, b.quadTriangleIndexBuffer, b.viewportSegments, T.paint, b.transform.zoom)
                            }(m, h))
                },
                line: function(m, l, h, _) {
                    if (m.renderPass !== "translucent")
                        return;
                    let b = h.paint.get("line-opacity")
                      , T = h.paint.get("line-width");
                    if (b.constantOr(1) === 0 || T.constantOr(1) === 0)
                        return;
                    let L = m.depthModeForSublayer(0, i.DepthMode.ReadOnly)
                      , R = m.colorModeForRenderPass()
                      , O = m.terrain && m.terrain.renderingToTexture ? 1 : i.exported.devicePixelRatio
                      , V = h.paint.get("line-dasharray")
                      , G = V.constantOr(1)
                      , J = h.layout.get("line-cap")
                      , le = h.paint.get("line-pattern")
                      , me = le.constantOr(1)
                      , pe = h.paint.get("line-gradient")
                      , ge = me ? "linePattern" : "line"
                      , ve = m.context
                      , re = ve.gl
                      , Ce = (De=>{
                        let Ve = [];
                        Ch(De) && Ve.push("RENDER_LINE_DASH"),
                        De.paint.get("line-gradient") && Ve.push("RENDER_LINE_GRADIENT");
                        let Fe = De.paint.get("line-trim-offset");
                        Fe[0] === 0 && Fe[1] === 0 || Ve.push("RENDER_LINE_TRIM_OFFSET");
                        let Xe = De.paint.get("line-pattern").constantOr(1)
                          , $e = De.paint.get("line-opacity").constantOr(1) !== 1;
                        return !Xe && $e && Ve.push("RENDER_LINE_ALPHA_DISCARD"),
                        Ve
                    }
                    )(h)
                      , Ae = Ce.includes("RENDER_LINE_ALPHA_DISCARD");
                    m.terrain && m.terrain.clipOrMaskOverlapStencilType() && (Ae = !1);
                    for (let De of _) {
                        let Ve = l.getTile(De);
                        if (me && !Ve.patternsLoaded())
                            continue;
                        let Fe = Ve.getBucket(h);
                        if (!Fe)
                            continue;
                        m.prepareDrawTile();
                        let Xe = Fe.programConfigurations.get(h.id)
                          , $e = m.useProgram(ge, Xe, Ce)
                          , rt = le.constantOr(null);
                        if (rt && Ve.imageAtlas) {
                            let Je = Ve.imageAtlas.patternPositions[rt.toString()];
                            Je && Xe.setConstantPatternPositions(Je)
                        }
                        let lt = V.constantOr(null)
                          , Vt = J.constantOr(null);
                        if (!me && lt && Vt && Ve.lineAtlas) {
                            let Je = Ve.lineAtlas.getDash(lt, Vt);
                            Je && Xe.setConstantPatternPositions(Je)
                        }
                        let[nt,vt] = h.paint.get("line-trim-offset");
                        if (Vt === "round" || Vt === "square") {
                            let Je = 1;
                            nt !== vt && (nt === 0 && (nt -= Je),
                            vt === 1 && (vt += Je))
                        }
                        let pt = m.terrain ? De.projMatrix : null
                          , Dt = me ? wg(m, Ve, h, pt, O) : Rf(m, Ve, h, pt, Fe.lineClipsArray.length, O, [nt, vt]);
                        if (pe) {
                            let Je = Fe.gradients[h.id]
                              , ct = Je.texture;
                            if (h.gradientVersion !== Je.version) {
                                let At = 256;
                                if (h.stepInterpolant) {
                                    let Pt = l.getSource().maxzoom
                                      , pn = De.canonical.z === Pt ? Math.ceil(1 << m.transform.maxZoom - De.canonical.z) : 1;
                                    At = i.clamp(i.nextPowerOfTwo(Fe.maxLineLength / i.EXTENT * 1024 * pn), 256, ve.maxTextureSize)
                                }
                                Je.gradient = i.renderColorRamp({
                                    expression: h.gradientExpression(),
                                    evaluationKey: "lineProgress",
                                    resolution: At,
                                    image: Je.gradient || void 0,
                                    clips: Fe.lineClipsArray
                                }),
                                Je.texture ? Je.texture.update(Je.gradient) : Je.texture = new i.Texture(ve,Je.gradient,re.RGBA),
                                Je.version = h.gradientVersion,
                                ct = Je.texture
                            }
                            ve.activeTexture.set(re.TEXTURE1),
                            ct.bind(h.stepInterpolant ? re.NEAREST : re.LINEAR, re.CLAMP_TO_EDGE)
                        }
                        G && (ve.activeTexture.set(re.TEXTURE0),
                        Ve.lineAtlasTexture.bind(re.LINEAR, re.REPEAT),
                        Xe.updatePaintBuffers()),
                        me && (ve.activeTexture.set(re.TEXTURE0),
                        Ve.imageAtlasTexture.bind(re.LINEAR, re.CLAMP_TO_EDGE),
                        Xe.updatePaintBuffers()),
                        m.prepareDrawProgram(ve, $e, De.toUnwrapped());
                        let st = Je=>{
                            $e.draw(ve, re.TRIANGLES, L, Je, R, i.CullFaceMode.disabled, Dt, h.id, Fe.layoutVertexBuffer, Fe.indexBuffer, Fe.segments, h.paint, m.transform.zoom, Xe, [Fe.layoutVertexBuffer2])
                        }
                        ;
                        if (Ae) {
                            let Je = m.stencilModeForClipping(De).ref;
                            Je === 0 && m.terrain && ve.clear({
                                stencil: 0
                            });
                            let ct = {
                                func: re.EQUAL,
                                mask: 255
                            };
                            Dt.u_alpha_discard_threshold = .8,
                            st(new i.StencilMode(ct,Je,255,re.KEEP,re.KEEP,re.INVERT)),
                            Dt.u_alpha_discard_threshold = 0,
                            st(new i.StencilMode(ct,Je,255,re.KEEP,re.KEEP,re.KEEP))
                        } else
                            st(m.stencilModeForClipping(De))
                    }
                    Ae && (m.resetStencilClippingMasks(),
                    m.terrain && ve.clear({
                        stencil: 0
                    }))
                },
                fill: function(m, l, h, _) {
                    let b = h.paint.get("fill-color")
                      , T = h.paint.get("fill-opacity");
                    if (T.constantOr(1) === 0)
                        return;
                    let L = m.colorModeForRenderPass()
                      , R = h.paint.get("fill-pattern")
                      , O = m.opaquePassEnabledForLayer() && !R.constantOr(1) && b.constantOr(i.Color.transparent).a === 1 && T.constantOr(0) === 1 ? "opaque" : "translucent";
                    if (m.renderPass === O) {
                        let V = m.depthModeForSublayer(1, m.renderPass === "opaque" ? i.DepthMode.ReadWrite : i.DepthMode.ReadOnly);
                        Cg(m, l, h, _, V, L, !1)
                    }
                    if (m.renderPass === "translucent" && h.paint.get("fill-antialias")) {
                        let V = m.depthModeForSublayer(h.getPaintProperty("fill-outline-color") ? 2 : 0, i.DepthMode.ReadOnly);
                        Cg(m, l, h, _, V, L, !0)
                    }
                },
                "fill-extrusion": function(m, l, h, _) {
                    let b = h.paint.get("fill-extrusion-opacity");
                    if (b !== 0 && m.renderPass === "translucent") {
                        let T = new i.DepthMode(m.context.gl.LEQUAL,i.DepthMode.ReadWrite,m.depthRangeFor3D);
                        if (b !== 1 || h.paint.get("fill-extrusion-pattern").constantOr(1))
                            Ff(m, l, h, _, T, i.StencilMode.disabled, i.ColorMode.disabled),
                            Ff(m, l, h, _, T, m.stencilModeFor3D(), m.colorModeForRenderPass()),
                            m.resetStencilClippingMasks();
                        else {
                            let L = m.colorModeForRenderPass();
                            Ff(m, l, h, _, T, i.StencilMode.disabled, L)
                        }
                    }
                },
                hillshade: function(m, l, h, _) {
                    if (m.renderPass !== "offscreen" && m.renderPass !== "translucent")
                        return;
                    let b = m.context
                      , T = m.depthModeForSublayer(0, i.DepthMode.ReadOnly)
                      , L = m.colorModeForRenderPass()
                      , R = m.terrain && m.terrain.renderingToTexture
                      , [O,V] = m.renderPass !== "translucent" || R ? [{}, _] : m.stencilConfigForOverlap(_);
                    for (let G of V) {
                        let J = l.getTile(G);
                        if (J.needsHillshadePrepare && m.renderPass === "offscreen")
                            bh(m, J, h, T, i.StencilMode.disabled, L);
                        else if (m.renderPass === "translucent") {
                            let le = R && m.terrain ? m.terrain.stencilModeForRTTOverlap(G) : O[G.overscaledZ];
                            Fc(m, G, J, h, T, le, L)
                        }
                    }
                    b.viewport.set([0, 0, m.width, m.height]),
                    m.resetStencilClippingMasks()
                },
                raster: function(m, l, h, _, b, T) {
                    if (m.renderPass !== "translucent" || h.paint.get("raster-opacity") === 0 || !_.length)
                        return;
                    let L = m.context
                      , R = L.gl
                      , O = l.getSource()
                      , V = m.useProgram("raster")
                      , G = m.colorModeForRenderPass()
                      , J = m.terrain && m.terrain.renderingToTexture
                      , [le,me] = O instanceof ue || J ? [{}, _] : m.stencilConfigForOverlap(_)
                      , pe = me[me.length - 1].overscaledZ
                      , ge = !m.options.moving;
                    for (let ve of me) {
                        let re = J ? i.DepthMode.disabled : m.depthModeForSublayer(ve.overscaledZ - pe, h.paint.get("raster-opacity") === 1 ? i.DepthMode.ReadWrite : i.DepthMode.ReadOnly, R.LESS)
                          , Ce = ve.toUnwrapped()
                          , Ae = l.getTile(ve);
                        if (J && (!Ae || !Ae.hasData()))
                            continue;
                        let De = J ? ve.projMatrix : m.transform.calculateProjMatrix(Ce, ge)
                          , Ve = m.terrain && J ? m.terrain.stencilModeForRTTOverlap(ve) : le[ve.overscaledZ]
                          , Fe = T ? 0 : h.paint.get("raster-fade-duration");
                        Ae.registerFadeDuration(Fe);
                        let Xe = l.findLoadedParent(ve, 0), $e = Uc(Ae, Xe, l, m.transform, Fe), rt, lt;
                        m.terrain && m.terrain.prepareDrawTile();
                        let Vt = h.paint.get("raster-resampling") === "nearest" ? R.NEAREST : R.LINEAR;
                        L.activeTexture.set(R.TEXTURE0),
                        Ae.texture.bind(Vt, R.CLAMP_TO_EDGE),
                        L.activeTexture.set(R.TEXTURE1),
                        Xe ? (Xe.texture.bind(Vt, R.CLAMP_TO_EDGE),
                        rt = Math.pow(2, Xe.tileID.overscaledZ - Ae.tileID.overscaledZ),
                        lt = [Ae.tileID.canonical.x * rt % 1, Ae.tileID.canonical.y * rt % 1]) : Ae.texture.bind(Vt, R.CLAMP_TO_EDGE);
                        let nt = tx(De, lt || [0, 0], rt || 1, $e, h, O instanceof ue ? O.perspectiveTransform : [0, 0]);
                        if (m.prepareDrawProgram(L, V, Ce),
                        O instanceof ue)
                            O.boundsBuffer && O.boundsSegments && V.draw(L, R.TRIANGLES, re, i.StencilMode.disabled, G, i.CullFaceMode.disabled, nt, h.id, O.boundsBuffer, m.quadTriangleIndexBuffer, O.boundsSegments);
                        else {
                            let {tileBoundsBuffer: vt, tileBoundsIndexBuffer: pt, tileBoundsSegments: Dt} = m.getTileBoundsBuffers(Ae);
                            V.draw(L, R.TRIANGLES, re, Ve, G, i.CullFaceMode.disabled, nt, h.id, vt, pt, Dt)
                        }
                    }
                    m.resetStencilClippingMasks()
                },
                background: function(m, l, h, _) {
                    let b = h.paint.get("background-color")
                      , T = h.paint.get("background-opacity");
                    if (T === 0)
                        return;
                    let L = m.context
                      , R = L.gl
                      , O = m.transform
                      , V = O.tileSize
                      , G = h.paint.get("background-pattern");
                    if (m.isPatternMissing(G))
                        return;
                    let J = !G && b.a === 1 && T === 1 && m.opaquePassEnabledForLayer() ? "opaque" : "translucent";
                    if (m.renderPass !== J)
                        return;
                    let le = i.StencilMode.disabled, me = m.depthModeForSublayer(0, J === "opaque" ? i.DepthMode.ReadWrite : i.DepthMode.ReadOnly), pe = m.colorModeForRenderPass(), ge = m.useProgram(G ? "backgroundPattern" : "background"), ve, re = _;
                    re || (ve = m.getBackgroundTiles(),
                    re = Object.values(ve).map(Ce=>Ce.tileID)),
                    G && (L.activeTexture.set(R.TEXTURE0),
                    m.imageManager.bind(m.context));
                    for (let Ce of re) {
                        let Ae = Ce.toUnwrapped()
                          , De = _ ? Ce.projMatrix : m.transform.calculateProjMatrix(Ae);
                        m.prepareDrawTile();
                        let Ve = l ? l.getTile(Ce) : ve ? ve[Ce.key] : new i.Tile(Ce,V,O.zoom,m)
                          , Fe = G ? Of(De, T, m, G, {
                            tileID: Ce,
                            tileSize: V
                        }) : nx(De, T, b);
                        m.prepareDrawProgram(L, ge, Ae);
                        let {tileBoundsBuffer: Xe, tileBoundsIndexBuffer: $e, tileBoundsSegments: rt} = m.getTileBoundsBuffers(Ve);
                        ge.draw(L, R.TRIANGLES, me, le, pe, i.CullFaceMode.disabled, Fe, h.id, Xe, $e, rt)
                    }
                },
                sky: function(m, l, h) {
                    let _ = m.transform
                      , b = _.projection.name === "mercator" || _.projection.name === "globe" ? 1 : i.smoothstep(7, 8, _.zoom)
                      , T = h.paint.get("sky-opacity") * b;
                    if (T === 0)
                        return;
                    let L = m.context
                      , R = h.paint.get("sky-type")
                      , O = new i.DepthMode(L.gl.LEQUAL,i.DepthMode.ReadOnly,[0, 1])
                      , V = m.frameCounter / 1e3 % 1;
                    R === "atmosphere" ? m.renderPass === "offscreen" ? h.needsSkyboxCapture(m) && (function(G, J, le, me) {
                        let pe = G.context
                          , ge = pe.gl
                          , ve = J.skyboxFbo;
                        if (!ve) {
                            ve = J.skyboxFbo = pe.createFramebuffer(32, 32, !1),
                            J.skyboxGeometry = new Dh(pe),
                            J.skyboxTexture = pe.gl.createTexture(),
                            ge.bindTexture(ge.TEXTURE_CUBE_MAP, J.skyboxTexture),
                            ge.texParameteri(ge.TEXTURE_CUBE_MAP, ge.TEXTURE_WRAP_S, ge.CLAMP_TO_EDGE),
                            ge.texParameteri(ge.TEXTURE_CUBE_MAP, ge.TEXTURE_WRAP_T, ge.CLAMP_TO_EDGE),
                            ge.texParameteri(ge.TEXTURE_CUBE_MAP, ge.TEXTURE_MIN_FILTER, ge.LINEAR),
                            ge.texParameteri(ge.TEXTURE_CUBE_MAP, ge.TEXTURE_MAG_FILTER, ge.LINEAR);
                            for (let De = 0; De < 6; ++De)
                                ge.texImage2D(ge.TEXTURE_CUBE_MAP_POSITIVE_X + De, 0, ge.RGBA, 32, 32, 0, ge.RGBA, ge.UNSIGNED_BYTE, null)
                        }
                        pe.bindFramebuffer.set(ve.framebuffer),
                        pe.viewport.set([0, 0, 32, 32]);
                        let re = J.getCenter(G, !0)
                          , Ce = G.useProgram("skyboxCapture")
                          , Ae = new Float64Array(16);
                        i.identity(Ae),
                        i.rotateY(Ae, Ae, .5 * -Math.PI),
                        ii(pe, J, Ce, Ae, re, 0),
                        i.identity(Ae),
                        i.rotateY(Ae, Ae, .5 * Math.PI),
                        ii(pe, J, Ce, Ae, re, 1),
                        i.identity(Ae),
                        i.rotateX(Ae, Ae, .5 * -Math.PI),
                        ii(pe, J, Ce, Ae, re, 2),
                        i.identity(Ae),
                        i.rotateX(Ae, Ae, .5 * Math.PI),
                        ii(pe, J, Ce, Ae, re, 3),
                        i.identity(Ae),
                        ii(pe, J, Ce, Ae, re, 4),
                        i.identity(Ae),
                        i.rotateY(Ae, Ae, Math.PI),
                        ii(pe, J, Ce, Ae, re, 5),
                        pe.viewport.set([0, 0, G.width, G.height])
                    }(m, h),
                    h.markSkyboxValid(m)) : m.renderPass === "sky" && function(G, J, le, me, pe) {
                        let ge = G.context
                          , ve = ge.gl
                          , re = G.transform
                          , Ce = G.useProgram("skybox");
                        ge.activeTexture.set(ve.TEXTURE0),
                        ve.bindTexture(ve.TEXTURE_CUBE_MAP, J.skyboxTexture);
                        let Ae = ((De,Ve,Fe,Xe,$e)=>({
                            u_matrix: De,
                            u_sun_direction: Ve,
                            u_cubemap: 0,
                            u_opacity: Xe,
                            u_temporal_offset: $e
                        }))(re.skyboxMatrix, J.getCenter(G, !1), 0, me, pe);
                        G.prepareDrawProgram(ge, Ce),
                        Ce.draw(ge, ve.TRIANGLES, le, i.StencilMode.disabled, G.colorModeForRenderPass(), i.CullFaceMode.backCW, Ae, "skybox", J.skyboxGeometry.vertexBuffer, J.skyboxGeometry.indexBuffer, J.skyboxGeometry.segment)
                    }(m, h, O, T, V) : R === "gradient" && m.renderPass === "sky" && function(G, J, le, me, pe) {
                        let ge = G.context
                          , ve = ge.gl
                          , re = G.transform
                          , Ce = G.useProgram("skyboxGradient");
                        J.skyboxGeometry || (J.skyboxGeometry = new Dh(ge)),
                        ge.activeTexture.set(ve.TEXTURE0);
                        let Ae = J.colorRampTexture;
                        Ae || (Ae = J.colorRampTexture = new i.Texture(ge,J.colorRamp,ve.RGBA)),
                        Ae.bind(ve.LINEAR, ve.CLAMP_TO_EDGE);
                        let De = ((Ve,Fe,Xe,$e,rt)=>({
                            u_matrix: Ve,
                            u_color_ramp: 0,
                            u_center_direction: Fe,
                            u_radius: i.degToRad(Xe),
                            u_opacity: $e,
                            u_temporal_offset: rt
                        }))(re.skyboxMatrix, J.getCenter(G, !1), J.paint.get("sky-gradient-radius"), me, pe);
                        G.prepareDrawProgram(ge, Ce),
                        Ce.draw(ge, ve.TRIANGLES, le, i.StencilMode.disabled, G.colorModeForRenderPass(), i.CullFaceMode.backCW, De, "skyboxGradient", J.skyboxGeometry.vertexBuffer, J.skyboxGeometry.indexBuffer, J.skyboxGeometry.segment)
                    }(m, h, O, T, V)
                },
                debug: function(m, l, h) {
                    for (let _ = 0; _ < h.length; _++)
                        Vf(m, l, h[_])
                },
                custom: function(m, l, h, _) {
                    let b = m.context
                      , T = h.implementation;
                    if (!m.transform.projection.unsupportedLayers || !m.transform.projection.unsupportedLayers.includes("custom") || m.terrain && (m.terrain.renderingToTexture || m.renderPass === "offscreen") && h.isLayerDraped()) {
                        if (m.renderPass === "offscreen") {
                            let L = T.prerender;
                            if (L) {
                                if (m.setCustomLayerDefaults(),
                                b.setColorMode(m.colorModeForRenderPass()),
                                m.transform.projection.name === "globe") {
                                    let R = m.transform.pointMerc;
                                    L.call(T, b.gl, m.transform.customLayerMatrix(), m.transform.getProjection(), m.transform.globeToMercatorMatrix(), i.globeToMercatorTransition(m.transform.zoom), [R.x, R.y], m.transform.pixelsPerMeterRatio)
                                } else
                                    L.call(T, b.gl, m.transform.customLayerMatrix());
                                b.setDirty(),
                                m.setBaseState()
                            }
                        } else if (m.renderPass === "translucent") {
                            if (m.terrain && m.terrain.renderingToTexture) {
                                let R = T.renderToTile;
                                if (R) {
                                    let O = _[0].canonical
                                      , V = new i.MercatorCoordinate(O.x + _[0].wrap * (1 << O.z),O.y,O.z);
                                    b.setDepthMode(i.DepthMode.disabled),
                                    b.setStencilMode(i.StencilMode.disabled),
                                    b.setColorMode(m.colorModeForRenderPass()),
                                    m.setCustomLayerDefaults(),
                                    R.call(T, b.gl, V),
                                    b.setDirty(),
                                    m.setBaseState()
                                }
                                return
                            }
                            m.setCustomLayerDefaults(),
                            b.setColorMode(m.colorModeForRenderPass()),
                            b.setStencilMode(i.StencilMode.disabled);
                            let L = T.renderingMode === "3d" ? new i.DepthMode(m.context.gl.LEQUAL,i.DepthMode.ReadWrite,m.depthRangeFor3D) : m.depthModeForSublayer(0, i.DepthMode.ReadOnly);
                            if (b.setDepthMode(L),
                            m.transform.projection.name === "globe") {
                                let R = m.transform.pointMerc;
                                T.render(b.gl, m.transform.customLayerMatrix(), m.transform.getProjection(), m.transform.globeToMercatorMatrix(), i.globeToMercatorTransition(m.transform.zoom), [R.x, R.y], m.transform.pixelsPerMeterRatio)
                            } else
                                T.render(b.gl, m.transform.customLayerMatrix());
                            b.setDirty(),
                            m.setBaseState(),
                            b.bindFramebuffer.set(null)
                        }
                    } else
                        i.warnOnce("Custom layers are not yet supported with this projection. Use mercator or globe to enable usage of custom layers.")
                }
            };
            class Xc {
                constructor(l, h, _=!1) {
                    this.context = new Te(l,_),
                    this.transform = h,
                    this._tileTextures = {},
                    this.frameCopies = [],
                    this.loadTimeStamps = [],
                    this.setup(),
                    this.numSublayers = i.SourceCache.maxUnderzooming + i.SourceCache.maxOverzooming + 1,
                    this.depthEpsilon = 1 / Math.pow(2, 16),
                    this.crossTileSymbolIndex = new hg,
                    this.deferredRenderGpuTimeQueries = [],
                    this.gpuTimers = {},
                    this.frameCounter = 0,
                    this._backgroundTiles = {}
                }
                updateTerrain(l, h) {
                    let _ = !!l && !!l.terrain && this.transform.projection.supportsTerrain;
                    if (!(_ || this._terrain && this._terrain.enabled))
                        return;
                    this._terrain || (this._terrain = new If(this,l));
                    let b = this._terrain;
                    this.transform.elevation = _ ? b : null,
                    b.update(l, this.transform, h)
                }
                _updateFog(l) {
                    let h = l.fog;
                    if (!h || this.transform.projection.name === "globe" || h.getOpacity(this.transform.pitch) < 1 || h.properties.get("horizon-blend") < .03)
                        return void (this.transform.fogCullDistSq = null);
                    let[_,b] = h.getFovAdjustedRange(this.transform._fov);
                    if (_ > b)
                        return void (this.transform.fogCullDistSq = null);
                    let T = _ + .78 * (b - _);
                    this.transform.fogCullDistSq = T * T
                }
                get terrain() {
                    return this.transform._terrainEnabled() && this._terrain && this._terrain.enabled ? this._terrain : null
                }
                resize(l, h) {
                    if (this.width = l * i.exported.devicePixelRatio,
                    this.height = h * i.exported.devicePixelRatio,
                    this.context.viewport.set([0, 0, this.width, this.height]),
                    this.style)
                        for (let _ of this.style.order)
                            this.style._layers[_].resize()
                }
                setup() {
                    let l = this.context
                      , h = new i.StructArrayLayout2i4;
                    h.emplaceBack(0, 0),
                    h.emplaceBack(i.EXTENT, 0),
                    h.emplaceBack(0, i.EXTENT),
                    h.emplaceBack(i.EXTENT, i.EXTENT),
                    this.tileExtentBuffer = l.createVertexBuffer(h, i.posAttributes.members),
                    this.tileExtentSegments = i.SegmentVector.simpleSegment(0, 0, 4, 2);
                    let _ = new i.StructArrayLayout2i4;
                    _.emplaceBack(0, 0),
                    _.emplaceBack(i.EXTENT, 0),
                    _.emplaceBack(0, i.EXTENT),
                    _.emplaceBack(i.EXTENT, i.EXTENT),
                    this.debugBuffer = l.createVertexBuffer(_, i.posAttributes.members),
                    this.debugSegments = i.SegmentVector.simpleSegment(0, 0, 4, 5);
                    let b = new i.StructArrayLayout2i4;
                    b.emplaceBack(-1, -1),
                    b.emplaceBack(1, -1),
                    b.emplaceBack(-1, 1),
                    b.emplaceBack(1, 1),
                    this.viewportBuffer = l.createVertexBuffer(b, i.posAttributes.members),
                    this.viewportSegments = i.SegmentVector.simpleSegment(0, 0, 4, 2);
                    let T = new i.StructArrayLayout4i8;
                    T.emplaceBack(0, 0, 0, 0),
                    T.emplaceBack(i.EXTENT, 0, i.EXTENT, 0),
                    T.emplaceBack(0, i.EXTENT, 0, i.EXTENT),
                    T.emplaceBack(i.EXTENT, i.EXTENT, i.EXTENT, i.EXTENT),
                    this.mercatorBoundsBuffer = l.createVertexBuffer(T, i.boundsAttributes.members),
                    this.mercatorBoundsSegments = i.SegmentVector.simpleSegment(0, 0, 4, 2);
                    let L = new i.StructArrayLayout3ui6;
                    L.emplaceBack(0, 1, 2),
                    L.emplaceBack(2, 1, 3),
                    this.quadTriangleIndexBuffer = l.createIndexBuffer(L);
                    let R = new i.StructArrayLayout1ui2;
                    for (let V of [0, 1, 3, 2, 0])
                        R.emplaceBack(V);
                    this.debugIndexBuffer = l.createIndexBuffer(R),
                    this.emptyTexture = new i.Texture(l,new i.RGBAImage({
                        width: 1,
                        height: 1
                    },Uint8Array.of(0, 0, 0, 0)),l.gl.RGBA),
                    this.identityMat = i.create();
                    let O = this.context.gl;
                    this.stencilClearMode = new i.StencilMode({
                        func: O.ALWAYS,
                        mask: 0
                    },0,255,O.ZERO,O.ZERO,O.ZERO),
                    this.loadTimeStamps.push(i.window.performance.now()),
                    this.atmosphereBuffer = new ox(this.context)
                }
                getMercatorTileBoundsBuffers() {
                    return {
                        tileBoundsBuffer: this.mercatorBoundsBuffer,
                        tileBoundsIndexBuffer: this.quadTriangleIndexBuffer,
                        tileBoundsSegments: this.mercatorBoundsSegments
                    }
                }
                getTileBoundsBuffers(l) {
                    return l._makeTileBoundsBuffers(this.context, this.transform.projection),
                    l._tileBoundsBuffer ? {
                        tileBoundsBuffer: l._tileBoundsBuffer,
                        tileBoundsIndexBuffer: l._tileBoundsIndexBuffer,
                        tileBoundsSegments: l._tileBoundsSegments
                    } : this.getMercatorTileBoundsBuffers()
                }
                clearStencil() {
                    let l = this.context
                      , h = l.gl;
                    this.nextStencilID = 1,
                    this.currentStencilSource = void 0,
                    this._tileClippingMaskIDs = {},
                    this.useProgram("clippingMask").draw(l, h.TRIANGLES, i.DepthMode.disabled, this.stencilClearMode, i.ColorMode.disabled, i.CullFaceMode.disabled, si(this.identityMat), "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments)
                }
                resetStencilClippingMasks() {
                    this.terrain || (this.currentStencilSource = void 0,
                    this._tileClippingMaskIDs = {})
                }
                _renderTileClippingMasks(l, h, _) {
                    if (!h || this.currentStencilSource === h.id || !l.isTileClipped() || !_ || _.length === 0)
                        return;
                    if (this._tileClippingMaskIDs && !this.terrain) {
                        let R = !1;
                        for (let O of _)
                            if (this._tileClippingMaskIDs[O.key] === void 0) {
                                R = !0;
                                break
                            }
                        if (!R)
                            return
                    }
                    this.currentStencilSource = h.id;
                    let b = this.context
                      , T = b.gl;
                    this.nextStencilID + _.length > 256 && this.clearStencil(),
                    b.setColorMode(i.ColorMode.disabled),
                    b.setDepthMode(i.DepthMode.disabled);
                    let L = this.useProgram("clippingMask");
                    this._tileClippingMaskIDs = {};
                    for (let R of _) {
                        let O = h.getTile(R)
                          , V = this._tileClippingMaskIDs[R.key] = this.nextStencilID++
                          , {tileBoundsBuffer: G, tileBoundsIndexBuffer: J, tileBoundsSegments: le} = this.getTileBoundsBuffers(O);
                        L.draw(b, T.TRIANGLES, i.DepthMode.disabled, new i.StencilMode({
                            func: T.ALWAYS,
                            mask: 0
                        },V,255,T.KEEP,T.KEEP,T.REPLACE), i.ColorMode.disabled, i.CullFaceMode.disabled, si(R.projMatrix), "$clipping", G, J, le)
                    }
                }
                stencilModeFor3D() {
                    this.currentStencilSource = void 0,
                    this.nextStencilID + 1 > 256 && this.clearStencil();
                    let l = this.nextStencilID++
                      , h = this.context.gl;
                    return new i.StencilMode({
                        func: h.NOTEQUAL,
                        mask: 255
                    },l,255,h.KEEP,h.KEEP,h.REPLACE)
                }
                stencilModeForClipping(l) {
                    if (this.terrain)
                        return this.terrain.stencilModeForRTTOverlap(l);
                    let h = this.context.gl;
                    return new i.StencilMode({
                        func: h.EQUAL,
                        mask: 255
                    },this._tileClippingMaskIDs[l.key],0,h.KEEP,h.KEEP,h.REPLACE)
                }
                stencilConfigForOverlap(l) {
                    let h = this.context.gl
                      , _ = l.sort((L,R)=>R.overscaledZ - L.overscaledZ)
                      , b = _[_.length - 1].overscaledZ
                      , T = _[0].overscaledZ - b + 1;
                    if (T > 1) {
                        this.currentStencilSource = void 0,
                        this.nextStencilID + T > 256 && this.clearStencil();
                        let L = {};
                        for (let R = 0; R < T; R++)
                            L[R + b] = new i.StencilMode({
                                func: h.GEQUAL,
                                mask: 255
                            },R + this.nextStencilID,255,h.KEEP,h.KEEP,h.REPLACE);
                        return this.nextStencilID += T,
                        [L, _]
                    }
                    return [{
                        [b]: i.StencilMode.disabled
                    }, _]
                }
                colorModeForRenderPass() {
                    let l = this.context.gl;
                    if (this._showOverdrawInspector) {
                        let h = 1 / 8;
                        return new i.ColorMode([l.CONSTANT_COLOR, l.ONE],new i.Color(h,h,h,0),[!0, !0, !0, !0])
                    }
                    return this.renderPass === "opaque" ? i.ColorMode.unblended : i.ColorMode.alphaBlended
                }
                depthModeForSublayer(l, h, _) {
                    if (!this.opaquePassEnabledForLayer())
                        return i.DepthMode.disabled;
                    let b = 1 - ((1 + this.currentLayer) * this.numSublayers + l) * this.depthEpsilon;
                    return new i.DepthMode(_ || this.context.gl.LEQUAL,h,[b, b])
                }
                opaquePassEnabledForLayer() {
                    return this.currentLayer < this.opaquePassCutoff
                }
                render(l, h) {
                    this.style = l,
                    this.options = h,
                    this.imageManager = l.imageManager,
                    this.glyphManager = l.glyphManager,
                    this.symbolFadeChange = l.placement.symbolFadeChange(i.exported.now()),
                    this.imageManager.beginFrame();
                    let _ = this.style.order
                      , b = this.style._sourceCaches;
                    for (let O in b) {
                        let V = b[O];
                        V.used && V.prepare(this.context)
                    }
                    let T = {}
                      , L = {}
                      , R = {};
                    for (let O in b) {
                        let V = b[O];
                        T[O] = V.getVisibleCoordinates(),
                        L[O] = T[O].slice().reverse(),
                        R[O] = V.getVisibleCoordinates(!0).reverse()
                    }
                    this.opaquePassCutoff = 1 / 0;
                    for (let O = 0; O < _.length; O++)
                        if (this.style._layers[_[O]].is3D()) {
                            this.opaquePassCutoff = O;
                            break
                        }
                    if (this.terrain && (this.terrain.updateTileBinding(R),
                    this.opaquePassCutoff = 0),
                    this.transform.projection.name !== "globe" || this.globeSharedBuffers || (this.globeSharedBuffers = new i.GlobeSharedBuffers(this.context)),
                    i.isMapAuthenticated(this.context.gl)) {
                        this.renderPass = "offscreen";
                        for (let O of _) {
                            let V = this.style._layers[O]
                              , G = l._getLayerSourceCache(V);
                            if (!V.hasOffscreenPass() || V.isHidden(this.transform.zoom))
                                continue;
                            let J = G ? L[G.id] : void 0;
                            (V.type === "custom" || V.isSky() || J && J.length) && this.renderLayer(this, G, V, J)
                        }
                        if (this.depthRangeFor3D = [0, 1 - (l.order.length + 2) * this.numSublayers * this.depthEpsilon],
                        this.terrain && (this.style.hasSymbolLayers() || this.style.hasCircleLayers()) && this.terrain.drawDepth(),
                        this.context.bindFramebuffer.set(null),
                        this.context.viewport.set([0, 0, this.width, this.height]),
                        this.context.clear({
                            color: h.showOverdrawInspector ? i.Color.black : i.Color.transparent,
                            depth: 1
                        }),
                        this.clearStencil(),
                        this._showOverdrawInspector = h.showOverdrawInspector,
                        this.renderPass = "opaque",
                        !this.terrain)
                            for (this.currentLayer = _.length - 1; this.currentLayer >= 0; this.currentLayer--) {
                                let O = this.style._layers[_[this.currentLayer]]
                                  , V = l._getLayerSourceCache(O);
                                if (O.isSky())
                                    continue;
                                let G = V ? L[V.id] : void 0;
                                this._renderTileClippingMasks(O, V, G),
                                this.renderLayer(this, V, O, G)
                            }
                        if (this.style.fog && this.transform.projection.supportsFog && function(O, V) {
                            let G = O.context
                              , J = G.gl
                              , le = O.transform
                              , me = new i.DepthMode(J.LEQUAL,i.DepthMode.ReadOnly,[0, 1])
                              , pe = O.useProgram("globeAtmosphere", null, le.projection.name === "globe" ? ["PROJECTION_GLOBE_VIEW", "FOG"] : ["FOG"])
                              , ge = i.globeToMercatorTransition(le.zoom)
                              , ve = V.properties.get("color").toArray01()
                              , re = V.properties.get("high-color").toArray01()
                              , Ce = V.properties.get("space-color").toArray01PremultipliedAlpha()
                              , Ae = i.identity$1([]);
                            i.rotateY$1(Ae, Ae, -i.degToRad(le._center.lng)),
                            i.rotateX$1(Ae, Ae, i.degToRad(le._center.lat)),
                            i.rotateZ$1(Ae, Ae, le.angle),
                            i.rotateX$1(Ae, Ae, -le._pitch);
                            let De = i.fromQuat(new Float32Array(16), Ae)
                              , Ve = i.mapValue(V.properties.get("star-intensity"), 0, 1, 0, .25)
                              , Fe = 5e-4
                              , Xe = i.mapValue(V.properties.get("horizon-blend"), 0, 1, Fe, .25)
                              , $e = i.globeUseCustomAntiAliasing(O, G, le) && Xe === Fe ? le.worldSize / (2 * Math.PI * 1.025) - 1 : le.globeRadius
                              , rt = O.frameCounter / 1e3 % 1
                              , lt = i.length(le.globeCenterInViewSpace)
                              , Vt = Math.sqrt(Math.pow(lt, 2) - Math.pow($e, 2))
                              , nt = Math.acos(Vt / lt)
                              , vt = ((Dt,st,Je,ct,At,Pt,pn,Xn,un,sn,vn,Qn,En,pi)=>({
                                u_frustum_tl: Dt,
                                u_frustum_tr: st,
                                u_frustum_br: Je,
                                u_frustum_bl: ct,
                                u_horizon: At,
                                u_transition: Pt,
                                u_fadeout_range: pn,
                                u_color: Xn,
                                u_high_color: un,
                                u_space_color: sn,
                                u_star_intensity: vn,
                                u_star_size: 5 * i.exported.devicePixelRatio,
                                u_star_density: 0,
                                u_temporal_offset: Qn,
                                u_horizon_angle: En,
                                u_rotation_matrix: pi
                            }))(le.frustumCorners.TL, le.frustumCorners.TR, le.frustumCorners.BR, le.frustumCorners.BL, le.frustumCorners.horizon, ge, Xe, ve, re, Ce, Ve, rt, nt, De);
                            O.prepareDrawProgram(G, pe);
                            let pt = O.atmosphereBuffer;
                            pt && pe.draw(G, J.TRIANGLES, me, i.StencilMode.disabled, i.ColorMode.alphaBlended, i.CullFaceMode.backCW, vt, "skybox", pt.vertexBuffer, pt.indexBuffer, pt.segments)
                        }(this, this.style.fog),
                        this.renderPass = "sky",
                        (i.globeToMercatorTransition(this.transform.zoom) > 0 || this.transform.projection.name !== "globe") && this.transform.isHorizonVisible())
                            for (this.currentLayer = 0; this.currentLayer < _.length; this.currentLayer++) {
                                let O = this.style._layers[_[this.currentLayer]]
                                  , V = l._getLayerSourceCache(O);
                                O.isSky() && this.renderLayer(this, V, O, V ? L[V.id] : void 0)
                            }
                        for (this.renderPass = "translucent",
                        this.currentLayer = 0; this.currentLayer < _.length; ) {
                            let O = this.style._layers[_[this.currentLayer]]
                              , V = l._getLayerSourceCache(O);
                            if (O.isSky()) {
                                ++this.currentLayer;
                                continue
                            }
                            if (this.terrain && this.style.isLayerDraped(O)) {
                                if (O.isHidden(this.transform.zoom)) {
                                    ++this.currentLayer;
                                    continue
                                }
                                this.currentLayer = this.terrain.renderBatch(this.currentLayer);
                                continue
                            }
                            let G = V ? (O.type === "symbol" ? R : L)[V.id] : void 0;
                            this._renderTileClippingMasks(O, V, V ? T[V.id] : void 0),
                            this.renderLayer(this, V, O, G),
                            ++this.currentLayer
                        }
                        if (this.terrain && this.terrain.postRender(),
                        this.options.showTileBoundaries || this.options.showQueryGeometry || this.options.showTileAABBs) {
                            let O = null;
                            i.values(this.style._layers).forEach(V=>{
                                let G = l._getLayerSourceCache(V);
                                G && !V.isHidden(this.transform.zoom) && (!O || O.getSource().maxzoom < G.getSource().maxzoom) && (O = G)
                            }
                            ),
                            O && this.options.showTileBoundaries && Gf.debug(this, O, O.getVisibleCoordinates())
                        }
                        this.options.showPadding && function(O) {
                            let V = O.transform.padding;
                            Jo(O, O.transform.height - (V.top || 0), 3, Bf),
                            Jo(O, V.bottom || 0, 3, Uf),
                            wl(O, V.left || 0, 3, Dg),
                            wl(O, O.transform.width - (V.right || 0), 3, Lg);
                            let G = O.transform.centerPoint;
                            (function(J, le, me, pe) {
                                jc(J, le - 1, me - 10, 2, 20, pe),
                                jc(J, le - 10, me - 1, 20, 2, pe)
                            }
                            )(O, G.x, O.transform.height - G.y, Rg)
                        }(this),
                        this.context.setDefault(),
                        this.frameCounter = (this.frameCounter + 1) % Number.MAX_SAFE_INTEGER,
                        this.tileLoaded && this.options.speedIndexTiming && (this.loadTimeStamps.push(i.window.performance.now()),
                        this.saveCanvasCopy())
                    }
                }
                renderLayer(l, h, _, b) {
                    _.isHidden(this.transform.zoom) || (_.type === "background" || _.type === "sky" || _.type === "custom" || b && b.length) && (this.id = _.id,
                    this.gpuTimingStart(_),
                    (!l.transform.projection.unsupportedLayers || !l.transform.projection.unsupportedLayers.includes(_.type) || l.terrain && _.type === "custom") && Gf[_.type](l, h, _, b, this.style.placement.variableOffsets, this.options.isInitialLoad),
                    this.gpuTimingEnd())
                }
                gpuTimingStart(l) {
                    if (!this.options.gpuTiming)
                        return;
                    let h = this.context.extTimerQuery
                      , _ = this.gpuTimers[l.id];
                    _ || (_ = this.gpuTimers[l.id] = {
                        calls: 0,
                        cpuTime: 0,
                        query: h.createQueryEXT()
                    }),
                    _.calls++,
                    h.beginQueryEXT(h.TIME_ELAPSED_EXT, _.query)
                }
                gpuTimingDeferredRenderStart() {
                    if (this.options.gpuTimingDeferredRender) {
                        let l = this.context.extTimerQuery
                          , h = l.createQueryEXT();
                        this.deferredRenderGpuTimeQueries.push(h),
                        l.beginQueryEXT(l.TIME_ELAPSED_EXT, h)
                    }
                }
                gpuTimingDeferredRenderEnd() {
                    if (!this.options.gpuTimingDeferredRender)
                        return;
                    let l = this.context.extTimerQuery;
                    l.endQueryEXT(l.TIME_ELAPSED_EXT)
                }
                gpuTimingEnd() {
                    if (!this.options.gpuTiming)
                        return;
                    let l = this.context.extTimerQuery;
                    l.endQueryEXT(l.TIME_ELAPSED_EXT)
                }
                collectGpuTimers() {
                    let l = this.gpuTimers;
                    return this.gpuTimers = {},
                    l
                }
                collectDeferredRenderGpuQueries() {
                    let l = this.deferredRenderGpuTimeQueries;
                    return this.deferredRenderGpuTimeQueries = [],
                    l
                }
                queryGpuTimers(l) {
                    let h = {};
                    for (let _ in l) {
                        let b = l[_]
                          , T = this.context.extTimerQuery
                          , L = T.getQueryObjectEXT(b.query, T.QUERY_RESULT_EXT) / 1e6;
                        T.deleteQueryEXT(b.query),
                        h[_] = L
                    }
                    return h
                }
                queryGpuTimeDeferredRender(l) {
                    if (!this.options.gpuTimingDeferredRender)
                        return 0;
                    let h = this.context.extTimerQuery
                      , _ = 0;
                    for (let b of l)
                        _ += h.getQueryObjectEXT(b, h.QUERY_RESULT_EXT) / 1e6,
                        h.deleteQueryEXT(b);
                    return _
                }
                translatePosMatrix(l, h, _, b, T) {
                    if (!_[0] && !_[1])
                        return l;
                    let L = T ? b === "map" ? this.transform.angle : 0 : b === "viewport" ? -this.transform.angle : 0;
                    if (L) {
                        let V = Math.sin(L)
                          , G = Math.cos(L);
                        _ = [_[0] * G - _[1] * V, _[0] * V + _[1] * G]
                    }
                    let R = [T ? _[0] : Ye(h, _[0], this.transform.zoom), T ? _[1] : Ye(h, _[1], this.transform.zoom), 0]
                      , O = new Float32Array(16);
                    return i.translate(O, l, R),
                    O
                }
                saveTileTexture(l) {
                    let h = this._tileTextures[l.size[0]];
                    h ? h.push(l) : this._tileTextures[l.size[0]] = [l]
                }
                getTileTexture(l) {
                    let h = this._tileTextures[l];
                    return h && h.length > 0 ? h.pop() : null
                }
                isPatternMissing(l) {
                    return l === null || l !== void 0 && !this.imageManager.getPattern(l.toString())
                }
                terrainRenderModeElevated() {
                    return this.style && !!this.style.getTerrain() && !!this.terrain && !this.terrain.renderingToTexture
                }
                currentGlobalDefines() {
                    let l = this.terrain && this.terrain.renderingToTexture
                      , h = this.terrain && this.terrain.exaggeration() === 0
                      , _ = this.style && this.style.fog
                      , b = [];
                    return this.terrainRenderModeElevated() && b.push("TERRAIN"),
                    this.transform.projection.name === "globe" && b.push("GLOBE"),
                    h && b.push("ZERO_EXAGGERATION"),
                    _ && !l && _.getOpacity(this.transform.pitch) !== 0 && b.push("FOG"),
                    l && b.push("RENDER_TO_TEXTURE"),
                    this._showOverdrawInspector && b.push("OVERDRAW_INSPECTOR"),
                    b
                }
                useProgram(l, h, _) {
                    this.cache = this.cache || {};
                    let b = _ || []
                      , T = this.currentGlobalDefines().concat(b)
                      , L = Cf.cacheKey(wf[l], l, T, h);
                    return this.cache[L] || (this.cache[L] = new Cf(this.context,l,wf[l],h,ix[l],T)),
                    this.cache[L]
                }
                setCustomLayerDefaults() {
                    this.context.unbindVAO(),
                    this.context.cullFace.setDefault(),
                    this.context.frontFace.setDefault(),
                    this.context.cullFaceSide.setDefault(),
                    this.context.activeTexture.setDefault(),
                    this.context.pixelStoreUnpack.setDefault(),
                    this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(),
                    this.context.pixelStoreUnpackFlipY.setDefault()
                }
                setBaseState() {
                    let l = this.context.gl;
                    this.context.cullFace.set(!1),
                    this.context.viewport.set([0, 0, this.width, this.height]),
                    this.context.blendEquation.set(l.FUNC_ADD)
                }
                initDebugOverlayCanvas() {
                    this.debugOverlayCanvas == null && (this.debugOverlayCanvas = i.window.document.createElement("canvas"),
                    this.debugOverlayCanvas.width = 512,
                    this.debugOverlayCanvas.height = 512,
                    this.debugOverlayTexture = new i.Texture(this.context,this.debugOverlayCanvas,this.context.gl.RGBA))
                }
                destroy() {
                    this._terrain && this._terrain.destroy(),
                    this.globeSharedBuffers && this.globeSharedBuffers.destroy(),
                    this.emptyTexture.destroy(),
                    this.debugOverlayTexture && this.debugOverlayTexture.destroy(),
                    this.atmosphereBuffer && this.atmosphereBuffer.destroy()
                }
                prepareDrawTile() {
                    this.terrain && this.terrain.prepareDrawTile()
                }
                prepareDrawProgram(l, h, _) {
                    if (this.terrain && this.terrain.renderingToTexture)
                        return;
                    let b = this.style.fog;
                    if (b) {
                        let T = b.getOpacity(this.transform.pitch)
                          , L = ((R,O,V,G,J,le,me,pe,ge,ve,re)=>{
                            let Ce = R.transform
                              , Ae = O.properties.get("color").toArray01();
                            Ae[3] = G;
                            let De = R.frameCounter / 1e3 % 1;
                            return {
                                u_fog_matrix: V ? Ce.calculateFogTileMatrix(V) : R.identityMat,
                                u_fog_range: O.getFovAdjustedRange(Ce._fov),
                                u_fog_color: Ae,
                                u_fog_horizon_blend: O.properties.get("horizon-blend"),
                                u_fog_temporal_offset: De,
                                u_frustum_tl: J,
                                u_frustum_tr: le,
                                u_frustum_br: me,
                                u_frustum_bl: pe,
                                u_globe_pos: ge,
                                u_globe_radius: ve,
                                u_viewport: re,
                                u_globe_transition: i.globeToMercatorTransition(Ce.zoom),
                                u_is_globe: +(Ce.projection.name === "globe")
                            }
                        }
                        )(this, b, _, T, this.transform.frustumCorners.TL, this.transform.frustumCorners.TR, this.transform.frustumCorners.BR, this.transform.frustumCorners.BL, this.transform.globeCenterInViewSpace, this.transform.globeRadius, [this.transform.width * i.exported.devicePixelRatio, this.transform.height * i.exported.devicePixelRatio]);
                        h.setFogUniformValues(l, L)
                    }
                }
                setTileLoadedFlag(l) {
                    this.tileLoaded = l
                }
                saveCanvasCopy() {
                    let l = this.canvasCopy();
                    l && (this.frameCopies.push(l),
                    this.tileLoaded = !1)
                }
                canvasCopy() {
                    let l = this.context.gl
                      , h = l.createTexture();
                    return l.bindTexture(l.TEXTURE_2D, h),
                    l.copyTexImage2D(l.TEXTURE_2D, 0, l.RGBA, 0, 0, l.drawingBufferWidth, l.drawingBufferHeight, 0),
                    h
                }
                getCanvasCopiesAndTimestamps() {
                    return {
                        canvasCopies: this.frameCopies,
                        timeStamps: this.loadTimeStamps
                    }
                }
                averageElevationNeedsEasing() {
                    if (!this.transform._elevation)
                        return !1;
                    let l = this.style && this.style.fog;
                    return !!l && l.getOpacity(this.transform.pitch) !== 0
                }
                getBackgroundTiles() {
                    let l = this._backgroundTiles
                      , h = this._backgroundTiles = {}
                      , _ = this.transform.coveringTiles({
                        tileSize: 512
                    });
                    for (let b of _)
                        h[b.key] = l[b.key] || new i.Tile(b,512,this.transform.tileZoom,this);
                    return h
                }
                clearBackgroundTiles() {
                    this._backgroundTiles = {}
                }
            }
            class Hf {
                constructor(l=0, h=0, _=0, b=0) {
                    if (isNaN(l) || l < 0 || isNaN(h) || h < 0 || isNaN(_) || _ < 0 || isNaN(b) || b < 0)
                        throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
                    this.top = l,
                    this.bottom = h,
                    this.left = _,
                    this.right = b
                }
                interpolate(l, h, _) {
                    return h.top != null && l.top != null && (this.top = i.number(l.top, h.top, _)),
                    h.bottom != null && l.bottom != null && (this.bottom = i.number(l.bottom, h.bottom, _)),
                    h.left != null && l.left != null && (this.left = i.number(l.left, h.left, _)),
                    h.right != null && l.right != null && (this.right = i.number(l.right, h.right, _)),
                    this
                }
                getCenter(l, h) {
                    let _ = i.clamp((this.left + l - this.right) / 2, 0, l)
                      , b = i.clamp((this.top + h - this.bottom) / 2, 0, h);
                    return new i.pointGeometry(_,b)
                }
                equals(l) {
                    return this.top === l.top && this.bottom === l.bottom && this.left === l.left && this.right === l.right
                }
                clone() {
                    return new Hf(this.top,this.bottom,this.left,this.right)
                }
                toJSON() {
                    return {
                        top: this.top,
                        bottom: this.bottom,
                        left: this.left,
                        right: this.right
                    }
                }
            }
            function Pg(m, l) {
                let h = i.getColumn(m, 3);
                i.fromQuat(m, l),
                i.setColumn(m, 3, h)
            }
            function Rh(m, l) {
                let h = i.identity$1([]);
                return i.rotateZ$1(h, h, -l),
                i.rotateX$1(h, h, -m),
                h
            }
            function kg(m, l) {
                let h = [m[0], m[1], 0]
                  , _ = [l[0], l[1], 0];
                if (i.length(h) >= 1e-15) {
                    let L = i.normalize([], h);
                    i.scale$2(_, L, i.dot(_, L)),
                    l[0] = _[0],
                    l[1] = _[1]
                }
                let b = i.cross([], l, m);
                if (i.len(b) < 1e-15)
                    return null;
                let T = Math.atan2(-b[1], b[0]);
                return Rh(Math.atan2(Math.sqrt(m[0] * m[0] + m[1] * m[1]), -m[2]), T)
            }
            class Ph {
                constructor(l, h) {
                    this.position = l,
                    this.orientation = h
                }
                get position() {
                    return this._position
                }
                set position(l) {
                    if (l) {
                        let h = l instanceof i.MercatorCoordinate ? l : new i.MercatorCoordinate(l[0],l[1],l[2]);
                        this._renderWorldCopies && (h.x = i.wrap(h.x, 0, 1)),
                        this._position = h
                    } else
                        this._position = null
                }
                lookAtPoint(l, h) {
                    if (this.orientation = null,
                    !this.position)
                        return;
                    let _ = this._elevation ? this._elevation.getAtPointOrZero(i.MercatorCoordinate.fromLngLat(l)) : 0
                      , b = this.position
                      , T = i.MercatorCoordinate.fromLngLat(l, _)
                      , L = [T.x - b.x, T.y - b.y, T.z - b.z];
                    h || (h = [0, 0, 1]),
                    h[2] = Math.abs(h[2]),
                    this.orientation = kg(L, h)
                }
                setPitchBearing(l, h) {
                    this.orientation = Rh(i.degToRad(l), i.degToRad(-h))
                }
            }
            class Sl {
                constructor(l, h) {
                    this._transform = i.identity([]),
                    this.orientation = h,
                    this.position = l
                }
                get mercatorPosition() {
                    let l = this.position;
                    return new i.MercatorCoordinate(l[0],l[1],l[2])
                }
                get position() {
                    let l = i.getColumn(this._transform, 3);
                    return [l[0], l[1], l[2]]
                }
                set position(l) {
                    var h;
                    l && i.setColumn(this._transform, 3, [(h = l)[0], h[1], h[2], 1])
                }
                get orientation() {
                    return this._orientation
                }
                set orientation(l) {
                    this._orientation = l || i.identity$1([]),
                    l && Pg(this._transform, this._orientation)
                }
                getPitchBearing() {
                    let l = this.forward()
                      , h = this.right();
                    return {
                        bearing: Math.atan2(-h[1], h[0]),
                        pitch: Math.atan2(Math.sqrt(l[0] * l[0] + l[1] * l[1]), -l[2])
                    }
                }
                setPitchBearing(l, h) {
                    this._orientation = Rh(l, h),
                    Pg(this._transform, this._orientation)
                }
                forward() {
                    let l = i.getColumn(this._transform, 2);
                    return [-l[0], -l[1], -l[2]]
                }
                up() {
                    let l = i.getColumn(this._transform, 1);
                    return [-l[0], -l[1], -l[2]]
                }
                right() {
                    let l = i.getColumn(this._transform, 0);
                    return [l[0], l[1], l[2]]
                }
                getCameraToWorld(l, h) {
                    let _ = new Float64Array(16);
                    return i.invert(_, this.getWorldToCamera(l, h)),
                    _
                }
                getWorldToCameraPosition(l, h, _) {
                    let b = this.position;
                    i.scale$2(b, b, -l);
                    let T = new Float64Array(16);
                    return i.fromScaling(T, [_, _, _]),
                    i.translate(T, T, b),
                    T[10] *= h,
                    T
                }
                getWorldToCamera(l, h) {
                    let _ = new Float64Array(16)
                      , b = new Float64Array(4)
                      , T = this.position;
                    return i.conjugate(b, this._orientation),
                    i.scale$2(T, T, -l),
                    i.fromQuat(_, b),
                    i.translate(_, _, T),
                    _[1] *= -1,
                    _[5] *= -1,
                    _[9] *= -1,
                    _[13] *= -1,
                    _[8] *= h,
                    _[9] *= h,
                    _[10] *= h,
                    _[11] *= h,
                    _
                }
                getCameraToClipPerspective(l, h, _, b) {
                    let T = new Float64Array(16);
                    return i.perspective(T, l, h, _, b),
                    T
                }
                getDistanceToElevation(l, h=!1) {
                    let _ = l === 0 ? 0 : i.mercatorZfromAltitude(l, h ? i.latFromMercatorY(this.position[1]) : this.position[1])
                      , b = this.forward();
                    return (_ - this.position[2]) / b[2]
                }
                clone() {
                    return new Sl([...this.position],[...this.orientation])
                }
            }
            function Al(m, l) {
                let h = Ra(m.projection, m.zoom, m.width, m.height)
                  , _ = function(T, L, R, O, V) {
                    let G = new i.LngLat(R.lng - 180 * Pa,R.lat)
                      , J = new i.LngLat(R.lng + 180 * Pa,R.lat)
                      , le = T.project(G.lng, G.lat)
                      , me = T.project(J.lng, J.lat)
                      , pe = -Math.atan2(me.y - le.y, me.x - le.x)
                      , ge = i.MercatorCoordinate.fromLngLat(R);
                    ge.y = i.clamp(ge.y, -.999975, .999975);
                    let ve = ge.toLngLat()
                      , re = T.project(ve.lng, ve.lat)
                      , Ce = i.MercatorCoordinate.fromLngLat(ve);
                    Ce.x += Pa;
                    let Ae = Ce.toLngLat()
                      , De = T.project(Ae.lng, Ae.lat)
                      , Ve = qc(De.x - re.x, De.y - re.y, pe)
                      , Fe = i.MercatorCoordinate.fromLngLat(ve);
                    Fe.y += Pa;
                    let Xe = Fe.toLngLat()
                      , $e = T.project(Xe.lng, Xe.lat)
                      , rt = qc($e.x - re.x, $e.y - re.y, pe)
                      , lt = Math.abs(Ve.x) / Math.abs(rt.y)
                      , Vt = i.identity([]);
                    i.rotateZ(Vt, Vt, -pe * (1 - (V ? 0 : O)));
                    let nt = i.identity([]);
                    return i.scale(nt, nt, [1, 1 - (1 - lt) * O, 1]),
                    nt[4] = -rt.x / rt.y * O,
                    i.rotateZ(nt, nt, pe),
                    i.multiply(nt, Vt, nt),
                    nt
                }(m.projection, 0, m.center, h, l)
                  , b = kh(m);
                return i.scale(_, _, [b, b, 1]),
                _
            }
            function kh(m) {
                let l = m.projection
                  , h = Ra(m.projection, m.zoom, m.width, m.height)
                  , _ = Zc(l, m.center)
                  , b = Zc(l, i.LngLat.convert(l.center));
                return Math.pow(2, _ * h + (1 - h) * b)
            }
            function Ra(m, l, h, _, b=1 / 0) {
                let T = m.range;
                if (!T)
                    return 0;
                let L = Math.min(b, Math.max(h, _))
                  , R = Math.log(L / 1024) / Math.LN2;
                return i.smoothstep(T[0] + R, T[1] + R, l)
            }
            let Pa = 1 / 4e4;
            function Zc(m, l) {
                let h = i.clamp(l.lat, -i.MAX_MERCATOR_LATITUDE, i.MAX_MERCATOR_LATITUDE)
                  , _ = new i.LngLat(l.lng - 180 * Pa,h)
                  , b = new i.LngLat(l.lng + 180 * Pa,h)
                  , T = m.project(_.lng, h)
                  , L = m.project(b.lng, h)
                  , R = i.MercatorCoordinate.fromLngLat(_)
                  , O = i.MercatorCoordinate.fromLngLat(b)
                  , V = L.x - T.x
                  , G = L.y - T.y
                  , J = O.x - R.x
                  , le = O.y - R.y
                  , me = Math.sqrt((J * J + le * le) / (V * V + G * G));
                return Math.log(me) / Math.LN2
            }
            function qc(m, l, h) {
                let _ = Math.cos(h)
                  , b = Math.sin(h);
                return {
                    x: m * _ - l * b,
                    y: m * b + l * _
                }
            }
            class rn {
                constructor(l, h, _, b, T, L, R) {
                    this.tileSize = 512,
                    this._renderWorldCopies = T === void 0 || T,
                    this._minZoom = l || 0,
                    this._maxZoom = h || 22,
                    this._minPitch = _ ?? 0,
                    this._maxPitch = b ?? 60,
                    this.setProjection(L),
                    this.setMaxBounds(R),
                    this.width = 0,
                    this.height = 0,
                    this._center = new i.LngLat(0,0),
                    this.zoom = 0,
                    this.angle = 0,
                    this._fov = .6435011087932844,
                    this._pitch = 0,
                    this._nearZ = 0,
                    this._farZ = 0,
                    this._unmodified = !0,
                    this._edgeInsets = new Hf,
                    this._projMatrixCache = {},
                    this._alignedProjMatrixCache = {},
                    this._fogTileMatrixCache = {},
                    this._distanceTileDataCache = {},
                    this._camera = new Sl,
                    this._centerAltitude = 0,
                    this._averageElevation = 0,
                    this.cameraElevationReference = "ground",
                    this._pixelsPerMercatorPixel = 1,
                    this.globeRadius = 0,
                    this.globeCenterInViewSpace = [0, 0, 0],
                    this._horizonShift = .1
                }
                clone() {
                    let l = new rn(this._minZoom,this._maxZoom,this._minPitch,this.maxPitch,this._renderWorldCopies,this.getProjection());
                    return l._elevation = this._elevation,
                    l._centerAltitude = this._centerAltitude,
                    l._centerAltitudeValidForExaggeration = this._centerAltitudeValidForExaggeration,
                    l.tileSize = this.tileSize,
                    l.mercatorFromTransition = this.mercatorFromTransition,
                    l.width = this.width,
                    l.height = this.height,
                    l.cameraElevationReference = this.cameraElevationReference,
                    l._center = this._center,
                    l._setZoom(this.zoom),
                    l._seaLevelZoom = this._seaLevelZoom,
                    l.angle = this.angle,
                    l._fov = this._fov,
                    l._pitch = this._pitch,
                    l._nearZ = this._nearZ,
                    l._farZ = this._farZ,
                    l._averageElevation = this._averageElevation,
                    l._unmodified = this._unmodified,
                    l._edgeInsets = this._edgeInsets.clone(),
                    l._camera = this._camera.clone(),
                    l._calcMatrices(),
                    l.freezeTileCoverage = this.freezeTileCoverage,
                    l.frustumCorners = this.frustumCorners,
                    l
                }
                get elevation() {
                    return this._elevation
                }
                set elevation(l) {
                    this._elevation !== l && (this._elevation = l,
                    this._updateCameraOnTerrain(),
                    this._calcMatrices())
                }
                updateElevation(l, h=!1) {
                    let _ = this._elevation && this._elevation.exaggeration() !== this._centerAltitudeValidForExaggeration;
                    (this._seaLevelZoom == null || _) && this._updateCameraOnTerrain(),
                    (l || _) && this._constrainCamera(h),
                    this._calcMatrices()
                }
                getProjection() {
                    return i.pick(this.projection, ["name", "center", "parallels"])
                }
                setProjection(l) {
                    this.projectionOptions = l || {
                        name: "mercator"
                    };
                    let h = this.projection ? this.getProjection() : void 0;
                    this.projection = i.getProjection(this.projectionOptions);
                    let _ = !v(h, this.getProjection());
                    return _ && this._calcMatrices(),
                    this.mercatorFromTransition = !1,
                    _
                }
                setMercatorFromTransition() {
                    let l = this.projection.name;
                    this.mercatorFromTransition = !0,
                    this.projectionOptions = {
                        name: "mercator"
                    },
                    this.projection = i.getProjection({
                        name: "mercator"
                    });
                    let h = l !== this.projection.name;
                    return h && this._calcMatrices(),
                    h
                }
                get minZoom() {
                    return this._minZoom
                }
                set minZoom(l) {
                    this._minZoom !== l && (this._minZoom = l,
                    this.zoom = Math.max(this.zoom, l))
                }
                get maxZoom() {
                    return this._maxZoom
                }
                set maxZoom(l) {
                    this._maxZoom !== l && (this._maxZoom = l,
                    this.zoom = Math.min(this.zoom, l))
                }
                get minPitch() {
                    return this._minPitch
                }
                set minPitch(l) {
                    this._minPitch !== l && (this._minPitch = l,
                    this.pitch = Math.max(this.pitch, l))
                }
                get maxPitch() {
                    return this._maxPitch
                }
                set maxPitch(l) {
                    this._maxPitch !== l && (this._maxPitch = l,
                    this.pitch = Math.min(this.pitch, l))
                }
                get renderWorldCopies() {
                    return this._renderWorldCopies && this.projection.supportsWorldCopies === !0
                }
                set renderWorldCopies(l) {
                    l === void 0 ? l = !0 : l === null && (l = !1),
                    this._renderWorldCopies = l
                }
                get worldSize() {
                    return this.tileSize * this.scale
                }
                get cameraWorldSizeForFog() {
                    let l = Math.max(this._camera.getDistanceToElevation(this._averageElevation), Number.EPSILON);
                    return this._worldSizeFromZoom(this._zoomFromMercatorZ(l))
                }
                get cameraWorldSize() {
                    let l = Math.max(this._camera.getDistanceToElevation(this._averageElevation, !0), Number.EPSILON);
                    return this._worldSizeFromZoom(this._zoomFromMercatorZ(l))
                }
                get pixelsPerMeter() {
                    return this.projection.pixelsPerMeter(this.center.lat, this.worldSize)
                }
                get cameraPixelsPerMeter() {
                    return i.mercatorZfromAltitude(this.center.lat, this.cameraWorldSizeForFog)
                }
                get centerOffset() {
                    return this.centerPoint._sub(this.size._div(2))
                }
                get size() {
                    return new i.pointGeometry(this.width,this.height)
                }
                get bearing() {
                    return i.wrap(this.rotation, -180, 180)
                }
                set bearing(l) {
                    this.rotation = l
                }
                get rotation() {
                    return -this.angle / Math.PI * 180
                }
                set rotation(l) {
                    let h = -l * Math.PI / 180;
                    var _;
                    this.angle !== h && (this._unmodified = !1,
                    this.angle = h,
                    this._calcMatrices(),
                    this.rotationMatrix = (_ = new i.ARRAY_TYPE(4),
                    i.ARRAY_TYPE != Float32Array && (_[1] = 0,
                    _[2] = 0),
                    _[0] = 1,
                    _[3] = 1,
                    _),
                    function(b, T, L) {
                        var R = T[0]
                          , O = T[1]
                          , V = T[2]
                          , G = T[3]
                          , J = Math.sin(L)
                          , le = Math.cos(L);
                        b[0] = R * le + V * J,
                        b[1] = O * le + G * J,
                        b[2] = R * -J + V * le,
                        b[3] = O * -J + G * le
                    }(this.rotationMatrix, this.rotationMatrix, this.angle))
                }
                get pitch() {
                    return this._pitch / Math.PI * 180
                }
                set pitch(l) {
                    let h = i.clamp(l, this.minPitch, this.maxPitch) / 180 * Math.PI;
                    this._pitch !== h && (this._unmodified = !1,
                    this._pitch = h,
                    this._calcMatrices())
                }
                get aspect() {
                    return this.width / this.height
                }
                get fovX() {
                    return this._fov
                }
                get fovY() {
                    let l = 1 / Math.tan(.5 * this.fovX);
                    return 2 * Math.atan(1 / this.aspect / l)
                }
                set fov(l) {
                    l = Math.max(.01, Math.min(60, l)),
                    this._fov !== l && (this._unmodified = !1,
                    this._fov = i.degToRad(l),
                    this._calcMatrices())
                }
                get averageElevation() {
                    return this._averageElevation
                }
                set averageElevation(l) {
                    this._averageElevation = l,
                    this._calcFogMatrices(),
                    this._distanceTileDataCache = {}
                }
                get zoom() {
                    return this._zoom
                }
                set zoom(l) {
                    let h = Math.min(Math.max(l, this.minZoom), this.maxZoom);
                    this._zoom !== h && (this._unmodified = !1,
                    this._setZoom(h),
                    this._updateSeaLevelZoom(),
                    this._constrain(),
                    this._calcMatrices())
                }
                _setZoom(l) {
                    this._zoom = l,
                    this.scale = this.zoomScale(l),
                    this.tileZoom = Math.floor(l),
                    this.zoomFraction = l - this.tileZoom
                }
                _updateCameraOnTerrain() {
                    if (!this._elevation || !this._elevation.isDataAvailableAtPoint(this.locationCoordinate(this.center)))
                        return this._centerAltitude = 0,
                        this._seaLevelZoom = null,
                        void (this._centerAltitudeValidForExaggeration = void 0);
                    let l = this._elevation;
                    this._centerAltitude = l.getAtPointOrZero(this.locationCoordinate(this.center)),
                    this._centerAltitudeValidForExaggeration = l.exaggeration(),
                    this._updateSeaLevelZoom()
                }
                _updateSeaLevelZoom() {
                    this._centerAltitudeValidForExaggeration !== void 0 && (this._seaLevelZoom = this._zoomFromMercatorZ((this.pixelsPerMeter * this._centerAltitude + this.cameraToCenterDistance) / this.worldSize))
                }
                sampleAverageElevation() {
                    if (!this._elevation)
                        return 0;
                    let l = this._elevation
                      , h = [[.5, .2], [.3, .5], [.5, .5], [.7, .5], [.5, .8]]
                      , _ = this.horizonLineFromTop()
                      , b = 0
                      , T = 0;
                    for (let L = 0; L < h.length; L++) {
                        let R = new i.pointGeometry(h[L][0] * this.width,_ + h[L][1] * (this.height - _))
                          , O = l.pointCoordinate(R);
                        if (!O)
                            continue;
                        let V = 1 / Math.hypot(O[0] - this._camera.position[0], O[1] - this._camera.position[1]);
                        b += O[3] * V,
                        T += V
                    }
                    return T === 0 ? NaN : b / T
                }
                get center() {
                    return this._center
                }
                set center(l) {
                    l.lat === this._center.lat && l.lng === this._center.lng || (this._unmodified = !1,
                    this._center = l,
                    this._terrainEnabled() && (this.cameraElevationReference === "ground" ? this._updateCameraOnTerrain() : this._updateZoomFromElevation()),
                    this._constrain(),
                    this._calcMatrices())
                }
                _updateZoomFromElevation() {
                    if (this._seaLevelZoom == null || !this._elevation)
                        return;
                    let l = this._seaLevelZoom
                      , h = this._elevation.getAtPointOrZero(this.locationCoordinate(this.center))
                      , _ = this.pixelsPerMeter / this.worldSize * h
                      , b = this._mercatorZfromZoom(l)
                      , T = this._mercatorZfromZoom(this._maxZoom)
                      , L = Math.max(b - _, T);
                    this._setZoom(this._zoomFromMercatorZ(L))
                }
                get padding() {
                    return this._edgeInsets.toJSON()
                }
                set padding(l) {
                    this._edgeInsets.equals(l) || (this._unmodified = !1,
                    this._edgeInsets.interpolate(this._edgeInsets, l, 1),
                    this._calcMatrices())
                }
                computeZoomRelativeTo(l) {
                    let h = this.rayIntersectionCoordinate(this.pointRayIntersection(this.centerPoint, l.toAltitude())), _;
                    _ = l.z < this._camera.position[2] ? [h.x, h.y, h.z] : [l.x, l.y, l.z];
                    let b = i.length(i.sub([], this._camera.position, _));
                    return i.clamp(this._zoomFromMercatorZ(b), this._minZoom, this._maxZoom)
                }
                setFreeCameraOptions(l) {
                    if (!this.height || !l.position && !l.orientation)
                        return;
                    this._updateCameraState();
                    let h = !1;
                    if (l.orientation && !i.exactEquals(l.orientation, this._camera.orientation) && (h = this._setCameraOrientation(l.orientation)),
                    l.position) {
                        let _ = [l.position.x, l.position.y, l.position.z];
                        i.exactEquals$1(_, this._camera.position) || (this._setCameraPosition(_),
                        h = !0)
                    }
                    h && (this._updateStateFromCamera(),
                    this.recenterOnTerrain())
                }
                getFreeCameraOptions() {
                    this._updateCameraState();
                    let l = this._camera.position
                      , h = new Ph;
                    return h.position = new i.MercatorCoordinate(l[0],l[1],l[2]),
                    h.orientation = this._camera.orientation,
                    h._elevation = this.elevation,
                    h._renderWorldCopies = this.renderWorldCopies,
                    h
                }
                _setCameraOrientation(l) {
                    if (!i.length$1(l))
                        return !1;
                    i.normalize$1(l, l);
                    let h = i.transformQuat([], [0, 0, -1], l)
                      , _ = i.transformQuat([], [0, -1, 0], l);
                    if (_[2] < 0)
                        return !1;
                    let b = kg(h, _);
                    return !!b && (this._camera.orientation = b,
                    !0)
                }
                _setCameraPosition(l) {
                    let h = this.zoomScale(this.minZoom) * this.tileSize
                      , _ = this.zoomScale(this.maxZoom) * this.tileSize
                      , b = this.cameraToCenterDistance;
                    l[2] = i.clamp(l[2], b / _, b / h),
                    this._camera.position = l
                }
                get centerPoint() {
                    return this._edgeInsets.getCenter(this.width, this.height)
                }
                get fovAboveCenter() {
                    return this._fov * (.5 + this.centerOffset.y / this.height)
                }
                isPaddingEqual(l) {
                    return this._edgeInsets.equals(l)
                }
                interpolatePadding(l, h, _) {
                    this._unmodified = !1,
                    this._edgeInsets.interpolate(l, h, _),
                    this._constrain(),
                    this._calcMatrices()
                }
                coveringZoomLevel(l) {
                    let h = (l.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / l.tileSize));
                    return Math.max(0, h)
                }
                getVisibleUnwrappedCoordinates(l) {
                    let h = [new i.UnwrappedTileID(0,l)];
                    if (this.renderWorldCopies) {
                        let _ = this.pointCoordinate(new i.pointGeometry(0,0))
                          , b = this.pointCoordinate(new i.pointGeometry(this.width,0))
                          , T = this.pointCoordinate(new i.pointGeometry(this.width,this.height))
                          , L = this.pointCoordinate(new i.pointGeometry(0,this.height))
                          , R = Math.floor(Math.min(_.x, b.x, T.x, L.x))
                          , O = Math.floor(Math.max(_.x, b.x, T.x, L.x))
                          , V = 1;
                        for (let G = R - V; G <= O + V; G++)
                            G !== 0 && h.push(new i.UnwrappedTileID(G,l))
                    }
                    return h
                }
                coveringTiles(l) {
                    let h = this.coveringZoomLevel(l)
                      , _ = h
                      , b = this.elevation && !l.isTerrainDEM
                      , T = this.projection.name === "mercator";
                    if (l.minzoom !== void 0 && h < l.minzoom)
                        return [];
                    l.maxzoom !== void 0 && h > l.maxzoom && (h = l.maxzoom);
                    let L = this.locationCoordinate(this.center)
                      , R = this.center.lat
                      , O = 1 << h
                      , V = [O * L.x, O * L.y, 0]
                      , G = this.projection.name === "globe"
                      , J = !G
                      , le = i.Frustum.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, h, J)
                      , me = G ? this._camera.mercatorPosition : this.pointCoordinate(this.getCameraPoint())
                      , pe = O * i.mercatorZfromAltitude(1, this.center.lat)
                      , ge = this._camera.position[2] / i.mercatorZfromAltitude(1, this.center.lat)
                      , ve = [O * me.x, O * me.y, ge * (J ? 1 : pe)]
                      , re = this.cameraToCenterDistance / l.tileSize * (l.roundZoom ? 1 : .502)
                      , Ce = this.pitch <= 60 && this._edgeInsets.top <= this._edgeInsets.bottom && !this._elevation && !this.projection.isReprojectedInTileSpace ? h : 0
                      , Ae = l.isTerrainDEM && this._elevation ? 1e4 * this._elevation.exaggeration() : this._centerAltitude
                      , De = l.isTerrainDEM ? -Ae : this._elevation ? this._elevation.getMinElevationBelowMSL() : 0
                      , Ve = this.projection.isReprojectedInTileSpace ? kh(this) : 1
                      , Fe = st=>{
                        let Je = 1 / 4e4
                          , ct = new i.MercatorCoordinate(st.x + Je,st.y,st.z)
                          , At = new i.MercatorCoordinate(st.x,st.y + Je,st.z)
                          , Pt = st.toLngLat()
                          , pn = ct.toLngLat()
                          , Xn = At.toLngLat()
                          , un = this.locationCoordinate(Pt)
                          , sn = this.locationCoordinate(pn)
                          , vn = this.locationCoordinate(Xn)
                          , Qn = Math.hypot(sn.x - un.x, sn.y - un.y)
                          , En = Math.hypot(vn.x - un.x, vn.y - un.y);
                        return Math.sqrt(Qn * En) * Ve / Je
                    }
                      , Xe = st=>{
                        let Je = Ae
                          , ct = De;
                        return {
                            aabb: i.tileAABB(this, O, 0, 0, 0, st, ct, Je, this.projection),
                            zoom: 0,
                            x: 0,
                            y: 0,
                            minZ: ct,
                            maxZ: Je,
                            wrap: st,
                            fullyVisible: !1
                        }
                    }
                      , $e = []
                      , rt = []
                      , lt = h
                      , Vt = l.reparseOverscaled ? _ : h
                      , nt = st=>st * st
                      , vt = nt((ge - this._centerAltitude) * pe)
                      , pt = st=>{
                        if (!this._elevation || !st.tileID || !T)
                            return;
                        let Je = this._elevation.getMinMaxForTile(st.tileID)
                          , ct = st.aabb;
                        Je ? (ct.min[2] = Je.min,
                        ct.max[2] = Je.max,
                        ct.center[2] = (ct.min[2] + ct.max[2]) / 2) : (st.shouldSplit = Dt(st),
                        st.shouldSplit || (ct.min[2] = ct.max[2] = ct.center[2] = this._centerAltitude))
                    }
                      , Dt = st=>{
                        if (st.zoom < Ce)
                            return !0;
                        if (st.zoom === lt)
                            return !1;
                        if (st.shouldSplit != null)
                            return st.shouldSplit;
                        let Je = st.aabb.distanceX(ve)
                          , ct = st.aabb.distanceY(ve)
                          , At = vt
                          , Pt = 1;
                        if (G) {
                            At = nt(st.aabb.distanceZ(ve));
                            let un = Math.pow(2, st.zoom)
                              , sn = i.latFromMercatorY((st.y + 1) / un)
                              , vn = i.latFromMercatorY(st.y / un)
                              , Qn = Math.min(Math.max(R, sn), vn)
                              , En = i.circumferenceAtLatitude(Qn) / i.circumferenceAtLatitude(R);
                            if (Pt = Qn === R ? 1 / Math.max(1, this._mercatorScaleRatio - .3) : Math.min(1, En / this._mercatorScaleRatio),
                            this.zoom <= i.GLOBE_ZOOM_THRESHOLD_MIN && st.zoom === lt - 1 && En >= .9)
                                return !0
                        } else if (b && (At = nt(st.aabb.distanceZ(ve) * pe)),
                        this.projection.isReprojectedInTileSpace && _ <= 5) {
                            let un = Math.pow(2, st.zoom)
                              , sn = Fe(new i.MercatorCoordinate((st.x + .5) / un,(st.y + .5) / un));
                            Pt = sn > .85 ? 1 : sn
                        }
                        let pn = Je * Je + ct * ct + At
                          , Xn = nt((1 << lt - st.zoom) * re * Pt * ((un,sn)=>{
                            if (sn * nt(.707) < un)
                                return 1;
                            let vn = Math.sqrt(sn / un);
                            return vn / (1.4144271570014144 + (Math.pow(1.1, vn - 1.4144271570014144 + 1) - 1) / (1.1 - 1) - 1)
                        }
                        )(Math.max(At, vt), pn));
                        return pn < Xn
                    }
                    ;
                    if (this.renderWorldCopies)
                        for (let st = 1; st <= 3; st++)
                            $e.push(Xe(-st)),
                            $e.push(Xe(st));
                    for ($e.push(Xe(0)); $e.length > 0; ) {
                        let st = $e.pop()
                          , Je = st.x
                          , ct = st.y
                          , At = st.fullyVisible;
                        if (!At) {
                            let Pt = st.aabb.intersects(le);
                            if (Pt === 0)
                                continue;
                            At = Pt === 2
                        }
                        if (st.zoom !== lt && Dt(st))
                            for (let Pt = 0; Pt < 4; Pt++) {
                                let pn = (Je << 1) + Pt % 2
                                  , Xn = (ct << 1) + (Pt >> 1)
                                  , un = {
                                    aabb: T ? st.aabb.quadrant(Pt) : i.tileAABB(this, O, st.zoom + 1, pn, Xn, st.wrap, st.minZ, st.maxZ, this.projection),
                                    zoom: st.zoom + 1,
                                    x: pn,
                                    y: Xn,
                                    wrap: st.wrap,
                                    fullyVisible: At,
                                    tileID: void 0,
                                    shouldSplit: void 0,
                                    minZ: st.minZ,
                                    maxZ: st.maxZ
                                };
                                b && !G && (un.tileID = new i.OverscaledTileID(st.zoom + 1 === lt ? Vt : st.zoom + 1,st.wrap,st.zoom + 1,pn,Xn),
                                pt(un)),
                                $e.push(un)
                            }
                        else {
                            let Pt = st.zoom === lt ? Vt : st.zoom;
                            if (l.minzoom && l.minzoom > Pt)
                                continue;
                            let pn = V[0] - (.5 + Je + (st.wrap << st.zoom)) * (1 << h - st.zoom)
                              , Xn = V[1] - .5 - ct
                              , un = st.tileID ? st.tileID : new i.OverscaledTileID(Pt,st.wrap,st.zoom,Je,ct);
                            rt.push({
                                tileID: un,
                                distanceSq: pn * pn + Xn * Xn
                            })
                        }
                    }
                    if (this.fogCullDistSq) {
                        let st = this.fogCullDistSq
                          , Je = this.horizonLineFromTop();
                        rt = rt.filter(ct=>{
                            let At = [0, 0, 0, 1]
                              , Pt = [i.EXTENT, i.EXTENT, 0, 1]
                              , pn = this.calculateFogTileMatrix(ct.tileID.toUnwrapped());
                            i.transformMat4$1(At, At, pn),
                            i.transformMat4$1(Pt, Pt, pn);
                            let Xn = i.getAABBPointSquareDist(At, Pt);
                            if (Xn === 0)
                                return !0;
                            let un = !1
                              , sn = this._elevation;
                            if (sn && Xn > st && Je !== 0) {
                                let vn = this.calculateProjMatrix(ct.tileID.toUnwrapped()), Qn;
                                l.isTerrainDEM || (Qn = sn.getMinMaxForTile(ct.tileID)),
                                Qn || (Qn = {
                                    min: De,
                                    max: Ae
                                });
                                let En = i.furthestTileCorner(this.rotation)
                                  , pi = [En[0] * i.EXTENT, En[1] * i.EXTENT, Qn.max];
                                i.transformMat4(pi, pi, vn),
                                un = (1 - pi[1]) * this.height * .5 < Je
                            }
                            return Xn < st || un
                        }
                        )
                    }
                    return rt.sort((st,Je)=>st.distanceSq - Je.distanceSq).map(st=>st.tileID)
                }
                resize(l, h) {
                    this.width = l,
                    this.height = h,
                    this.pixelsToGLUnits = [2 / l, -2 / h],
                    this._constrain(),
                    this._calcMatrices()
                }
                get unmodified() {
                    return this._unmodified
                }
                zoomScale(l) {
                    return Math.pow(2, l)
                }
                scaleZoom(l) {
                    return Math.log(l) / Math.LN2
                }
                project(l) {
                    let h = i.clamp(l.lat, -i.MAX_MERCATOR_LATITUDE, i.MAX_MERCATOR_LATITUDE)
                      , _ = this.projection.project(l.lng, h);
                    return new i.pointGeometry(_.x * this.worldSize,_.y * this.worldSize)
                }
                unproject(l) {
                    return this.projection.unproject(l.x / this.worldSize, l.y / this.worldSize)
                }
                get point() {
                    return this.project(this.center)
                }
                get pointMerc() {
                    return this.point._div(this.worldSize)
                }
                get pixelsPerMeterRatio() {
                    return this.pixelsPerMeter / i.mercatorZfromAltitude(1, this.center.lat) / this.worldSize
                }
                setLocationAtPoint(l, h) {
                    let _, b, T = this.centerPoint;
                    if (this.projection.name === "globe") {
                        let R = this.worldSize;
                        _ = (h.x - T.x) / R,
                        b = (h.y - T.y) / R
                    } else {
                        let R = this.pointCoordinate(h)
                          , O = this.pointCoordinate(T);
                        _ = R.x - O.x,
                        b = R.y - O.y
                    }
                    let L = this.locationCoordinate(l);
                    this.setLocation(new i.MercatorCoordinate(L.x - _,L.y - b))
                }
                setLocation(l) {
                    this.center = this.coordinateLocation(l),
                    this.projection.wrap && (this.center = this.center.wrap())
                }
                locationPoint(l) {
                    return this.projection.locationPoint(this, l)
                }
                locationPoint3D(l) {
                    return this.projection.locationPoint(this, l, !0)
                }
                pointLocation(l) {
                    return this.coordinateLocation(this.pointCoordinate(l))
                }
                pointLocation3D(l) {
                    return this.coordinateLocation(this.pointCoordinate3D(l))
                }
                locationCoordinate(l, h) {
                    let _ = h ? i.mercatorZfromAltitude(h, l.lat) : void 0
                      , b = this.projection.project(l.lng, l.lat);
                    return new i.MercatorCoordinate(b.x,b.y,_)
                }
                coordinateLocation(l) {
                    return this.projection.unproject(l.x, l.y)
                }
                pointRayIntersection(l, h) {
                    let _ = h ?? this._centerAltitude
                      , b = [l.x, l.y, 0, 1]
                      , T = [l.x, l.y, 1, 1];
                    i.transformMat4$1(b, b, this.pixelMatrixInverse),
                    i.transformMat4$1(T, T, this.pixelMatrixInverse);
                    let L = T[3];
                    i.scale$1(b, b, 1 / b[3]),
                    i.scale$1(T, T, 1 / L);
                    let R = b[2]
                      , O = T[2];
                    return {
                        p0: b,
                        p1: T,
                        t: R === O ? 0 : (_ - R) / (O - R)
                    }
                }
                screenPointToMercatorRay(l) {
                    let h = [l.x, l.y, 0, 1]
                      , _ = [l.x, l.y, 1, 1];
                    return i.transformMat4$1(h, h, this.pixelMatrixInverse),
                    i.transformMat4$1(_, _, this.pixelMatrixInverse),
                    i.scale$1(h, h, 1 / h[3]),
                    i.scale$1(_, _, 1 / _[3]),
                    h[2] = i.mercatorZfromAltitude(h[2], this._center.lat) * this.worldSize,
                    _[2] = i.mercatorZfromAltitude(_[2], this._center.lat) * this.worldSize,
                    i.scale$1(h, h, 1 / this.worldSize),
                    i.scale$1(_, _, 1 / this.worldSize),
                    new i.Ray([h[0], h[1], h[2]],i.normalize([], i.sub([], _, h)))
                }
                rayIntersectionCoordinate(l) {
                    let {p0: h, p1: _, t: b} = l
                      , T = i.mercatorZfromAltitude(h[2], this._center.lat)
                      , L = i.mercatorZfromAltitude(_[2], this._center.lat);
                    return new i.MercatorCoordinate(i.number(h[0], _[0], b) / this.worldSize,i.number(h[1], _[1], b) / this.worldSize,i.number(T, L, b))
                }
                pointCoordinate(l, h=this._centerAltitude) {
                    return this.projection.pointCoordinate(this, l.x, l.y, h)
                }
                pointCoordinate3D(l) {
                    if (!this.elevation)
                        return this.pointCoordinate(l);
                    let h = this.projection.pointCoordinate3D(this, l.x, l.y);
                    if (h)
                        return new i.MercatorCoordinate(h[0],h[1],h[2]);
                    let _ = 0
                      , b = this.horizonLineFromTop();
                    if (l.y > b)
                        return this.pointCoordinate(l);
                    let T = .02 * b
                      , L = l.clone();
                    for (let R = 0; R < 10 && b - _ > T; R++) {
                        L.y = i.number(_, b, .66);
                        let O = this.projection.pointCoordinate3D(this, L.x, L.y);
                        O ? (b = L.y,
                        h = O) : _ = L.y
                    }
                    return h ? new i.MercatorCoordinate(h[0],h[1],h[2]) : this.pointCoordinate(l)
                }
                isPointAboveHorizon(l) {
                    return this.projection.isPointAboveHorizon(this, l)
                }
                _coordinatePoint(l, h) {
                    let _ = h && this.elevation ? this.elevation.getAtPointOrZero(l, this._centerAltitude) : this._centerAltitude
                      , b = [l.x * this.worldSize, l.y * this.worldSize, _ + l.toAltitude(), 1];
                    return i.transformMat4$1(b, b, this.pixelMatrix),
                    b[3] > 0 ? new i.pointGeometry(b[0] / b[3],b[1] / b[3]) : new i.pointGeometry(Number.MAX_VALUE,Number.MAX_VALUE)
                }
                _getBoundsNonRectangular() {
                    let {top: l, left: h} = this._edgeInsets
                      , _ = this.height - this._edgeInsets.bottom
                      , b = this.width - this._edgeInsets.right
                      , T = this.pointLocation3D(new i.pointGeometry(h,l))
                      , L = this.pointLocation3D(new i.pointGeometry(b,l))
                      , R = this.pointLocation3D(new i.pointGeometry(b,_))
                      , O = this.pointLocation3D(new i.pointGeometry(h,_))
                      , V = Math.min(T.lng, L.lng, R.lng, O.lng)
                      , G = Math.max(T.lng, L.lng, R.lng, O.lng)
                      , J = Math.min(T.lat, L.lat, R.lat, O.lat)
                      , le = Math.max(T.lat, L.lat, R.lat, O.lat)
                      , me = Math.pow(2, -this.zoom) / 16 * 270
                      , pe = this.projection.name === "globe" ? 1 : 4
                      , ge = (ve,re,Ce,Ae,De)=>{
                        let Ve = (ve + Ce) / 2
                          , Fe = (re + Ae) / 2
                          , Xe = new i.pointGeometry(Ve,Fe)
                          , {lng: $e, lat: rt} = this.pointLocation3D(Xe)
                          , lt = Math.max(0, V - $e, J - rt, $e - G, rt - le);
                        V = Math.min(V, $e),
                        G = Math.max(G, $e),
                        J = Math.min(J, rt),
                        le = Math.max(le, rt),
                        (De < pe || lt > me) && (ge(ve, re, Ve, Fe, De + 1),
                        ge(Ve, Fe, Ce, Ae, De + 1))
                    }
                    ;
                    if (ge(h, l, b, l, 1),
                    ge(b, l, b, _, 1),
                    ge(b, _, h, _, 1),
                    ge(h, _, h, l, 1),
                    this.projection.name === "globe") {
                        let[ve,re] = i.polesInViewport(this);
                        ve ? (le = 90,
                        G = 180,
                        V = -180) : re && (J = -90,
                        G = 180,
                        V = -180)
                    }
                    return new i.LngLatBounds(new i.LngLat(V,J),new i.LngLat(G,le))
                }
                _getBoundsRectangular(l, h) {
                    let {top: _, left: b} = this._edgeInsets
                      , T = this.height - this._edgeInsets.bottom
                      , L = this.width - this._edgeInsets.right
                      , R = new i.pointGeometry(b,_)
                      , O = new i.pointGeometry(L,_)
                      , V = new i.pointGeometry(L,T)
                      , G = new i.pointGeometry(b,T)
                      , J = this.pointCoordinate(R, l)
                      , le = this.pointCoordinate(O, l)
                      , me = this.pointCoordinate(V, h)
                      , pe = this.pointCoordinate(G, h)
                      , ge = (ve,re)=>(re.y - ve.y) / (re.x - ve.x);
                    return J.y > 1 && le.y >= 0 ? J = new i.MercatorCoordinate((1 - pe.y) / ge(pe, J) + pe.x,1) : J.y < 0 && le.y <= 1 && (J = new i.MercatorCoordinate(-pe.y / ge(pe, J) + pe.x,0)),
                    le.y > 1 && J.y >= 0 ? le = new i.MercatorCoordinate((1 - me.y) / ge(me, le) + me.x,1) : le.y < 0 && J.y <= 1 && (le = new i.MercatorCoordinate(-me.y / ge(me, le) + me.x,0)),
                    new i.LngLatBounds().extend(this.coordinateLocation(J)).extend(this.coordinateLocation(le)).extend(this.coordinateLocation(pe)).extend(this.coordinateLocation(me))
                }
                _getBoundsRectangularTerrain() {
                    let l = this.elevation;
                    if (!l.visibleDemTiles.length || l.isUsingMockSource())
                        return this._getBoundsRectangular(0, 0);
                    let h = l.visibleDemTiles.reduce((_,b)=>{
                        if (b.dem) {
                            let T = b.dem.tree;
                            _.min = Math.min(_.min, T.minimums[0]),
                            _.max = Math.max(_.max, T.maximums[0])
                        }
                        return _
                    }
                    , {
                        min: Number.MAX_VALUE,
                        max: 0
                    });
                    return this._getBoundsRectangular(h.min * l.exaggeration(), h.max * l.exaggeration())
                }
                getBounds() {
                    return this.projection.name === "mercator" || this.projection.name === "equirectangular" ? this._terrainEnabled() ? this._getBoundsRectangularTerrain() : this._getBoundsRectangular(0, 0) : this._getBoundsNonRectangular()
                }
                horizonLineFromTop(l=!0) {
                    let h = this.height / 2 / Math.tan(this._fov / 2) / Math.tan(Math.max(this._pitch, .1)) + this.centerOffset.y
                      , _ = this.height / 2 - h * (1 - this._horizonShift);
                    return l ? Math.max(0, _) : _
                }
                getMaxBounds() {
                    return this.maxBounds
                }
                setMaxBounds(l) {
                    this.maxBounds = l,
                    this.minLat = -i.MAX_MERCATOR_LATITUDE,
                    this.maxLat = i.MAX_MERCATOR_LATITUDE,
                    this.minLng = -180,
                    this.maxLng = 180,
                    l && (this.minLat = l.getSouth(),
                    this.maxLat = l.getNorth(),
                    this.minLng = l.getWest(),
                    this.maxLng = l.getEast(),
                    this.maxLng < this.minLng && (this.maxLng += 360)),
                    this.worldMinX = i.mercatorXfromLng(this.minLng) * this.tileSize,
                    this.worldMaxX = i.mercatorXfromLng(this.maxLng) * this.tileSize,
                    this.worldMinY = i.mercatorYfromLat(this.maxLat) * this.tileSize,
                    this.worldMaxY = i.mercatorYfromLat(this.minLat) * this.tileSize,
                    this._constrain()
                }
                calculatePosMatrix(l, h) {
                    return this.projection.createTileMatrix(this, h, l)
                }
                calculateDistanceTileData(l) {
                    let h = l.key
                      , _ = this._distanceTileDataCache;
                    if (_[h])
                        return _[h];
                    let b = l.canonical
                      , T = 1 / this.height
                      , L = this.cameraWorldSize
                      , R = L / this.zoomScale(b.z)
                      , O = (b.x + Math.pow(2, b.z) * l.wrap) * R
                      , V = b.y * R
                      , G = this.point;
                    G.x *= L / this.worldSize,
                    G.y *= L / this.worldSize;
                    let J = this.angle
                      , le = Math.sin(-J)
                      , me = -Math.cos(-J);
                    return _[h] = {
                        bearing: [le, me],
                        center: [(G.x - O) * T, (G.y - V) * T],
                        scale: R / i.EXTENT * T
                    },
                    _[h]
                }
                calculateFogTileMatrix(l) {
                    let h = l.key
                      , _ = this._fogTileMatrixCache;
                    if (_[h])
                        return _[h];
                    let b = this.projection.createTileMatrix(this, this.cameraWorldSizeForFog, l);
                    return i.multiply(b, this.worldToFogMatrix, b),
                    _[h] = new Float32Array(b),
                    _[h]
                }
                calculateProjMatrix(l, h=!1) {
                    let _ = l.key
                      , b = h ? this._alignedProjMatrixCache : this._projMatrixCache;
                    if (b[_])
                        return b[_];
                    let T = this.calculatePosMatrix(l, this.worldSize);
                    return i.multiply(T, this.projection.isReprojectedInTileSpace ? this.mercatorMatrix : h ? this.alignedProjMatrix : this.projMatrix, T),
                    b[_] = new Float32Array(T),
                    b[_]
                }
                calculatePixelsToTileUnitsMatrix(l) {
                    let h = l.tileID.key
                      , _ = this._pixelsToTileUnitsCache;
                    if (_[h])
                        return _[h];
                    let b = function(T, L) {
                        let {scale: R} = T.tileTransform
                          , O = R * i.EXTENT / (T.tileSize * Math.pow(2, L.zoom - T.tileID.overscaledZ + T.tileID.canonical.z));
                        return V = new Float32Array(4),
                        le = (G = L.inverseAdjustmentMatrix)[1],
                        me = G[2],
                        pe = G[3],
                        ve = (J = [O, O])[1],
                        V[0] = G[0] * (ge = J[0]),
                        V[1] = le * ge,
                        V[2] = me * ve,
                        V[3] = pe * ve,
                        V;
                        var V, G, J, le, me, pe, ge, ve
                    }(l, this);
                    return _[h] = b,
                    _[h]
                }
                customLayerMatrix() {
                    return this.mercatorMatrix.slice()
                }
                globeToMercatorMatrix() {
                    if (this.projection.name === "globe") {
                        let l = 1 / this.worldSize
                          , h = i.fromScaling([], [l, l, l]);
                        return i.multiply(h, h, this.globeMatrix),
                        h
                    }
                }
                recenterOnTerrain() {
                    if (!this._elevation || this.projection.name === "globe")
                        return;
                    let l = this._elevation;
                    this._updateCameraState();
                    let h = i.mercatorZfromAltitude(1, this._center.lat) * this.worldSize
                      , _ = this._computeCameraPosition(h)
                      , b = this._camera.forward()
                      , T = i.mercatorZfromAltitude(1, this._center.lat);
                    _[2] /= T,
                    b[2] /= T,
                    i.normalize(b, b);
                    let L = l.raycast(_, b, l.exaggeration());
                    if (L) {
                        let R = i.scaleAndAdd([], _, b, L)
                          , O = new i.MercatorCoordinate(R[0],R[1],i.mercatorZfromAltitude(R[2], i.latFromMercatorY(R[1])))
                          , V = (O.z + i.length([O.x - _[0], O.y - _[1], O.z - _[2] * T])) * this._pixelsPerMercatorPixel;
                        this._seaLevelZoom = this._zoomFromMercatorZ(V),
                        this._centerAltitude = O.toAltitude(),
                        this._center = this.coordinateLocation(O),
                        this._updateZoomFromElevation(),
                        this._constrain(),
                        this._calcMatrices()
                    }
                }
                _constrainCamera(l=!1) {
                    if (!this._elevation)
                        return;
                    let h = this._elevation
                      , _ = i.mercatorZfromAltitude(1, this._center.lat) * this.worldSize
                      , b = this._computeCameraPosition(_)
                      , T = h.getAtPointOrZero(new i.MercatorCoordinate(...b))
                      , L = this.pixelsPerMeter / this.worldSize * T
                      , R = this._minimumHeightOverTerrain()
                      , O = b[2] - L;
                    if (O <= R)
                        if (O < 0 || l) {
                            let V = this.locationCoordinate(this._center, this._centerAltitude)
                              , G = [b[0], b[1], V.z - b[2]]
                              , J = i.length(G);
                            G[2] -= (R - O) / this._pixelsPerMercatorPixel;
                            let le = i.length(G);
                            if (le === 0)
                                return;
                            i.scale$2(G, G, J / le * this._pixelsPerMercatorPixel),
                            this._camera.position = [b[0], b[1], V.z * this._pixelsPerMercatorPixel - G[2]],
                            this._updateStateFromCamera()
                        } else
                            this._isCameraConstrained = !0
                }
                _constrain() {
                    if (!this.center || !this.width || !this.height || this._constraining)
                        return;
                    this._constraining = !0;
                    let l = this.projection.name === "globe" || this.mercatorFromTransition;
                    if (this.projection.isReprojectedInTileSpace || l) {
                        let le = this.center;
                        return le.lat = i.clamp(le.lat, this.minLat, this.maxLat),
                        (this.maxBounds || !this.renderWorldCopies && !l) && (le.lng = i.clamp(le.lng, this.minLng, this.maxLng)),
                        this.center = le,
                        void (this._constraining = !1)
                    }
                    let h = this._unmodified
                      , {x: _, y: b} = this.point
                      , T = 0
                      , L = _
                      , R = b
                      , O = this.width / 2
                      , V = this.height / 2
                      , G = this.worldMinY * this.scale
                      , J = this.worldMaxY * this.scale;
                    if (b - V < G && (R = G + V),
                    b + V > J && (R = J - V),
                    J - G < this.height && (T = Math.max(T, this.height / (J - G)),
                    R = (J + G) / 2),
                    this.maxBounds || !this._renderWorldCopies || !this.projection.wrap) {
                        let le = this.worldMinX * this.scale
                          , me = this.worldMaxX * this.scale
                          , pe = this.worldSize / 2 - (le + me) / 2;
                        L = (_ + pe + this.worldSize) % this.worldSize - pe,
                        L - O < le && (L = le + O),
                        L + O > me && (L = me - O),
                        me - le < this.width && (T = Math.max(T, this.width / (me - le)),
                        L = (me + le) / 2)
                    }
                    L === _ && R === b || (this.center = this.unproject(new i.pointGeometry(L,R))),
                    T && (this.zoom += this.scaleZoom(T)),
                    this._constrainCamera(),
                    this._unmodified = h,
                    this._constraining = !1
                }
                _minZoomForBounds() {
                    let l = Math.max(0, this.scaleZoom(this.height / (this.worldMaxY - this.worldMinY)));
                    return this.maxBounds && (l = Math.max(l, this.scaleZoom(this.width / (this.worldMaxX - this.worldMinX)))),
                    l
                }
                _maxCameraBoundsDistance() {
                    return this._mercatorZfromZoom(this._minZoomForBounds())
                }
                _calcMatrices() {
                    if (!this.height)
                        return;
                    let l = this.centerOffset
                      , h = this.pixelsPerMeter;
                    this.projection.name === "globe" && (this._mercatorScaleRatio = i.mercatorZfromAltitude(1, this.center.lat) / i.mercatorZfromAltitude(1, i.GLOBE_SCALE_MATCH_LATITUDE));
                    let _ = Ra(this.projection, this.zoom, this.width, this.height, 1024);
                    this._pixelsPerMercatorPixel = this.projection.pixelSpaceConversion(this.center.lat, this.worldSize, _),
                    this.cameraToCenterDistance = .5 / Math.tan(.5 * this._fov) * this.height * this._pixelsPerMercatorPixel,
                    this._updateCameraState(),
                    this._farZ = this.projection.farthestPixelDistance(this),
                    this._nearZ = this.height / 50;
                    let b = this.projection.zAxisUnit === "meters" ? h : 1
                      , T = this._camera.getWorldToCamera(this.worldSize, b)
                      , L = this._camera.getCameraToClipPerspective(this._fov, this.width / this.height, this._nearZ, this._farZ);
                    L[8] = 2 * -l.x / this.width,
                    L[9] = 2 * l.y / this.height;
                    let R = i.mul([], L, T);
                    if (this.projection.isReprojectedInTileSpace) {
                        let Fe = this.locationCoordinate(this.center)
                          , Xe = i.identity([]);
                        i.translate(Xe, Xe, [Fe.x * this.worldSize, Fe.y * this.worldSize, 0]),
                        i.multiply(Xe, Xe, Al(this)),
                        i.translate(Xe, Xe, [-Fe.x * this.worldSize, -Fe.y * this.worldSize, 0]),
                        i.multiply(R, R, Xe),
                        this.inverseAdjustmentMatrix = function($e) {
                            let rt = Al($e, !0);
                            return oe([], [rt[0], rt[1], rt[4], rt[5]])
                        }(this)
                    } else
                        this.inverseAdjustmentMatrix = [1, 0, 0, 1];
                    this.mercatorMatrix = i.scale([], R, [this.worldSize, this.worldSize, this.worldSize / b, 1]),
                    this.projMatrix = R,
                    this.invProjMatrix = i.invert(new Float64Array(16), this.projMatrix);
                    let O = i.invert([], L);
                    this.frustumCorners = i.FrustumCorners.fromInvProjectionMatrix(O, this.horizonLineFromTop(), this.height);
                    let V = new Float32Array(16);
                    i.identity(V),
                    i.scale(V, V, [1, -1, 1]),
                    i.rotateX(V, V, this._pitch),
                    i.rotateZ(V, V, this.angle);
                    let G = i.perspective(new Float32Array(16), this._fov, this.width / this.height, this._nearZ, this._farZ)
                      , J = (Math.PI / 2 - this._pitch) * (this.height / this._fov) * this._horizonShift;
                    G[8] = 2 * -l.x / this.width,
                    G[9] = 2 * (l.y + J) / this.height,
                    this.skyboxMatrix = i.multiply(V, G, V);
                    let le = this.point
                      , me = le.x
                      , pe = le.y
                      , ge = this.width % 2 / 2
                      , ve = this.height % 2 / 2
                      , re = Math.cos(this.angle)
                      , Ce = Math.sin(this.angle)
                      , Ae = me - Math.round(me) + re * ge + Ce * ve
                      , De = pe - Math.round(pe) + re * ve + Ce * ge
                      , Ve = new Float64Array(R);
                    if (i.translate(Ve, Ve, [Ae > .5 ? Ae - 1 : Ae, De > .5 ? De - 1 : De, 0]),
                    this.alignedProjMatrix = Ve,
                    R = i.create(),
                    i.scale(R, R, [this.width / 2, -this.height / 2, 1]),
                    i.translate(R, R, [1, -1, 0]),
                    this.labelPlaneMatrix = R,
                    R = i.create(),
                    i.scale(R, R, [1, -1, 1]),
                    i.translate(R, R, [-1, -1, 0]),
                    i.scale(R, R, [2 / this.width, 2 / this.height, 1]),
                    this.glCoordMatrix = R,
                    this.pixelMatrix = i.multiply(new Float64Array(16), this.labelPlaneMatrix, this.projMatrix),
                    this._calcFogMatrices(),
                    this._distanceTileDataCache = {},
                    R = i.invert(new Float64Array(16), this.pixelMatrix),
                    !R)
                        throw new Error("failed to invert matrix");
                    if (this.pixelMatrixInverse = R,
                    this.projection.name === "globe" || this.mercatorFromTransition) {
                        this.globeMatrix = i.calculateGlobeMatrix(this);
                        let Fe = [this.globeMatrix[12], this.globeMatrix[13], this.globeMatrix[14]];
                        this.globeCenterInViewSpace = i.transformMat4(Fe, Fe, T),
                        this.globeRadius = this.worldSize / 2 / Math.PI - 1
                    } else
                        this.globeMatrix = R;
                    this._projMatrixCache = {},
                    this._alignedProjMatrixCache = {},
                    this._pixelsToTileUnitsCache = {}
                }
                _calcFogMatrices() {
                    this._fogTileMatrixCache = {};
                    let l = this.cameraWorldSizeForFog
                      , h = this.cameraPixelsPerMeter
                      , _ = this._camera.position
                      , b = 1 / this.height / this._pixelsPerMercatorPixel
                      , T = [l, l, h];
                    i.scale$2(T, T, b),
                    i.scale$2(_, _, -1),
                    i.multiply$2(_, _, T);
                    let L = i.create();
                    i.translate(L, L, _),
                    i.scale(L, L, T),
                    this.mercatorFogMatrix = L,
                    this.worldToFogMatrix = this._camera.getWorldToCameraPosition(l, h, b)
                }
                _computeCameraPosition(l) {
                    let h = (l = l || this.pixelsPerMeter) / this.pixelsPerMeter
                      , _ = this._camera.forward()
                      , b = this.point
                      , T = this._mercatorZfromZoom(this._seaLevelZoom ? this._seaLevelZoom : this._zoom) * h - l / this.worldSize * this._centerAltitude;
                    return [b.x / this.worldSize - _[0] * T, b.y / this.worldSize - _[1] * T, l / this.worldSize * this._centerAltitude - _[2] * T]
                }
                _updateCameraState() {
                    this.height && (this._camera.setPitchBearing(this._pitch, this.angle),
                    this._camera.position = this._computeCameraPosition())
                }
                _translateCameraConstrained(l) {
                    let h = this._maxCameraBoundsDistance() * Math.cos(this._pitch)
                      , _ = this._camera.position[2]
                      , b = l[2]
                      , T = 1;
                    this.projection.wrap && (this.center = this.center.wrap()),
                    b > 0 && (T = Math.min((h - _) / b, 1)),
                    this._camera.position = i.scaleAndAdd([], this._camera.position, l, T),
                    this._updateStateFromCamera()
                }
                _updateStateFromCamera() {
                    let l = this._camera.position
                      , h = this._camera.forward()
                      , {pitch: _, bearing: b} = this._camera.getPitchBearing()
                      , T = i.mercatorZfromAltitude(this._centerAltitude, this.center.lat) * this._pixelsPerMercatorPixel
                      , L = this._mercatorZfromZoom(this._maxZoom) * Math.cos(i.degToRad(this._maxPitch))
                      , R = Math.max((l[2] - T) / Math.cos(_), L)
                      , O = this._zoomFromMercatorZ(R);
                    i.scaleAndAdd(l, l, h, R),
                    this._pitch = i.clamp(_, i.degToRad(this.minPitch), i.degToRad(this.maxPitch)),
                    this.angle = i.wrap(b, -Math.PI, Math.PI),
                    this._setZoom(i.clamp(O, this._minZoom, this._maxZoom)),
                    this._updateSeaLevelZoom(),
                    this._center = this.coordinateLocation(new i.MercatorCoordinate(l[0],l[1],l[2])),
                    this._unmodified = !1,
                    this._constrain(),
                    this._calcMatrices()
                }
                _worldSizeFromZoom(l) {
                    return Math.pow(2, l) * this.tileSize
                }
                _mercatorZfromZoom(l) {
                    return this.cameraToCenterDistance / this._worldSizeFromZoom(l)
                }
                _minimumHeightOverTerrain() {
                    let l = Math.min((this._seaLevelZoom != null ? this._seaLevelZoom : this._zoom) + 4, this._maxZoom);
                    return this._mercatorZfromZoom(l)
                }
                _zoomFromMercatorZ(l) {
                    return this.scaleZoom(this.cameraToCenterDistance / (l * this.tileSize))
                }
                zoomFromMercatorZAdjusted(l) {
                    let h = 0
                      , _ = i.GLOBE_ZOOM_THRESHOLD_MAX
                      , b = 0
                      , T = 1 / 0;
                    for (; _ - h > 1e-6 && _ > h; ) {
                        let L = h + .5 * (_ - h)
                          , R = this.tileSize * Math.pow(2, L)
                          , O = this.getCameraToCenterDistance(this.projection, L, R)
                          , V = this.scaleZoom(O / (l * this.tileSize))
                          , G = Math.abs(L - V);
                        G < T && (T = G,
                        b = L),
                        L < V ? h = L : _ = L
                    }
                    return b
                }
                _terrainEnabled() {
                    return !(!this._elevation || !this.projection.supportsTerrain && (i.warnOnce("Terrain is not yet supported with alternate projections. Use mercator or globe to enable terrain."),
                    1))
                }
                anyCornerOffEdge(l, h) {
                    let _ = Math.min(l.x, h.x)
                      , b = Math.max(l.x, h.x)
                      , T = Math.min(l.y, h.y)
                      , L = Math.max(l.y, h.y);
                    if (T < this.horizonLineFromTop(!1))
                        return !0;
                    if (this.projection.name !== "mercator")
                        return !1;
                    let R = [new i.pointGeometry(_,T), new i.pointGeometry(b,L), new i.pointGeometry(_,L), new i.pointGeometry(b,T)]
                      , O = this.renderWorldCopies ? -3 : 0
                      , V = this.renderWorldCopies ? 4 : 1;
                    for (let G of R) {
                        let J = this.pointRayIntersection(G);
                        if (J.t < 0)
                            return !0;
                        let le = this.rayIntersectionCoordinate(J);
                        if (le.x < O || le.y < 0 || le.x > V || le.y > 1)
                            return !0
                    }
                    return !1
                }
                isHorizonVisible() {
                    return this.pitch + i.radToDeg(this.fovAboveCenter) > 88 || this.anyCornerOffEdge(new i.pointGeometry(0,0), new i.pointGeometry(this.width,this.height))
                }
                zoomDeltaToMovement(l, h) {
                    let _ = i.length(i.sub([], this._camera.position, l))
                      , b = this._zoomFromMercatorZ(_) + h;
                    return _ - this._mercatorZfromZoom(b)
                }
                getCameraPoint() {
                    if (this.projection.name === "globe") {
                        let l = function([h,_,b], T) {
                            let L = [h, _, b, 1];
                            i.transformMat4$1(L, L, T);
                            let R = L[3] = Math.max(L[3], 1e-6);
                            return L[0] /= R,
                            L[1] /= R,
                            L[2] /= R,
                            L
                        }([this.globeMatrix[12], this.globeMatrix[13], this.globeMatrix[14]], this.pixelMatrix);
                        return new i.pointGeometry(l[0],l[1])
                    }
                    {
                        let l = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
                        return this.centerPoint.add(new i.pointGeometry(0,l))
                    }
                }
                getCameraToCenterDistance(l, h=this.zoom, _=this.worldSize) {
                    let b = Ra(l, h, this.width, this.height, 1024)
                      , T = l.pixelSpaceConversion(this.center.lat, _, b);
                    return .5 / Math.tan(.5 * this._fov) * this.height * T
                }
                getWorldToCameraMatrix() {
                    let l = this._camera.getWorldToCamera(this.worldSize, this.projection.zAxisUnit === "meters" ? this.pixelsPerMeter : 1);
                    return this.projection.name === "globe" && i.multiply(l, l, this.globeMatrix),
                    l
                }
            }
            function zs(m, l) {
                let h = !1
                  , _ = null
                  , b = ()=>{
                    _ = null,
                    h && (m(),
                    _ = setTimeout(b, l),
                    h = !1)
                }
                ;
                return ()=>(h = !0,
                _ || b(),
                _)
            }
            class zg {
                constructor(l) {
                    this._hashName = l && encodeURIComponent(l),
                    i.bindAll(["_getCurrentHash", "_onHashChange", "_updateHash"], this),
                    this._updateHash = zs(this._updateHashUnthrottled.bind(this), 300)
                }
                addTo(l) {
                    return this._map = l,
                    i.window.addEventListener("hashchange", this._onHashChange, !1),
                    l.on("moveend", this._updateHash),
                    this
                }
                remove() {
                    return this._map ? (this._map.off("moveend", this._updateHash),
                    i.window.removeEventListener("hashchange", this._onHashChange, !1),
                    clearTimeout(this._updateHash()),
                    this._map = void 0,
                    this) : this
                }
                getHashString() {
                    let l = this._map;
                    if (!l)
                        return "";
                    let h = Wf(l);
                    if (this._hashName) {
                        let _ = this._hashName
                          , b = !1
                          , T = i.window.location.hash.slice(1).split("&").map(L=>{
                            let R = L.split("=")[0];
                            return R === _ ? (b = !0,
                            `${R}=${h}`) : L
                        }
                        ).filter(L=>L);
                        return b || T.push(`${_}=${h}`),
                        `#${T.join("&")}`
                    }
                    return `#${h}`
                }
                _getCurrentHash() {
                    let l = i.window.location.hash.replace("#", "");
                    if (this._hashName) {
                        let h;
                        return l.split("&").map(_=>_.split("=")).forEach(_=>{
                            _[0] === this._hashName && (h = _)
                        }
                        ),
                        (h && h[1] || "").split("/")
                    }
                    return l.split("/")
                }
                _onHashChange() {
                    let l = this._map;
                    if (!l)
                        return !1;
                    let h = this._getCurrentHash();
                    if (h.length >= 3 && !h.some(_=>isNaN(_))) {
                        let _ = l.dragRotate.isEnabled() && l.touchZoomRotate.isEnabled() ? +(h[3] || 0) : l.getBearing();
                        return l.jumpTo({
                            center: [+h[2], +h[1]],
                            zoom: +h[0],
                            bearing: _,
                            pitch: +(h[4] || 0)
                        }),
                        !0
                    }
                    return !1
                }
                _updateHashUnthrottled() {
                    let l = i.window.location.href.replace(/(#.+)?$/, this.getHashString());
                    i.window.history.replaceState(i.window.history.state, null, l)
                }
            }
            function Wf(m, l) {
                let h = m.getCenter()
                  , _ = Math.round(100 * m.getZoom()) / 100
                  , b = Math.ceil((_ * Math.LN2 + Math.log(512 / 360 / .5)) / Math.LN10)
                  , T = Math.pow(10, b)
                  , L = Math.round(h.lng * T) / T
                  , R = Math.round(h.lat * T) / T
                  , O = m.getBearing()
                  , V = m.getPitch()
                  , G = l ? `/${L}/${R}/${_}` : `${_}/${R}/${L}`;
                return (O || V) && (G += "/" + Math.round(10 * O) / 10),
                V && (G += `/${Math.round(V)}`),
                G
            }
            let Kc = {
                linearity: .3,
                easing: i.bezier(0, 0, .3, 1)
            }
              , Ml = i.extend({
                deceleration: 2500,
                maxSpeed: 1400
            }, Kc)
              , Og = i.extend({
                deceleration: 20,
                maxSpeed: 1400
            }, Kc)
              , zh = i.extend({
                deceleration: 1e3,
                maxSpeed: 360
            }, Kc)
              , jf = i.extend({
                deceleration: 1e3,
                maxSpeed: 90
            }, Kc);
            class Oh {
                constructor(l) {
                    this._map = l,
                    this.clear()
                }
                clear() {
                    this._inertiaBuffer = []
                }
                record(l) {
                    this._drainInertiaBuffer(),
                    this._inertiaBuffer.push({
                        time: i.exported.now(),
                        settings: l
                    })
                }
                _drainInertiaBuffer() {
                    let l = this._inertiaBuffer
                      , h = i.exported.now();
                    for (; l.length > 0 && h - l[0].time > 160; )
                        l.shift()
                }
                _onMoveEnd(l) {
                    if (this._drainInertiaBuffer(),
                    this._inertiaBuffer.length < 2)
                        return;
                    let h = {
                        zoom: 0,
                        bearing: 0,
                        pitch: 0,
                        pan: new i.pointGeometry(0,0),
                        pinchAround: void 0,
                        around: void 0
                    };
                    for (let {settings: T} of this._inertiaBuffer)
                        h.zoom += T.zoomDelta || 0,
                        h.bearing += T.bearingDelta || 0,
                        h.pitch += T.pitchDelta || 0,
                        T.panDelta && h.pan._add(T.panDelta),
                        T.around && (h.around = T.around),
                        T.pinchAround && (h.pinchAround = T.pinchAround);
                    let _ = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time
                      , b = {};
                    if (h.pan.mag()) {
                        let T = Jc(h.pan.mag(), _, i.extend({}, Ml, l || {}));
                        b.offset = h.pan.mult(T.amount / h.pan.mag()),
                        b.center = this._map.transform.center,
                        Yc(b, T)
                    }
                    if (h.zoom) {
                        let T = Jc(h.zoom, _, Og);
                        b.zoom = this._map.transform.zoom + T.amount,
                        Yc(b, T)
                    }
                    if (h.bearing) {
                        let T = Jc(h.bearing, _, zh);
                        b.bearing = this._map.transform.bearing + i.clamp(T.amount, -179, 179),
                        Yc(b, T)
                    }
                    if (h.pitch) {
                        let T = Jc(h.pitch, _, jf);
                        b.pitch = this._map.transform.pitch + T.amount,
                        Yc(b, T)
                    }
                    if (b.zoom || b.bearing) {
                        let T = h.pinchAround === void 0 ? h.around : h.pinchAround;
                        b.around = T ? this._map.unproject(T) : this._map.getCenter()
                    }
                    return this.clear(),
                    b.noMoveStart = !0,
                    b
                }
            }
            function Yc(m, l) {
                (!m.duration || m.duration < l.duration) && (m.duration = l.duration,
                m.easing = l.easing)
            }
            function Jc(m, l, h) {
                let {maxSpeed: _, linearity: b, deceleration: T} = h
                  , L = i.clamp(m * b / (l / 1e3), -_, _)
                  , R = Math.abs(L) / (T * b);
                return {
                    easing: h.easing,
                    duration: 1e3 * R,
                    amount: L * (R / 2)
                }
            }
            class Er extends i.Event {
                preventDefault() {
                    this._defaultPrevented = !0
                }
                get defaultPrevented() {
                    return this._defaultPrevented
                }
                constructor(l, h, _, b={}) {
                    let T = W(h.getCanvasContainer(), _)
                      , L = h.unproject(T);
                    super(l, i.extend({
                        point: T,
                        lngLat: L,
                        originalEvent: _
                    }, b)),
                    this._defaultPrevented = !1,
                    this.target = h
                }
            }
            class Nh extends i.Event {
                preventDefault() {
                    this._defaultPrevented = !0
                }
                get defaultPrevented() {
                    return this._defaultPrevented
                }
                constructor(l, h, _) {
                    let b = l === "touchend" ? _.changedTouches : _.touches
                      , T = fe(h.getCanvasContainer(), b)
                      , L = T.map(O=>h.unproject(O))
                      , R = T.reduce((O,V,G,J)=>O.add(V.div(J.length)), new i.pointGeometry(0,0));
                    super(l, {
                        points: T,
                        point: R,
                        lngLats: L,
                        lngLat: h.unproject(R),
                        originalEvent: _
                    }),
                    this._defaultPrevented = !1
                }
            }
            class ax extends i.Event {
                preventDefault() {
                    this._defaultPrevented = !0
                }
                get defaultPrevented() {
                    return this._defaultPrevented
                }
                constructor(l, h, _) {
                    super(l, {
                        originalEvent: _
                    }),
                    this._defaultPrevented = !1
                }
            }
            class Ng {
                constructor(l, h) {
                    this._map = l,
                    this._clickTolerance = h.clickTolerance
                }
                reset() {
                    this._mousedownPos = void 0
                }
                wheel(l) {
                    return this._firePreventable(new ax(l.type,this._map,l))
                }
                mousedown(l, h) {
                    return this._mousedownPos = h,
                    this._firePreventable(new Er(l.type,this._map,l))
                }
                mouseup(l) {
                    this._map.fire(new Er(l.type,this._map,l))
                }
                preclick(l) {
                    let h = i.extend({}, l);
                    h.type = "preclick",
                    this._map.fire(new Er(h.type,this._map,h))
                }
                click(l, h) {
                    this._mousedownPos && this._mousedownPos.dist(h) >= this._clickTolerance || (this.preclick(l),
                    this._map.fire(new Er(l.type,this._map,l)))
                }
                dblclick(l) {
                    return this._firePreventable(new Er(l.type,this._map,l))
                }
                mouseover(l) {
                    this._map.fire(new Er(l.type,this._map,l))
                }
                mouseout(l) {
                    this._map.fire(new Er(l.type,this._map,l))
                }
                touchstart(l) {
                    return this._firePreventable(new Nh(l.type,this._map,l))
                }
                touchmove(l) {
                    this._map.fire(new Nh(l.type,this._map,l))
                }
                touchend(l) {
                    this._map.fire(new Nh(l.type,this._map,l))
                }
                touchcancel(l) {
                    this._map.fire(new Nh(l.type,this._map,l))
                }
                _firePreventable(l) {
                    if (this._map.fire(l),
                    l.defaultPrevented)
                        return {}
                }
                isEnabled() {
                    return !0
                }
                isActive() {
                    return !1
                }
                enable() {}
                disable() {}
            }
            class Fh {
                constructor(l) {
                    this._map = l
                }
                reset() {
                    this._delayContextMenu = !1,
                    this._contextMenuEvent = void 0
                }
                mousemove(l) {
                    this._map.fire(new Er(l.type,this._map,l))
                }
                mousedown() {
                    this._delayContextMenu = !0
                }
                mouseup() {
                    this._delayContextMenu = !1,
                    this._contextMenuEvent && (this._map.fire(new Er("contextmenu",this._map,this._contextMenuEvent)),
                    delete this._contextMenuEvent)
                }
                contextmenu(l) {
                    this._delayContextMenu ? this._contextMenuEvent = l : this._map.fire(new Er(l.type,this._map,l)),
                    this._map.listens("contextmenu") && l.preventDefault()
                }
                isEnabled() {
                    return !0
                }
                isActive() {
                    return !1
                }
                enable() {}
                disable() {}
            }
            class Xf {
                constructor(l, h) {
                    this._map = l,
                    this._el = l.getCanvasContainer(),
                    this._container = l.getContainer(),
                    this._clickTolerance = h.clickTolerance || 1
                }
                isEnabled() {
                    return !!this._enabled
                }
                isActive() {
                    return !!this._active
                }
                enable() {
                    this.isEnabled() || (this._enabled = !0)
                }
                disable() {
                    this.isEnabled() && (this._enabled = !1)
                }
                mousedown(l, h) {
                    this.isEnabled() && l.shiftKey && l.button === 0 && (U(),
                    this._startPos = this._lastPos = h,
                    this._active = !0)
                }
                mousemoveWindow(l, h) {
                    if (!this._active)
                        return;
                    let _ = h
                      , b = this._startPos
                      , T = this._lastPos;
                    if (!b || !T || T.equals(_) || !this._box && _.dist(b) < this._clickTolerance)
                        return;
                    this._lastPos = _,
                    this._box || (this._box = C("div", "mapboxgl-boxzoom", this._container),
                    this._container.classList.add("mapboxgl-crosshair"),
                    this._fireEvent("boxzoomstart", l));
                    let L = Math.min(b.x, _.x)
                      , R = Math.max(b.x, _.x)
                      , O = Math.min(b.y, _.y)
                      , V = Math.max(b.y, _.y);
                    this._map._requestDomTask(()=>{
                        this._box && (this._box.style.transform = `translate(${L}px,${O}px)`,
                        this._box.style.width = R - L + "px",
                        this._box.style.height = V - O + "px")
                    }
                    )
                }
                mouseupWindow(l, h) {
                    if (!this._active)
                        return;
                    let _ = this._startPos
                      , b = h;
                    if (_ && l.button === 0) {
                        if (this.reset(),
                        X(),
                        _.x !== b.x || _.y !== b.y)
                            return this._map.fire(new i.Event("boxzoomend",{
                                originalEvent: l
                            })),
                            {
                                cameraAnimation: T=>T.fitScreenCoordinates(_, b, this._map.getBearing(), {
                                    linear: !1
                                })
                            };
                        this._fireEvent("boxzoomcancel", l)
                    }
                }
                keydown(l) {
                    this._active && l.keyCode === 27 && (this.reset(),
                    this._fireEvent("boxzoomcancel", l))
                }
                blur() {
                    this.reset()
                }
                reset() {
                    this._active = !1,
                    this._container.classList.remove("mapboxgl-crosshair"),
                    this._box && (this._box.remove(),
                    this._box = null),
                    Z(),
                    delete this._startPos,
                    delete this._lastPos
                }
                _fireEvent(l, h) {
                    return this._map.fire(new i.Event(l,{
                        originalEvent: h
                    }))
                }
            }
            function Bh(m, l) {
                let h = {};
                for (let _ = 0; _ < m.length; _++)
                    h[m[_].identifier] = l[_];
                return h
            }
            class Fg {
                constructor(l) {
                    this.reset(),
                    this.numTouches = l.numTouches
                }
                reset() {
                    this.centroid = void 0,
                    this.startTime = 0,
                    this.touches = {},
                    this.aborted = !1
                }
                touchstart(l, h, _) {
                    (this.centroid || _.length > this.numTouches) && (this.aborted = !0),
                    this.aborted || (this.startTime === 0 && (this.startTime = l.timeStamp),
                    _.length === this.numTouches && (this.centroid = function(b) {
                        let T = new i.pointGeometry(0,0);
                        for (let L of b)
                            T._add(L);
                        return T.div(b.length)
                    }(h),
                    this.touches = Bh(_, h)))
                }
                touchmove(l, h, _) {
                    if (this.aborted || !this.centroid)
                        return;
                    let b = Bh(_, h);
                    for (let T in this.touches) {
                        let L = this.touches[T]
                          , R = b[T];
                        (!R || R.dist(L) > 30) && (this.aborted = !0)
                    }
                }
                touchend(l, h, _) {
                    if ((!this.centroid || l.timeStamp - this.startTime > 500) && (this.aborted = !0),
                    _.length === 0) {
                        let b = !this.aborted && this.centroid;
                        if (this.reset(),
                        b)
                            return b
                    }
                }
            }
            class Il {
                constructor(l) {
                    this.singleTap = new Fg(l),
                    this.numTaps = l.numTaps,
                    this.reset()
                }
                reset() {
                    this.lastTime = 1 / 0,
                    this.lastTap = void 0,
                    this.count = 0,
                    this.singleTap.reset()
                }
                touchstart(l, h, _) {
                    this.singleTap.touchstart(l, h, _)
                }
                touchmove(l, h, _) {
                    this.singleTap.touchmove(l, h, _)
                }
                touchend(l, h, _) {
                    let b = this.singleTap.touchend(l, h, _);
                    if (b) {
                        let T = l.timeStamp - this.lastTime < 500
                          , L = !this.lastTap || this.lastTap.dist(b) < 30;
                        if (T && L || this.reset(),
                        this.count++,
                        this.lastTime = l.timeStamp,
                        this.lastTap = b,
                        this.count === this.numTaps)
                            return this.reset(),
                            b
                    }
                }
            }
            class Zf {
                constructor() {
                    this._zoomIn = new Il({
                        numTouches: 1,
                        numTaps: 2
                    }),
                    this._zoomOut = new Il({
                        numTouches: 2,
                        numTaps: 1
                    }),
                    this.reset()
                }
                reset() {
                    this._active = !1,
                    this._zoomIn.reset(),
                    this._zoomOut.reset()
                }
                touchstart(l, h, _) {
                    this._zoomIn.touchstart(l, h, _),
                    this._zoomOut.touchstart(l, h, _)
                }
                touchmove(l, h, _) {
                    this._zoomIn.touchmove(l, h, _),
                    this._zoomOut.touchmove(l, h, _)
                }
                touchend(l, h, _) {
                    let b = this._zoomIn.touchend(l, h, _)
                      , T = this._zoomOut.touchend(l, h, _);
                    return b ? (this._active = !0,
                    l.preventDefault(),
                    setTimeout(()=>this.reset(), 0),
                    {
                        cameraAnimation: L=>L.easeTo({
                            duration: 300,
                            zoom: L.getZoom() + 1,
                            around: L.unproject(b)
                        }, {
                            originalEvent: l
                        })
                    }) : T ? (this._active = !0,
                    l.preventDefault(),
                    setTimeout(()=>this.reset(), 0),
                    {
                        cameraAnimation: L=>L.easeTo({
                            duration: 300,
                            zoom: L.getZoom() - 1,
                            around: L.unproject(T)
                        }, {
                            originalEvent: l
                        })
                    }) : void 0
                }
                touchcancel() {
                    this.reset()
                }
                enable() {
                    this._enabled = !0
                }
                disable() {
                    this._enabled = !1,
                    this.reset()
                }
                isEnabled() {
                    return this._enabled
                }
                isActive() {
                    return this._active
                }
            }
            let Bg = {
                0: 1,
                2: 2
            };
            class Uh {
                constructor(l) {
                    this.reset(),
                    this._clickTolerance = l.clickTolerance || 1
                }
                blur() {
                    this.reset()
                }
                reset() {
                    this._active = !1,
                    this._moved = !1,
                    this._lastPoint = void 0,
                    this._eventButton = void 0
                }
                _correctButton(l, h) {
                    return !1
                }
                _move(l, h) {
                    return {}
                }
                mousedown(l, h) {
                    if (this._lastPoint)
                        return;
                    let _ = ce(l);
                    this._correctButton(l, _) && (this._lastPoint = h,
                    this._eventButton = _)
                }
                mousemoveWindow(l, h) {
                    let _ = this._lastPoint;
                    if (_) {
                        if (l.preventDefault(),
                        this._eventButton != null && function(b, T) {
                            let L = Bg[T];
                            return b.buttons === void 0 || (b.buttons & L) !== L
                        }(l, this._eventButton))
                            this.reset();
                        else if (this._moved || !(h.dist(_) < this._clickTolerance))
                            return this._moved = !0,
                            this._lastPoint = h,
                            this._move(_, h)
                    }
                }
                mouseupWindow(l) {
                    this._lastPoint && ce(l) === this._eventButton && (this._moved && X(),
                    this.reset())
                }
                enable() {
                    this._enabled = !0
                }
                disable() {
                    this._enabled = !1,
                    this.reset()
                }
                isEnabled() {
                    return this._enabled
                }
                isActive() {
                    return this._active
                }
            }
            class Ug extends Uh {
                mousedown(l, h) {
                    super.mousedown(l, h),
                    this._lastPoint && (this._active = !0)
                }
                _correctButton(l, h) {
                    return h === 0 && !l.ctrlKey
                }
                _move(l, h) {
                    return {
                        around: h,
                        panDelta: h.sub(l)
                    }
                }
            }
            class qf extends Uh {
                _correctButton(l, h) {
                    return h === 0 && l.ctrlKey || h === 2
                }
                _move(l, h) {
                    let _ = .8 * (h.x - l.x);
                    if (_)
                        return this._active = !0,
                        {
                            bearingDelta: _
                        }
                }
                contextmenu(l) {
                    l.preventDefault()
                }
            }
            class Kf extends Uh {
                _correctButton(l, h) {
                    return h === 0 && l.ctrlKey || h === 2
                }
                _move(l, h) {
                    let _ = -.5 * (h.y - l.y);
                    if (_)
                        return this._active = !0,
                        {
                            pitchDelta: _
                        }
                }
                contextmenu(l) {
                    l.preventDefault()
                }
            }
            class Cl {
                constructor(l, h) {
                    this._map = l,
                    this._el = l.getCanvasContainer(),
                    this._minTouches = 1,
                    this._clickTolerance = h.clickTolerance || 1,
                    this.reset(),
                    i.bindAll(["_addTouchPanBlocker", "_showTouchPanBlockerAlert"], this)
                }
                reset() {
                    this._active = !1,
                    this._touches = {},
                    this._sum = new i.pointGeometry(0,0)
                }
                touchstart(l, h, _) {
                    return this._calculateTransform(l, h, _)
                }
                touchmove(l, h, _) {
                    if (this._active && !(_.length < this._minTouches)) {
                        if (this._map._cooperativeGestures && !this._map.isMoving()) {
                            if (_.length === 1 && !i.isFullscreen())
                                return void this._showTouchPanBlockerAlert();
                            this._alertContainer.style.visibility !== "hidden" && (this._alertContainer.style.visibility = "hidden",
                            clearTimeout(this._alertTimer))
                        }
                        return l.cancelable && l.preventDefault(),
                        this._calculateTransform(l, h, _)
                    }
                }
                touchend(l, h, _) {
                    this._calculateTransform(l, h, _),
                    this._active && _.length < this._minTouches && this.reset()
                }
                touchcancel() {
                    this.reset()
                }
                _calculateTransform(l, h, _) {
                    _.length > 0 && (this._active = !0);
                    let b = Bh(_, h)
                      , T = new i.pointGeometry(0,0)
                      , L = new i.pointGeometry(0,0)
                      , R = 0;
                    for (let V in b) {
                        let G = b[V]
                          , J = this._touches[V];
                        J && (T._add(G),
                        L._add(G.sub(J)),
                        R++,
                        b[V] = G)
                    }
                    if (this._touches = b,
                    R < this._minTouches || !L.mag())
                        return;
                    let O = L.div(R);
                    return this._sum._add(O),
                    this._sum.mag() < this._clickTolerance ? void 0 : {
                        around: T.div(R),
                        panDelta: O
                    }
                }
                enable() {
                    this._enabled = !0,
                    this._map._cooperativeGestures && (this._addTouchPanBlocker(),
                    this._el.classList.add("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page"))
                }
                disable() {
                    this._enabled = !1,
                    this._map._cooperativeGestures && (clearTimeout(this._alertTimer),
                    this._alertContainer.remove(),
                    this._el.classList.remove("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page")),
                    this.reset()
                }
                isEnabled() {
                    return !!this._enabled
                }
                isActive() {
                    return !!this._active
                }
                _addTouchPanBlocker() {
                    this._map && !this._alertContainer && (this._alertContainer = C("div", "mapboxgl-touch-pan-blocker", this._map._container),
                    this._alertContainer.textContent = this._map._getUIString("TouchPanBlocker.Message"),
                    this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(.05 * this._el.clientWidth)))}px`)
                }
                _showTouchPanBlockerAlert() {
                    this._alertContainer.style.visibility = "visible",
                    this._alertContainer.classList.add("mapboxgl-touch-pan-blocker-show"),
                    this._alertContainer.setAttribute("role", "alert"),
                    clearTimeout(this._alertTimer),
                    this._alertTimer = setTimeout(()=>{
                        this._alertContainer.classList.remove("mapboxgl-touch-pan-blocker-show"),
                        this._alertContainer.setAttribute("role", "null")
                    }
                    , 500)
                }
            }
            class Vh {
                constructor() {
                    this.reset()
                }
                reset() {
                    this._active = !1,
                    this._firstTwoTouches = void 0
                }
                _start(l) {}
                _move(l, h, _) {
                    return {}
                }
                touchstart(l, h, _) {
                    this._firstTwoTouches || _.length < 2 || (this._firstTwoTouches = [_[0].identifier, _[1].identifier],
                    this._start([h[0], h[1]]))
                }
                touchmove(l, h, _) {
                    let b = this._firstTwoTouches;
                    if (!b)
                        return;
                    l.preventDefault();
                    let[T,L] = b
                      , R = $c(_, h, T)
                      , O = $c(_, h, L);
                    if (!R || !O)
                        return;
                    let V = this._aroundCenter ? null : R.add(O).div(2);
                    return this._move([R, O], V, l)
                }
                touchend(l, h, _) {
                    if (!this._firstTwoTouches)
                        return;
                    let[b,T] = this._firstTwoTouches
                      , L = $c(_, h, b)
                      , R = $c(_, h, T);
                    L && R || (this._active && X(),
                    this.reset())
                }
                touchcancel() {
                    this.reset()
                }
                enable(l) {
                    this._enabled = !0,
                    this._aroundCenter = !!l && l.around === "center"
                }
                disable() {
                    this._enabled = !1,
                    this.reset()
                }
                isEnabled() {
                    return this._enabled
                }
                isActive() {
                    return this._active
                }
            }
            function $c(m, l, h) {
                for (let _ = 0; _ < m.length; _++)
                    if (m[_].identifier === h)
                        return l[_]
            }
            function Vg(m, l) {
                return Math.log(m / l) / Math.LN2
            }
            class Gg extends Vh {
                reset() {
                    super.reset(),
                    this._distance = 0,
                    this._startDistance = 0
                }
                _start(l) {
                    this._startDistance = this._distance = l[0].dist(l[1])
                }
                _move(l, h) {
                    let _ = this._distance;
                    if (this._distance = l[0].dist(l[1]),
                    this._active || !(Math.abs(Vg(this._distance, this._startDistance)) < .1))
                        return this._active = !0,
                        {
                            zoomDelta: Vg(this._distance, _),
                            pinchAround: h
                        }
                }
            }
            function Yf(m, l) {
                return 180 * m.angleWith(l) / Math.PI
            }
            class Hg extends Vh {
                reset() {
                    super.reset(),
                    this._minDiameter = 0,
                    this._startVector = void 0,
                    this._vector = void 0
                }
                _start(l) {
                    this._startVector = this._vector = l[0].sub(l[1]),
                    this._minDiameter = l[0].dist(l[1])
                }
                _move(l, h) {
                    let _ = this._vector;
                    if (this._vector = l[0].sub(l[1]),
                    _ && (this._active || !this._isBelowThreshold(this._vector)))
                        return this._active = !0,
                        {
                            bearingDelta: Yf(this._vector, _),
                            pinchAround: h
                        }
                }
                _isBelowThreshold(l) {
                    this._minDiameter = Math.min(this._minDiameter, l.mag());
                    let h = 25 / (Math.PI * this._minDiameter) * 360
                      , _ = this._startVector;
                    if (!_)
                        return !1;
                    let b = Yf(l, _);
                    return Math.abs(b) < h
                }
            }
            function Gh(m) {
                return Math.abs(m.y) > Math.abs(m.x)
            }
            class Hr extends Vh {
                constructor(l) {
                    super(),
                    this._map = l
                }
                reset() {
                    super.reset(),
                    this._valid = void 0,
                    this._firstMove = void 0,
                    this._lastPoints = void 0
                }
                _start(l) {
                    this._lastPoints = l,
                    Gh(l[0].sub(l[1])) && (this._valid = !1)
                }
                _move(l, h, _) {
                    let b = this._lastPoints;
                    if (!b)
                        return;
                    let T = l[0].sub(b[0])
                      , L = l[1].sub(b[1]);
                    return this._map._cooperativeGestures && !i.isFullscreen() && _.touches.length < 3 || (this._valid = this.gestureBeginsVertically(T, L, _.timeStamp),
                    !this._valid) ? void 0 : (this._lastPoints = l,
                    this._active = !0,
                    {
                        pitchDelta: (T.y + L.y) / 2 * -.5
                    })
                }
                gestureBeginsVertically(l, h, _) {
                    if (this._valid !== void 0)
                        return this._valid;
                    let b = l.mag() >= 2
                      , T = h.mag() >= 2;
                    if (!b && !T)
                        return;
                    if (!b || !T)
                        return this._firstMove == null && (this._firstMove = _),
                        _ - this._firstMove < 100 && void 0;
                    let L = l.y > 0 == h.y > 0;
                    return Gh(l) && Gh(h) && L
                }
            }
            let lx = {
                panStep: 100,
                bearingStep: 15,
                pitchStep: 10
            };
            class Wg {
                constructor() {
                    let l = lx;
                    this._panStep = l.panStep,
                    this._bearingStep = l.bearingStep,
                    this._pitchStep = l.pitchStep,
                    this._rotationDisabled = !1
                }
                blur() {
                    this.reset()
                }
                reset() {
                    this._active = !1
                }
                keydown(l) {
                    if (l.altKey || l.ctrlKey || l.metaKey)
                        return;
                    let h = 0
                      , _ = 0
                      , b = 0
                      , T = 0
                      , L = 0;
                    switch (l.keyCode) {
                    case 61:
                    case 107:
                    case 171:
                    case 187:
                        h = 1;
                        break;
                    case 189:
                    case 109:
                    case 173:
                        h = -1;
                        break;
                    case 37:
                        l.shiftKey ? _ = -1 : (l.preventDefault(),
                        T = -1);
                        break;
                    case 39:
                        l.shiftKey ? _ = 1 : (l.preventDefault(),
                        T = 1);
                        break;
                    case 38:
                        l.shiftKey ? b = 1 : (l.preventDefault(),
                        L = -1);
                        break;
                    case 40:
                        l.shiftKey ? b = -1 : (l.preventDefault(),
                        L = 1);
                        break;
                    default:
                        return
                    }
                    return this._rotationDisabled && (_ = 0,
                    b = 0),
                    {
                        cameraAnimation: R=>{
                            let O = R.getZoom();
                            R.easeTo({
                                duration: 300,
                                easeId: "keyboardHandler",
                                easing: cx,
                                zoom: h ? Math.round(O) + h * (l.shiftKey ? 2 : 1) : O,
                                bearing: R.getBearing() + _ * this._bearingStep,
                                pitch: R.getPitch() + b * this._pitchStep,
                                offset: [-T * this._panStep, -L * this._panStep],
                                center: R.getCenter()
                            }, {
                                originalEvent: l
                            })
                        }
                    }
                }
                enable() {
                    this._enabled = !0
                }
                disable() {
                    this._enabled = !1,
                    this.reset()
                }
                isEnabled() {
                    return this._enabled
                }
                isActive() {
                    return this._active
                }
                disableRotation() {
                    this._rotationDisabled = !0
                }
                enableRotation() {
                    this._rotationDisabled = !1
                }
            }
            function cx(m) {
                return m * (2 - m)
            }
            let jg = 4.000244140625;
            class Io {
                constructor(l, h) {
                    this._map = l,
                    this._el = l.getCanvasContainer(),
                    this._handler = h,
                    this._delta = 0,
                    this._defaultZoomRate = .01,
                    this._wheelZoomRate = .0022222222222222222,
                    i.bindAll(["_onTimeout", "_addScrollZoomBlocker", "_showBlockerAlert"], this)
                }
                setZoomRate(l) {
                    this._defaultZoomRate = l
                }
                setWheelZoomRate(l) {
                    this._wheelZoomRate = l
                }
                isEnabled() {
                    return !!this._enabled
                }
                isActive() {
                    return this._active || this._finishTimeout !== void 0
                }
                isZooming() {
                    return !!this._zooming
                }
                enable(l) {
                    this.isEnabled() || (this._enabled = !0,
                    this._aroundCenter = !!l && l.around === "center",
                    this._map._cooperativeGestures && this._addScrollZoomBlocker())
                }
                disable() {
                    this.isEnabled() && (this._enabled = !1,
                    this._map._cooperativeGestures && (clearTimeout(this._alertTimer),
                    this._alertContainer.remove()))
                }
                wheel(l) {
                    if (!this.isEnabled())
                        return;
                    if (this._map._cooperativeGestures) {
                        if (!(l.ctrlKey || l.metaKey || this.isZooming() || i.isFullscreen()))
                            return void this._showBlockerAlert();
                        this._alertContainer.style.visibility !== "hidden" && (this._alertContainer.style.visibility = "hidden",
                        clearTimeout(this._alertTimer))
                    }
                    let h = l.deltaMode === i.window.WheelEvent.DOM_DELTA_LINE ? 40 * l.deltaY : l.deltaY
                      , _ = i.exported.now()
                      , b = _ - (this._lastWheelEventTime || 0);
                    this._lastWheelEventTime = _,
                    h !== 0 && h % jg == 0 ? this._type = "wheel" : h !== 0 && Math.abs(h) < 4 ? this._type = "trackpad" : b > 400 ? (this._type = null,
                    this._lastValue = h,
                    this._timeout = setTimeout(this._onTimeout, 40, l)) : this._type || (this._type = Math.abs(b * h) < 200 ? "trackpad" : "wheel",
                    this._timeout && (clearTimeout(this._timeout),
                    this._timeout = null,
                    h += this._lastValue)),
                    l.shiftKey && h && (h /= 4),
                    this._type && (this._lastWheelEvent = l,
                    this._delta -= h,
                    this._active || this._start(l)),
                    l.preventDefault()
                }
                _onTimeout(l) {
                    this._type = "wheel",
                    this._delta -= this._lastValue,
                    this._active || this._start(l)
                }
                _start(l) {
                    if (!this._delta)
                        return;
                    this._frameId && (this._frameId = null),
                    this._active = !0,
                    this.isZooming() || (this._zooming = !0),
                    this._finishTimeout && (clearTimeout(this._finishTimeout),
                    delete this._finishTimeout);
                    let h = W(this._el, l);
                    this._aroundPoint = this._aroundCenter ? this._map.transform.centerPoint : h,
                    this._aroundCoord = this._map.transform.pointCoordinate3D(this._aroundPoint),
                    this._targetZoom = void 0,
                    this._frameId || (this._frameId = !0,
                    this._handler._triggerRenderFrame())
                }
                renderFrame() {
                    if (!this._frameId || (this._frameId = null,
                    !this.isActive()))
                        return;
                    let l = this._map.transform;
                    this._type === "wheel" && l.projection.wrap && (l._center.lng >= 180 || l._center.lng <= -180) && (this._prevEase = null,
                    this._easing = null,
                    this._lastWheelEvent = null,
                    this._lastWheelEventTime = 0);
                    let h = ()=>l._terrainEnabled() && this._aroundCoord ? l.computeZoomRelativeTo(this._aroundCoord) : l.zoom;
                    if (this._delta !== 0) {
                        let O = this._type === "wheel" && Math.abs(this._delta) > jg ? this._wheelZoomRate : this._defaultZoomRate
                          , V = 2 / (1 + Math.exp(-Math.abs(this._delta * O)));
                        this._delta < 0 && V !== 0 && (V = 1 / V);
                        let G = h()
                          , J = Math.pow(2, G)
                          , le = typeof this._targetZoom == "number" ? l.zoomScale(this._targetZoom) : J;
                        this._targetZoom = Math.min(l.maxZoom, Math.max(l.minZoom, l.scaleZoom(le * V))),
                        this._type === "wheel" && (this._startZoom = G,
                        this._easing = this._smoothOutEasing(200)),
                        this._delta = 0
                    }
                    let _ = typeof this._targetZoom == "number" ? this._targetZoom : h(), b = this._startZoom, T = this._easing, L, R = !1;
                    if (this._type === "wheel" && b && T) {
                        let O = Math.min((i.exported.now() - this._lastWheelEventTime) / 200, 1)
                          , V = T(O);
                        L = i.number(b, _, V),
                        O < 1 ? this._frameId || (this._frameId = !0) : R = !0
                    } else
                        L = _,
                        R = !0;
                    return this._active = !0,
                    R && (this._active = !1,
                    this._finishTimeout = setTimeout(()=>{
                        this._zooming = !1,
                        this._handler._triggerRenderFrame(),
                        delete this._targetZoom,
                        delete this._finishTimeout
                    }
                    , 200)),
                    {
                        noInertia: !0,
                        needsRenderFrame: !R,
                        zoomDelta: L - h(),
                        around: this._aroundPoint,
                        aroundCoord: this._aroundCoord,
                        originalEvent: this._lastWheelEvent
                    }
                }
                _smoothOutEasing(l) {
                    let h = i.ease;
                    if (this._prevEase) {
                        let _ = this._prevEase
                          , b = (i.exported.now() - _.start) / _.duration
                          , T = _.easing(b + .01) - _.easing(b)
                          , L = .27 / Math.sqrt(T * T + 1e-4) * .01
                          , R = Math.sqrt(.0729 - L * L);
                        h = i.bezier(L, R, .25, 1)
                    }
                    return this._prevEase = {
                        start: i.exported.now(),
                        duration: l,
                        easing: h
                    },
                    h
                }
                blur() {
                    this.reset()
                }
                reset() {
                    this._active = !1
                }
                _addScrollZoomBlocker() {
                    this._map && !this._alertContainer && (this._alertContainer = C("div", "mapboxgl-scroll-zoom-blocker", this._map._container),
                    this._alertContainer.textContent = /(Mac|iPad)/i.test(i.window.navigator.userAgent) ? this._map._getUIString("ScrollZoomBlocker.CmdMessage") : this._map._getUIString("ScrollZoomBlocker.CtrlMessage"),
                    this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(.05 * this._el.clientWidth)))}px`)
                }
                _showBlockerAlert() {
                    this._alertContainer.style.visibility = "visible",
                    this._alertContainer.classList.add("mapboxgl-scroll-zoom-blocker-show"),
                    this._alertContainer.setAttribute("role", "alert"),
                    clearTimeout(this._alertTimer),
                    this._alertTimer = setTimeout(()=>{
                        this._alertContainer.classList.remove("mapboxgl-scroll-zoom-blocker-show"),
                        this._alertContainer.setAttribute("role", "null")
                    }
                    , 200)
                }
            }
            class Xg {
                constructor(l, h) {
                    this._clickZoom = l,
                    this._tapZoom = h
                }
                enable() {
                    this._clickZoom.enable(),
                    this._tapZoom.enable()
                }
                disable() {
                    this._clickZoom.disable(),
                    this._tapZoom.disable()
                }
                isEnabled() {
                    return this._clickZoom.isEnabled() && this._tapZoom.isEnabled()
                }
                isActive() {
                    return this._clickZoom.isActive() || this._tapZoom.isActive()
                }
            }
            class Dl {
                constructor() {
                    this.reset()
                }
                reset() {
                    this._active = !1
                }
                blur() {
                    this.reset()
                }
                dblclick(l, h) {
                    return l.preventDefault(),
                    {
                        cameraAnimation: _=>{
                            _.easeTo({
                                duration: 300,
                                zoom: _.getZoom() + (l.shiftKey ? -1 : 1),
                                around: _.unproject(h)
                            }, {
                                originalEvent: l
                            })
                        }
                    }
                }
                enable() {
                    this._enabled = !0
                }
                disable() {
                    this._enabled = !1,
                    this.reset()
                }
                isEnabled() {
                    return this._enabled
                }
                isActive() {
                    return this._active
                }
            }
            class uo {
                constructor() {
                    this._tap = new Il({
                        numTouches: 1,
                        numTaps: 1
                    }),
                    this.reset()
                }
                reset() {
                    this._active = !1,
                    this._swipePoint = void 0,
                    this._swipeTouch = 0,
                    this._tapTime = 0,
                    this._tap.reset()
                }
                touchstart(l, h, _) {
                    this._swipePoint || (this._tapTime && l.timeStamp - this._tapTime > 500 && this.reset(),
                    this._tapTime ? _.length > 0 && (this._swipePoint = h[0],
                    this._swipeTouch = _[0].identifier) : this._tap.touchstart(l, h, _))
                }
                touchmove(l, h, _) {
                    if (this._tapTime) {
                        if (this._swipePoint) {
                            if (_[0].identifier !== this._swipeTouch)
                                return;
                            let b = h[0]
                              , T = b.y - this._swipePoint.y;
                            return this._swipePoint = b,
                            l.preventDefault(),
                            this._active = !0,
                            {
                                zoomDelta: T / 128
                            }
                        }
                    } else
                        this._tap.touchmove(l, h, _)
                }
                touchend(l, h, _) {
                    this._tapTime ? this._swipePoint && _.length === 0 && this.reset() : this._tap.touchend(l, h, _) && (this._tapTime = l.timeStamp)
                }
                touchcancel() {
                    this.reset()
                }
                enable() {
                    this._enabled = !0
                }
                disable() {
                    this._enabled = !1,
                    this.reset()
                }
                isEnabled() {
                    return this._enabled
                }
                isActive() {
                    return this._active
                }
            }
            class Hh {
                constructor(l, h, _) {
                    this._el = l,
                    this._mousePan = h,
                    this._touchPan = _
                }
                enable(l) {
                    this._inertiaOptions = l || {},
                    this._mousePan.enable(),
                    this._touchPan.enable(),
                    this._el.classList.add("mapboxgl-touch-drag-pan")
                }
                disable() {
                    this._mousePan.disable(),
                    this._touchPan.disable(),
                    this._el.classList.remove("mapboxgl-touch-drag-pan")
                }
                isEnabled() {
                    return this._mousePan.isEnabled() && this._touchPan.isEnabled()
                }
                isActive() {
                    return this._mousePan.isActive() || this._touchPan.isActive()
                }
            }
            class cn {
                constructor(l, h, _) {
                    this._pitchWithRotate = l.pitchWithRotate,
                    this._mouseRotate = h,
                    this._mousePitch = _
                }
                enable() {
                    this._mouseRotate.enable(),
                    this._pitchWithRotate && this._mousePitch.enable()
                }
                disable() {
                    this._mouseRotate.disable(),
                    this._mousePitch.disable()
                }
                isEnabled() {
                    return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled())
                }
                isActive() {
                    return this._mouseRotate.isActive() || this._mousePitch.isActive()
                }
            }
            class Zg {
                constructor(l, h, _, b) {
                    this._el = l,
                    this._touchZoom = h,
                    this._touchRotate = _,
                    this._tapDragZoom = b,
                    this._rotationDisabled = !1,
                    this._enabled = !0
                }
                enable(l) {
                    this._touchZoom.enable(l),
                    this._rotationDisabled || this._touchRotate.enable(l),
                    this._tapDragZoom.enable(),
                    this._el.classList.add("mapboxgl-touch-zoom-rotate")
                }
                disable() {
                    this._touchZoom.disable(),
                    this._touchRotate.disable(),
                    this._tapDragZoom.disable(),
                    this._el.classList.remove("mapboxgl-touch-zoom-rotate")
                }
                isEnabled() {
                    return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled()
                }
                isActive() {
                    return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive()
                }
                disableRotation() {
                    this._rotationDisabled = !0,
                    this._touchRotate.disable()
                }
                enableRotation() {
                    this._rotationDisabled = !1,
                    this._touchZoom.isEnabled() && this._touchRotate.enable()
                }
            }
            let Qc = m=>m.zoom || m.drag || m.pitch || m.rotate;
            class eu extends i.Event {
            }
            class tu {
                constructor() {
                    this.constants = [1, 1, .01],
                    this.radius = 0
                }
                setup(l, h) {
                    let _ = i.sub([], h, l);
                    this.radius = i.length(_[2] < 0 ? i.div([], _, this.constants) : [_[0], _[1], 0])
                }
                projectRay(l) {
                    i.div(l, l, this.constants),
                    i.normalize(l, l),
                    i.mul$1(l, l, this.constants);
                    let h = i.scale$2([], l, this.radius);
                    if (h[2] > 0) {
                        let _ = i.scale$2([], [0, 0, 1], i.dot(h, [0, 0, 1]))
                          , b = i.scale$2([], i.normalize([], [h[0], h[1], 0]), this.radius)
                          , T = i.add([], h, i.scale$2([], i.sub([], i.add([], b, _), h), 2));
                        h[0] = T[0],
                        h[1] = T[1]
                    }
                    return h
                }
            }
            function nu(m) {
                return m.panDelta && m.panDelta.mag() || m.zoomDelta || m.bearingDelta || m.pitchDelta
            }
            class qg {
                constructor(l, h) {
                    this._map = l,
                    this._el = this._map.getCanvasContainer(),
                    this._handlers = [],
                    this._handlersById = {},
                    this._changes = [],
                    this._inertia = new Oh(l),
                    this._bearingSnap = h.bearingSnap,
                    this._previousActiveHandlers = {},
                    this._trackingEllipsoid = new tu,
                    this._dragOrigin = null,
                    this._eventsInProgress = {},
                    this._addDefaultHandlers(h),
                    i.bindAll(["handleEvent", "handleWindowEvent"], this);
                    let _ = this._el;
                    this._listeners = [[_, "touchstart", {
                        passive: !0
                    }], [_, "touchmove", {
                        passive: !1
                    }], [_, "touchend", void 0], [_, "touchcancel", void 0], [_, "mousedown", void 0], [_, "mousemove", void 0], [_, "mouseup", void 0], [i.window.document, "mousemove", {
                        capture: !0
                    }], [i.window.document, "mouseup", void 0], [_, "mouseover", void 0], [_, "mouseout", void 0], [_, "dblclick", void 0], [_, "click", void 0], [_, "keydown", {
                        capture: !1
                    }], [_, "keyup", void 0], [_, "wheel", {
                        passive: !1
                    }], [_, "contextmenu", void 0], [i.window, "blur", void 0]];
                    for (let[b,T,L] of this._listeners)
                        b.addEventListener(T, b === i.window.document ? this.handleWindowEvent : this.handleEvent, L)
                }
                destroy() {
                    for (let[l,h,_] of this._listeners)
                        l.removeEventListener(h, l === i.window.document ? this.handleWindowEvent : this.handleEvent, _)
                }
                _addDefaultHandlers(l) {
                    let h = this._map
                      , _ = h.getCanvasContainer();
                    this._add("mapEvent", new Ng(h,l));
                    let b = h.boxZoom = new Xf(h,l);
                    this._add("boxZoom", b);
                    let T = new Zf
                      , L = new Dl;
                    h.doubleClickZoom = new Xg(L,T),
                    this._add("tapZoom", T),
                    this._add("clickZoom", L);
                    let R = new uo;
                    this._add("tapDragZoom", R);
                    let O = h.touchPitch = new Hr(h);
                    this._add("touchPitch", O);
                    let V = new qf(l)
                      , G = new Kf(l);
                    h.dragRotate = new cn(l,V,G),
                    this._add("mouseRotate", V, ["mousePitch"]),
                    this._add("mousePitch", G, ["mouseRotate"]);
                    let J = new Ug(l)
                      , le = new Cl(h,l);
                    h.dragPan = new Hh(_,J,le),
                    this._add("mousePan", J),
                    this._add("touchPan", le, ["touchZoom", "touchRotate"]);
                    let me = new Hg
                      , pe = new Gg;
                    h.touchZoomRotate = new Zg(_,pe,me,R),
                    this._add("touchRotate", me, ["touchPan", "touchZoom"]),
                    this._add("touchZoom", pe, ["touchPan", "touchRotate"]),
                    this._add("blockableMapEvent", new Fh(h));
                    let ge = h.scrollZoom = new Io(h,this);
                    this._add("scrollZoom", ge, ["mousePan"]);
                    let ve = h.keyboard = new Wg;
                    this._add("keyboard", ve);
                    for (let re of ["boxZoom", "doubleClickZoom", "tapDragZoom", "touchPitch", "dragRotate", "dragPan", "touchZoomRotate", "scrollZoom", "keyboard"])
                        l.interactive && l[re] && h[re].enable(l[re])
                }
                _add(l, h, _) {
                    this._handlers.push({
                        handlerName: l,
                        handler: h,
                        allowed: _
                    }),
                    this._handlersById[l] = h
                }
                stop(l) {
                    if (!this._updatingCamera) {
                        for (let {handler: h} of this._handlers)
                            h.reset();
                        this._inertia.clear(),
                        this._fireEvents({}, {}, l),
                        this._changes = []
                    }
                }
                isActive() {
                    for (let {handler: l} of this._handlers)
                        if (l.isActive())
                            return !0;
                    return !1
                }
                isZooming() {
                    return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming()
                }
                isRotating() {
                    return !!this._eventsInProgress.rotate
                }
                isMoving() {
                    return !!Qc(this._eventsInProgress) || this.isZooming()
                }
                _isDragging() {
                    return !!this._eventsInProgress.drag
                }
                _blockedByActive(l, h, _) {
                    for (let b in l)
                        if (b !== _ && (!h || h.indexOf(b) < 0))
                            return !0;
                    return !1
                }
                handleWindowEvent(l) {
                    this.handleEvent(l, `${l.type}Window`)
                }
                _getMapTouches(l) {
                    let h = [];
                    for (let _ of l)
                        this._el.contains(_.target) && h.push(_);
                    return h
                }
                handleEvent(l, h) {
                    this._updatingCamera = !0;
                    let _ = l.type === "renderFrame"
                      , b = _ ? void 0 : l
                      , T = {
                        needsRenderFrame: !1
                    }
                      , L = {}
                      , R = {}
                      , O = l.touches ? this._getMapTouches(l.touches) : void 0
                      , V = O ? fe(this._el, O) : _ ? void 0 : W(this._el, l);
                    for (let {handlerName: le, handler: me, allowed: pe} of this._handlers) {
                        if (!me.isEnabled())
                            continue;
                        let ge;
                        this._blockedByActive(R, pe, le) ? me.reset() : me[h || l.type] && (ge = me[h || l.type](l, V, O),
                        this.mergeHandlerResult(T, L, ge, le, b),
                        ge && ge.needsRenderFrame && this._triggerRenderFrame()),
                        (ge || me.isActive()) && (R[le] = me)
                    }
                    let G = {};
                    for (let le in this._previousActiveHandlers)
                        R[le] || (G[le] = b);
                    this._previousActiveHandlers = R,
                    (Object.keys(G).length || nu(T)) && (this._changes.push([T, L, G]),
                    this._triggerRenderFrame()),
                    (Object.keys(R).length || nu(T)) && this._map._stop(!0),
                    this._updatingCamera = !1;
                    let {cameraAnimation: J} = T;
                    J && (this._inertia.clear(),
                    this._fireEvents({}, {}, !0),
                    this._changes = [],
                    J(this._map))
                }
                mergeHandlerResult(l, h, _, b, T) {
                    if (!_)
                        return;
                    i.extend(l, _);
                    let L = {
                        handlerName: b,
                        originalEvent: _.originalEvent || T
                    };
                    _.zoomDelta !== void 0 && (h.zoom = L),
                    _.panDelta !== void 0 && (h.drag = L),
                    _.pitchDelta !== void 0 && (h.pitch = L),
                    _.bearingDelta !== void 0 && (h.rotate = L)
                }
                _applyChanges() {
                    let l = {}
                      , h = {}
                      , _ = {};
                    for (let[b,T,L] of this._changes)
                        b.panDelta && (l.panDelta = (l.panDelta || new i.pointGeometry(0,0))._add(b.panDelta)),
                        b.zoomDelta && (l.zoomDelta = (l.zoomDelta || 0) + b.zoomDelta),
                        b.bearingDelta && (l.bearingDelta = (l.bearingDelta || 0) + b.bearingDelta),
                        b.pitchDelta && (l.pitchDelta = (l.pitchDelta || 0) + b.pitchDelta),
                        b.around !== void 0 && (l.around = b.around),
                        b.aroundCoord !== void 0 && (l.aroundCoord = b.aroundCoord),
                        b.pinchAround !== void 0 && (l.pinchAround = b.pinchAround),
                        b.noInertia && (l.noInertia = b.noInertia),
                        i.extend(h, T),
                        i.extend(_, L);
                    this._updateMapTransform(l, h, _),
                    this._changes = []
                }
                _updateMapTransform(l, h, _) {
                    let b = this._map
                      , T = b.transform
                      , L = Ce=>[Ce.x, Ce.y, Ce.z];
                    if ((Ce=>{
                        let Ae = this._eventsInProgress.drag;
                        return Ae && !this._handlersById[Ae.handlerName].isActive()
                    }
                    )() && !nu(l)) {
                        let Ce = T.zoom;
                        T.cameraElevationReference = "sea",
                        T.recenterOnTerrain(),
                        T.cameraElevationReference = "ground",
                        Ce !== T.zoom && this._map._update(!0)
                    }
                    if (T._isCameraConstrained && b._stop(!0),
                    !nu(l))
                        return void this._fireEvents(h, _, !0);
                    let {panDelta: R, zoomDelta: O, bearingDelta: V, pitchDelta: G, around: J, aroundCoord: le, pinchAround: me} = l;
                    T._isCameraConstrained && (O > 0 && (O = 0),
                    T._isCameraConstrained = !1),
                    me !== void 0 && (J = me),
                    (O || (Ce=>h.drag && !this._eventsInProgress.drag)()) && J && (this._dragOrigin = L(T.pointCoordinate3D(J)),
                    this._trackingEllipsoid.setup(T._camera.position, this._dragOrigin)),
                    T.cameraElevationReference = "sea",
                    b._stop(!0),
                    J = J || b.transform.centerPoint,
                    V && (T.bearing += V),
                    G && (T.pitch += G),
                    T._updateCameraState();
                    let pe = [0, 0, 0];
                    if (R)
                        if (T.projection.name === "mercator") {
                            let Ce = this._trackingEllipsoid.projectRay(T.screenPointToMercatorRay(J).dir)
                              , Ae = this._trackingEllipsoid.projectRay(T.screenPointToMercatorRay(J.sub(R)).dir);
                            pe[0] = Ae[0] - Ce[0],
                            pe[1] = Ae[1] - Ce[1]
                        } else {
                            let Ce = T.pointCoordinate(J);
                            if (T.projection.name === "globe") {
                                R = R.rotate(-T.angle);
                                let Ae = T._pixelsPerMercatorPixel / T.worldSize;
                                pe[0] = -R.x * i.mercatorScale(i.latFromMercatorY(Ce.y)) * Ae,
                                pe[1] = -R.y * i.mercatorScale(T.center.lat) * Ae
                            } else {
                                let Ae = T.pointCoordinate(J.sub(R));
                                Ce && Ae && (pe[0] = Ae.x - Ce.x,
                                pe[1] = Ae.y - Ce.y)
                            }
                        }
                    let ge = T.zoom
                      , ve = [0, 0, 0];
                    if (O) {
                        let Ce = L(le || T.pointCoordinate3D(J))
                          , Ae = {
                            dir: i.normalize([], i.sub([], Ce, T._camera.position))
                        };
                        if (Ae.dir[2] < 0) {
                            let De = T.zoomDeltaToMovement(Ce, O);
                            i.scale$2(ve, Ae.dir, De)
                        }
                    }
                    let re = i.add(pe, pe, ve);
                    T._translateCameraConstrained(re),
                    O && Math.abs(T.zoom - ge) > 1e-4 && T.recenterOnTerrain(),
                    T.cameraElevationReference = "ground",
                    this._map._update(),
                    l.noInertia || this._inertia.record(l),
                    this._fireEvents(h, _, !0)
                }
                _fireEvents(l, h, _) {
                    let b = Qc(this._eventsInProgress)
                      , T = Qc(l)
                      , L = {};
                    for (let G in l) {
                        let {originalEvent: J} = l[G];
                        this._eventsInProgress[G] || (L[`${G}start`] = J),
                        this._eventsInProgress[G] = l[G]
                    }
                    !b && T && this._fireEvent("movestart", T.originalEvent);
                    for (let G in L)
                        this._fireEvent(G, L[G]);
                    T && this._fireEvent("move", T.originalEvent);
                    for (let G in l) {
                        let {originalEvent: J} = l[G];
                        this._fireEvent(G, J)
                    }
                    let R = {}, O;
                    for (let G in this._eventsInProgress) {
                        let {handlerName: J, originalEvent: le} = this._eventsInProgress[G];
                        this._handlersById[J].isActive() || (delete this._eventsInProgress[G],
                        O = h[J] || le,
                        R[`${G}end`] = O)
                    }
                    for (let G in R)
                        this._fireEvent(G, R[G]);
                    let V = Qc(this._eventsInProgress);
                    if (_ && (b || T) && !V) {
                        this._updatingCamera = !0;
                        let G = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions)
                          , J = le=>le !== 0 && -this._bearingSnap < le && le < this._bearingSnap;
                        G ? (J(G.bearing || this._map.getBearing()) && (G.bearing = 0),
                        this._map.easeTo(G, {
                            originalEvent: O
                        })) : (this._map.fire(new i.Event("moveend",{
                            originalEvent: O
                        })),
                        J(this._map.getBearing()) && this._map.resetNorth()),
                        this._updatingCamera = !1
                    }
                }
                _fireEvent(l, h) {
                    this._map.fire(new i.Event(l,h ? {
                        originalEvent: h
                    } : {}))
                }
                _requestFrame() {
                    return this._map.triggerRepaint(),
                    this._map._renderTaskQueue.add(l=>{
                        this._frameId = void 0,
                        this.handleEvent(new eu("renderFrame",{
                            timeStamp: l
                        })),
                        this._applyChanges()
                    }
                    )
                }
                _triggerRenderFrame() {
                    this._frameId === void 0 && (this._frameId = this._requestFrame())
                }
            }
            let Jf = "map.setFreeCameraOptions(...) and map.getFreeCameraOptions() are not yet supported for non-mercator projections.";
            class Kg extends i.Evented {
                constructor(l, h) {
                    super(),
                    this._moving = !1,
                    this._zooming = !1,
                    this.transform = l,
                    this._bearingSnap = h.bearingSnap,
                    i.bindAll(["_renderFrameCallback"], this)
                }
                getCenter() {
                    return new i.LngLat(this.transform.center.lng,this.transform.center.lat)
                }
                setCenter(l, h) {
                    return this.jumpTo({
                        center: l
                    }, h)
                }
                panBy(l, h, _) {
                    return l = i.pointGeometry.convert(l).mult(-1),
                    this.panTo(this.transform.center, i.extend({
                        offset: l
                    }, h), _)
                }
                panTo(l, h, _) {
                    return this.easeTo(i.extend({
                        center: l
                    }, h), _)
                }
                getZoom() {
                    return this.transform.zoom
                }
                setZoom(l, h) {
                    return this.jumpTo({
                        zoom: l
                    }, h),
                    this
                }
                zoomTo(l, h, _) {
                    return this.easeTo(i.extend({
                        zoom: l
                    }, h), _)
                }
                zoomIn(l, h) {
                    return this.zoomTo(this.getZoom() + 1, l, h),
                    this
                }
                zoomOut(l, h) {
                    return this.zoomTo(this.getZoom() - 1, l, h),
                    this
                }
                getBearing() {
                    return this.transform.bearing
                }
                setBearing(l, h) {
                    return this.jumpTo({
                        bearing: l
                    }, h),
                    this
                }
                getPadding() {
                    return this.transform.padding
                }
                setPadding(l, h) {
                    return this.jumpTo({
                        padding: l
                    }, h),
                    this
                }
                rotateTo(l, h, _) {
                    return this.easeTo(i.extend({
                        bearing: l
                    }, h), _)
                }
                resetNorth(l, h) {
                    return this.rotateTo(0, i.extend({
                        duration: 1e3
                    }, l), h),
                    this
                }
                resetNorthPitch(l, h) {
                    return this.easeTo(i.extend({
                        bearing: 0,
                        pitch: 0,
                        duration: 1e3
                    }, l), h),
                    this
                }
                snapToNorth(l, h) {
                    return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(l, h) : this
                }
                getPitch() {
                    return this.transform.pitch
                }
                setPitch(l, h) {
                    return this.jumpTo({
                        pitch: l
                    }, h),
                    this
                }
                cameraForBounds(l, h) {
                    l = i.LngLatBounds.convert(l);
                    let _ = h && h.bearing || 0
                      , b = h && h.pitch || 0
                      , T = l.getNorthWest()
                      , L = l.getSouthEast();
                    return this._cameraForBounds(this.transform, T, L, _, b, h)
                }
                _extendCameraOptions(l) {
                    let h = {
                        top: 0,
                        bottom: 0,
                        right: 0,
                        left: 0
                    };
                    if (typeof (l = i.extend({
                        padding: h,
                        offset: [0, 0],
                        maxZoom: this.transform.maxZoom
                    }, l)).padding == "number") {
                        let _ = l.padding;
                        l.padding = {
                            top: _,
                            bottom: _,
                            right: _,
                            left: _
                        }
                    }
                    return l.padding = i.extend(h, l.padding),
                    l
                }
                _minimumAABBFrustumDistance(l, h) {
                    let _ = h.max[0] - h.min[0]
                      , b = h.max[1] - h.min[1];
                    return _ / b > l.aspect ? _ / (2 * Math.tan(.5 * l.fovX) * l.aspect) : b / (2 * Math.tan(.5 * l.fovY) * l.aspect)
                }
                _cameraForBoundsOnGlobe(l, h, _, b, T, L) {
                    let R = l.clone()
                      , O = this._extendCameraOptions(L);
                    R.bearing = b,
                    R.pitch = T;
                    let V = i.LngLat.convert(h)
                      , G = i.LngLat.convert(_)
                      , J = .5 * (V.lat + G.lat)
                      , le = .5 * (V.lng + G.lng)
                      , me = i.latLngToECEF(J, le)
                      , pe = i.normalize([], me)
                      , ge = i.normalize([], i.cross([], pe, [0, 1, 0]))
                      , ve = i.cross([], ge, pe)
                      , re = [ge[0], ge[1], ge[2], 0, ve[0], ve[1], ve[2], 0, pe[0], pe[1], pe[2], 0, 0, 0, 0, 1]
                      , Ce = [me, i.latLngToECEF(V.lat, V.lng), i.latLngToECEF(G.lat, V.lng), i.latLngToECEF(G.lat, G.lng), i.latLngToECEF(V.lat, G.lng), i.latLngToECEF(J, V.lng), i.latLngToECEF(J, G.lng), i.latLngToECEF(V.lat, le), i.latLngToECEF(G.lat, le)]
                      , Ae = i.Aabb.fromPoints(Ce.map(At=>[i.dot(ge, At), i.dot(ve, At), i.dot(pe, At)]))
                      , De = i.transformMat4([], Ae.center, re);
                    i.squaredLength(De) === 0 && i.set(De, 0, 0, 1),
                    i.normalize(De, De),
                    i.scale$2(De, De, i.GLOBE_RADIUS),
                    R.center = i.ecefToLatLng(De);
                    let Ve = R.getWorldToCameraMatrix()
                      , Fe = i.invert(new Float64Array(16), Ve);
                    Ae = i.Aabb.applyTransform(Ae, i.multiply([], Ve, re)),
                    i.transformMat4(De, De, Ve);
                    let Xe = .5 * (Ae.max[2] - Ae.min[2])
                      , $e = this._minimumAABBFrustumDistance(R, Ae)
                      , rt = i.scale$2([], [0, 0, 1], Xe)
                      , lt = i.add(rt, De, rt)
                      , Vt = $e + (R.pitch === 0 ? 0 : i.distance(De, lt))
                      , nt = R.globeCenterInViewSpace
                      , vt = i.sub([], De, [nt[0], nt[1], nt[2]]);
                    i.normalize(vt, vt),
                    i.scale$2(vt, vt, Vt);
                    let pt = i.add([], De, vt);
                    i.transformMat4(pt, pt, Fe);
                    let Dt = i.earthRadius / i.GLOBE_RADIUS
                      , st = i.length(pt)
                      , Je = i.mercatorZfromAltitude(Math.max(st * Dt - i.earthRadius, Number.EPSILON), 0)
                      , ct = Math.min(R.zoomFromMercatorZAdjusted(Je), O.maxZoom);
                    return ct > .5 * (i.GLOBE_ZOOM_THRESHOLD_MIN + i.GLOBE_ZOOM_THRESHOLD_MAX) ? (R.setProjection({
                        name: "mercator"
                    }),
                    R.zoom = ct,
                    this._cameraForBounds(R, h, _, b, T, L)) : {
                        center: R.center,
                        zoom: ct,
                        bearing: b,
                        pitch: T
                    }
                }
                queryTerrainElevation(l, h) {
                    let _ = this.transform.elevation;
                    return _ ? (h = i.extend({}, {
                        exaggerated: !0
                    }, h),
                    _.getAtPoint(i.MercatorCoordinate.fromLngLat(l), null, h.exaggerated)) : null
                }
                _cameraForBounds(l, h, _, b, T, L) {
                    if (l.projection.name === "globe")
                        return this._cameraForBoundsOnGlobe(l, h, _, b, T, L);
                    let R = l.clone()
                      , O = this._extendCameraOptions(L)
                      , V = R.padding;
                    R.bearing = b,
                    R.pitch = T;
                    let G = i.LngLat.convert(h)
                      , J = i.LngLat.convert(_)
                      , le = new i.LngLat(G.lng,J.lat)
                      , me = new i.LngLat(J.lng,G.lat)
                      , pe = R.project(G)
                      , ge = R.project(J)
                      , ve = this.queryTerrainElevation(G)
                      , re = this.queryTerrainElevation(J)
                      , Ce = this.queryTerrainElevation(le)
                      , Ae = this.queryTerrainElevation(me)
                      , De = [[pe.x, pe.y, Math.min(ve || 0, re || 0, Ce || 0, Ae || 0)], [ge.x, ge.y, Math.max(ve || 0, re || 0, Ce || 0, Ae || 0)]]
                      , Ve = i.Aabb.fromPoints(De)
                      , Fe = R.getWorldToCameraMatrix()
                      , Xe = i.invert(new Float64Array(16), Fe);
                    Ve = i.Aabb.applyTransform(Ve, Fe);
                    let $e = i.sub([], Ve.max, Ve.min)
                      , rt = V.left || 0
                      , lt = V.right || 0
                      , Vt = V.bottom || 0
                      , nt = V.top || 0
                      , {left: vt, right: pt, top: Dt, bottom: st} = O.padding
                      , Je = .5 * (rt + lt)
                      , ct = .5 * (nt + Vt)
                      , At = Math.min(R.scaleZoom(R.scale * Math.min((R.width - (rt + lt + vt + pt)) / $e[0], (R.height - (Vt + nt + st + Dt)) / $e[1])), O.maxZoom)
                      , Pt = R.scale / R.zoomScale(At);
                    Ve = new i.Aabb([Ve.min[0] - (vt + Je) * Pt, Ve.min[1] - (st + ct) * Pt, Ve.min[2]],[Ve.max[0] + (pt + Je) * Pt, Ve.max[1] + (Dt + ct) * Pt, Ve.max[2]]);
                    let pn = .5 * $e[2]
                      , Xn = this._minimumAABBFrustumDistance(R, Ve)
                      , un = [0, 0, 1, 0];
                    i.transformMat4$1(un, un, Fe),
                    i.normalize$2(un, un);
                    let sn = i.scale$2([], un, Xn + pn)
                      , vn = i.add([], Ve.center, sn)
                      , Qn = (typeof O.offset.x == "number" && typeof O.offset.y == "number" ? new i.pointGeometry(O.offset.x,O.offset.y) : i.pointGeometry.convert(O.offset)).rotate(-i.degToRad(b));
                    Ve.center[0] -= Qn.x * Pt,
                    Ve.center[1] += Qn.y * Pt,
                    i.transformMat4(Ve.center, Ve.center, Xe),
                    i.transformMat4(vn, vn, Xe);
                    let En = [Ve.center[0], Ve.center[1], vn[2] * R.pixelsPerMeter];
                    i.scale$2(En, En, 1 / R.worldSize);
                    let pi = i.lngFromMercatorX(En[0])
                      , Ti = i.latFromMercatorY(En[1])
                      , Ri = Math.min(R._zoomFromMercatorZ(En[2]), O.maxZoom)
                      , Mi = new i.LngLat(pi,Ti);
                    return R.mercatorFromTransition && Ri < .5 * (i.GLOBE_ZOOM_THRESHOLD_MIN + i.GLOBE_ZOOM_THRESHOLD_MAX) ? (R.setProjection({
                        name: "globe"
                    }),
                    R.zoom = Ri,
                    this._cameraForBounds(R, h, _, b, T, L)) : {
                        center: Mi,
                        zoom: Ri,
                        bearing: b,
                        pitch: T
                    }
                }
                fitBounds(l, h, _) {
                    let b = this.cameraForBounds(l, h);
                    return this._fitInternal(b, h, _)
                }
                fitScreenCoordinates(l, h, _, b, T) {
                    let L = i.pointGeometry.convert(l)
                      , R = i.pointGeometry.convert(h)
                      , O = new i.pointGeometry(Math.min(L.x, R.x),Math.min(L.y, R.y))
                      , V = new i.pointGeometry(Math.max(L.x, R.x),Math.max(L.y, R.y));
                    if (this.transform.projection.name === "mercator" && this.transform.anyCornerOffEdge(L, R))
                        return this;
                    let G = this.transform.pointLocation3D(O)
                      , J = this.transform.pointLocation3D(V)
                      , le = this.transform.pointLocation3D(new i.pointGeometry(O.x,V.y))
                      , me = this.transform.pointLocation3D(new i.pointGeometry(V.x,O.y))
                      , pe = [Math.min(G.lng, J.lng, le.lng, me.lng), Math.min(G.lat, J.lat, le.lat, me.lat)]
                      , ge = [Math.max(G.lng, J.lng, le.lng, me.lng), Math.max(G.lat, J.lat, le.lat, me.lat)]
                      , ve = b && b.pitch ? b.pitch : this.getPitch()
                      , re = this._cameraForBounds(this.transform, pe, ge, _, ve, b);
                    return this._fitInternal(re, b, T)
                }
                _fitInternal(l, h, _) {
                    return l ? (delete (h = i.extend(l, h)).padding,
                    h.linear ? this.easeTo(h, _) : this.flyTo(h, _)) : this
                }
                jumpTo(l, h) {
                    this.stop();
                    let _ = l.preloadOnly ? this.transform.clone() : this.transform
                      , b = !1
                      , T = !1
                      , L = !1;
                    return "zoom"in l && _.zoom !== +l.zoom && (b = !0,
                    _.zoom = +l.zoom),
                    l.center !== void 0 && (_.center = i.LngLat.convert(l.center)),
                    "bearing"in l && _.bearing !== +l.bearing && (T = !0,
                    _.bearing = +l.bearing),
                    "pitch"in l && _.pitch !== +l.pitch && (L = !0,
                    _.pitch = +l.pitch),
                    l.padding == null || _.isPaddingEqual(l.padding) || (_.padding = l.padding),
                    l.preloadOnly ? (this._preloadTiles(_),
                    this) : (this.fire(new i.Event("movestart",h)).fire(new i.Event("move",h)),
                    b && this.fire(new i.Event("zoomstart",h)).fire(new i.Event("zoom",h)).fire(new i.Event("zoomend",h)),
                    T && this.fire(new i.Event("rotatestart",h)).fire(new i.Event("rotate",h)).fire(new i.Event("rotateend",h)),
                    L && this.fire(new i.Event("pitchstart",h)).fire(new i.Event("pitch",h)).fire(new i.Event("pitchend",h)),
                    this.fire(new i.Event("moveend",h)))
                }
                getFreeCameraOptions() {
                    return this.transform.projection.supportsFreeCamera || i.warnOnce(Jf),
                    this.transform.getFreeCameraOptions()
                }
                setFreeCameraOptions(l, h) {
                    let _ = this.transform;
                    if (!_.projection.supportsFreeCamera)
                        return i.warnOnce(Jf),
                        this;
                    this.stop();
                    let b = _.zoom
                      , T = _.pitch
                      , L = _.bearing;
                    _.setFreeCameraOptions(l);
                    let R = b !== _.zoom
                      , O = T !== _.pitch
                      , V = L !== _.bearing;
                    return this.fire(new i.Event("movestart",h)).fire(new i.Event("move",h)),
                    R && this.fire(new i.Event("zoomstart",h)).fire(new i.Event("zoom",h)).fire(new i.Event("zoomend",h)),
                    V && this.fire(new i.Event("rotatestart",h)).fire(new i.Event("rotate",h)).fire(new i.Event("rotateend",h)),
                    O && this.fire(new i.Event("pitchstart",h)).fire(new i.Event("pitch",h)).fire(new i.Event("pitchend",h)),
                    this.fire(new i.Event("moveend",h)),
                    this
                }
                easeTo(l, h) {
                    this._stop(!1, l.easeId),
                    ((l = i.extend({
                        offset: [0, 0],
                        duration: 500,
                        easing: i.ease
                    }, l)).animate === !1 || !l.essential && i.exported.prefersReducedMotion) && (l.duration = 0);
                    let _ = this.transform, b = this.getZoom(), T = this.getBearing(), L = this.getPitch(), R = this.getPadding(), O = "zoom"in l ? +l.zoom : b, V = "bearing"in l ? this._normalizeBearing(l.bearing, T) : T, G = "pitch"in l ? +l.pitch : L, J = "padding"in l ? l.padding : _.padding, le = i.pointGeometry.convert(l.offset), me, pe, ge;
                    if (_.projection.name === "globe") {
                        let rt = i.MercatorCoordinate.fromLngLat(_.center)
                          , lt = le.rotate(-_.angle);
                        rt.x += lt.x / _.worldSize,
                        rt.y += lt.y / _.worldSize;
                        let Vt = rt.toLngLat()
                          , nt = i.LngLat.convert(l.center || Vt);
                        this._normalizeCenter(nt),
                        me = _.centerPoint.add(lt),
                        pe = new i.pointGeometry(rt.x,rt.y).mult(_.worldSize),
                        ge = new i.pointGeometry(i.mercatorXfromLng(nt.lng),i.mercatorYfromLat(nt.lat)).mult(_.worldSize).sub(pe)
                    } else {
                        me = _.centerPoint.add(le);
                        let rt = _.pointLocation(me)
                          , lt = i.LngLat.convert(l.center || rt);
                        this._normalizeCenter(lt),
                        pe = _.project(rt),
                        ge = _.project(lt).sub(pe)
                    }
                    let ve = _.zoomScale(O - b), re, Ce;
                    l.around && (re = i.LngLat.convert(l.around),
                    Ce = _.locationPoint(re));
                    let Ae = this._zooming || O !== b
                      , De = this._rotating || T !== V
                      , Ve = this._pitching || G !== L
                      , Fe = !_.isPaddingEqual(J)
                      , Xe = rt=>lt=>{
                        if (Ae && (rt.zoom = i.number(b, O, lt)),
                        De && (rt.bearing = i.number(T, V, lt)),
                        Ve && (rt.pitch = i.number(L, G, lt)),
                        Fe && (rt.interpolatePadding(R, J, lt),
                        me = rt.centerPoint.add(le)),
                        re)
                            rt.setLocationAtPoint(re, Ce);
                        else {
                            let Vt = rt.zoomScale(rt.zoom - b)
                              , nt = O > b ? Math.min(2, ve) : Math.max(.5, ve)
                              , vt = Math.pow(nt, 1 - lt)
                              , pt = rt.unproject(pe.add(ge.mult(lt * vt)).mult(Vt));
                            rt.setLocationAtPoint(rt.renderWorldCopies ? pt.wrap() : pt, me)
                        }
                        return l.preloadOnly || this._fireMoveEvents(h),
                        rt
                    }
                    ;
                    if (l.preloadOnly) {
                        let rt = this._emulate(Xe, l.duration, _);
                        return this._preloadTiles(rt),
                        this
                    }
                    let $e = {
                        moving: this._moving,
                        zooming: this._zooming,
                        rotating: this._rotating,
                        pitching: this._pitching
                    };
                    return this._zooming = Ae,
                    this._rotating = De,
                    this._pitching = Ve,
                    this._padding = Fe,
                    this._easeId = l.easeId,
                    this._prepareEase(h, l.noMoveStart, $e),
                    this._ease(Xe(_), rt=>{
                        _.recenterOnTerrain(),
                        this._afterEase(h, rt)
                    }
                    , l),
                    this
                }
                _prepareEase(l, h, _={}) {
                    this._moving = !0,
                    this.transform.cameraElevationReference = "sea",
                    h || _.moving || this.fire(new i.Event("movestart",l)),
                    this._zooming && !_.zooming && this.fire(new i.Event("zoomstart",l)),
                    this._rotating && !_.rotating && this.fire(new i.Event("rotatestart",l)),
                    this._pitching && !_.pitching && this.fire(new i.Event("pitchstart",l))
                }
                _fireMoveEvents(l) {
                    this.fire(new i.Event("move",l)),
                    this._zooming && this.fire(new i.Event("zoom",l)),
                    this._rotating && this.fire(new i.Event("rotate",l)),
                    this._pitching && this.fire(new i.Event("pitch",l))
                }
                _afterEase(l, h) {
                    if (this._easeId && h && this._easeId === h)
                        return;
                    this._easeId = void 0,
                    this.transform.cameraElevationReference = "ground";
                    let _ = this._zooming
                      , b = this._rotating
                      , T = this._pitching;
                    this._moving = !1,
                    this._zooming = !1,
                    this._rotating = !1,
                    this._pitching = !1,
                    this._padding = !1,
                    _ && this.fire(new i.Event("zoomend",l)),
                    b && this.fire(new i.Event("rotateend",l)),
                    T && this.fire(new i.Event("pitchend",l)),
                    this.fire(new i.Event("moveend",l))
                }
                flyTo(l, h) {
                    if (!l.essential && i.exported.prefersReducedMotion) {
                        let At = i.pick(l, ["center", "zoom", "bearing", "pitch", "around"]);
                        return this.jumpTo(At, h)
                    }
                    this.stop(),
                    l = i.extend({
                        offset: [0, 0],
                        speed: 1.2,
                        curve: 1.42,
                        easing: i.ease
                    }, l);
                    let _ = this.transform
                      , b = this.getZoom()
                      , T = this.getBearing()
                      , L = this.getPitch()
                      , R = this.getPadding()
                      , O = "zoom"in l ? i.clamp(+l.zoom, _.minZoom, _.maxZoom) : b
                      , V = "bearing"in l ? this._normalizeBearing(l.bearing, T) : T
                      , G = "pitch"in l ? +l.pitch : L
                      , J = "padding"in l ? l.padding : _.padding
                      , le = _.zoomScale(O - b)
                      , me = i.pointGeometry.convert(l.offset)
                      , pe = _.centerPoint.add(me)
                      , ge = _.pointLocation(pe)
                      , ve = i.LngLat.convert(l.center || ge);
                    this._normalizeCenter(ve);
                    let re = _.project(ge)
                      , Ce = _.project(ve).sub(re)
                      , Ae = l.curve
                      , De = Math.max(_.width, _.height)
                      , Ve = De / le
                      , Fe = Ce.mag();
                    if ("minZoom"in l) {
                        let At = i.clamp(Math.min(l.minZoom, b, O), _.minZoom, _.maxZoom)
                          , Pt = De / _.zoomScale(At - b);
                        Ae = Math.sqrt(Pt / Fe * 2)
                    }
                    let Xe = Ae * Ae;
                    function $e(At) {
                        let Pt = (Ve * Ve - De * De + (At ? -1 : 1) * Xe * Xe * Fe * Fe) / (2 * (At ? Ve : De) * Xe * Fe);
                        return Math.log(Math.sqrt(Pt * Pt + 1) - Pt)
                    }
                    function rt(At) {
                        return (Math.exp(At) - Math.exp(-At)) / 2
                    }
                    function lt(At) {
                        return (Math.exp(At) + Math.exp(-At)) / 2
                    }
                    let Vt = $e(0)
                      , nt = function(At) {
                        return lt(Vt) / lt(Vt + Ae * At)
                    }
                      , vt = function(At) {
                        return De * ((lt(Vt) * (rt(Pt = Vt + Ae * At) / lt(Pt)) - rt(Vt)) / Xe) / Fe;
                        var Pt
                    }
                      , pt = ($e(1) - Vt) / Ae;
                    if (Math.abs(Fe) < 1e-6 || !isFinite(pt)) {
                        if (Math.abs(De - Ve) < 1e-6)
                            return this.easeTo(l, h);
                        let At = Ve < De ? -1 : 1;
                        pt = Math.abs(Math.log(Ve / De)) / Ae,
                        vt = function() {
                            return 0
                        }
                        ,
                        nt = function(Pt) {
                            return Math.exp(At * Ae * Pt)
                        }
                    }
                    l.duration = "duration"in l ? +l.duration : 1e3 * pt / ("screenSpeed"in l ? +l.screenSpeed / Ae : +l.speed),
                    l.maxDuration && l.duration > l.maxDuration && (l.duration = 0);
                    let Dt = T !== V
                      , st = G !== L
                      , Je = !_.isPaddingEqual(J)
                      , ct = At=>Pt=>{
                        let pn = Pt * pt
                          , Xn = 1 / nt(pn);
                        At.zoom = Pt === 1 ? O : b + At.scaleZoom(Xn),
                        Dt && (At.bearing = i.number(T, V, Pt)),
                        st && (At.pitch = i.number(L, G, Pt)),
                        Je && (At.interpolatePadding(R, J, Pt),
                        pe = At.centerPoint.add(me));
                        let un = Pt === 1 ? ve : At.unproject(re.add(Ce.mult(vt(pn))).mult(Xn));
                        return At.setLocationAtPoint(At.renderWorldCopies ? un.wrap() : un, pe),
                        At._updateCameraOnTerrain(),
                        l.preloadOnly || this._fireMoveEvents(h),
                        At
                    }
                    ;
                    if (l.preloadOnly) {
                        let At = this._emulate(ct, l.duration, _);
                        return this._preloadTiles(At),
                        this
                    }
                    return this._zooming = !0,
                    this._rotating = Dt,
                    this._pitching = st,
                    this._padding = Je,
                    this._prepareEase(h, !1),
                    this._ease(ct(_), ()=>this._afterEase(h), l),
                    this
                }
                isEasing() {
                    return !!this._easeFrameId
                }
                stop() {
                    return this._stop()
                }
                _stop(l, h) {
                    if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId),
                    this._easeFrameId = void 0,
                    this._onEaseFrame = void 0),
                    this._onEaseEnd) {
                        let _ = this._onEaseEnd;
                        this._onEaseEnd = void 0,
                        _.call(this, h)
                    }
                    if (!l) {
                        let _ = this.handlers;
                        _ && _.stop(!1)
                    }
                    return this
                }
                _ease(l, h, _) {
                    _.animate === !1 || _.duration === 0 ? (l(1),
                    h()) : (this._easeStart = i.exported.now(),
                    this._easeOptions = _,
                    this._onEaseFrame = l,
                    this._onEaseEnd = h,
                    this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback))
                }
                _renderFrameCallback() {
                    let l = Math.min((i.exported.now() - this._easeStart) / this._easeOptions.duration, 1)
                      , h = this._onEaseFrame;
                    h && h(this._easeOptions.easing(l)),
                    l < 1 ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop()
                }
                _normalizeBearing(l, h) {
                    l = i.wrap(l, -180, 180);
                    let _ = Math.abs(l - h);
                    return Math.abs(l - 360 - h) < _ && (l -= 360),
                    Math.abs(l + 360 - h) < _ && (l += 360),
                    l
                }
                _normalizeCenter(l) {
                    let h = this.transform;
                    if (!h.renderWorldCopies || h.maxBounds)
                        return;
                    let _ = l.lng - h.center.lng;
                    l.lng += _ > 180 ? -360 : _ < -180 ? 360 : 0
                }
                _emulate(l, h, _) {
                    let b = Math.ceil(15 * h / 1e3)
                      , T = []
                      , L = l(_.clone());
                    for (let R = 0; R <= b; R++) {
                        let O = L(R / b);
                        T.push(O.clone())
                    }
                    return T
                }
            }
            class $f {
                constructor(l={}) {
                    this.options = l,
                    i.bindAll(["_toggleAttribution", "_updateEditLink", "_updateData", "_updateCompact"], this)
                }
                getDefaultPosition() {
                    return "bottom-right"
                }
                onAdd(l) {
                    let h = this.options && this.options.compact;
                    return this._map = l,
                    this._container = C("div", "mapboxgl-ctrl mapboxgl-ctrl-attrib"),
                    this._compactButton = C("button", "mapboxgl-ctrl-attrib-button", this._container),
                    C("span", "mapboxgl-ctrl-icon", this._compactButton).setAttribute("aria-hidden", "true"),
                    this._compactButton.type = "button",
                    this._compactButton.addEventListener("click", this._toggleAttribution),
                    this._setElementTitle(this._compactButton, "ToggleAttribution"),
                    this._innerContainer = C("div", "mapboxgl-ctrl-attrib-inner", this._container),
                    this._innerContainer.setAttribute("role", "list"),
                    h && this._container.classList.add("mapboxgl-compact"),
                    this._updateAttributions(),
                    this._updateEditLink(),
                    this._map.on("styledata", this._updateData),
                    this._map.on("sourcedata", this._updateData),
                    this._map.on("moveend", this._updateEditLink),
                    h === void 0 && (this._map.on("resize", this._updateCompact),
                    this._updateCompact()),
                    this._container
                }
                onRemove() {
                    this._container.remove(),
                    this._map.off("styledata", this._updateData),
                    this._map.off("sourcedata", this._updateData),
                    this._map.off("moveend", this._updateEditLink),
                    this._map.off("resize", this._updateCompact),
                    this._map = void 0,
                    this._attribHTML = void 0
                }
                _setElementTitle(l, h) {
                    let _ = this._map._getUIString(`AttributionControl.${h}`);
                    l.setAttribute("aria-label", _),
                    l.removeAttribute("title"),
                    l.firstElementChild && l.firstElementChild.setAttribute("title", _)
                }
                _toggleAttribution() {
                    this._container.classList.contains("mapboxgl-compact-show") ? (this._container.classList.remove("mapboxgl-compact-show"),
                    this._compactButton.setAttribute("aria-expanded", "false")) : (this._container.classList.add("mapboxgl-compact-show"),
                    this._compactButton.setAttribute("aria-expanded", "true"))
                }
                _updateEditLink() {
                    let l = this._editLink;
                    l || (l = this._editLink = this._container.querySelector(".mapbox-improve-map"));
                    let h = [{
                        key: "owner",
                        value: this.styleOwner
                    }, {
                        key: "id",
                        value: this.styleId
                    }, {
                        key: "access_token",
                        value: this._map._requestManager._customAccessToken || i.config.ACCESS_TOKEN
                    }];
                    if (l) {
                        let _ = h.reduce((b,T,L)=>(T.value && (b += `${T.key}=${T.value}${L < h.length - 1 ? "&" : ""}`),
                        b), "?");
                        l.href = `${i.config.FEEDBACK_URL}/${_}#${Wf(this._map, !0)}`,
                        l.rel = "noopener nofollow",
                        this._setElementTitle(l, "MapFeedback")
                    }
                }
                _updateData(l) {
                    !l || l.sourceDataType !== "metadata" && l.sourceDataType !== "visibility" && l.dataType !== "style" || (this._updateAttributions(),
                    this._updateEditLink())
                }
                _updateAttributions() {
                    if (!this._map.style)
                        return;
                    let l = [];
                    if (this._map.style.stylesheet) {
                        let b = this._map.style.stylesheet;
                        this.styleOwner = b.owner,
                        this.styleId = b.id
                    }
                    let h = this._map.style._sourceCaches;
                    for (let b in h) {
                        let T = h[b];
                        if (T.used) {
                            let L = T.getSource();
                            L.attribution && l.indexOf(L.attribution) < 0 && l.push(L.attribution)
                        }
                    }
                    l.sort((b,T)=>b.length - T.length),
                    l = l.filter((b,T)=>{
                        for (let L = T + 1; L < l.length; L++)
                            if (l[L].indexOf(b) >= 0)
                                return !1;
                        return !0
                    }
                    ),
                    this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? l = [...this.options.customAttribution, ...l] : l.unshift(this.options.customAttribution));
                    let _ = l.join(" | ");
                    _ !== this._attribHTML && (this._attribHTML = _,
                    l.length ? (this._innerContainer.innerHTML = _,
                    this._container.classList.remove("mapboxgl-attrib-empty")) : this._container.classList.add("mapboxgl-attrib-empty"),
                    this._editLink = null)
                }
                _updateCompact() {
                    this._map.getCanvasContainer().offsetWidth <= 640 ? this._container.classList.add("mapboxgl-compact") : this._container.classList.remove("mapboxgl-compact", "mapboxgl-compact-show")
                }
            }
            class Qf {
                constructor() {
                    i.bindAll(["_updateLogo", "_updateCompact"], this)
                }
                onAdd(l) {
                    this._map = l,
                    this._container = C("div", "mapboxgl-ctrl");
                    let h = C("a", "mapboxgl-ctrl-logo");
                    return h.target = "_blank",
                    h.rel = "noopener nofollow",
                    h.href = "https://www.mapbox.com/",
                    h.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")),
                    h.setAttribute("rel", "noopener nofollow"),
                    this._container.appendChild(h),
                    this._container.style.display = "none",
                    this._map.on("sourcedata", this._updateLogo),
                    this._updateLogo(),
                    this._map.on("resize", this._updateCompact),
                    this._updateCompact(),
                    this._container
                }
                onRemove() {
                    this._container.remove(),
                    this._map.off("sourcedata", this._updateLogo),
                    this._map.off("resize", this._updateCompact)
                }
                getDefaultPosition() {
                    return "bottom-left"
                }
                _updateLogo(l) {
                    l && l.sourceDataType !== "metadata" || (this._container.style.display = this._logoRequired() ? "block" : "none")
                }
                _logoRequired() {
                    if (!this._map.style)
                        return !0;
                    let l = this._map.style._sourceCaches;
                    if (Object.entries(l).length === 0)
                        return !0;
                    for (let h in l) {
                        let _ = l[h].getSource();
                        if (_.hasOwnProperty("mapbox_logo") && !_.mapbox_logo)
                            return !1
                    }
                    return !0
                }
                _updateCompact() {
                    let l = this._container.children;
                    if (l.length) {
                        let h = l[0];
                        this._map.getCanvasContainer().offsetWidth < 250 ? h.classList.add("mapboxgl-compact") : h.classList.remove("mapboxgl-compact")
                    }
                }
            }
            class iu {
                constructor() {
                    this._queue = [],
                    this._id = 0,
                    this._cleared = !1,
                    this._currentlyRunning = !1
                }
                add(l) {
                    let h = ++this._id;
                    return this._queue.push({
                        callback: l,
                        id: h,
                        cancelled: !1
                    }),
                    h
                }
                remove(l) {
                    let h = this._currentlyRunning
                      , _ = h ? this._queue.concat(h) : this._queue;
                    for (let b of _)
                        if (b.id === l)
                            return void (b.cancelled = !0)
                }
                run(l=0) {
                    let h = this._currentlyRunning = this._queue;
                    this._queue = [];
                    for (let _ of h)
                        if (!_.cancelled && (_.callback(l),
                        this._cleared))
                            break;
                    this._cleared = !1,
                    this._currentlyRunning = !1
                }
                clear() {
                    this._currentlyRunning && (this._cleared = !0),
                    this._queue = []
                }
            }
            function Wh(m, l, h) {
                if (m = new i.LngLat(m.lng,m.lat),
                l) {
                    let _ = new i.LngLat(m.lng - 360,m.lat)
                      , b = new i.LngLat(m.lng + 360,m.lat)
                      , T = 360 * Math.ceil(Math.abs(m.lng - h.center.lng) / 360)
                      , L = h.locationPoint(m).distSqr(l)
                      , R = l.x < 0 || l.y < 0 || l.x > h.width || l.y > h.height;
                    h.locationPoint(_).distSqr(l) < L && (R || Math.abs(_.lng - h.center.lng) < T) ? m = _ : h.locationPoint(b).distSqr(l) < L && (R || Math.abs(b.lng - h.center.lng) < T) && (m = b)
                }
                for (; Math.abs(m.lng - h.center.lng) > 180; ) {
                    let _ = h.locationPoint(m);
                    if (_.x >= 0 && _.y >= 0 && _.x <= h.width && _.y <= h.height)
                        break;
                    m.lng > h.center.lng ? m.lng -= 360 : m.lng += 360
                }
                return m
            }
            let Ll = {
                center: "translate(-50%,-50%)",
                top: "translate(-50%,0)",
                "top-left": "translate(0,0)",
                "top-right": "translate(-100%,0)",
                bottom: "translate(-50%,-100%)",
                "bottom-left": "translate(0,-100%)",
                "bottom-right": "translate(-100%,-100%)",
                left: "translate(0,-50%)",
                right: "translate(-100%,-50%)"
            };
            class jh extends i.Evented {
                constructor(l, h) {
                    if (super(),
                    (l instanceof i.window.HTMLElement || h) && (l = i.extend({
                        element: l
                    }, h)),
                    i.bindAll(["_update", "_onMove", "_onUp", "_addDragHandler", "_onMapClick", "_onKeyPress", "_clearFadeTimer"], this),
                    this._anchor = l && l.anchor || "center",
                    this._color = l && l.color || "#3FB1CE",
                    this._scale = l && l.scale || 1,
                    this._draggable = l && l.draggable || !1,
                    this._clickTolerance = l && l.clickTolerance || 0,
                    this._isDragging = !1,
                    this._state = "inactive",
                    this._rotation = l && l.rotation || 0,
                    this._rotationAlignment = l && l.rotationAlignment || "auto",
                    this._pitchAlignment = l && l.pitchAlignment && l.pitchAlignment || "auto",
                    this._updateMoving = ()=>this._update(!0),
                    this._occludedOpacity = l && l.occludedOpacity || .2,
                    l && l.element)
                        this._element = l.element,
                        this._offset = i.pointGeometry.convert(l && l.offset || [0, 0]);
                    else {
                        this._defaultMarker = !0,
                        this._element = C("div");
                        let b = 41
                          , T = 27
                          , L = I("svg", {
                            display: "block",
                            height: b * this._scale + "px",
                            width: T * this._scale + "px",
                            viewBox: `0 0 ${T} ${b}`
                        }, this._element)
                          , R = I("radialGradient", {
                            id: "shadowGradient"
                        }, I("defs", {}, L));
                        I("stop", {
                            offset: "10%",
                            "stop-opacity": .4
                        }, R),
                        I("stop", {
                            offset: "100%",
                            "stop-opacity": .05
                        }, R),
                        I("ellipse", {
                            cx: 13.5,
                            cy: 34.8,
                            rx: 10.5,
                            ry: 5.25,
                            fill: "url(#shadowGradient)"
                        }, L),
                        I("path", {
                            fill: this._color,
                            d: "M27,13.5C27,19.07 20.25,27 14.75,34.5C14.02,35.5 12.98,35.5 12.25,34.5C6.75,27 0,19.22 0,13.5C0,6.04 6.04,0 13.5,0C20.96,0 27,6.04 27,13.5Z"
                        }, L),
                        I("path", {
                            opacity: .25,
                            d: "M13.5,0C6.04,0 0,6.04 0,13.5C0,19.22 6.75,27 12.25,34.5C13,35.52 14.02,35.5 14.75,34.5C20.25,27 27,19.07 27,13.5C27,6.04 20.96,0 13.5,0ZM13.5,1C20.42,1 26,6.58 26,13.5C26,15.9 24.5,19.18 22.22,22.74C19.95,26.3 16.71,30.14 13.94,33.91C13.74,34.18 13.61,34.32 13.5,34.44C13.39,34.32 13.26,34.18 13.06,33.91C10.28,30.13 7.41,26.31 5.02,22.77C2.62,19.23 1,15.95 1,13.5C1,6.58 6.58,1 13.5,1Z"
                        }, L),
                        I("circle", {
                            fill: "white",
                            cx: 13.5,
                            cy: 13.5,
                            r: 5.5
                        }, L),
                        this._offset = i.pointGeometry.convert(l && l.offset || [0, -14])
                    }
                    this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", "Map marker"),
                    this._element.classList.add("mapboxgl-marker"),
                    this._element.addEventListener("dragstart", b=>{
                        b.preventDefault()
                    }
                    ),
                    this._element.addEventListener("mousedown", b=>{
                        b.preventDefault()
                    }
                    );
                    let _ = this._element.classList;
                    for (let b in Ll)
                        _.remove(`mapboxgl-marker-anchor-${b}`);
                    _.add(`mapboxgl-marker-anchor-${this._anchor}`),
                    this._popup = null
                }
                addTo(l) {
                    return l === this._map || (this.remove(),
                    this._map = l,
                    l.getCanvasContainer().appendChild(this._element),
                    l.on("move", this._updateMoving),
                    l.on("moveend", this._update),
                    l.on("remove", this._clearFadeTimer),
                    l._addMarker(this),
                    this.setDraggable(this._draggable),
                    this._update(),
                    l.on("click", this._onMapClick)),
                    this
                }
                remove() {
                    let l = this._map;
                    return l && (l.off("click", this._onMapClick),
                    l.off("move", this._updateMoving),
                    l.off("moveend", this._update),
                    l.off("mousedown", this._addDragHandler),
                    l.off("touchstart", this._addDragHandler),
                    l.off("mouseup", this._onUp),
                    l.off("touchend", this._onUp),
                    l.off("mousemove", this._onMove),
                    l.off("touchmove", this._onMove),
                    l.off("remove", this._clearFadeTimer),
                    l._removeMarker(this),
                    this._map = void 0),
                    this._clearFadeTimer(),
                    this._element.remove(),
                    this._popup && this._popup.remove(),
                    this
                }
                getLngLat() {
                    return this._lngLat
                }
                setLngLat(l) {
                    return this._lngLat = i.LngLat.convert(l),
                    this._pos = null,
                    this._popup && this._popup.setLngLat(this._lngLat),
                    this._update(!0),
                    this
                }
                getElement() {
                    return this._element
                }
                setPopup(l) {
                    if (this._popup && (this._popup.remove(),
                    this._popup = null,
                    this._element.removeAttribute("role"),
                    this._element.removeEventListener("keypress", this._onKeyPress),
                    this._originalTabIndex || this._element.removeAttribute("tabindex")),
                    l) {
                        if (!("offset"in l.options)) {
                            let h = 38.1
                              , _ = 13.5
                              , b = Math.sqrt(Math.pow(_, 2) / 2);
                            l.options.offset = this._defaultMarker ? {
                                top: [0, 0],
                                "top-left": [0, 0],
                                "top-right": [0, 0],
                                bottom: [0, -h],
                                "bottom-left": [b, -1 * (h - _ + b)],
                                "bottom-right": [-b, -1 * (h - _ + b)],
                                left: [_, -1 * (h - _)],
                                right: [-_, -1 * (h - _)]
                            } : this._offset
                        }
                        this._popup = l,
                        l._marker = this,
                        this._lngLat && this._popup.setLngLat(this._lngLat),
                        this._element.setAttribute("role", "button"),
                        this._originalTabIndex = this._element.getAttribute("tabindex"),
                        this._originalTabIndex || this._element.setAttribute("tabindex", "0"),
                        this._element.addEventListener("keypress", this._onKeyPress),
                        this._element.setAttribute("aria-expanded", "false")
                    }
                    return this
                }
                _onKeyPress(l) {
                    let h = l.code
                      , _ = l.charCode || l.keyCode;
                    h !== "Space" && h !== "Enter" && _ !== 32 && _ !== 13 || this.togglePopup()
                }
                _onMapClick(l) {
                    let h = l.originalEvent.target
                      , _ = this._element;
                    this._popup && (h === _ || _.contains(h)) && this.togglePopup()
                }
                getPopup() {
                    return this._popup
                }
                togglePopup() {
                    let l = this._popup;
                    return l ? (l.isOpen() ? (l.remove(),
                    this._element.setAttribute("aria-expanded", "false")) : this._map && (l.addTo(this._map),
                    this._element.setAttribute("aria-expanded", "true")),
                    this) : this
                }
                _behindTerrain() {
                    let l = this._map
                      , h = this._pos;
                    if (!l || !h)
                        return !1;
                    let _ = l.unproject(h)
                      , b = l.getFreeCameraOptions();
                    if (!b.position)
                        return !1;
                    let T = b.position.toLngLat();
                    return T.distanceTo(_) < .9 * T.distanceTo(this._lngLat)
                }
                _evaluateOpacity() {
                    let l = this._map;
                    if (!l)
                        return;
                    let h = this._pos;
                    if (!h || h.x < 0 || h.x > l.transform.width || h.y < 0 || h.y > l.transform.height)
                        return void this._clearFadeTimer();
                    let _ = l.unproject(h), b;
                    l._showingGlobe() && i.isLngLatBehindGlobe(l.transform, this._lngLat) ? b = 0 : (b = 1 - l._queryFogOpacity(_),
                    l.transform._terrainEnabled() && l.getTerrain() && this._behindTerrain() && (b *= this._occludedOpacity)),
                    this._element.style.opacity = `${b}`,
                    this._element.style.pointerEvents = b > 0 ? "auto" : "none",
                    this._popup && this._popup._setOpacity(b),
                    this._fadeTimer = null
                }
                _clearFadeTimer() {
                    this._fadeTimer && (clearTimeout(this._fadeTimer),
                    this._fadeTimer = null)
                }
                _updateDOM() {
                    let l = this._pos;
                    if (!l || !this._map)
                        return;
                    let h = this._offset.mult(this._scale);
                    this._element.style.transform = `
            translate(${l.x}px,${l.y}px)
            ${Ll[this._anchor]}
            ${this._calculateXYTransform()} ${this._calculateZTransform()}
            translate(${h.x}px,${h.y}px)
        `
                }
                _calculateXYTransform() {
                    let l = this._pos
                      , h = this._map
                      , _ = this.getPitchAlignment();
                    if (!h || !l || _ !== "map")
                        return "";
                    if (!h._showingGlobe()) {
                        let O = h.getPitch();
                        return O ? `rotateX(${O}deg)` : ""
                    }
                    let b = i.radToDeg(i.globeTiltAtLngLat(h.transform, this._lngLat))
                      , T = l.sub(i.globeCenterToScreenPoint(h.transform))
                      , L = Math.abs(T.x) + Math.abs(T.y);
                    if (L === 0)
                        return "";
                    let R = b / L;
                    return `rotateX(${-T.y * R}deg) rotateY(${T.x * R}deg)`
                }
                _calculateZTransform() {
                    let l = this._pos
                      , h = this._map;
                    if (!h || !l)
                        return "";
                    let _ = 0
                      , b = this.getRotationAlignment();
                    if (b === "map")
                        if (h._showingGlobe()) {
                            let T = h.project(new i.LngLat(this._lngLat.lng,this._lngLat.lat + .001))
                              , L = h.project(new i.LngLat(this._lngLat.lng,this._lngLat.lat - .001)).sub(T);
                            _ = i.radToDeg(Math.atan2(L.y, L.x)) - 90
                        } else
                            _ = -h.getBearing();
                    else if (b === "horizon") {
                        let T = i.smoothstep(4, 6, h.getZoom())
                          , L = i.globeCenterToScreenPoint(h.transform);
                        L.y += T * h.transform.height;
                        let R = l.sub(L)
                          , O = i.radToDeg(Math.atan2(R.y, R.x));
                        _ = (O > 90 ? O - 270 : O + 90) * (1 - T)
                    }
                    return _ += this._rotation,
                    _ ? `rotateZ(${_}deg)` : ""
                }
                _update(l) {
                    i.window.cancelAnimationFrame(this._updateFrameId);
                    let h = this._map;
                    h && (h.transform.renderWorldCopies && (this._lngLat = Wh(this._lngLat, this._pos, h.transform)),
                    this._pos = h.project(this._lngLat),
                    l === !0 ? this._updateFrameId = i.window.requestAnimationFrame(()=>{
                        this._element && this._pos && this._anchor && (this._pos = this._pos.round(),
                        this._updateDOM())
                    }
                    ) : this._pos = this._pos.round(),
                    h._requestDomTask(()=>{
                        this._map && (this._element && this._pos && this._anchor && this._updateDOM(),
                        (h._showingGlobe() || h.getTerrain() || h.getFog()) && !this._fadeTimer && (this._fadeTimer = setTimeout(this._evaluateOpacity.bind(this), 60)))
                    }
                    ))
                }
                getOffset() {
                    return this._offset
                }
                setOffset(l) {
                    return this._offset = i.pointGeometry.convert(l),
                    this._update(),
                    this
                }
                _onMove(l) {
                    let h = this._map;
                    if (!h)
                        return;
                    let _ = this._pointerdownPos
                      , b = this._positionDelta;
                    if (_ && b) {
                        if (!this._isDragging) {
                            let T = this._clickTolerance || h._clickTolerance;
                            if (l.point.dist(_) < T)
                                return;
                            this._isDragging = !0
                        }
                        this._pos = l.point.sub(b),
                        this._lngLat = h.unproject(this._pos),
                        this.setLngLat(this._lngLat),
                        this._element.style.pointerEvents = "none",
                        this._state === "pending" && (this._state = "active",
                        this.fire(new i.Event("dragstart"))),
                        this.fire(new i.Event("drag"))
                    }
                }
                _onUp() {
                    this._element.style.pointerEvents = "auto",
                    this._positionDelta = null,
                    this._pointerdownPos = null,
                    this._isDragging = !1;
                    let l = this._map;
                    l && (l.off("mousemove", this._onMove),
                    l.off("touchmove", this._onMove)),
                    this._state === "active" && this.fire(new i.Event("dragend")),
                    this._state = "inactive"
                }
                _addDragHandler(l) {
                    let h = this._map
                      , _ = this._pos;
                    h && _ && this._element.contains(l.originalEvent.target) && (l.preventDefault(),
                    this._positionDelta = l.point.sub(_),
                    this._pointerdownPos = l.point,
                    this._state = "pending",
                    h.on("mousemove", this._onMove),
                    h.on("touchmove", this._onMove),
                    h.once("mouseup", this._onUp),
                    h.once("touchend", this._onUp))
                }
                setDraggable(l) {
                    this._draggable = !!l;
                    let h = this._map;
                    return h && (l ? (h.on("mousedown", this._addDragHandler),
                    h.on("touchstart", this._addDragHandler)) : (h.off("mousedown", this._addDragHandler),
                    h.off("touchstart", this._addDragHandler))),
                    this
                }
                isDraggable() {
                    return this._draggable
                }
                setRotation(l) {
                    return this._rotation = l || 0,
                    this._update(),
                    this
                }
                getRotation() {
                    return this._rotation
                }
                setRotationAlignment(l) {
                    return this._rotationAlignment = l || "auto",
                    this._update(),
                    this
                }
                getRotationAlignment() {
                    return this._rotationAlignment === "auto" || this._rotationAlignment === "horizon" && this._map && !this._map._showingGlobe() ? "viewport" : this._rotationAlignment
                }
                setPitchAlignment(l) {
                    return this._pitchAlignment = l || "auto",
                    this._update(),
                    this
                }
                getPitchAlignment() {
                    return this._pitchAlignment === "auto" ? this.getRotationAlignment() : this._pitchAlignment
                }
                setOccludedOpacity(l) {
                    return this._occludedOpacity = l || .2,
                    this._update(),
                    this
                }
                getOccludedOpacity() {
                    return this._occludedOpacity
                }
            }
            let Yg = {
                closeButton: !0,
                closeOnClick: !0,
                focusAfterOpen: !0,
                className: "",
                maxWidth: "240px"
            }
              , Jg = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
            function ep(m=new i.pointGeometry(0,0), l="bottom") {
                if (typeof m == "number") {
                    let h = Math.round(Math.sqrt(.5 * Math.pow(m, 2)));
                    switch (l) {
                    case "top":
                        return new i.pointGeometry(0,m);
                    case "top-left":
                        return new i.pointGeometry(h,h);
                    case "top-right":
                        return new i.pointGeometry(-h,h);
                    case "bottom":
                        return new i.pointGeometry(0,-m);
                    case "bottom-left":
                        return new i.pointGeometry(h,-h);
                    case "bottom-right":
                        return new i.pointGeometry(-h,-h);
                    case "left":
                        return new i.pointGeometry(m,0);
                    case "right":
                        return new i.pointGeometry(-m,0)
                    }
                    return new i.pointGeometry(0,0)
                }
                return m instanceof i.pointGeometry || Array.isArray(m) ? i.pointGeometry.convert(m) : i.pointGeometry.convert(m[l] || [0, 0])
            }
            class $g {
                constructor(l) {
                    this.jumpTo(l)
                }
                getValue(l) {
                    if (l <= this._startTime)
                        return this._start;
                    if (l >= this._endTime)
                        return this._end;
                    let h = i.easeCubicInOut((l - this._startTime) / (this._endTime - this._startTime));
                    return this._start * (1 - h) + this._end * h
                }
                isEasing(l) {
                    return l >= this._startTime && l <= this._endTime
                }
                jumpTo(l) {
                    this._startTime = -1 / 0,
                    this._endTime = -1 / 0,
                    this._start = l,
                    this._end = l
                }
                easeTo(l, h, _) {
                    this._start = this.getValue(h),
                    this._end = l,
                    this._startTime = h,
                    this._endTime = h + _
                }
            }
            let Qg = {
                "AttributionControl.ToggleAttribution": "Toggle attribution",
                "AttributionControl.MapFeedback": "Map feedback",
                "FullscreenControl.Enter": "Enter fullscreen",
                "FullscreenControl.Exit": "Exit fullscreen",
                "GeolocateControl.FindMyLocation": "Find my location",
                "GeolocateControl.LocationNotAvailable": "Location not available",
                "LogoControl.Title": "Mapbox logo",
                "Map.Title": "Map",
                "NavigationControl.ResetBearing": "Reset bearing to north",
                "NavigationControl.ZoomIn": "Zoom in",
                "NavigationControl.ZoomOut": "Zoom out",
                "ScrollZoomBlocker.CtrlMessage": "Use ctrl + scroll to zoom the map",
                "ScrollZoomBlocker.CmdMessage": "Use ⌘ + scroll to zoom the map",
                "TouchPanBlocker.Message": "Use two fingers to move the map"
            }
              , e_ = {
                center: [0, 0],
                zoom: 0,
                bearing: 0,
                pitch: 0,
                minZoom: -2,
                maxZoom: 22,
                minPitch: 0,
                maxPitch: 85,
                interactive: !0,
                scrollZoom: !0,
                boxZoom: !0,
                dragRotate: !0,
                dragPan: !0,
                keyboard: !0,
                doubleClickZoom: !0,
                touchZoomRotate: !0,
                touchPitch: !0,
                cooperativeGestures: !1,
                performanceMetricsCollection: !0,
                bearingSnap: 7,
                clickTolerance: 3,
                pitchWithRotate: !0,
                hash: !1,
                attributionControl: !0,
                failIfMajorPerformanceCaveat: !1,
                preserveDrawingBuffer: !1,
                trackResize: !0,
                optimizeForTerrain: !0,
                renderWorldCopies: !0,
                refreshExpiredTiles: !0,
                minTileCacheSize: null,
                maxTileCacheSize: null,
                localIdeographFontFamily: "sans-serif",
                localFontFamily: null,
                transformRequest: null,
                accessToken: null,
                fadeDuration: 300,
                crossSourceCollisions: !0
            }
              , tp = {
                showCompass: !0,
                showZoom: !0,
                visualizePitch: !1
            };
            class t_ {
                constructor(l, h, _=!1) {
                    this._clickTolerance = 10,
                    this.element = h,
                    this.mouseRotate = new qf({
                        clickTolerance: l.dragRotate._mouseRotate._clickTolerance
                    }),
                    this.map = l,
                    _ && (this.mousePitch = new Kf({
                        clickTolerance: l.dragRotate._mousePitch._clickTolerance
                    })),
                    i.bindAll(["mousedown", "mousemove", "mouseup", "touchstart", "touchmove", "touchend", "reset"], this),
                    h.addEventListener("mousedown", this.mousedown),
                    h.addEventListener("touchstart", this.touchstart, {
                        passive: !1
                    }),
                    h.addEventListener("touchmove", this.touchmove),
                    h.addEventListener("touchend", this.touchend),
                    h.addEventListener("touchcancel", this.reset)
                }
                down(l, h) {
                    this.mouseRotate.mousedown(l, h),
                    this.mousePitch && this.mousePitch.mousedown(l, h),
                    U()
                }
                move(l, h) {
                    let _ = this.map
                      , b = this.mouseRotate.mousemoveWindow(l, h)
                      , T = b && b.bearingDelta;
                    if (T && _.setBearing(_.getBearing() + T),
                    this.mousePitch) {
                        let L = this.mousePitch.mousemoveWindow(l, h)
                          , R = L && L.pitchDelta;
                        R && _.setPitch(_.getPitch() + R)
                    }
                }
                off() {
                    let l = this.element;
                    l.removeEventListener("mousedown", this.mousedown),
                    l.removeEventListener("touchstart", this.touchstart, {
                        passive: !1
                    }),
                    l.removeEventListener("touchmove", this.touchmove),
                    l.removeEventListener("touchend", this.touchend),
                    l.removeEventListener("touchcancel", this.reset),
                    this.offTemp()
                }
                offTemp() {
                    Z(),
                    i.window.removeEventListener("mousemove", this.mousemove),
                    i.window.removeEventListener("mouseup", this.mouseup)
                }
                mousedown(l) {
                    this.down(i.extend({}, l, {
                        ctrlKey: !0,
                        preventDefault: ()=>l.preventDefault()
                    }), W(this.element, l)),
                    i.window.addEventListener("mousemove", this.mousemove),
                    i.window.addEventListener("mouseup", this.mouseup)
                }
                mousemove(l) {
                    this.move(l, W(this.element, l))
                }
                mouseup(l) {
                    this.mouseRotate.mouseupWindow(l),
                    this.mousePitch && this.mousePitch.mouseupWindow(l),
                    this.offTemp()
                }
                touchstart(l) {
                    l.targetTouches.length !== 1 ? this.reset() : (this._startPos = this._lastPos = fe(this.element, l.targetTouches)[0],
                    this.down({
                        type: "mousedown",
                        button: 0,
                        ctrlKey: !0,
                        preventDefault: ()=>l.preventDefault()
                    }, this._startPos))
                }
                touchmove(l) {
                    l.targetTouches.length !== 1 ? this.reset() : (this._lastPos = fe(this.element, l.targetTouches)[0],
                    this.move({
                        preventDefault: ()=>l.preventDefault()
                    }, this._lastPos))
                }
                touchend(l) {
                    l.targetTouches.length === 0 && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(),
                    this.reset()
                }
                reset() {
                    this.mouseRotate.reset(),
                    this.mousePitch && this.mousePitch.reset(),
                    delete this._startPos,
                    delete this._lastPos,
                    this.offTemp()
                }
            }
            let n_ = {
                positionOptions: {
                    enableHighAccuracy: !1,
                    maximumAge: 0,
                    timeout: 6e3
                },
                fitBoundsOptions: {
                    maxZoom: 15
                },
                trackUserLocation: !1,
                showAccuracyCircle: !0,
                showUserLocation: !0,
                showUserHeading: !1
            }
              , i_ = {
                maxWidth: 100,
                unit: "metric"
            };
            function r_(m, l, h) {
                let _ = Xh(l)
                  , b = _ / l
                  , T = {
                    kilometer: "km",
                    meter: "m",
                    mile: "mi",
                    foot: "ft",
                    "nautical-mile": "nm"
                }[h];
                this._map._requestDomTask(()=>{
                    this._container.style.width = m * b + "px",
                    this._container.innerHTML = `${_}&nbsp;${T}`
                }
                )
            }
            function Xh(m) {
                let l = Math.pow(10, `${Math.floor(m)}`.length - 1)
                  , h = m / l;
                return h = h >= 10 ? 10 : h >= 5 ? 5 : h >= 3 ? 3 : h >= 2 ? 2 : h >= 1 ? 1 : function(_) {
                    let b = Math.pow(10, Math.ceil(-Math.log(_) / Math.LN10));
                    return Math.round(_ * b) / b
                }(h),
                l * h
            }
            let ru = {
                version: i.version,
                supported: x,
                setRTLTextPlugin: i.setRTLTextPlugin,
                getRTLTextPluginStatus: i.getRTLTextPluginStatus,
                Map: class extends Kg {
                    constructor(m) {
                        if (i.LivePerformanceUtils.mark(i.PerformanceMarkers.create),
                        (m = i.extend({}, e_, m)).minZoom != null && m.maxZoom != null && m.minZoom > m.maxZoom)
                            throw new Error("maxZoom must be greater than or equal to minZoom");
                        if (m.minPitch != null && m.maxPitch != null && m.minPitch > m.maxPitch)
                            throw new Error("maxPitch must be greater than or equal to minPitch");
                        if (m.minPitch != null && m.minPitch < 0)
                            throw new Error("minPitch must be greater than or equal to 0");
                        if (m.maxPitch != null && m.maxPitch > 85)
                            throw new Error("maxPitch must be less than or equal to 85");
                        if (m.antialias && i.isSafariWithAntialiasingBug(i.window) && (m.antialias = !1,
                        i.warnOnce("Antialiasing is disabled for this WebGL context to avoid browser bug: https://github.com/mapbox/mapbox-gl-js/issues/11609")),
                        super(new rn(m.minZoom,m.maxZoom,m.minPitch,m.maxPitch,m.renderWorldCopies), m),
                        this._interactive = m.interactive,
                        this._minTileCacheSize = m.minTileCacheSize,
                        this._maxTileCacheSize = m.maxTileCacheSize,
                        this._failIfMajorPerformanceCaveat = m.failIfMajorPerformanceCaveat,
                        this._preserveDrawingBuffer = m.preserveDrawingBuffer,
                        this._antialias = m.antialias,
                        this._useWebGL2 = m.useWebGL2,
                        this._trackResize = m.trackResize,
                        this._bearingSnap = m.bearingSnap,
                        this._refreshExpiredTiles = m.refreshExpiredTiles,
                        this._fadeDuration = m.fadeDuration,
                        this._isInitialLoad = !0,
                        this._crossSourceCollisions = m.crossSourceCollisions,
                        this._collectResourceTiming = m.collectResourceTiming,
                        this._optimizeForTerrain = m.optimizeForTerrain,
                        this._language = this._parseLanguage(m.language),
                        this._worldview = m.worldview,
                        this._renderTaskQueue = new iu,
                        this._domRenderTaskQueue = new iu,
                        this._controls = [],
                        this._markers = [],
                        this._popups = [],
                        this._mapId = i.uniqueId(),
                        this._locale = i.extend({}, Qg, m.locale),
                        this._clickTolerance = m.clickTolerance,
                        this._cooperativeGestures = m.cooperativeGestures,
                        this._performanceMetricsCollection = m.performanceMetricsCollection,
                        this._containerWidth = 0,
                        this._containerHeight = 0,
                        this._averageElevationLastSampledAt = -1 / 0,
                        this._averageElevationExaggeration = 0,
                        this._averageElevation = new $g(0),
                        this._interactionRange = [1 / 0, -1 / 0],
                        this._visibilityHidden = 0,
                        this._useExplicitProjection = !1,
                        this._requestManager = new i.RequestManager(m.transformRequest,m.accessToken,m.testMode),
                        this._silenceAuthErrors = !!m.testMode,
                        typeof m.container == "string") {
                            if (this._container = i.window.document.getElementById(m.container),
                            !this._container)
                                throw new Error(`Container '${m.container}' not found.`)
                        } else {
                            if (!(m.container instanceof i.window.HTMLElement))
                                throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
                            this._container = m.container
                        }
                        if (this._container.childNodes.length > 0 && i.warnOnce("The map container element should be empty, otherwise the map's interactivity will be negatively impacted. If you want to display a message when WebGL is not supported, use the Mapbox GL Supported plugin instead."),
                        m.maxBounds && this.setMaxBounds(m.maxBounds),
                        i.bindAll(["_onWindowOnline", "_onWindowResize", "_onVisibilityChange", "_onMapScroll", "_contextLost", "_contextRestored"], this),
                        this._setupContainer(),
                        this._setupPainter(),
                        this.painter === void 0)
                            throw new Error("Failed to initialize WebGL.");
                        this.on("move", ()=>this._update(!1)),
                        this.on("moveend", ()=>this._update(!1)),
                        this.on("zoom", ()=>this._update(!0)),
                        i.window !== void 0 && (i.window.addEventListener("online", this._onWindowOnline, !1),
                        i.window.addEventListener("resize", this._onWindowResize, !1),
                        i.window.addEventListener("orientationchange", this._onWindowResize, !1),
                        i.window.addEventListener("webkitfullscreenchange", this._onWindowResize, !1),
                        i.window.addEventListener("visibilitychange", this._onVisibilityChange, !1)),
                        this.handlers = new qg(this,m),
                        this._localFontFamily = m.localFontFamily,
                        this._localIdeographFontFamily = m.localIdeographFontFamily,
                        m.style && this.setStyle(m.style, {
                            localFontFamily: this._localFontFamily,
                            localIdeographFontFamily: this._localIdeographFontFamily
                        }),
                        m.projection && this.setProjection(m.projection),
                        this._hash = m.hash && new zg(typeof m.hash == "string" && m.hash || void 0).addTo(this),
                        this._hash && this._hash._onHashChange() || (this.jumpTo({
                            center: m.center,
                            zoom: m.zoom,
                            bearing: m.bearing,
                            pitch: m.pitch
                        }),
                        m.bounds && (this.resize(),
                        this.fitBounds(m.bounds, i.extend({}, m.fitBoundsOptions, {
                            duration: 0
                        })))),
                        this.resize(),
                        m.attributionControl && this.addControl(new $f({
                            customAttribution: m.customAttribution
                        })),
                        this._logoControl = new Qf,
                        this.addControl(this._logoControl, m.logoPosition),
                        this.on("style.load", ()=>{
                            this.transform.unmodified && this.jumpTo(this.style.stylesheet)
                        }
                        ),
                        this.on("data", l=>{
                            this._update(l.dataType === "style"),
                            this.fire(new i.Event(`${l.dataType}data`,l))
                        }
                        ),
                        this.on("dataloading", l=>{
                            this.fire(new i.Event(`${l.dataType}dataloading`,l))
                        }
                        )
                    }
                    _getMapId() {
                        return this._mapId
                    }
                    addControl(m, l) {
                        if (l === void 0 && (l = m.getDefaultPosition ? m.getDefaultPosition() : "top-right"),
                        !m || !m.onAdd)
                            return this.fire(new i.ErrorEvent(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
                        let h = m.onAdd(this);
                        this._controls.push(m);
                        let _ = this._controlPositions[l];
                        return l.indexOf("bottom") !== -1 ? _.insertBefore(h, _.firstChild) : _.appendChild(h),
                        this
                    }
                    removeControl(m) {
                        if (!m || !m.onRemove)
                            return this.fire(new i.ErrorEvent(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
                        let l = this._controls.indexOf(m);
                        return l > -1 && this._controls.splice(l, 1),
                        m.onRemove(this),
                        this
                    }
                    hasControl(m) {
                        return this._controls.indexOf(m) > -1
                    }
                    getContainer() {
                        return this._container
                    }
                    getCanvasContainer() {
                        return this._canvasContainer
                    }
                    getCanvas() {
                        return this._canvas
                    }
                    resize(m) {
                        if (this._updateContainerDimensions(),
                        this._containerWidth === this.transform.width && this._containerHeight === this.transform.height)
                            return this;
                        this._resizeCanvas(this._containerWidth, this._containerHeight),
                        this.transform.resize(this._containerWidth, this._containerHeight),
                        this.painter.resize(Math.ceil(this._containerWidth), Math.ceil(this._containerHeight));
                        let l = !this._moving;
                        return l && this.fire(new i.Event("movestart",m)).fire(new i.Event("move",m)),
                        this.fire(new i.Event("resize",m)),
                        l && this.fire(new i.Event("moveend",m)),
                        this
                    }
                    getBounds() {
                        return this.transform.getBounds()
                    }
                    getMaxBounds() {
                        return this.transform.getMaxBounds() || null
                    }
                    setMaxBounds(m) {
                        return this.transform.setMaxBounds(i.LngLatBounds.convert(m)),
                        this._update()
                    }
                    setMinZoom(m) {
                        if ((m = m ?? -2) >= -2 && m <= this.transform.maxZoom)
                            return this.transform.minZoom = m,
                            this._update(),
                            this.getZoom() < m ? this.setZoom(m) : this.fire(new i.Event("zoomstart")).fire(new i.Event("zoom")).fire(new i.Event("zoomend")),
                            this;
                        throw new Error("minZoom must be between -2 and the current maxZoom, inclusive")
                    }
                    getMinZoom() {
                        return this.transform.minZoom
                    }
                    setMaxZoom(m) {
                        if ((m = m ?? 22) >= this.transform.minZoom)
                            return this.transform.maxZoom = m,
                            this._update(),
                            this.getZoom() > m ? this.setZoom(m) : this.fire(new i.Event("zoomstart")).fire(new i.Event("zoom")).fire(new i.Event("zoomend")),
                            this;
                        throw new Error("maxZoom must be greater than the current minZoom")
                    }
                    getMaxZoom() {
                        return this.transform.maxZoom
                    }
                    setMinPitch(m) {
                        if ((m = m ?? 0) < 0)
                            throw new Error("minPitch must be greater than or equal to 0");
                        if (m >= 0 && m <= this.transform.maxPitch)
                            return this.transform.minPitch = m,
                            this._update(),
                            this.getPitch() < m ? this.setPitch(m) : this.fire(new i.Event("pitchstart")).fire(new i.Event("pitch")).fire(new i.Event("pitchend")),
                            this;
                        throw new Error("minPitch must be between 0 and the current maxPitch, inclusive")
                    }
                    getMinPitch() {
                        return this.transform.minPitch
                    }
                    setMaxPitch(m) {
                        if ((m = m ?? 85) > 85)
                            throw new Error("maxPitch must be less than or equal to 85");
                        if (m >= this.transform.minPitch)
                            return this.transform.maxPitch = m,
                            this._update(),
                            this.getPitch() > m ? this.setPitch(m) : this.fire(new i.Event("pitchstart")).fire(new i.Event("pitch")).fire(new i.Event("pitchend")),
                            this;
                        throw new Error("maxPitch must be greater than or equal to minPitch")
                    }
                    getMaxPitch() {
                        return this.transform.maxPitch
                    }
                    getRenderWorldCopies() {
                        return this.transform.renderWorldCopies
                    }
                    setRenderWorldCopies(m) {
                        return this.transform.renderWorldCopies = m,
                        this.transform.renderWorldCopies || this._forceMarkerAndPopupUpdate(!0),
                        this._update()
                    }
                    getLanguage() {
                        return this._language
                    }
                    _parseLanguage(m) {
                        return m === "auto" ? i.window.navigator.language : Array.isArray(m) ? m.length === 0 ? void 0 : m.map(l=>l === "auto" ? i.window.navigator.language : l) : m
                    }
                    setLanguage(m) {
                        let l = this._parseLanguage(m);
                        if (!this.style || l === this._language)
                            return this;
                        this._language = l,
                        this.style._reloadSources();
                        for (let h of this._controls)
                            h._setLanguage && h._setLanguage(this._language);
                        return this
                    }
                    getWorldview() {
                        return this._worldview
                    }
                    setWorldview(m) {
                        return this.style && m !== this._worldview ? (this._worldview = m,
                        this.style._reloadSources(),
                        this) : this
                    }
                    getProjection() {
                        return this.transform.mercatorFromTransition ? {
                            name: "globe",
                            center: [0, 0]
                        } : this.transform.getProjection()
                    }
                    _showingGlobe() {
                        return this.transform.projection.name === "globe"
                    }
                    setProjection(m) {
                        return this._lazyInitEmptyStyle(),
                        m ? typeof m == "string" && (m = {
                            name: m
                        }) : m = null,
                        this._useExplicitProjection = !!m,
                        this._prioritizeAndUpdateProjection(m, this.style.stylesheet ? this.style.stylesheet.projection : null)
                    }
                    _updateProjectionTransition() {
                        if (this.getProjection().name !== "globe")
                            return;
                        let m = this.transform, l = m.projection.name, h;
                        l === "globe" && m.zoom >= i.GLOBE_ZOOM_THRESHOLD_MAX ? (m.setMercatorFromTransition(),
                        h = !0) : l === "mercator" && m.zoom < i.GLOBE_ZOOM_THRESHOLD_MAX && (m.setProjection({
                            name: "globe"
                        }),
                        h = !0),
                        h && (this.style.applyProjectionUpdate(),
                        this.style._forceSymbolLayerUpdate())
                    }
                    _prioritizeAndUpdateProjection(m, l) {
                        return this._updateProjection(m || l || {
                            name: "mercator"
                        })
                    }
                    _updateProjection(m) {
                        let l;
                        if (l = m.name === "globe" && this.transform.zoom >= i.GLOBE_ZOOM_THRESHOLD_MAX ? this.transform.setMercatorFromTransition() : this.transform.setProjection(m),
                        this.style.applyProjectionUpdate(),
                        l) {
                            this.painter.clearBackgroundTiles();
                            for (let h in this.style._sourceCaches)
                                this.style._sourceCaches[h].clearTiles();
                            this._update(!0),
                            this._forceMarkerAndPopupUpdate(!0)
                        }
                        return this
                    }
                    project(m) {
                        return this.transform.locationPoint3D(i.LngLat.convert(m))
                    }
                    unproject(m) {
                        return this.transform.pointLocation3D(i.pointGeometry.convert(m))
                    }
                    isMoving() {
                        return this._moving || this.handlers && this.handlers.isMoving() || !1
                    }
                    isZooming() {
                        return this._zooming || this.handlers && this.handlers.isZooming() || !1
                    }
                    isRotating() {
                        return this._rotating || this.handlers && this.handlers.isRotating() || !1
                    }
                    _isDragging() {
                        return this.handlers && this.handlers._isDragging() || !1
                    }
                    _createDelegatedListener(m, l, h) {
                        if (m === "mouseenter" || m === "mouseover") {
                            let _ = !1
                              , b = L=>{
                                let R = l.filter(V=>this.getLayer(V))
                                  , O = R.length ? this.queryRenderedFeatures(L.point, {
                                    layers: R
                                }) : [];
                                O.length ? _ || (_ = !0,
                                h.call(this, new Er(m,this,L.originalEvent,{
                                    features: O
                                }))) : _ = !1
                            }
                              , T = ()=>{
                                _ = !1
                            }
                            ;
                            return {
                                layers: new Set(l),
                                listener: h,
                                delegates: {
                                    mousemove: b,
                                    mouseout: T
                                }
                            }
                        }
                        if (m === "mouseleave" || m === "mouseout") {
                            let _ = !1
                              , b = L=>{
                                let R = l.filter(O=>this.getLayer(O));
                                (R.length ? this.queryRenderedFeatures(L.point, {
                                    layers: R
                                }) : []).length ? _ = !0 : _ && (_ = !1,
                                h.call(this, new Er(m,this,L.originalEvent)))
                            }
                              , T = L=>{
                                _ && (_ = !1,
                                h.call(this, new Er(m,this,L.originalEvent)))
                            }
                            ;
                            return {
                                layers: new Set(l),
                                listener: h,
                                delegates: {
                                    mousemove: b,
                                    mouseout: T
                                }
                            }
                        }
                        {
                            let _ = b=>{
                                let T = l.filter(R=>this.getLayer(R))
                                  , L = T.length ? this.queryRenderedFeatures(b.point, {
                                    layers: T
                                }) : [];
                                L.length && (b.features = L,
                                h.call(this, b),
                                delete b.features)
                            }
                            ;
                            return {
                                layers: new Set(l),
                                listener: h,
                                delegates: {
                                    [m]: _
                                }
                            }
                        }
                    }
                    on(m, l, h) {
                        if (h === void 0)
                            return super.on(m, l);
                        Array.isArray(l) || (l = [l]);
                        let _ = this._createDelegatedListener(m, l, h);
                        this._delegatedListeners = this._delegatedListeners || {},
                        this._delegatedListeners[m] = this._delegatedListeners[m] || [],
                        this._delegatedListeners[m].push(_);
                        for (let b in _.delegates)
                            this.on(b, _.delegates[b]);
                        return this
                    }
                    once(m, l, h) {
                        if (h === void 0)
                            return super.once(m, l);
                        Array.isArray(l) || (l = [l]);
                        let _ = this._createDelegatedListener(m, l, h);
                        for (let b in _.delegates)
                            this.once(b, _.delegates[b]);
                        return this
                    }
                    off(m, l, h) {
                        if (h === void 0)
                            return super.off(m, l);
                        l = new Set(Array.isArray(l) ? l : [l]);
                        let _ = (T,L)=>{
                            if (T.size !== L.size)
                                return !1;
                            for (let R of T)
                                if (!L.has(R))
                                    return !1;
                            return !0
                        }
                          , b = this._delegatedListeners ? this._delegatedListeners[m] : void 0;
                        return b && (T=>{
                            for (let L = 0; L < T.length; L++) {
                                let R = T[L];
                                if (R.listener === h && _(R.layers, l)) {
                                    for (let O in R.delegates)
                                        this.off(O, R.delegates[O]);
                                    return T.splice(L, 1),
                                    this
                                }
                            }
                        }
                        )(b),
                        this
                    }
                    queryRenderedFeatures(m, l) {
                        return this.style ? (l !== void 0 || m === void 0 || m instanceof i.pointGeometry || Array.isArray(m) || (l = m,
                        m = void 0),
                        this.style.queryRenderedFeatures(m = m || [[0, 0], [this.transform.width, this.transform.height]], l = l || {}, this.transform)) : []
                    }
                    querySourceFeatures(m, l) {
                        return this.style.querySourceFeatures(m, l)
                    }
                    setStyle(m, l) {
                        return (l = i.extend({}, {
                            localIdeographFontFamily: this._localIdeographFontFamily,
                            localFontFamily: this._localFontFamily
                        }, l)).diff !== !1 && l.localIdeographFontFamily === this._localIdeographFontFamily && l.localFontFamily === this._localFontFamily && this.style && m ? (this._diffStyle(m, l),
                        this) : (this._localIdeographFontFamily = l.localIdeographFontFamily,
                        this._localFontFamily = l.localFontFamily,
                        this._updateStyle(m, l))
                    }
                    _getUIString(m) {
                        let l = this._locale[m];
                        if (l == null)
                            throw new Error(`Missing UI string '${m}'`);
                        return l
                    }
                    _updateStyle(m, l) {
                        return this.style && (this.style.setEventedParent(null),
                        this.style._remove(),
                        this.style = void 0),
                        m && (this.style = new ks(this,l || {}),
                        this.style.setEventedParent(this, {
                            style: this.style
                        }),
                        typeof m == "string" ? this.style.loadURL(m) : this.style.loadJSON(m)),
                        this._updateTerrain(),
                        this
                    }
                    _lazyInitEmptyStyle() {
                        this.style || (this.style = new ks(this,{}),
                        this.style.setEventedParent(this, {
                            style: this.style
                        }),
                        this.style.loadEmpty())
                    }
                    _diffStyle(m, l) {
                        if (typeof m == "string") {
                            let h = this._requestManager.normalizeStyleURL(m)
                              , _ = this._requestManager.transformRequest(h, i.ResourceType.Style);
                            i.getJSON(_, (b,T)=>{
                                b ? this.fire(new i.ErrorEvent(b)) : T && this._updateDiff(T, l)
                            }
                            )
                        } else
                            typeof m == "object" && this._updateDiff(m, l)
                    }
                    _updateDiff(m, l) {
                        try {
                            this.style.setState(m) && this._update(!0)
                        } catch (h) {
                            i.warnOnce(`Unable to perform style diff: ${h.message || h.error || h}.  Rebuilding the style from scratch.`),
                            this._updateStyle(m, l)
                        }
                    }
                    getStyle() {
                        if (this.style)
                            return this.style.serialize()
                    }
                    isStyleLoaded() {
                        return this.style ? this.style.loaded() : (i.warnOnce("There is no style added to the map."),
                        !1)
                    }
                    addSource(m, l) {
                        return this._lazyInitEmptyStyle(),
                        this.style.addSource(m, l),
                        this._update(!0)
                    }
                    isSourceLoaded(m) {
                        return !!this.style && this.style._isSourceCacheLoaded(m)
                    }
                    areTilesLoaded() {
                        let m = this.style && this.style._sourceCaches;
                        for (let l in m) {
                            let h = m[l]._tiles;
                            for (let _ in h) {
                                let b = h[_];
                                if (b.state !== "loaded" && b.state !== "errored")
                                    return !1
                            }
                        }
                        return !0
                    }
                    addSourceType(m, l, h) {
                        this._lazyInitEmptyStyle(),
                        this.style.addSourceType(m, l, h)
                    }
                    removeSource(m) {
                        return this.style.removeSource(m),
                        this._updateTerrain(),
                        this._update(!0)
                    }
                    getSource(m) {
                        return this.style.getSource(m)
                    }
                    addImage(m, l, {pixelRatio: h=1, sdf: _=!1, stretchX: b, stretchY: T, content: L}={}) {
                        if (this._lazyInitEmptyStyle(),
                        l instanceof i.window.HTMLImageElement || i.window.ImageBitmap && l instanceof i.window.ImageBitmap) {
                            let {width: R, height: O, data: V} = i.exported.getImageData(l);
                            this.style.addImage(m, {
                                data: new i.RGBAImage({
                                    width: R,
                                    height: O
                                },V),
                                pixelRatio: h,
                                stretchX: b,
                                stretchY: T,
                                content: L,
                                sdf: _,
                                version: 0
                            })
                        } else if (l.width === void 0 || l.height === void 0)
                            this.fire(new i.ErrorEvent(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
                        else {
                            let {width: R, height: O} = l
                              , V = l;
                            this.style.addImage(m, {
                                data: new i.RGBAImage({
                                    width: R,
                                    height: O
                                },new Uint8Array(V.data)),
                                pixelRatio: h,
                                stretchX: b,
                                stretchY: T,
                                content: L,
                                sdf: _,
                                version: 0,
                                userImage: V
                            }),
                            V.onAdd && V.onAdd(this, m)
                        }
                    }
                    updateImage(m, l) {
                        let h = this.style.getImage(m);
                        if (!h)
                            return void this.fire(new i.ErrorEvent(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
                        let _ = l instanceof i.window.HTMLImageElement || i.window.ImageBitmap && l instanceof i.window.ImageBitmap ? i.exported.getImageData(l) : l
                          , {width: b, height: T} = _;
                        b !== void 0 && T !== void 0 ? b === h.data.width && T === h.data.height ? (h.data.replace(_.data, !(l instanceof i.window.HTMLImageElement || i.window.ImageBitmap && l instanceof i.window.ImageBitmap)),
                        this.style.updateImage(m, h)) : this.fire(new i.ErrorEvent(new Error(`The width and height of the updated image (${b}, ${T})
                must be that same as the previous version of the image
                (${h.data.width}, ${h.data.height})`))) : this.fire(new i.ErrorEvent(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")))
                    }
                    hasImage(m) {
                        return m ? !!this.style.getImage(m) : (this.fire(new i.ErrorEvent(new Error("Missing required image id"))),
                        !1)
                    }
                    removeImage(m) {
                        this.style.removeImage(m)
                    }
                    loadImage(m, l) {
                        i.getImage(this._requestManager.transformRequest(m, i.ResourceType.Image), (h,_)=>{
                            l(h, _ instanceof i.window.HTMLImageElement ? i.exported.getImageData(_) : _)
                        }
                        )
                    }
                    listImages() {
                        return this.style.listImages()
                    }
                    addLayer(m, l) {
                        return this._lazyInitEmptyStyle(),
                        this.style.addLayer(m, l),
                        this._update(!0)
                    }
                    moveLayer(m, l) {
                        return this.style.moveLayer(m, l),
                        this._update(!0)
                    }
                    removeLayer(m) {
                        return this.style.removeLayer(m),
                        this._update(!0)
                    }
                    getLayer(m) {
                        return this.style.getLayer(m)
                    }
                    setLayerZoomRange(m, l, h) {
                        return this.style.setLayerZoomRange(m, l, h),
                        this._update(!0)
                    }
                    setFilter(m, l, h={}) {
                        return this.style.setFilter(m, l, h),
                        this._update(!0)
                    }
                    getFilter(m) {
                        return this.style.getFilter(m)
                    }
                    setPaintProperty(m, l, h, _={}) {
                        return this.style.setPaintProperty(m, l, h, _),
                        this._update(!0)
                    }
                    getPaintProperty(m, l) {
                        return this.style.getPaintProperty(m, l)
                    }
                    setLayoutProperty(m, l, h, _={}) {
                        return this.style.setLayoutProperty(m, l, h, _),
                        this._update(!0)
                    }
                    getLayoutProperty(m, l) {
                        return this.style.getLayoutProperty(m, l)
                    }
                    setLight(m, l={}) {
                        return this._lazyInitEmptyStyle(),
                        this.style.setLight(m, l),
                        this._update(!0)
                    }
                    getLight() {
                        return this.style.getLight()
                    }
                    setTerrain(m) {
                        return this._lazyInitEmptyStyle(),
                        !m && this.transform.projection.requiresDraping ? this.style.setTerrainForDraping() : this.style.setTerrain(m),
                        this._averageElevationLastSampledAt = -1 / 0,
                        this._update(!0)
                    }
                    getTerrain() {
                        return this.style ? this.style.getTerrain() : null
                    }
                    setFog(m) {
                        return this._lazyInitEmptyStyle(),
                        this.style.setFog(m),
                        this._update(!0)
                    }
                    getFog() {
                        return this.style ? this.style.getFog() : null
                    }
                    _queryFogOpacity(m) {
                        return this.style && this.style.fog ? this.style.fog.getOpacityAtLatLng(i.LngLat.convert(m), this.transform) : 0
                    }
                    setFeatureState(m, l) {
                        return this.style.setFeatureState(m, l),
                        this._update()
                    }
                    removeFeatureState(m, l) {
                        return this.style.removeFeatureState(m, l),
                        this._update()
                    }
                    getFeatureState(m) {
                        return this.style.getFeatureState(m)
                    }
                    _updateContainerDimensions() {
                        if (!this._container)
                            return;
                        let m = this._container.getBoundingClientRect().width || 400, l = this._container.getBoundingClientRect().height || 300, h, _, b, T = this._container;
                        for (; T && (!_ || !b); ) {
                            let L = i.window.getComputedStyle(T).transform;
                            L && L !== "none" && (h = L.match(/matrix.*\((.+)\)/)[1].split(", "),
                            h[0] && h[0] !== "0" && h[0] !== "1" && (_ = h[0]),
                            h[3] && h[3] !== "0" && h[3] !== "1" && (b = h[3])),
                            T = T.parentElement
                        }
                        this._containerWidth = _ ? Math.abs(m / _) : m,
                        this._containerHeight = b ? Math.abs(l / b) : l
                    }
                    _detectMissingCSS() {
                        i.window.getComputedStyle(this._missingCSSCanary).getPropertyValue("background-color") !== "rgb(250, 128, 114)" && i.warnOnce("This page appears to be missing CSS declarations for Mapbox GL JS, which may cause the map to display incorrectly. Please ensure your page includes mapbox-gl.css, as described in https://www.mapbox.com/mapbox-gl-js/api/.")
                    }
                    _setupContainer() {
                        let m = this._container;
                        m.classList.add("mapboxgl-map"),
                        (this._missingCSSCanary = C("div", "mapboxgl-canary", m)).style.visibility = "hidden",
                        this._detectMissingCSS();
                        let l = this._canvasContainer = C("div", "mapboxgl-canvas-container", m);
                        this._interactive && l.classList.add("mapboxgl-interactive"),
                        this._canvas = C("canvas", "mapboxgl-canvas", l),
                        this._canvas.addEventListener("webglcontextlost", this._contextLost, !1),
                        this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1),
                        this._canvas.setAttribute("tabindex", "0"),
                        this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")),
                        this._canvas.setAttribute("role", "region"),
                        this._updateContainerDimensions(),
                        this._resizeCanvas(this._containerWidth, this._containerHeight);
                        let h = this._controlContainer = C("div", "mapboxgl-control-container", m)
                          , _ = this._controlPositions = {};
                        ["top-left", "top-right", "bottom-left", "bottom-right"].forEach(b=>{
                            _[b] = C("div", `mapboxgl-ctrl-${b}`, h)
                        }
                        ),
                        this._container.addEventListener("scroll", this._onMapScroll, !1)
                    }
                    _resizeCanvas(m, l) {
                        let h = i.exported.devicePixelRatio || 1;
                        this._canvas.width = h * Math.ceil(m),
                        this._canvas.height = h * Math.ceil(l),
                        this._canvas.style.width = `${m}px`,
                        this._canvas.style.height = `${l}px`
                    }
                    _addMarker(m) {
                        this._markers.push(m)
                    }
                    _removeMarker(m) {
                        let l = this._markers.indexOf(m);
                        l !== -1 && this._markers.splice(l, 1)
                    }
                    _addPopup(m) {
                        this._popups.push(m)
                    }
                    _removePopup(m) {
                        let l = this._popups.indexOf(m);
                        l !== -1 && this._popups.splice(l, 1)
                    }
                    _setupPainter() {
                        let m = i.extend({}, x.webGLContextAttributes, {
                            failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat,
                            preserveDrawingBuffer: this._preserveDrawingBuffer,
                            antialias: this._antialias || !1
                        })
                          , l = this._useWebGL2 && this._canvas.getContext("webgl2", m)
                          , h = l || this._canvas.getContext("webgl", m) || this._canvas.getContext("experimental-webgl", m);
                        h ? (this._useWebGL2 && !l && i.warnOnce("Failed to create WebGL 2 context. Using WebGL 1."),
                        i.storeAuthState(h, !0),
                        this.painter = new Xc(h,this.transform,!!l),
                        this.on("data", _=>{
                            _.dataType === "source" && this.painter.setTileLoadedFlag(!0)
                        }
                        ),
                        i.exported$1.testSupport(h)) : this.fire(new i.ErrorEvent(new Error("Failed to initialize WebGL")))
                    }
                    _contextLost(m) {
                        m.preventDefault(),
                        this._frame && (this._frame.cancel(),
                        this._frame = null),
                        this.fire(new i.Event("webglcontextlost",{
                            originalEvent: m
                        }))
                    }
                    _contextRestored(m) {
                        this._setupPainter(),
                        this.resize(),
                        this._update(),
                        this.fire(new i.Event("webglcontextrestored",{
                            originalEvent: m
                        }))
                    }
                    _onMapScroll(m) {
                        if (m.target === this._container)
                            return this._container.scrollTop = 0,
                            this._container.scrollLeft = 0,
                            !1
                    }
                    loaded() {
                        return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded()
                    }
                    _update(m) {
                        return this.style ? (this._styleDirty = this._styleDirty || m,
                        this._sourcesDirty = !0,
                        this.triggerRepaint(),
                        this) : this
                    }
                    _requestRenderFrame(m) {
                        return this._update(),
                        this._renderTaskQueue.add(m)
                    }
                    _cancelRenderFrame(m) {
                        this._renderTaskQueue.remove(m)
                    }
                    _requestDomTask(m) {
                        !this.loaded() || this.loaded() && !this.isMoving() ? m() : this._domRenderTaskQueue.add(m)
                    }
                    _render(m) {
                        let l, h = this.painter.context.extTimerQuery, _ = i.exported.now();
                        if (this.listens("gpu-timing-frame") && (l = h.createQueryEXT(),
                        h.beginQueryEXT(h.TIME_ELAPSED_EXT, l)),
                        this.painter.context.setDirty(),
                        this.painter.setBaseState(),
                        (this.isMoving() || this.isRotating() || this.isZooming()) && (this._interactionRange[0] = Math.min(this._interactionRange[0], i.window.performance.now()),
                        this._interactionRange[1] = Math.max(this._interactionRange[1], i.window.performance.now())),
                        this._renderTaskQueue.run(m),
                        this._domRenderTaskQueue.run(m),
                        this._removed)
                            return;
                        this._updateProjectionTransition();
                        let b = this._isInitialLoad ? 0 : this._fadeDuration;
                        if (this.style && this._styleDirty) {
                            this._styleDirty = !1;
                            let R = this.transform.zoom
                              , O = this.transform.pitch
                              , V = i.exported.now()
                              , G = new i.EvaluationParameters(R,{
                                now: V,
                                fadeDuration: b,
                                pitch: O,
                                transition: this.style.getTransition()
                            });
                            this.style.update(G)
                        }
                        this.style && this.style.fog && this.style.fog.hasTransition() && (this.style._markersNeedUpdate = !0,
                        this._sourcesDirty = !0);
                        let T = !1;
                        if (this.style && this._sourcesDirty ? (this._sourcesDirty = !1,
                        this.painter._updateFog(this.style),
                        this._updateTerrain(),
                        T = this._updateAverageElevation(_),
                        this.style._updateSources(this.transform),
                        this._forceMarkerAndPopupUpdate()) : T = this._updateAverageElevation(_),
                        this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, b, this._crossSourceCollisions),
                        this.style && this.painter.render(this.style, {
                            showTileBoundaries: this.showTileBoundaries,
                            showTerrainWireframe: this.showTerrainWireframe,
                            showOverdrawInspector: this._showOverdrawInspector,
                            showQueryGeometry: !!this._showQueryGeometry,
                            showTileAABBs: this.showTileAABBs,
                            rotating: this.isRotating(),
                            zooming: this.isZooming(),
                            moving: this.isMoving(),
                            fadeDuration: b,
                            isInitialLoad: this._isInitialLoad,
                            showPadding: this.showPadding,
                            gpuTiming: !!this.listens("gpu-timing-layer"),
                            gpuTimingDeferredRender: !!this.listens("gpu-timing-deferred-render"),
                            speedIndexTiming: this.speedIndexTiming
                        }),
                        this.fire(new i.Event("render")),
                        this.loaded() && !this._loaded && (this._loaded = !0,
                        this.fire(new i.Event("load"))),
                        this.style && this.style.hasTransitions() && (this._styleDirty = !0),
                        this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles(),
                        l) {
                            let R = i.exported.now() - _;
                            h.endQueryEXT(h.TIME_ELAPSED_EXT, l),
                            setTimeout(()=>{
                                let O = h.getQueryObjectEXT(l, h.QUERY_RESULT_EXT) / 1e6;
                                h.deleteQueryEXT(l),
                                this.fire(new i.Event("gpu-timing-frame",{
                                    cpuTime: R,
                                    gpuTime: O
                                })),
                                i.window.performance.mark("frame-gpu", {
                                    startTime: _,
                                    detail: {
                                        gpuTime: O
                                    }
                                })
                            }
                            , 50)
                        }
                        if (this.listens("gpu-timing-layer")) {
                            let R = this.painter.collectGpuTimers();
                            setTimeout(()=>{
                                let O = this.painter.queryGpuTimers(R);
                                this.fire(new i.Event("gpu-timing-layer",{
                                    layerTimes: O
                                }))
                            }
                            , 50)
                        }
                        if (this.listens("gpu-timing-deferred-render")) {
                            let R = this.painter.collectDeferredRenderGpuQueries();
                            setTimeout(()=>{
                                let O = this.painter.queryGpuTimeDeferredRender(R);
                                this.fire(new i.Event("gpu-timing-deferred-render",{
                                    gpuTime: O
                                }))
                            }
                            , 50)
                        }
                        let L = this._sourcesDirty || this._styleDirty || this._placementDirty || T;
                        if (L || this._repaint)
                            this.triggerRepaint();
                        else {
                            let R = !this.isMoving() && this.loaded();
                            if (R && (T = this._updateAverageElevation(_, !0)),
                            T)
                                this.triggerRepaint();
                            else if (this._triggerFrame(!1),
                            R && (this.fire(new i.Event("idle")),
                            this._isInitialLoad = !1,
                            this.speedIndexTiming)) {
                                let O = this._calculateSpeedIndex();
                                this.fire(new i.Event("speedindexcompleted",{
                                    speedIndex: O
                                })),
                                this.speedIndexTiming = !1
                            }
                        }
                        !this._loaded || this._fullyLoaded || L || (this._fullyLoaded = !0,
                        i.LivePerformanceUtils.mark(i.PerformanceMarkers.fullLoad),
                        this._performanceMetricsCollection && i.postPerformanceEvent(this._requestManager._customAccessToken, {
                            width: this.painter.width,
                            height: this.painter.height,
                            interactionRange: this._interactionRange,
                            visibilityHidden: this._visibilityHidden,
                            terrainEnabled: !!this.painter.style.getTerrain(),
                            fogEnabled: !!this.painter.style.getFog(),
                            projection: this.getProjection().name,
                            zoom: this.transform.zoom,
                            renderer: this.painter.context.renderer,
                            vendor: this.painter.context.vendor
                        }),
                        this._authenticate())
                    }
                    _forceMarkerAndPopupUpdate(m) {
                        for (let l of this._markers)
                            m && !this.getRenderWorldCopies() && (l._lngLat = l._lngLat.wrap()),
                            l._update();
                        for (let l of this._popups)
                            !m || this.getRenderWorldCopies() || l._trackPointer || (l._lngLat = l._lngLat.wrap()),
                            l._update()
                    }
                    _updateAverageElevation(m, l=!1) {
                        let h = _=>(this.transform.averageElevation = _,
                        this._update(!1),
                        !0);
                        if (!this.painter.averageElevationNeedsEasing())
                            return this.transform.averageElevation !== 0 && h(0);
                        if ((l || m - this._averageElevationLastSampledAt > 500) && !this._averageElevation.isEasing(m)) {
                            let _ = this.transform.averageElevation
                              , b = this.transform.sampleAverageElevation()
                              , T = !1;
                            this.transform.elevation && (T = this.transform.elevation.exaggeration() !== this._averageElevationExaggeration,
                            this._averageElevationExaggeration = this.transform.elevation.exaggeration()),
                            isNaN(b) ? b = 0 : this._averageElevationLastSampledAt = m;
                            let L = Math.abs(_ - b);
                            if (L > 1) {
                                if (this._isInitialLoad || T)
                                    return this._averageElevation.jumpTo(b),
                                    h(b);
                                this._averageElevation.easeTo(b, m, 300)
                            } else if (L > 1e-4)
                                return this._averageElevation.jumpTo(b),
                                h(b)
                        }
                        return !!this._averageElevation.isEasing(m) && h(this._averageElevation.getValue(m))
                    }
                    _authenticate() {
                        i.getMapSessionAPI(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, m=>{
                            if (m && (m.message === i.AUTH_ERR_MSG || m.status === 401)) {
                                let l = this.painter.context.gl;
                                i.storeAuthState(l, !1),
                                this._logoControl instanceof Qf && this._logoControl._updateLogo(),
                                l && l.clear(l.DEPTH_BUFFER_BIT | l.COLOR_BUFFER_BIT | l.STENCIL_BUFFER_BIT),
                                this._silenceAuthErrors || this.fire(new i.ErrorEvent(new Error("A valid Mapbox access token is required to use Mapbox GL JS. To create an account or a new access token, visit https://account.mapbox.com/")))
                            }
                        }
                        ),
                        i.postMapLoadEvent(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, ()=>{}
                        )
                    }
                    _updateTerrain() {
                        let m = this._isDragging();
                        this.painter.updateTerrain(this.style, m)
                    }
                    _calculateSpeedIndex() {
                        let m = this.painter.canvasCopy()
                          , l = this.painter.getCanvasCopiesAndTimestamps();
                        l.timeStamps.push(performance.now());
                        let h = this.painter.context.gl
                          , _ = h.createFramebuffer();
                        function b(T) {
                            h.framebufferTexture2D(h.FRAMEBUFFER, h.COLOR_ATTACHMENT0, h.TEXTURE_2D, T, 0);
                            let L = new Uint8Array(h.drawingBufferWidth * h.drawingBufferHeight * 4);
                            return h.readPixels(0, 0, h.drawingBufferWidth, h.drawingBufferHeight, h.RGBA, h.UNSIGNED_BYTE, L),
                            L
                        }
                        return h.bindFramebuffer(h.FRAMEBUFFER, _),
                        this._canvasPixelComparison(b(m), l.canvasCopies.map(b), l.timeStamps)
                    }
                    _canvasPixelComparison(m, l, h) {
                        let _ = h[1] - h[0]
                          , b = m.length / 4;
                        for (let T = 0; T < l.length; T++) {
                            let L = l[T]
                              , R = 0;
                            for (let O = 0; O < L.length; O += 4)
                                L[O] === m[O] && L[O + 1] === m[O + 1] && L[O + 2] === m[O + 2] && L[O + 3] === m[O + 3] && (R += 1);
                            _ += (h[T + 2] - h[T + 1]) * (1 - R / b)
                        }
                        return _
                    }
                    remove() {
                        this._hash && this._hash.remove();
                        for (let l of this._controls)
                            l.onRemove(this);
                        this._controls = [],
                        this._frame && (this._frame.cancel(),
                        this._frame = null),
                        this._renderTaskQueue.clear(),
                        this._domRenderTaskQueue.clear(),
                        this.style && this.style.destroy(),
                        this.painter.destroy(),
                        this.handlers && this.handlers.destroy(),
                        this.handlers = void 0,
                        this.setStyle(null),
                        i.window !== void 0 && (i.window.removeEventListener("resize", this._onWindowResize, !1),
                        i.window.removeEventListener("orientationchange", this._onWindowResize, !1),
                        i.window.removeEventListener("webkitfullscreenchange", this._onWindowResize, !1),
                        i.window.removeEventListener("online", this._onWindowOnline, !1),
                        i.window.removeEventListener("visibilitychange", this._onVisibilityChange, !1));
                        let m = this.painter.context.gl.getExtension("WEBGL_lose_context");
                        m && m.loseContext(),
                        this._canvas.removeEventListener("webglcontextlost", this._contextLost, !1),
                        this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, !1),
                        this._canvasContainer.remove(),
                        this._controlContainer.remove(),
                        this._missingCSSCanary.remove(),
                        this._canvas = void 0,
                        this._canvasContainer = void 0,
                        this._controlContainer = void 0,
                        this._missingCSSCanary = void 0,
                        this._container.classList.remove("mapboxgl-map"),
                        this._container.removeEventListener("scroll", this._onMapScroll, !1),
                        i.removeAuthState(this.painter.context.gl),
                        this._removed = !0,
                        this.fire(new i.Event("remove"))
                    }
                    triggerRepaint() {
                        this._triggerFrame(!0)
                    }
                    _triggerFrame(m) {
                        this._renderNextFrame = this._renderNextFrame || m,
                        this.style && !this._frame && (this._frame = i.exported.frame(l=>{
                            let h = !!this._renderNextFrame;
                            this._frame = null,
                            this._renderNextFrame = null,
                            h && this._render(l)
                        }
                        ))
                    }
                    _preloadTiles(m) {
                        let l = this.style ? Object.values(this.style._sourceCaches) : [];
                        return i.asyncAll(l, (h,_)=>h._preloadTiles(m, _), ()=>{
                            this.triggerRepaint()
                        }
                        ),
                        this
                    }
                    _onWindowOnline() {
                        this._update()
                    }
                    _onWindowResize(m) {
                        this._trackResize && this.resize({
                            originalEvent: m
                        })._update()
                    }
                    _onVisibilityChange() {
                        i.window.document.visibilityState === "hidden" && this._visibilityHidden++
                    }
                    get showTileBoundaries() {
                        return !!this._showTileBoundaries
                    }
                    set showTileBoundaries(m) {
                        this._showTileBoundaries !== m && (this._showTileBoundaries = m,
                        this._update())
                    }
                    get showTerrainWireframe() {
                        return !!this._showTerrainWireframe
                    }
                    set showTerrainWireframe(m) {
                        this._showTerrainWireframe !== m && (this._showTerrainWireframe = m,
                        this._update())
                    }
                    get speedIndexTiming() {
                        return !!this._speedIndexTiming
                    }
                    set speedIndexTiming(m) {
                        this._speedIndexTiming !== m && (this._speedIndexTiming = m,
                        this._update())
                    }
                    get showPadding() {
                        return !!this._showPadding
                    }
                    set showPadding(m) {
                        this._showPadding !== m && (this._showPadding = m,
                        this._update())
                    }
                    get showCollisionBoxes() {
                        return !!this._showCollisionBoxes
                    }
                    set showCollisionBoxes(m) {
                        this._showCollisionBoxes !== m && (this._showCollisionBoxes = m,
                        m ? this.style._generateCollisionBoxes() : this._update())
                    }
                    get showOverdrawInspector() {
                        return !!this._showOverdrawInspector
                    }
                    set showOverdrawInspector(m) {
                        this._showOverdrawInspector !== m && (this._showOverdrawInspector = m,
                        this._update())
                    }
                    get repaint() {
                        return !!this._repaint
                    }
                    set repaint(m) {
                        this._repaint !== m && (this._repaint = m,
                        this.triggerRepaint())
                    }
                    get vertices() {
                        return !!this._vertices
                    }
                    set vertices(m) {
                        this._vertices = m,
                        this._update()
                    }
                    get showTileAABBs() {
                        return !!this._showTileAABBs
                    }
                    set showTileAABBs(m) {
                        this._showTileAABBs !== m && (this._showTileAABBs = m,
                        m && this._update())
                    }
                    _setCacheLimits(m, l) {
                        i.setCacheLimits(m, l)
                    }
                    get version() {
                        return i.version
                    }
                }
                ,
                NavigationControl: class {
                    constructor(m) {
                        this.options = i.extend({}, tp, m),
                        this._container = C("div", "mapboxgl-ctrl mapboxgl-ctrl-group"),
                        this._container.addEventListener("contextmenu", l=>l.preventDefault()),
                        this.options.showZoom && (i.bindAll(["_setButtonTitle", "_updateZoomButtons"], this),
                        this._zoomInButton = this._createButton("mapboxgl-ctrl-zoom-in", l=>{
                            this._map && this._map.zoomIn({}, {
                                originalEvent: l
                            })
                        }
                        ),
                        C("span", "mapboxgl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"),
                        this._zoomOutButton = this._createButton("mapboxgl-ctrl-zoom-out", l=>{
                            this._map && this._map.zoomOut({}, {
                                originalEvent: l
                            })
                        }
                        ),
                        C("span", "mapboxgl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")),
                        this.options.showCompass && (i.bindAll(["_rotateCompassArrow"], this),
                        this._compass = this._createButton("mapboxgl-ctrl-compass", l=>{
                            let h = this._map;
                            h && (this.options.visualizePitch ? h.resetNorthPitch({}, {
                                originalEvent: l
                            }) : h.resetNorth({}, {
                                originalEvent: l
                            }))
                        }
                        ),
                        this._compassIcon = C("span", "mapboxgl-ctrl-icon", this._compass),
                        this._compassIcon.setAttribute("aria-hidden", "true"))
                    }
                    _updateZoomButtons() {
                        let m = this._map;
                        if (!m)
                            return;
                        let l = m.getZoom()
                          , h = l === m.getMaxZoom()
                          , _ = l === m.getMinZoom();
                        this._zoomInButton.disabled = h,
                        this._zoomOutButton.disabled = _,
                        this._zoomInButton.setAttribute("aria-disabled", h.toString()),
                        this._zoomOutButton.setAttribute("aria-disabled", _.toString())
                    }
                    _rotateCompassArrow() {
                        let m = this._map;
                        if (!m)
                            return;
                        let l = this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(m.transform.pitch * (Math.PI / 180)), .5)}) rotateX(${m.transform.pitch}deg) rotateZ(${m.transform.angle * (180 / Math.PI)}deg)` : `rotate(${m.transform.angle * (180 / Math.PI)}deg)`;
                        m._requestDomTask(()=>{
                            this._compassIcon && (this._compassIcon.style.transform = l)
                        }
                        )
                    }
                    onAdd(m) {
                        return this._map = m,
                        this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"),
                        this._setButtonTitle(this._zoomOutButton, "ZoomOut"),
                        m.on("zoom", this._updateZoomButtons),
                        this._updateZoomButtons()),
                        this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"),
                        this.options.visualizePitch && m.on("pitch", this._rotateCompassArrow),
                        m.on("rotate", this._rotateCompassArrow),
                        this._rotateCompassArrow(),
                        this._handler = new t_(m,this._compass,this.options.visualizePitch)),
                        this._container
                    }
                    onRemove() {
                        let m = this._map;
                        m && (this._container.remove(),
                        this.options.showZoom && m.off("zoom", this._updateZoomButtons),
                        this.options.showCompass && (this.options.visualizePitch && m.off("pitch", this._rotateCompassArrow),
                        m.off("rotate", this._rotateCompassArrow),
                        this._handler && this._handler.off(),
                        this._handler = void 0),
                        this._map = void 0)
                    }
                    _createButton(m, l) {
                        let h = C("button", m, this._container);
                        return h.type = "button",
                        h.addEventListener("click", l),
                        h
                    }
                    _setButtonTitle(m, l) {
                        if (!this._map)
                            return;
                        let h = this._map._getUIString(`NavigationControl.${l}`);
                        m.setAttribute("aria-label", h),
                        m.firstElementChild && m.firstElementChild.setAttribute("title", h)
                    }
                }
                ,
                GeolocateControl: class extends i.Evented {
                    constructor(m) {
                        super(),
                        this.options = i.extend({
                            geolocation: i.window.navigator.geolocation
                        }, n_, m),
                        i.bindAll(["_onSuccess", "_onError", "_onZoom", "_finish", "_setupUI", "_updateCamera", "_updateMarker", "_updateMarkerRotation", "_onDeviceOrientation"], this),
                        this._updateMarkerRotationThrottled = zs(this._updateMarkerRotation, 20),
                        this._numberOfWatches = 0
                    }
                    onAdd(m) {
                        return this._map = m,
                        this._container = C("div", "mapboxgl-ctrl mapboxgl-ctrl-group"),
                        this._checkGeolocationSupport(this._setupUI),
                        this._container
                    }
                    onRemove() {
                        this._geolocationWatchID !== void 0 && (this.options.geolocation.clearWatch(this._geolocationWatchID),
                        this._geolocationWatchID = void 0),
                        this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(),
                        this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(),
                        this._container.remove(),
                        this._map.off("zoom", this._onZoom),
                        this._map = void 0,
                        this._numberOfWatches = 0,
                        this._noTimeout = !1
                    }
                    _checkGeolocationSupport(m) {
                        let l = (h=!!this.options.geolocation)=>{
                            this._supportsGeolocation = h,
                            m(h)
                        }
                        ;
                        this._supportsGeolocation !== void 0 ? m(this._supportsGeolocation) : i.window.navigator.permissions !== void 0 ? i.window.navigator.permissions.query({
                            name: "geolocation"
                        }).then(h=>l(h.state !== "denied")).catch(()=>l()) : l()
                    }
                    _isOutOfMapMaxBounds(m) {
                        let l = this._map.getMaxBounds()
                          , h = m.coords;
                        return !!l && (h.longitude < l.getWest() || h.longitude > l.getEast() || h.latitude < l.getSouth() || h.latitude > l.getNorth())
                    }
                    _setErrorState() {
                        switch (this._watchState) {
                        case "WAITING_ACTIVE":
                            this._watchState = "ACTIVE_ERROR",
                            this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"),
                            this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                            break;
                        case "ACTIVE_LOCK":
                            this._watchState = "ACTIVE_ERROR",
                            this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"),
                            this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error"),
                            this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
                            break;
                        case "BACKGROUND":
                            this._watchState = "BACKGROUND_ERROR",
                            this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"),
                            this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error"),
                            this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting")
                        }
                    }
                    _onSuccess(m) {
                        if (this._map) {
                            if (this._isOutOfMapMaxBounds(m))
                                return this._setErrorState(),
                                this.fire(new i.Event("outofmaxbounds",m)),
                                this._updateMarker(),
                                void this._finish();
                            if (this.options.trackUserLocation)
                                switch (this._lastKnownPosition = m,
                                this._watchState) {
                                case "WAITING_ACTIVE":
                                case "ACTIVE_LOCK":
                                case "ACTIVE_ERROR":
                                    this._watchState = "ACTIVE_LOCK",
                                    this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"),
                                    this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"),
                                    this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                                    break;
                                case "BACKGROUND":
                                case "BACKGROUND_ERROR":
                                    this._watchState = "BACKGROUND",
                                    this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"),
                                    this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"),
                                    this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background")
                                }
                            this.options.showUserLocation && this._watchState !== "OFF" && this._updateMarker(m),
                            this.options.trackUserLocation && this._watchState !== "ACTIVE_LOCK" || this._updateCamera(m),
                            this.options.showUserLocation && this._dotElement.classList.remove("mapboxgl-user-location-dot-stale"),
                            this.fire(new i.Event("geolocate",m)),
                            this._finish()
                        }
                    }
                    _updateCamera(m) {
                        let l = new i.LngLat(m.coords.longitude,m.coords.latitude)
                          , h = m.coords.accuracy
                          , _ = this._map.getBearing()
                          , b = i.extend({
                            bearing: _
                        }, this.options.fitBoundsOptions);
                        this._map.fitBounds(l.toBounds(h), b, {
                            geolocateSource: !0
                        })
                    }
                    _updateMarker(m) {
                        if (m) {
                            let l = new i.LngLat(m.coords.longitude,m.coords.latitude);
                            this._accuracyCircleMarker.setLngLat(l).addTo(this._map),
                            this._userLocationDotMarker.setLngLat(l).addTo(this._map),
                            this._accuracy = m.coords.accuracy,
                            this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius()
                        } else
                            this._userLocationDotMarker.remove(),
                            this._accuracyCircleMarker.remove()
                    }
                    _updateCircleRadius() {
                        let m = this._map.transform
                          , l = i.mercatorZfromAltitude(1, m._center.lat) * m.worldSize
                          , h = Math.ceil(2 * this._accuracy * l);
                        this._circleElement.style.width = `${h}px`,
                        this._circleElement.style.height = `${h}px`
                    }
                    _onZoom() {
                        this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius()
                    }
                    _updateMarkerRotation() {
                        this._userLocationDotMarker && typeof this._heading == "number" ? (this._userLocationDotMarker.setRotation(this._heading),
                        this._dotElement.classList.add("mapboxgl-user-location-show-heading")) : (this._dotElement.classList.remove("mapboxgl-user-location-show-heading"),
                        this._userLocationDotMarker.setRotation(0))
                    }
                    _onError(m) {
                        if (this._map) {
                            if (this.options.trackUserLocation)
                                if (m.code === 1) {
                                    this._watchState = "OFF",
                                    this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"),
                                    this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"),
                                    this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"),
                                    this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"),
                                    this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"),
                                    this._geolocateButton.disabled = !0;
                                    let l = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                                    this._geolocateButton.setAttribute("aria-label", l),
                                    this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", l),
                                    this._geolocationWatchID !== void 0 && this._clearWatch()
                                } else {
                                    if (m.code === 3 && this._noTimeout)
                                        return;
                                    this._setErrorState()
                                }
                            this._watchState !== "OFF" && this.options.showUserLocation && this._dotElement.classList.add("mapboxgl-user-location-dot-stale"),
                            this.fire(new i.Event("error",m)),
                            this._finish()
                        }
                    }
                    _finish() {
                        this._timeoutId && clearTimeout(this._timeoutId),
                        this._timeoutId = void 0
                    }
                    _setupUI(m) {
                        if (this._map !== void 0) {
                            if (this._container.addEventListener("contextmenu", l=>l.preventDefault()),
                            this._geolocateButton = C("button", "mapboxgl-ctrl-geolocate", this._container),
                            C("span", "mapboxgl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"),
                            this._geolocateButton.type = "button",
                            m === !1) {
                                i.warnOnce("Geolocation support is not available so the GeolocateControl will be disabled.");
                                let l = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                                this._geolocateButton.disabled = !0,
                                this._geolocateButton.setAttribute("aria-label", l),
                                this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", l)
                            } else {
                                let l = this._map._getUIString("GeolocateControl.FindMyLocation");
                                this._geolocateButton.setAttribute("aria-label", l),
                                this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", l)
                            }
                            this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"),
                            this._watchState = "OFF"),
                            this.options.showUserLocation && (this._dotElement = C("div", "mapboxgl-user-location"),
                            this._dotElement.appendChild(C("div", "mapboxgl-user-location-dot")),
                            this._dotElement.appendChild(C("div", "mapboxgl-user-location-heading")),
                            this._userLocationDotMarker = new jh({
                                element: this._dotElement,
                                rotationAlignment: "map",
                                pitchAlignment: "map"
                            }),
                            this._circleElement = C("div", "mapboxgl-user-location-accuracy-circle"),
                            this._accuracyCircleMarker = new jh({
                                element: this._circleElement,
                                pitchAlignment: "map"
                            }),
                            this.options.trackUserLocation && (this._watchState = "OFF"),
                            this._map.on("zoom", this._onZoom)),
                            this._geolocateButton.addEventListener("click", this.trigger.bind(this)),
                            this._setup = !0,
                            this.options.trackUserLocation && this._map.on("movestart", l=>{
                                l.geolocateSource || this._watchState !== "ACTIVE_LOCK" || l.originalEvent && l.originalEvent.type === "resize" || (this._watchState = "BACKGROUND",
                                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background"),
                                this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"),
                                this.fire(new i.Event("trackuserlocationend")))
                            }
                            )
                        }
                    }
                    _onDeviceOrientation(m) {
                        this._userLocationDotMarker && (m.webkitCompassHeading ? this._heading = m.webkitCompassHeading : m.absolute === !0 && (this._heading = -1 * m.alpha),
                        this._updateMarkerRotationThrottled())
                    }
                    trigger() {
                        if (!this._setup)
                            return i.warnOnce("Geolocate control triggered before added to a map"),
                            !1;
                        if (this.options.trackUserLocation) {
                            switch (this._watchState) {
                            case "OFF":
                                this._watchState = "WAITING_ACTIVE",
                                this.fire(new i.Event("trackuserlocationstart"));
                                break;
                            case "WAITING_ACTIVE":
                            case "ACTIVE_LOCK":
                            case "ACTIVE_ERROR":
                            case "BACKGROUND_ERROR":
                                this._numberOfWatches--,
                                this._noTimeout = !1,
                                this._watchState = "OFF",
                                this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"),
                                this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"),
                                this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"),
                                this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"),
                                this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"),
                                this.fire(new i.Event("trackuserlocationend"));
                                break;
                            case "BACKGROUND":
                                this._watchState = "ACTIVE_LOCK",
                                this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"),
                                this._lastKnownPosition && this._updateCamera(this._lastKnownPosition),
                                this.fire(new i.Event("trackuserlocationstart"))
                            }
                            switch (this._watchState) {
                            case "WAITING_ACTIVE":
                                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"),
                                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                                break;
                            case "ACTIVE_LOCK":
                                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                                break;
                            case "ACTIVE_ERROR":
                                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"),
                                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                                break;
                            case "BACKGROUND":
                                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
                                break;
                            case "BACKGROUND_ERROR":
                                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"),
                                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error")
                            }
                            if (this._watchState === "OFF" && this._geolocationWatchID !== void 0)
                                this._clearWatch();
                            else if (this._geolocationWatchID === void 0) {
                                let m;
                                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"),
                                this._geolocateButton.setAttribute("aria-pressed", "true"),
                                this._numberOfWatches++,
                                this._numberOfWatches > 1 ? (m = {
                                    maximumAge: 6e5,
                                    timeout: 0
                                },
                                this._noTimeout = !0) : (m = this.options.positionOptions,
                                this._noTimeout = !1),
                                this._geolocationWatchID = this.options.geolocation.watchPosition(this._onSuccess, this._onError, m),
                                this.options.showUserHeading && this._addDeviceOrientationListener()
                            }
                        } else
                            this.options.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions),
                            this._timeoutId = setTimeout(this._finish, 1e4);
                        return !0
                    }
                    _addDeviceOrientationListener() {
                        let m = ()=>{
                            i.window.addEventListener("ondeviceorientationabsolute"in i.window ? "deviceorientationabsolute" : "deviceorientation", this._onDeviceOrientation)
                        }
                        ;
                        i.window.DeviceMotionEvent !== void 0 && typeof i.window.DeviceMotionEvent.requestPermission == "function" ? DeviceOrientationEvent.requestPermission().then(l=>{
                            l === "granted" && m()
                        }
                        ).catch(console.error) : m()
                    }
                    _clearWatch() {
                        this.options.geolocation.clearWatch(this._geolocationWatchID),
                        i.window.removeEventListener("deviceorientation", this._onDeviceOrientation),
                        i.window.removeEventListener("deviceorientationabsolute", this._onDeviceOrientation),
                        this._geolocationWatchID = void 0,
                        this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"),
                        this._geolocateButton.setAttribute("aria-pressed", "false"),
                        this.options.showUserLocation && this._updateMarker(null)
                    }
                }
                ,
                AttributionControl: $f,
                ScaleControl: class {
                    constructor(m) {
                        this.options = i.extend({}, i_, m),
                        function() {
                            try {
                                return new Intl.NumberFormat("en",{
                                    style: "unit",
                                    unitDisplay: "narrow",
                                    unit: "meter"
                                }),
                                !0
                            } catch (l) {
                                return !1
                            }
                        }() || (this._setScale = r_.bind(this)),
                        i.bindAll(["_update", "_setScale", "setUnit"], this)
                    }
                    getDefaultPosition() {
                        return "bottom-left"
                    }
                    _update() {
                        let m = this.options.maxWidth || 100
                          , l = this._map
                          , h = l._containerHeight / 2
                          , _ = l._containerWidth / 2 - m / 2
                          , b = l.unproject([_, h])
                          , T = l.unproject([_ + m, h])
                          , L = b.distanceTo(T);
                        if (this.options.unit === "imperial") {
                            let R = 3.2808 * L;
                            R > 5280 ? this._setScale(m, R / 5280, "mile") : this._setScale(m, R, "foot")
                        } else
                            this.options.unit === "nautical" ? this._setScale(m, L / 1852, "nautical-mile") : L >= 1e3 ? this._setScale(m, L / 1e3, "kilometer") : this._setScale(m, L, "meter")
                    }
                    _setScale(m, l, h) {
                        let _ = Xh(l)
                          , b = _ / l;
                        this._map._requestDomTask(()=>{
                            this._container.style.width = m * b + "px",
                            this._container.innerHTML = h !== "nautical-mile" ? new Intl.NumberFormat(this._language,{
                                style: "unit",
                                unitDisplay: "narrow",
                                unit: h
                            }).format(_) : `${_}&nbsp;nm`
                        }
                        )
                    }
                    onAdd(m) {
                        return this._map = m,
                        this._language = m.getLanguage(),
                        this._container = C("div", "mapboxgl-ctrl mapboxgl-ctrl-scale", m.getContainer()),
                        this._container.dir = "auto",
                        this._map.on("move", this._update),
                        this._update(),
                        this._container
                    }
                    onRemove() {
                        this._container.remove(),
                        this._map.off("move", this._update),
                        this._map = void 0
                    }
                    _setLanguage(m) {
                        this._language = m,
                        this._update()
                    }
                    setUnit(m) {
                        this.options.unit = m,
                        this._update()
                    }
                }
                ,
                FullscreenControl: class {
                    constructor(m) {
                        this._fullscreen = !1,
                        m && m.container && (m.container instanceof i.window.HTMLElement ? this._container = m.container : i.warnOnce("Full screen control 'container' must be a DOM element.")),
                        i.bindAll(["_onClickFullscreen", "_changeIcon"], this),
                        "onfullscreenchange"in i.window.document ? this._fullscreenchange = "fullscreenchange" : "onwebkitfullscreenchange"in i.window.document && (this._fullscreenchange = "webkitfullscreenchange")
                    }
                    onAdd(m) {
                        return this._map = m,
                        this._container || (this._container = this._map.getContainer()),
                        this._controlContainer = C("div", "mapboxgl-ctrl mapboxgl-ctrl-group"),
                        this._checkFullscreenSupport() ? this._setupUI() : (this._controlContainer.style.display = "none",
                        i.warnOnce("This device does not support fullscreen mode.")),
                        this._controlContainer
                    }
                    onRemove() {
                        this._controlContainer.remove(),
                        this._map = null,
                        i.window.document.removeEventListener(this._fullscreenchange, this._changeIcon)
                    }
                    _checkFullscreenSupport() {
                        return !(!i.window.document.fullscreenEnabled && !i.window.document.webkitFullscreenEnabled)
                    }
                    _setupUI() {
                        let m = this._fullscreenButton = C("button", "mapboxgl-ctrl-fullscreen", this._controlContainer);
                        C("span", "mapboxgl-ctrl-icon", m).setAttribute("aria-hidden", "true"),
                        m.type = "button",
                        this._updateTitle(),
                        this._fullscreenButton.addEventListener("click", this._onClickFullscreen),
                        i.window.document.addEventListener(this._fullscreenchange, this._changeIcon)
                    }
                    _updateTitle() {
                        let m = this._getTitle();
                        this._fullscreenButton.setAttribute("aria-label", m),
                        this._fullscreenButton.firstElementChild && this._fullscreenButton.firstElementChild.setAttribute("title", m)
                    }
                    _getTitle() {
                        return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter")
                    }
                    _isFullscreen() {
                        return this._fullscreen
                    }
                    _changeIcon() {
                        (i.window.document.fullscreenElement || i.window.document.webkitFullscreenElement) === this._container !== this._fullscreen && (this._fullscreen = !this._fullscreen,
                        this._fullscreenButton.classList.toggle("mapboxgl-ctrl-shrink"),
                        this._fullscreenButton.classList.toggle("mapboxgl-ctrl-fullscreen"),
                        this._updateTitle())
                    }
                    _onClickFullscreen() {
                        this._isFullscreen() ? i.window.document.exitFullscreen ? i.window.document.exitFullscreen() : i.window.document.webkitCancelFullScreen && i.window.document.webkitCancelFullScreen() : this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.webkitRequestFullscreen && this._container.webkitRequestFullscreen()
                    }
                }
                ,
                Popup: class extends i.Evented {
                    constructor(m) {
                        super(),
                        this.options = i.extend(Object.create(Yg), m),
                        i.bindAll(["_update", "_onClose", "remove", "_onMouseEvent"], this),
                        this._classList = new Set(m && m.className ? m.className.trim().split(/\s+/) : [])
                    }
                    addTo(m) {
                        return this._map && this.remove(),
                        this._map = m,
                        this.options.closeOnClick && m.on("preclick", this._onClose),
                        this.options.closeOnMove && m.on("move", this._onClose),
                        m.on("remove", this.remove),
                        this._update(),
                        m._addPopup(this),
                        this._focusFirstElement(),
                        this._trackPointer ? (m.on("mousemove", this._onMouseEvent),
                        m.on("mouseup", this._onMouseEvent),
                        m._canvasContainer.classList.add("mapboxgl-track-pointer")) : m.on("move", this._update),
                        this.fire(new i.Event("open")),
                        this
                    }
                    isOpen() {
                        return !!this._map
                    }
                    remove() {
                        this._content && this._content.remove(),
                        this._container && (this._container.remove(),
                        this._container = void 0);
                        let m = this._map;
                        return m && (m.off("move", this._update),
                        m.off("move", this._onClose),
                        m.off("preclick", this._onClose),
                        m.off("click", this._onClose),
                        m.off("remove", this.remove),
                        m.off("mousemove", this._onMouseEvent),
                        m.off("mouseup", this._onMouseEvent),
                        m.off("drag", this._onMouseEvent),
                        m._canvasContainer && m._canvasContainer.classList.remove("mapboxgl-track-pointer"),
                        m._removePopup(this),
                        this._map = void 0),
                        this.fire(new i.Event("close")),
                        this
                    }
                    getLngLat() {
                        return this._lngLat
                    }
                    setLngLat(m) {
                        this._lngLat = i.LngLat.convert(m),
                        this._pos = null,
                        this._trackPointer = !1,
                        this._update();
                        let l = this._map;
                        return l && (l.on("move", this._update),
                        l.off("mousemove", this._onMouseEvent),
                        l._canvasContainer.classList.remove("mapboxgl-track-pointer")),
                        this
                    }
                    trackPointer() {
                        this._trackPointer = !0,
                        this._pos = null,
                        this._update();
                        let m = this._map;
                        return m && (m.off("move", this._update),
                        m.on("mousemove", this._onMouseEvent),
                        m.on("drag", this._onMouseEvent),
                        m._canvasContainer.classList.add("mapboxgl-track-pointer")),
                        this
                    }
                    getElement() {
                        return this._container
                    }
                    setText(m) {
                        return this.setDOMContent(i.window.document.createTextNode(m))
                    }
                    setHTML(m) {
                        let l = i.window.document.createDocumentFragment(), h = i.window.document.createElement("body"), _;
                        for (h.innerHTML = m; _ = h.firstChild,
                        _; )
                            l.appendChild(_);
                        return this.setDOMContent(l)
                    }
                    getMaxWidth() {
                        return this._container && this._container.style.maxWidth
                    }
                    setMaxWidth(m) {
                        return this.options.maxWidth = m,
                        this._update(),
                        this
                    }
                    setDOMContent(m) {
                        let l = this._content;
                        if (l)
                            for (; l.hasChildNodes(); )
                                l.firstChild && l.removeChild(l.firstChild);
                        else
                            l = this._content = C("div", "mapboxgl-popup-content", this._container || void 0);
                        if (l.appendChild(m),
                        this.options.closeButton) {
                            let h = this._closeButton = C("button", "mapboxgl-popup-close-button", l);
                            h.type = "button",
                            h.setAttribute("aria-label", "Close popup"),
                            h.setAttribute("aria-hidden", "true"),
                            h.innerHTML = "&#215;",
                            h.addEventListener("click", this._onClose)
                        }
                        return this._update(),
                        this._focusFirstElement(),
                        this
                    }
                    addClassName(m) {
                        return this._classList.add(m),
                        this._updateClassList(),
                        this
                    }
                    removeClassName(m) {
                        return this._classList.delete(m),
                        this._updateClassList(),
                        this
                    }
                    setOffset(m) {
                        return this.options.offset = m,
                        this._update(),
                        this
                    }
                    toggleClassName(m) {
                        let l;
                        return this._classList.delete(m) ? l = !1 : (this._classList.add(m),
                        l = !0),
                        this._updateClassList(),
                        l
                    }
                    _onMouseEvent(m) {
                        this._update(m.point)
                    }
                    _getAnchor(m) {
                        if (this.options.anchor)
                            return this.options.anchor;
                        let l = this._map
                          , h = this._container
                          , _ = this._pos;
                        if (!l || !h || !_)
                            return "bottom";
                        let b = h.offsetWidth
                          , T = h.offsetHeight
                          , L = _.x < b / 2
                          , R = _.x > l.transform.width - b / 2;
                        if (_.y + m < T)
                            return L ? "top-left" : R ? "top-right" : "top";
                        if (_.y > l.transform.height - T) {
                            if (L)
                                return "bottom-left";
                            if (R)
                                return "bottom-right"
                        }
                        return L ? "left" : R ? "right" : "bottom"
                    }
                    _updateClassList() {
                        let m = this._container;
                        if (!m)
                            return;
                        let l = [...this._classList];
                        l.push("mapboxgl-popup"),
                        this._anchor && l.push(`mapboxgl-popup-anchor-${this._anchor}`),
                        this._trackPointer && l.push("mapboxgl-popup-track-pointer"),
                        m.className = l.join(" ")
                    }
                    _update(m) {
                        let l = this._map
                          , h = this._content;
                        if (!l || !this._lngLat && !this._trackPointer || !h)
                            return;
                        let _ = this._container;
                        if (_ || (_ = this._container = C("div", "mapboxgl-popup", l.getContainer()),
                        this._tip = C("div", "mapboxgl-popup-tip", _),
                        _.appendChild(h)),
                        this.options.maxWidth && _.style.maxWidth !== this.options.maxWidth && (_.style.maxWidth = this.options.maxWidth),
                        l.transform.renderWorldCopies && !this._trackPointer && (this._lngLat = Wh(this._lngLat, this._pos, l.transform)),
                        !this._trackPointer || m) {
                            let b = this._pos = this._trackPointer && m ? m : l.project(this._lngLat)
                              , T = ep(this.options.offset)
                              , L = this._anchor = this._getAnchor(T.y)
                              , R = ep(this.options.offset, L)
                              , O = b.add(R).round();
                            l._requestDomTask(()=>{
                                this._container && L && (this._container.style.transform = `${Ll[L]} translate(${O.x}px,${O.y}px)`)
                            }
                            )
                        }
                        if (!this._marker && l._showingGlobe()) {
                            let b = i.isLngLatBehindGlobe(l.transform, this._lngLat) ? 0 : 1;
                            this._setOpacity(b)
                        }
                        this._updateClassList()
                    }
                    _focusFirstElement() {
                        if (!this.options.focusAfterOpen || !this._container)
                            return;
                        let m = this._container.querySelector(Jg);
                        m && m.focus()
                    }
                    _onClose() {
                        this.remove()
                    }
                    _setOpacity(m) {
                        this._container && (this._container.style.opacity = `${m}`),
                        this._content && (this._content.style.pointerEvents = m ? "auto" : "none")
                    }
                }
                ,
                Marker: jh,
                Style: ks,
                LngLat: i.LngLat,
                LngLatBounds: i.LngLatBounds,
                Point: i.pointGeometry,
                MercatorCoordinate: i.MercatorCoordinate,
                FreeCameraOptions: Ph,
                Evented: i.Evented,
                config: i.config,
                prewarm: function() {
                    fn().acquire(ze)
                },
                clearPrewarmedResources: function() {
                    let m = wt;
                    m && (m.isPreloaded() && m.numActive() === 1 ? (m.release(ze),
                    wt = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"))
                },
                get accessToken() {
                    return i.config.ACCESS_TOKEN
                },
                set accessToken(m) {
                    i.config.ACCESS_TOKEN = m
                },
                get baseApiUrl() {
                    return i.config.API_URL
                },
                set baseApiUrl(m) {
                    i.config.API_URL = m
                },
                get workerCount() {
                    return Rt.workerCount
                },
                set workerCount(m) {
                    Rt.workerCount = m
                },
                get maxParallelImageRequests() {
                    return i.config.MAX_PARALLEL_IMAGE_REQUESTS
                },
                set maxParallelImageRequests(m) {
                    i.config.MAX_PARALLEL_IMAGE_REQUESTS = m
                },
                clearStorage(m) {
                    i.clearTileCache(m)
                },
                workerUrl: "",
                workerClass: null,
                setNow: i.exported.setNow,
                restoreNow: i.exported.restoreNow
            };
            return ru
        });
        var p = c;
        return p
    })
})
  , Ic = q6;
Ic.accessToken = "pk.eyJ1IjoicXVhZHdlYXRoZXIiLCJhIjoiY2w2YXZ4YjAzMWdmODNkbWx5YmwycjcxaSJ9.DOMnL520hn-dTFcGgkH2BQ";
var uh = {};
uh.fsSource = `
    precision mediump float;
    varying float color;
    uniform sampler2D u_texture;
    uniform float u_min;
    uniform float u_max;
    uniform float u_opacity;

    void main() {
        float calcolor = (color-u_min)/(u_max - u_min);
        vec3 color = texture2D(u_texture,vec2(min(max(calcolor,0.0),1.0),0.0)).xyz;
        gl_FragColor = vec4(color.x*u_opacity, color.y*u_opacity, color.z*u_opacity, u_opacity);
    }
`;
uh.fsSourceFramebuffer = `
    precision highp float;
    varying float color;
    uniform float u_min;
    uniform float u_max;

    vec4 EncodeFloatRGBA( float v ) {
        vec4 enc = vec4(1.0, 255.0, 65025.0, 16581375.0) * v;
        enc = fract(enc);
        enc -= enc.yzww * vec4(1.0/255.0,1.0/255.0,1.0/255.0,0.0);
        return enc;
    }

    void main() {
        vec4 encoded;

        //get on 0-1 scale
        float calcolor = min(1.0, max((color - u_min)/(u_max - u_min), 0.0));

        //if upper end, need this check because [0,1)
        if (abs(calcolor - 1.0) < 0.00001) {
            encoded = vec4(1.0,0.0,0.0,1.0);
        } else {
            encoded = EncodeFloatRGBA(calcolor);
            encoded.a = 1.0;
        }
       
        gl_FragColor = encoded;

    }

`;
uh.vsSource = `
    //x: azimuth
    //y: range
    //z: value
    attribute vec3 aPosition;
    attribute float aColor;
    
    uniform mat4 u_matrix;
    varying float color;

    void main() {
        color = aPosition.z;
        gl_Position = u_matrix * vec4(aPosition.x,aPosition.y,0.0,1.0);
    }
`;
function K6(r, e) {
    var t = r.getCenter()
      , o = r.getZoom()
      , c = r.getBearing()
      , d = r.getPitch();
    e.forEach(function(p) {
        p.jumpTo({
            center: t,
            zoom: o,
            bearing: c,
            pitch: d
        })
    })
}
function Y6() {
    var r, e = arguments.length;
    if (e === 1)
        r = arguments[0];
    else {
        r = [];
        for (var t = 0; t < e; t++)
            r.push(arguments[t])
    }
    var o = [];
    r.forEach(function(i, v) {
        o[v] = p.bind(null, i, r.filter(function(x, E) {
            return E !== v
        }))
    });
    function c() {
        r.forEach(function(i, v) {
            i.on("move", o[v])
        })
    }
    function d() {
        r.forEach(function(i, v) {
            i.off("move", o[v])
        })
    }
    function p(i, v) {
        d(),
        K6(i, v),
        c()
    }
    return c(),
    function() {
        d(),
        o = []
    }
}
var s3 = Y6;
function J6(r) {
    let e;
    return {
        c() {
            e = qe("canvas"),
            je(e, "class", "svelte-80k2l0")
        },
        m(t, o) {
            yn(t, e, o),
            r[2](e)
        },
        p: Hn,
        i: Hn,
        o: Hn,
        d(t) {
            t && mn(e),
            r[2](null)
        }
    }
}
function $6(r, e, t) {
    let {REFLECTIVITY: o, VELOCITY: c, VELOCITY_DEALIASED: d} = Vs, {field: p} = e, i, v;
    function x() {
        p === void 0 || v === void 0 || v.render(p)
    }
    Ha(()=>{
        v = pC(i),
        p !== void 0 && v.render(p)
    }
    );
    function E(A) {
        Bi[A ? "unshift" : "push"](()=>{
            i = A,
            t(0, i)
        }
        )
    }
    return r.$$set = A=>{
        "field"in A && t(1, p = A.field)
    }
    ,
    r.$$.update = ()=>{
        if (r.$$.dirty & 2) {
            e: x()
        }
    }
    ,
    [i, p, E]
}
var o3 = class extends mi {
    constructor(e) {
        super();
        _i(this, e, $6, J6, di, {
            field: 1
        })
    }
}
  , a3 = o3;
function l3(r, e, t) {
    let o = r.slice();
    return o[32] = e[t],
    o
}
function c3(r) {
    let e, t = r[32].text + "", o, c, d;
    return {
        c() {
            e = qe("option"),
            o = Un(t),
            c = It(),
            e.__value = d = r[32].value,
            e.value = e.__value
        },
        m(p, i) {
            yn(p, e, i),
            Se(e, o),
            Se(e, c)
        },
        p(p, i) {
            i[0] & 64 && t !== (t = p[32].text + "") && gi(o, t),
            i[0] & 64 && d !== (d = p[32].value) && (e.__value = d,
            e.value = e.__value)
        },
        d(p) {
            p && mn(e)
        }
    }
}
function u3(r) {
    let e, t, o, c, d, p, i = (r[2] ? " " + r[2].toFixed(1) + " km" : "") + "", v, x, E, A = (r[1] === void 0 || isNaN(r[1]) ? "" : `${r[1]} ${r[4] > -1 ? r[9][r[4]] : ""}`) + "", C;
    return {
        c() {
            e = qe("table"),
            t = qe("tbody"),
            o = qe("tr"),
            o.innerHTML = `<th class="file svelte-1ntsdwj">Beam Height</th> 
                            <th class="vcp svelte-1ntsdwj">Gate Value</th>`,
            c = It(),
            d = qe("tr"),
            p = qe("td"),
            v = Un(i),
            x = It(),
            E = qe("td"),
            C = Un(A),
            je(o, "class", "svelte-1ntsdwj"),
            je(p, "class", "content file svelte-1ntsdwj"),
            je(E, "class", "content vcp svelte-1ntsdwj"),
            je(d, "class", "svelte-1ntsdwj"),
            je(e, "class", "svelte-1ntsdwj")
        },
        m(I, D) {
            yn(I, e, D),
            Se(e, t),
            Se(t, o),
            Se(t, c),
            Se(t, d),
            Se(d, p),
            Se(p, v),
            Se(d, x),
            Se(d, E),
            Se(E, C)
        },
        p(I, D) {
            D[0] & 4 && i !== (i = (I[2] ? " " + I[2].toFixed(1) + " km" : "") + "") && gi(v, i),
            D[0] & 18 && A !== (A = (I[1] === void 0 || isNaN(I[1]) ? "" : `${I[1]} ${I[4] > -1 ? I[9][I[4]] : ""}`) + "") && gi(C, A)
        },
        d(I) {
            I && mn(e)
        }
    }
}
function Q6(r) {
    let e, t, o, c, d, p, i, v = (r[5] ? `${r[5].elevation}° elevation` : "") + "", x, E, A, C = (r[5] ? r[5].date.toUTCString().replace("GMT", "UTC") : "") + "", I, D, P, k, U, Z, K, X, W, fe = r[6], ce = [];
    for (let oe = 0; oe < fe.length; oe += 1)
        ce[oe] = c3(l3(r, fe, oe));
    let _e = r[2] && r[3] && r[7] === r[8] && u3(r);
    return Z = new a3({
        props: {
            field: r[0]
        }
    }),
    {
        c() {
            e = qe("div"),
            t = qe("div"),
            o = qe("div"),
            c = qe("select");
            for (let oe = 0; oe < ce.length; oe += 1)
                ce[oe].c();
            d = It(),
            p = qe("div"),
            i = qe("p"),
            x = Un(v),
            E = It(),
            A = qe("p"),
            I = Un(C),
            D = It(),
            P = qe("div"),
            _e && _e.c(),
            k = It(),
            U = qe("div"),
            Qi(Z.$$.fragment),
            je(c, "class", "s svelte-1ntsdwj"),
            r[4] === void 0 && jl(()=>r[13].call(c)),
            je(i, "class", "metap svelte-1ntsdwj"),
            je(A, "class", "metap svelte-1ntsdwj"),
            je(p, "class", "meta svelte-1ntsdwj"),
            je(o, "class", "left svelte-1ntsdwj"),
            je(P, "class", "right svelte-1ntsdwj"),
            je(t, "class", "barContainer svelte-1ntsdwj"),
            je(U, "class", "colorbar svelte-1ntsdwj"),
            je(e, "class", "main-container svelte-1ntsdwj")
        },
        m(oe, ee) {
            yn(oe, e, ee),
            Se(e, t),
            Se(t, o),
            Se(o, c);
            for (let j = 0; j < ce.length; j += 1)
                ce[j].m(c, null);
            bu(c, r[4]),
            Se(o, d),
            Se(o, p),
            Se(p, i),
            Se(i, x),
            Se(p, E),
            Se(p, A),
            Se(A, I),
            Se(t, D),
            Se(t, P),
            _e && _e.m(P, null),
            Se(e, k),
            Se(e, U),
            qi(Z, U, null),
            K = !0,
            X || (W = [wn(c, "change", r[13]), wn(c, "change", r[10])],
            X = !0)
        },
        p(oe, ee) {
            if (ee[0] & 64) {
                fe = oe[6];
                let ne;
                for (ne = 0; ne < fe.length; ne += 1) {
                    let be = l3(oe, fe, ne);
                    ce[ne] ? ce[ne].p(be, ee) : (ce[ne] = c3(be),
                    ce[ne].c(),
                    ce[ne].m(c, null))
                }
                for (; ne < ce.length; ne += 1)
                    ce[ne].d(1);
                ce.length = fe.length
            }
            ee[0] & 80 && bu(c, oe[4]),
            (!K || ee[0] & 32) && v !== (v = (oe[5] ? `${oe[5].elevation}° elevation` : "") + "") && gi(x, v),
            (!K || ee[0] & 32) && C !== (C = (oe[5] ? oe[5].date.toUTCString().replace("GMT", "UTC") : "") + "") && gi(I, C),
            oe[2] && oe[3] && oe[7] === oe[8] ? _e ? _e.p(oe, ee) : (_e = u3(oe),
            _e.c(),
            _e.m(P, null)) : _e && (_e.d(1),
            _e = null);
            let j = {};
            ee[0] & 1 && (j.field = oe[0]),
            Z.$set(j)
        },
        i(oe) {
            K || (Wn(Z.$$.fragment, oe),
            K = !0)
        },
        o(oe) {
            ri(Z.$$.fragment, oe),
            K = !1
        },
        d(oe) {
            oe && mn(e),
            As(ce, oe),
            _e && _e.d(),
            Ki(Z),
            X = !1,
            Wi(W)
        }
    }
}
function eV(r, e, t) {
    let o, c, d, p;
    Ht(r, ui, tt=>t(12, o = tt)),
    Ht(r, ws, tt=>t(14, c = tt)),
    Ht(r, Za, tt=>t(15, d = tt)),
    Ht(r, zr, tt=>t(7, p = tt));
    let {DEALIASED: i, RAW: v} = da, {READING: x} = Yr, {REFLECTIVITY: E, VELOCITY: A, VELOCITY_DEALIASED: C, CC: I, PHI: D, ZDR: P, SW: k} = Vs, U = go(), Z = Qs(), K, {mouseoverValue: X} = e, {field: W} = e, {idx: fe} = e, {height: ce} = e, {over: _e} = e, oe, ee;
    o[fe] && o[fe].type ? oe = o[fe].type : (oe = -1,
    ee = [{
        value: -1,
        text: "No Scan Selected"
    }]);
    let j = {
        0: "dBZ",
        1: "kt",
        9: "",
        10: "deg km-1",
        5: "dB",
        2: "kt"
    }
      , ne = [0, 1, 9, 10, 2, 5]
      , be = {
        0: "Reflectivity",
        1: "Velocity",
        2: "Spectrum Width",
        5: "Differential Reflectivity",
        9: "Correlation Coefficient",
        10: "Specific Differential Phase"
    }
      , te = {
        0: E,
        1: A,
        9: I,
        10: D,
        5: P,
        2: k
    };
    function ae(tt) {
        oe === 1 && d === i ? t(0, W = C) : t(0, W = te[oe]),
        Z("message", {
            value: "setField",
            idx: fe,
            field: W
        }),
        bn(ws, c[fe].field = W, c),
        U.logStore(o[fe].scan)
    }
    function se() {
        if (!o[fe] || !o[fe].scan)
            return;
        let tt = o[fe].scan.scan
          , Ke = [];
        for (let Gt = 0; Gt < tt.length; Gt++) {
            let Ye = tt[Gt].fields;
            for (let gn = 0; gn < Ye.length; gn++)
                Ke.push(Ye[gn])
        }
        let bt = new Set(Ke)
          , Et = Array.from(bt).sort(function(Gt, Ye) {
            return Gt - Ye
        });
        t(6, ee = Et.map(Gt=>({
            value: Gt,
            text: be[Gt]
        })).filter(Gt=>ne.indexOf(Gt.value) >= 0)),
        c[fe] !== void 0 && (c[fe].field === C || c[fe].field === A ? t(4, oe = 1) : t(4, oe = o[fe].type))
    }
    function ke(tt, Ke) {
        if (o[fe] === void 0 || o[fe].scan === null)
            return;
        let bt, Et, Gt = o[fe].scan.scan;
        for (let Ye = 0; Ye < Gt.length; Ye++)
            if (Gt[Ye].fields.indexOf(tt) > -1) {
                bt = Gt[Ye].date,
                Et = Gt[Ye].elevation.toFixed(1);
                break
            }
        if (bt)
            return {
                date: bt,
                elevation: Et
            }
    }
    function Be() {
        oe = Op(this),
        t(4, oe),
        t(6, ee)
    }
    return r.$$set = tt=>{
        "mouseoverValue"in tt && t(1, X = tt.mouseoverValue),
        "field"in tt && t(0, W = tt.field),
        "idx"in tt && t(11, fe = tt.idx),
        "height"in tt && t(2, ce = tt.height),
        "over"in tt && t(3, _e = tt.over)
    }
    ,
    r.$$.update = ()=>{
        if (r.$$.dirty[0] & 4096) {
            e: se()
        }
        if (r.$$.dirty[0] & 4112) {
            e: t(5, K = ke(oe, o))
        }
    }
    ,
    [W, X, ce, _e, oe, K, ee, p, x, j, ae, fe, o, Be]
}
var h3 = class extends mi {
    constructor(e) {
        super();
        _i(this, e, eV, Q6, di, {
            mouseoverValue: 1,
            field: 0,
            idx: 11,
            height: 2,
            over: 3
        }, null, [-1, -1])
    }
}
  , d3 = h3;
function f3(r, e, t) {
    let o = r.slice();
    return o[94] = e[t],
    o
}
function p3(r) {
    let e;
    return {
        c() {
            e = qe("div"),
            e.innerHTML = `<div class="radar-container svelte-1bbym0j"><div class="background svelte-1bbym0j"></div> 
                <div class="line svelte-1bbym0j"></div> 
                <div class="inner svelte-1bbym0j"></div> 
                <div class="outer svelte-1bbym0j"></div> 
                <div class="border svelte-1bbym0j"></div></div>`,
            je(e, "class", "loading svelte-1bbym0j")
        },
        m(t, o) {
            yn(t, e, o)
        },
        d(t) {
            t && mn(e)
        }
    }
}
function m3(r) {
    let e, t;
    return {
        c() {
            e = qe("canvas"),
            vu(e, "display", "none"),
            je(e, "id", t = r[94])
        },
        m(o, c) {
            yn(o, e, c)
        },
        p: Hn,
        d(o) {
            o && mn(e)
        }
    }
}
function tV(r) {
    let e, t, o, c, d, p, i, v, x, E, A, C, I;
    d = new d3({
        props: {
            mouseoverValue: r[6],
            field: r[7],
            idx: r[1],
            height: r[9],
            over: r[3]
        }
    }),
    d.$on("message", r[2]);
    let D = r[8] && p3(r)
      , P = r[10]
      , k = [];
    for (let U = 0; U < P.length; U += 1)
        k[U] = m3(f3(r, P, U));
    return {
        c() {
            e = qe("div"),
            t = qe("div"),
            c = It(),
            Qi(d.$$.fragment),
            p = It(),
            D && D.c(),
            v = It();
            for (let U = 0; U < k.length; U += 1)
                k[U].c();
            x = It(),
            E = qe("canvas"),
            je(t, "id", o = "map" + r[1]),
            je(t, "class", "mapContainer svelte-1bbym0j"),
            Gn(t, "active", !r[0]),
            je(e, "id", i = "mapwrapper" + r[1]),
            je(e, "class", "mapWrapper svelte-1bbym0j"),
            Gn(e, "active", !r[0]),
            je(E, "class", "canvas3d svelte-1bbym0j"),
            je(E, "width", A = 32),
            je(E, "height", C = 32)
        },
        m(U, Z) {
            yn(U, e, Z),
            Se(e, t),
            r[24](t),
            Se(e, c),
            qi(d, e, null),
            Se(e, p),
            D && D.m(e, null),
            yn(U, v, Z);
            for (let K = 0; K < k.length; K += 1)
                k[K].m(U, Z);
            yn(U, x, Z),
            yn(U, E, Z),
            r[25](E),
            I = !0
        },
        p(U, Z) {
            (!I || Z[0] & 2 && o !== (o = "map" + U[1])) && je(t, "id", o),
            Z[0] & 1 && Gn(t, "active", !U[0]);
            let K = {};
            if (Z[0] & 64 && (K.mouseoverValue = U[6]),
            Z[0] & 128 && (K.field = U[7]),
            Z[0] & 2 && (K.idx = U[1]),
            Z[0] & 512 && (K.height = U[9]),
            Z[0] & 8 && (K.over = U[3]),
            d.$set(K),
            U[8] ? D || (D = p3(U),
            D.c(),
            D.m(e, null)) : D && (D.d(1),
            D = null),
            (!I || Z[0] & 2 && i !== (i = "mapwrapper" + U[1])) && je(e, "id", i),
            Z[0] & 1 && Gn(e, "active", !U[0]),
            Z[0] & 1024) {
                P = U[10];
                let X;
                for (X = 0; X < P.length; X += 1) {
                    let W = f3(U, P, X);
                    k[X] ? k[X].p(W, Z) : (k[X] = m3(W),
                    k[X].c(),
                    k[X].m(x.parentNode, x))
                }
                for (; X < k.length; X += 1)
                    k[X].d(1);
                k.length = P.length
            }
        },
        i(U) {
            I || (Wn(d.$$.fragment, U),
            I = !0)
        },
        o(U) {
            ri(d.$$.fragment, U),
            I = !1
        },
        d(U) {
            U && mn(e),
            r[24](null),
            Ki(d),
            D && D.d(),
            U && mn(v),
            As(k, U),
            U && mn(x),
            U && mn(E),
            r[25](null)
        }
    }
}
function nV(r, e, t) {
    let o, c, d, p, i, v, x, E, A, C, I, D, P, k, U, Z, K, X, W, fe, ce;
    Ht(r, ws, ye=>t(36, o = ye)),
    Ht(r, ku, ye=>t(11, c = ye)),
    Ht(r, _o, ye=>t(37, d = ye)),
    Ht(r, zr, ye=>t(12, p = ye)),
    Ht(r, ui, ye=>t(13, i = ye)),
    Ht(r, bs, ye=>t(14, v = ye)),
    Ht(r, Za, ye=>t(38, x = ye)),
    Ht(r, lm, ye=>t(15, E = ye)),
    Ht(r, Pu, ye=>t(16, A = ye)),
    Ht(r, Ru, ye=>t(17, C = ye)),
    Ht(r, ec, ye=>t(18, I = ye)),
    Ht(r, Ql, ye=>t(19, D = ye)),
    Ht(r, Hs, ye=>t(20, P = ye)),
    Ht(r, Ou, ye=>t(39, k = ye)),
    Ht(r, zu, ye=>t(40, U = ye)),
    Ht(r, Jr, ye=>t(21, Z = ye)),
    Ht(r, Qr, ye=>t(41, K = ye)),
    Ht(r, js, ye=>t(42, X = ye)),
    Ht(r, lM, ye=>t(43, W = ye)),
    Ht(r, Vp, ye=>t(22, fe = ye)),
    Ht(r, Gp, ye=>t(23, ce = ye));
    let {REFLECTIVITY: _e, VELOCITY: oe, VELOCITY_DEALIASED: ee, CC: j, PHI: ne, ZDR: be, SW: te} = Vs
      , {DEALIASED: ae} = da
      , {READING: se, MODE3D: ke, CROSS: Be} = Yr
      , {HISTORICAL: tt, LIVE: Ke} = Gs
      , bt = Qs()
      , Et = go()
      , {show: Gt} = e
      , {idx: Ye} = e
      , gn = c.styleid
      , gt = c.layer
      , Tn = 0
      , xn = new Ic.Popup;
    function Dn() {
        if (!o[Ye])
            return;
        let ye = o[Ye].getSource("alerts");
        ye && ye.setData(fe)
    }
    function Bt() {
        if (!o[Ye])
            return;
        let ye = o[Ye].getSource("lightning");
        if (ye) {
            ye.setData(ce);
            let et = new Date().getTime() / 1e3;
            o[Ye].setPaintProperty("lightning", "circle-color", ["interpolate", ["linear"], ["/", ["-", et, ["get", "date"]], 1800], .1, "#fff", 1, "#696969"])
        }
    }
    let An = {}, ut, ot = [0, 1], xt, on = {}, $t = {}, Pn = new Uint8Array(4), kt, Zt, zn = !1, Qt, xe;
    function he() {
        o[Ye] && o[Ye].triggerRepaint()
    }
    function Qe() {
        t(8, zn = !0)
    }
    function ft() {
        "lon"in P && o[Ye] && (X === tt && o[Ye].flyTo({
            center: [P.lon, P.lat],
            zoom: 7.5
        }),
        Zn(),
        Vn(),
        bn(Ou, k = null, k),
        bn(zu, U = null, U))
    }
    let St = 0;
    function Mt() {
        St = 1
    }
    function an() {
        o[Ye].getSource("lightning") === void 0 && o[Ye].addSource("lightning", {
            type: "geojson",
            data: ce
        });
        let et;
        if (A ? et = "visible" : et = "none",
        o[Ye].getStyle().layers.map(ze=>ze.id).indexOf("lightning") < 0) {
            o[Ye].addLayer({
                id: "lightning-blur",
                type: "circle",
                source: "lightning",
                paint: {
                    "circle-color": "#000",
                    "circle-opacity": .3,
                    "circle-blur": .4,
                    "circle-radius": ["interpolate", ["linear"], ["zoom"], 6, 4, 13, 12],
                    "circle-translate": [2, 2]
                },
                layout: {
                    visibility: et
                }
            });
            let ze = new Date().getTime() / 1e3;
            o[Ye].addLayer({
                id: "lightning",
                type: "circle",
                source: "lightning",
                paint: {
                    "circle-color": ["interpolate", ["linear"], ["/", ["-", ze, ["get", "date"]], 1800], .1, "#fff", 1, "#696969"],
                    "circle-radius": ["interpolate", ["linear"], ["zoom"], 6, 3, 13, 8],
                    "circle-stroke-color": "#ebebeb",
                    "circle-stroke-width": ["interpolate", ["linear"], ["zoom"], 6, .25, 13, 1.5],
                    "circle-stroke-opacity": 1
                },
                layout: {
                    visibility: et
                }
            })
        }
    }
    function Ie() {
        o[Ye].getSource("alerts") === void 0 && o[Ye].addSource("alerts", {
            type: "geojson",
            data: fe
        });
        let et;
        I ? et = "visible" : et = "none";
        let We = o[Ye].getStyle().layers.map(Rt=>Rt.id), ze;
        We.indexOf("sites") > -1 ? ze = "sites" : ze = "",
        We.indexOf("alerts-background") < 0 && (o[Ye].addLayer({
            id: "alerts-background",
            type: "line",
            source: "alerts",
            layout: {
                visibility: et
            },
            filter: ["!=", ["get", "event"], "Special Weather Statement"],
            paint: {
                "line-color": "#232323",
                "line-width": 4.5
            }
        }, ze),
        o[Ye].addLayer({
            id: "alerts",
            type: "line",
            source: "alerts",
            layout: {
                visibility: et
            },
            filter: ["!=", ["get", "event"], "Special Weather Statement"],
            paint: {
                "line-color": ["case", ["==", ["get", "event"], "Tornado Warning"], "#f00", ["==", ["get", "event"], "Severe Thunderstorm Warning"], "#ff0", ["==", ["get", "event"], "Flash Flood Warning"], "#0f0", ["==", ["get", "event"], "Winter Storm Warning"], "#f0f", "#fff"],
                "line-width": 3
            }
        }, ze),
        o[Ye].addLayer({
            id: "alerts-fill",
            type: "fill",
            source: "alerts",
            layout: {
                visibility: et
            },
            filter: ["!=", ["get", "event"], "Special Weather Statement"],
            paint: {
                "fill-opacity": 0
            }
        }, ze))
    }
    function Ct() {
        o[Ye].getSource("alerts") === void 0 && o[Ye].addSource("alerts", {
            type: "geojson",
            data: fe
        });
        let et;
        C ? et = "visible" : et = "none";
        let We = o[Ye].getStyle().layers.map(Rt=>Rt.id), ze;
        We.indexOf("alerts") > -1 ? ze = "alerts" : ze = "",
        We.indexOf("sws-background") < 0 && (o[Ye].addLayer({
            id: "sws-background",
            type: "line",
            source: "alerts",
            layout: {
                visibility: et
            },
            filter: ["==", ["get", "event"], "Special Weather Statement"],
            paint: {
                "line-color": "#232323",
                "line-width": 4.5
            }
        }, ze),
        o[Ye].addLayer({
            id: "sws",
            type: "line",
            source: "alerts",
            layout: {
                visibility: et
            },
            filter: ["==", ["get", "event"], "Special Weather Statement"],
            paint: {
                "line-color": ["case", ["==", ["get", "event"], "Special Weather Statement"], "#fff", "#fff"],
                "line-width": 3
            }
        }, ze),
        o[Ye].addLayer({
            id: "sws-fill",
            type: "fill",
            source: "alerts",
            layout: {
                visibility: et
            },
            filter: ["==", ["get", "event"], "Special Weather Statement"],
            paint: {
                "fill-opacity": 0
            }
        }, ze))
    }
    function ln() {
        if (o[Ye].getSource("sites") === void 0) {
            o[Ye].addSource("sites", {
                type: "geojson",
                data: W
            });
            let et = ji.site === void 0 ? null : ji.site;
            o[Ye].addLayer({
                id: "sites",
                type: "symbol",
                source: "sites",
                layout: {
                    "icon-image": ["case", ["==", ["slice", ["get", "STATION_ID"], 7], et], "selected", "unselected"],
                    "text-field": ["slice", ["get", "STATION_ID"], 7],
                    "icon-text-fit": "both",
                    "text-size": 12,
                    "text-font": ["Arial Unicode MS Bold"],
                    "icon-text-fit-padding": [4, 8, 4, 8]
                },
                paint: {
                    "text-color": "#fff",
                    "icon-halo-width": 20,
                    "icon-halo-color": "#fff"
                }
            }),
            o[Ye].on("click", "sites", function(We) {
                if (X != Ke || K)
                    return;
                let ze = We.features[0].properties.STATION_ID.split(":").slice(-1)[0];
                (ze[0] === "K" || ze[0] === "P" || ze[0] === "T") && (ji.setSite(ze),
                o[Ye].setLayoutProperty("sites", "icon-image", ["case", ["==", ["slice", ["get", "STATION_ID"], 7], ji.site], "selected", "unselected"]))
            }),
            o[Ye].on("click", ["sws-fill", "alerts-fill"], function(We) {
                let ze = {
                    "Tornado Warning": "#ef1212",
                    "Special Weather Statement": "#000",
                    "Severe Thunderstorm Warning": "#f9dc00",
                    "Flash Flood Warning": "#00990F"
                }
                  , Rt = "";
                for (let wt = 0; wt < We.features.length; wt++)
                    Rt += `<h3 style="
                background-color:${ze[We.features[wt].properties.event]};
                color:white;
                padding:8px;
                white-space:normal;
                margin:0;
                border-radius:inherit;
                border-bottom-left-radius:0px;
                border-bottom-right-radius:-0px;
                ">
                    ${We.features[wt].properties.event}
                    </h3><p style="
                    font-weight:bold;
                    padding:8px;
                    padding-bottom:0px;
                    margin:0;
                    ">${We.features[wt].properties.headline}
                        </p><p style="
                        margin:0;
                        padding:8px;
                        ">${We.features[wt].properties.description}
                            </p>`;
                xn.isOpen() && xn.remove(),
                xn.setLngLat(We.lngLat).setHTML(Rt).addTo(o[Ye])
            }),
            o[Ye].on("mouseenter", ["sites", "sws-fill", "alerts-fill"], function(We) {
                o[Ye].getCanvas().style.cursor = "pointer"
            }),
            o[Ye].on("mouseleave", ["sites", "sws-fill", "alerts-fill"], function(We) {
                p === Be || p === ke ? o[Ye].getCanvas().style.cursor = "crosshair" : o[Ye].getCanvas().style.cursor = ""
            })
        }
    }
    function Kt(ye) {
        if (ye !== null) {
            if (ye.detail.value === "loadVertices" && Qt && (Qt.updateData(),
            t(8, zn = !1)),
            ye.detail.value === "setBox" && Ln(ye.detail.box),
            ye.detail.value === "setLine" && Ln(ye.detail.line),
            ye.detail.value === "removeBox" && Zn(),
            ye.detail.value === "removeLine" && Vn(),
            ye.detail.value === "showSites" && ln(),
            ye.detail.value === "showAlerts" && Ie(),
            ye.detail.value === "showLightning" && an(),
            ye.detail.value === "showStatements" && Ct(),
            ye.detail.value === "activateMap" && (Ps(),
            (o[Ye].field === oe || o[Ye].field === ee) && bn(ws, o[Ye].field = x === ae ? ee : oe, o),
            i[0].scan && Et.logStore(i[0].scan)),
            ye.detail.value === "setField") {
                let et = ye.detail.field;
                Ee(et)
            }
            ye.detail.value === "clearMap" && (Qt.clear(),
            o[Ye].triggerRepaint()),
            ye.detail.value === "setDealiasState" && (o[Ye].field === oe || o[Ye].field === ee) && (Ee(x === ae ? ee : oe),
            Et.logStore(i[Ye].scan)),
            ye.detail.value === "startLoading" && t(8, zn = !0)
        }
    }
    yv(()=>{
        o[Ye] && St && (o[Ye].resize(),
        St = 0)
    }
    );
    let Ge = Symbol("drawing"), Wt = Symbol("done"), Ut = se, _n, Ft;
    function nn(ye) {
        bn(zu, U = ye, U)
    }
    function Jt(ye) {
        bn(Ou, k = ye, k)
    }
    function Ln(ye) {
        let et = ye[0].lat
          , We = ye[0].lng
          , ze = ye[1].lat
          , Rt = ye[1].lng;
        if (p === ke) {
            let wt = [Math.min(We, Rt), Math.max(et, ze)]
              , fn = [Math.max(We, Rt), Math.min(et, ze)]
              , Mn = {
                type: "Feature",
                geometry: {
                    type: "Polygon",
                    coordinates: [[wt, [fn[0], wt[1]], fn, [wt[0], fn[1]], wt]]
                }
            };
            o[Ye].getSource("box").setData(Mn)
        }
        if (p === Be) {
            let wt = {
                type: "Feature",
                geometry: {
                    type: "LineString",
                    coordinates: [[We, et], [Rt, ze]]
                }
            };
            o[Ye].getSource("line").setData(wt),
            An.A && An.A.setLngLat([We, et]).addTo(o[Ye]),
            An.B && An.B.setLngLat([Rt, ze]).addTo(o[Ye])
        }
    }
    function Zn() {
        o[Ye] && o[Ye].getSource("box") && (bn(zu, U = null, U),
        o[Ye].getSource("box").setData({
            type: "Feature",
            geometry: {
                type: "Polygon",
                coordinates: []
            }
        }))
    }
    function Vn() {
        o[Ye] && o[Ye].getSource("line") && (bn(Ou, k = null, k),
        o[Ye].getSource("line").setData({
            type: "Feature",
            geometry: {
                type: "Polygon",
                coordinates: []
            }
        }),
        An.A && An.A.remove(),
        An.B && An.B.remove())
    }
    function Tr(ye) {
        Ut = Ge,
        _n = ye.lngLat.wrap()
    }
    function fr(ye) {
        let et = ut.getBoundingClientRect()
          , We = new Ic.Point(ye.clientX - et.left - ut.clientLeft,ye.clientY - et.top - ut.clientTop);
        return o[Ye].unproject(We)
    }
    function Rs(ye) {
        if (p === ke && ye.composedPath()[0].localName != "select" && Zn(),
        p === Be && ye.composedPath()[0].localName != "select" && Vn(),
        p === ke || p === Be) {
            if (ye.composedPath().indexOf(o[Ye]._canvas) == -1)
                return;
            Ut = Ge,
            _n = fr(ye)
        }
    }
    function Cr(ye) {
        e: if (Ut === Ge) {
            if (ye.lngLat)
                break e;
            Ft = fr(ye),
            Ln([_n, Ft]),
            p === ke ? bt("message", {
                value: "setBox",
                idx: Ye,
                box: [_n, Ft]
            }) : p === Be && bt("message", {
                value: "setLine",
                idx: Ye,
                line: [_n, Ft]
            })
        }
        if (p === se && !d && (P && P.lon && i[0].scan ? t(9, xe = yS(P.lon, P.lat, ye.lngLat.lng, ye.lngLat.lat, i[0].scan.scan[0].elevation)) : t(9, xe = null),
        Qt)) {
            Qt.gl.bindFramebuffer(Qt.gl.FRAMEBUFFER, Qt.fb);
            let et = window.devicePixelRatio || 1;
            Qt.gl.readPixels(et * ye.point.x, Qt.gl.drawingBufferHeight - et * ye.point.y, 1, 1, Qt.gl.RGBA, Qt.gl.UNSIGNED_BYTE, Pn),
            ue(Pn)
        }
    }
    function Vr(ye) {
        Ut === se && Qt && (Qt.gl.bindFramebuffer(Qt.gl.FRAMEBUFFER, Qt.fb),
        Qt.gl.readPixels(2 * ye.point.x, Qt.gl.drawingBufferHeight - 2 * ye.point.y, 1, 1, Qt.gl.RGBA, Qt.gl.UNSIGNED_BYTE, Pn),
        ue(Pn))
    }
    function Gr(ye) {
        Ut === Ge && (Ut = Wt,
        p === ke && nn([_n, fr(ye)]),
        p === Be && Jt([_n, fr(ye)]))
    }
    function Ps() {
        !o[Ye] || (p === ke && (o[Ye].getCanvas().style.cursor = "crosshair",
        o[Ye].dragPan.disable(),
        Vn(),
        U && Ln(U),
        ut.addEventListener("mousedown", Rs, !0),
        ut.addEventListener("mousemove", Cr),
        document.addEventListener("mouseup", Gr)),
        p === Be && (o[Ye].getCanvas().style.cursor = "crosshair",
        o[Ye].dragPan.disable(),
        Zn(),
        k && Ln(k),
        ut.addEventListener("mousedown", Rs, !0),
        ut.addEventListener("mousemove", Cr),
        document.addEventListener("mouseup", Gr)),
        p === se && (o[Ye].getCanvas().style.cursor = "",
        Zn(),
        Vn(),
        o[Ye].dragPan.enable(),
        ut.removeEventListener("mousedown", Rs),
        ut.removeEventListener("mousemove", Cr),
        document.removeEventListener("mouseup", Gr)),
        Ct(),
        Ie(),
        an(),
        D && ln())
    }
    function ds(ye) {
        if (!o[Ye])
            return;
        let et = o[Ye].getStyle().layers.map(We=>We.id);
        ye === "sites" && et.indexOf("sites") > -1 && (D ? o[Ye].setLayoutProperty("sites", "visibility", "visible") : o[Ye].setLayoutProperty("sites", "visibility", "none")),
        ye === "lightning" && et.indexOf("lightning") > -1 && (A ? (o[Ye].setLayoutProperty("lightning", "visibility", "visible"),
        o[Ye].setLayoutProperty("lightning-blur", "visibility", "visible")) : (o[Ye].setLayoutProperty("lightning", "visibility", "none"),
        o[Ye].setLayoutProperty("lightning-blur", "visibility", "none"))),
        ye === "alerts" && et.indexOf("alerts") > -1 && (I ? (o[Ye].setLayoutProperty("alerts-background", "visibility", "visible"),
        o[Ye].setLayoutProperty("alerts", "visibility", "visible"),
        o[Ye].setLayoutProperty("alerts-fill", "visibility", "visible")) : (o[Ye].setLayoutProperty("alerts-background", "visibility", "none"),
        o[Ye].setLayoutProperty("alerts", "visibility", "none"),
        o[Ye].setLayoutProperty("alerts-fill", "visibility", "none"))),
        ye === "sws" && et.indexOf("sws") > -1 && (C ? (o[Ye].setLayoutProperty("sws-background", "visibility", "visible"),
        o[Ye].setLayoutProperty("sws", "visibility", "visible"),
        o[Ye].setLayoutProperty("sws-fill", "visibility", "visible")) : (o[Ye].setLayoutProperty("sws-background", "visibility", "none"),
        o[Ye].setLayoutProperty("sws", "visibility", "none"),
        o[Ye].setLayoutProperty("sws-fill", "visibility", "none")))
    }
    function Te() {
        Qt && (Qt.updateOpacity(),
        he())
    }
    function Y(ye, et) {
        let We = this
          , ze = ye;
        this.layerType = et;
        let Rt, wt = function(ht) {
            We.layerType = ht,
            Rt = new Float32Array([]),
            jt()
        }, fn = function() {
            Rt = new Float32Array([])
        }, Mn, Nn = function(ht) {
            if (Rt === void 0 || Rt.length == 0)
                return;
            ze.flush();
            let mr = 0
              , jn = ze.TRIANGLES;
            ze.useProgram(this.programFramebuffer),
            ze.uniformMatrix4fv(this.matrixLocationFramebuffer, !1, ht),
            We.layerType === _e && (ze.uniform1f(this.minLocationFramebuffer, 0),
            ze.uniform1f(this.maxLocationFramebuffer, 80)),
            We.layerType === j && (ze.uniform1f(this.minLocationFramebuffer, .2),
            ze.uniform1f(this.maxLocationFramebuffer, 1.05)),
            We.layerType === ne && (ze.uniform1f(this.minLocationFramebuffer, -2),
            ze.uniform1f(this.maxLocationFramebuffer, 10)),
            We.layerType === be && (ze.uniform1f(this.minLocationFramebuffer, -8),
            ze.uniform1f(this.maxLocationFramebuffer, 8)),
            We.layerType === te && (ze.uniform1f(this.minLocationFramebuffer, 0),
            ze.uniform1f(this.maxLocationFramebuffer, 60)),
            We.layerType === oe && (ze.uniform1f(this.minLocationFramebuffer, hl),
            ze.uniform1f(this.maxLocationFramebuffer, dl)),
            We.layerType === ee && (ze.uniform1f(this.minLocationFramebuffer, hl * 2),
            ze.uniform1f(this.maxLocationFramebuffer, dl * 2)),
            ze.bindFramebuffer(ze.FRAMEBUFFER, Mn),
            ze.clearColor(0, 0, 0, 0),
            ze.clear(ye.COLOR_BUFFER_BIT | ye.DEPTH_BUFFER_BIT),
            d || ze.drawArrays(jn, mr, Rt.length / 3),
            ze.flush(),
            ze.bindFramebuffer(ze.FRAMEBUFFER, null),
            ze.useProgram(this.program),
            ze.uniformMatrix4fv(this.matrixLocation, !1, ht),
            ze.drawArrays(jn, mr, Rt.length / 3)
        };
        function jt() {
            ze.useProgram(We.program),
            ze.activeTexture(ye.TEXTURE7),
            ze.bindTexture(ze.TEXTURE_2D, on[We.layerType]),
            ze.texImage2D(ze.TEXTURE_2D, 0, ze.RGBA, ze.RGBA, ze.UNSIGNED_BYTE, $t[We.layerType]),
            ze.texParameteri(ze.TEXTURE_2D, ze.TEXTURE_WRAP_S, ze.CLAMP_TO_EDGE),
            ze.texParameteri(ze.TEXTURE_2D, ze.TEXTURE_WRAP_T, ze.CLAMP_TO_EDGE),
            ze.texParameteri(ze.TEXTURE_2D, ze.TEXTURE_MIN_FILTER, ze.LINEAR),
            ze.uniform1i(We.textureLocation, 7),
            We.layerType === _e && (ze.uniform1f(We.minLocation, 0),
            ze.uniform1f(We.maxLocation, 80)),
            We.layerType === j && (ze.uniform1f(We.minLocation, .2),
            ze.uniform1f(We.maxLocation, 1.05)),
            We.layerType === ne && (ze.uniform1f(We.minLocation, -2),
            ze.uniform1f(We.maxLocation, 10)),
            We.layerType === be && (ze.uniform1f(We.minLocation, -8),
            ze.uniform1f(We.maxLocation, 8)),
            We.layerType === te && (ze.uniform1f(We.minLocation, 0),
            ze.uniform1f(We.maxLocation, 60)),
            We.layerType === oe && (ze.uniform1f(We.minLocation, hl),
            ze.uniform1f(We.maxLocation, dl)),
            We.layerType === ee && (ze.uniform1f(We.minLocation, hl),
            ze.uniform1f(We.maxLocation, dl))
        }
        function qn() {
            let ht = ze.drawingBufferWidth
              , mr = ze.drawingBufferHeight
              , jn = ze.createTexture();
            ze.bindTexture(ze.TEXTURE_2D, jn);
            let vr = 0
              , ao = ze.RGBA
              , Zi = 0
              , Xo = ze.RGBA
              , hh = ze.UNSIGNED_BYTE
              , Zo = null;
            ze.texImage2D(ze.TEXTURE_2D, vr, ao, ht, mr, Zi, Xo, hh, Zo),
            ze.texParameteri(ze.TEXTURE_2D, ze.TEXTURE_MIN_FILTER, ze.NEAREST),
            ze.texParameteri(ze.TEXTURE_2D, ze.TEXTURE_WRAP_S, ze.CLAMP_TO_EDGE),
            ze.texParameteri(ze.TEXTURE_2D, ze.TEXTURE_WRAP_T, ze.CLAMP_TO_EDGE),
            Mn = ze.createFramebuffer(),
            ze.bindFramebuffer(ze.FRAMEBUFFER, Mn);
            let Xt = ze.COLOR_ATTACHMENT0;
            ze.framebufferTexture2D(ze.FRAMEBUFFER, Xt, ze.TEXTURE_2D, jn, vr)
        }
        let On = function() {
            ze.useProgram(We.program),
            ze.uniform1f(We.opacityLocation, E.opacity)
        }
          , ar = function() {
            Rt = v[i[Ye].file][i[Ye].type][i[Ye].elevation],
            Rt !== void 0 && (ze.bindBuffer(ze.ARRAY_BUFFER, We.positionBuffer),
            ze.bufferSubData(ze.ARRAY_BUFFER, 0, Rt))
        }
          , pr = function() {
            let ht = 3
              , mr = ze.FLOAT
              , jn = !1
              , vr = 0
              , ao = 0;
            ze.bindBuffer(ze.ARRAY_BUFFER, We.positionBuffer),
            ze.bufferData(ze.ARRAY_BUFFER, 1e8, ze.DYNAMIC_DRAW),
            ze.enableVertexAttribArray(We.positionLocation),
            ze.vertexAttribPointer(We.positionLocation, ht, mr, jn, vr, ao)
        };
        return qn(),
        pr(),
        On(),
        {
            render: Nn,
            updateData: ar,
            createFrameBuffer: qn,
            fb: Mn,
            gl: ze,
            setType: wt,
            clear: fn,
            attachColor: jt,
            updateOpacity: On
        }
    }
    function F(ye, et, We, ze) {
        return {
            id: "custom-layer",
            type: "custom",
            minzoom: 0,
            maxzoom: 18,
            onAdd(Rt, wt) {
                let fn = Rw(wt, ye);
                $t[ye] = fn.imageData,
                on[ye] = fn.texture;
                var Mn = wt.getExtension("OES_element_index_uint")
                  , Nn = wt.createShader(wt.VERTEX_SHADER);
                wt.shaderSource(Nn, et),
                wt.compileShader(Nn);
                var jt = wt.createShader(wt.FRAGMENT_SHADER);
                wt.shaderSource(jt, We),
                wt.compileShader(jt);
                var qn = wt.createShader(wt.FRAGMENT_SHADER);
                wt.shaderSource(qn, ze),
                wt.compileShader(qn),
                this.program = wt.createProgram(),
                wt.attachShader(this.program, Nn),
                wt.attachShader(this.program, jt),
                wt.linkProgram(this.program),
                this.matrixLocation = wt.getUniformLocation(this.program, "u_matrix"),
                this.minLocation = wt.getUniformLocation(this.program, "u_min"),
                this.maxLocation = wt.getUniformLocation(this.program, "u_max"),
                this.positionLocation = wt.getAttribLocation(this.program, "aPosition"),
                this.colorLocation = wt.getAttribLocation(this.program, "aColor"),
                this.textureLocation = wt.getUniformLocation(this.program, "u_texture"),
                this.opacityLocation = wt.getUniformLocation(this.program, "u_opacity"),
                this.programFramebuffer = wt.createProgram(),
                wt.attachShader(this.programFramebuffer, Nn),
                wt.attachShader(this.programFramebuffer, qn),
                wt.linkProgram(this.programFramebuffer),
                this.matrixLocationFramebuffer = wt.getUniformLocation(this.programFramebuffer, "u_matrix"),
                this.minLocationFramebuffer = wt.getUniformLocation(this.programFramebuffer, "u_min"),
                this.maxLocationFramebuffer = wt.getUniformLocation(this.programFramebuffer, "u_max"),
                this.positionBuffer = wt.createBuffer(),
                this.indexBuffer = wt.createBuffer(),
                this.colorBuffer = wt.createBuffer(),
                Qt = Y.apply(this, [wt, ye]),
                Qt.attachColor()
            },
            render(Rt, wt) {
                Qt.render.apply(this, [wt])
            }
        }
    }
    function $() {
        let ye = o[Ye].getStyle().layers, et;
        for (let ze of ye)
            if (ze.type === "symbol") {
                et = ze.id;
                break
            }
        (!gt || o[Ye].getLayer(gt) === void 0) && (gt = et),
        bn(ku, c.layer = gt, c);
        let We = o[Ye].getStyle().layers.map(ze=>ze.id);
        o[Ye].getSource("box") || o[Ye].addSource("box", {
            type: "geojson",
            data: {
                type: "Feature",
                geometry: {
                    type: "Polygon",
                    coordinates: []
                }
            }
        }),
        o[Ye].getSource("line") || o[Ye].addSource("line", {
            type: "geojson",
            data: {
                type: "Feature",
                geometry: {
                    type: "LineString",
                    coordinates: []
                }
            }
        }),
        o[Ye].getLayer("custom-layer") === void 0 && o[Ye].addLayer(F(o[Ye].field, uh.vsSource, uh.fsSource, uh.fsSourceFramebuffer), gt),
        We.indexOf("box") < 0 && o[Ye].addLayer({
            id: "box",
            type: "fill",
            source: "box",
            layout: {},
            paint: {
                "fill-color": "#fff",
                "fill-opacity": .075
            }
        }),
        We.indexOf("box-outline") < 0 && o[Ye].addLayer({
            id: "box-outline",
            type: "line",
            source: "box",
            layout: {},
            paint: {
                "line-color": "#fff",
                "line-width": 2
            }
        }),
        We.indexOf("cross-line") < 0 && o[Ye].addLayer({
            id: "cross-line",
            type: "line",
            source: "line",
            layout: {},
            paint: {
                "line-color": "#0080ff",
                "line-width": 2
            }
        })
    }
    Ha(()=>{
        let ye, et;
        o[0] && o[0]._loaded ? (et = o[0].getZoom(),
        ye = o[0].getCenter()) : (et = 3.5,
        ye = [-95, 37.5]),
        bn(ws, o[Ye] = new Ic.Map({
            container: ut,
            style: gn,
            center: ye,
            zoom: et,
            maxZoom: 18,
            projection: "mercator"
        }), o),
        bn(ws, o[Ye].setLoading = Qe, o),
        bn(ws, o[Ye].updateField = Ee, o),
        Ee(Ye === 0 ? _e : x === ae ? ee : oe),
        o[Ye].on("load", function() {
            o[Ye].keyboard.disable(),
            $(),
            i[0].scan && Et.logStore(i[0].scan),
            o[0]._loaded && o[1] && o[1]._loaded && s3(o[0], o[1]);
            let We = document.createElement("div");
            We.className = "crosslabel",
            We.textContent = "A";
            let ze = document.createElement("div");
            ze.className = "crosslabel",
            ze.textContent = "B",
            An.A = new Ic.Marker(We),
            An.B = new Ic.Marker(ze),
            Ps()
        }),
        o[Ye].on("style.load", function() {
            let We = Sw("selected")
              , ze = Sw("unselected");
            o[Ye].addImage("selected", We),
            o[Ye].addImage("unselected", ze),
            $();
            let Rt = o[Ye].field;
            Rt && Qt && Qt.setType(Rt),
            i[Ye] && v[i[Ye].file] && Qt && Qt.updateData(),
            Ps()
        }),
        o[Ye].on("mousemove", Cr),
        ut.addEventListener("mouseleave", We=>{
            t(3, Tn = 0)
        }
        ),
        ut.addEventListener("mouseenter", We=>{
            p === se && !d && t(3, Tn = 1)
        }
        )
    }
    );
    function ie(ye, et) {
        let We, ze;
        o[Ye].field === ee ? (We = et[0] * 2,
        ze = et[1] * 2) : (We = et[0],
        ze = et[1]);
        let Rt = ye[0] / 255 + ye[1] / 65025 + ye[2] / 16581375;
        if (ye[3] === 255)
            return Rt * (ze - We) + We
    }
    function ue(ye) {
        let et = ie(ye, Sc[o[Ye].field]);
        if (et === void 0) {
            t(6, kt = void 0);
            return
        }
        o[Ye].field === j ? t(6, kt = et.toFixed(2)) : o[Ye].field === ne || o[Ye].field === be ? t(6, kt = et.toFixed(1)) : t(6, kt = (Math.round(et * 2) / 2).toFixed(1))
    }
    function Ee(ye) {
        if ((!(ye in on) || !on[ye]) && Qt) {
            let et = Rw(Qt.gl, ye);
            $t[ye] = et.imageData,
            on[ye] = et.texture
        }
        bn(ws, o[Ye].field = ye, o),
        t(7, Zt = ye),
        Qt && Qt.setType(ye)
    }
    function He() {
        if (c.styleid != gn) {
            let ye = c.styleid;
            ye != gn && (gt = c.layer,
            gn = ye,
            o[Ye].setStyle(ye))
        }
    }
    function Re(ye) {
        Bi[ye ? "unshift" : "push"](()=>{
            ut = ye,
            t(4, ut)
        }
        )
    }
    function Ze(ye) {
        Bi[ye ? "unshift" : "push"](()=>{
            xt = ye,
            t(5, xt)
        }
        )
    }
    return r.$$set = ye=>{
        "show"in ye && t(0, Gt = ye.show),
        "idx"in ye && t(1, Ye = ye.idx)
    }
    ,
    r.$$.update = ()=>{
        if (r.$$.dirty[0] & 4194304) {
            e: Dn()
        }
        if (r.$$.dirty[0] & 8388608) {
            e: Bt()
        }
        if (r.$$.dirty[0] & 2097152) {
            e: Mt()
        }
        if (r.$$.dirty[0] & 16384) {
            e: he("vertex data updated")
        }
        if (r.$$.dirty[0] & 8192) {
            e: he("selections updated")
        }
        if (r.$$.dirty[0] & 1048576) {
            e: ft()
        }
        if (r.$$.dirty[0] & 4096) {
            e: Ps()
        }
        if (r.$$.dirty[0] & 524288) {
            e: ds("sites")
        }
        if (r.$$.dirty[0] & 262144) {
            e: ds("alerts")
        }
        if (r.$$.dirty[0] & 131072) {
            e: ds("sws")
        }
        if (r.$$.dirty[0] & 65536) {
            e: ds("lightning")
        }
        if (r.$$.dirty[0] & 2048) {
            e: He()
        }
        if (r.$$.dirty[0] & 32768) {
            e: Te()
        }
    }
    ,
    [Gt, Ye, Kt, Tn, ut, xt, kt, Zt, zn, xe, ot, c, p, i, v, E, A, C, I, D, P, Z, fe, ce, Re, Ze]
}
var g3 = class extends mi {
    constructor(e) {
        super();
        _i(this, e, nV, tV, di, {
            show: 0,
            idx: 1,
            handleMessage: 2
        }, null, [-1, -1, -1, -1])
    }
    get handleMessage() {
        return this.$$.ctx[2]
    }
}
  , Pw = g3;
function sV(r) {
    let e, t, o, c, d, p, i, v, x, E, A, C, I, D, P, k, U, Z, K;
    return {
        c() {
            e = qe("div"),
            t = qe("div"),
            t.innerHTML = '<a href="https://quadweather.com" target="_blank"><img class="image svelte-1lhsuho" width="200" height="56" src="qwlogo.png" alt="logo"/></a>',
            o = It(),
            c = qe("div"),
            c.innerHTML = `<p class="svelte-1lhsuho">Viewing NEXRAD Level II files typically requires downloading software
            that only works on a specific operating system with difficult dependencies. With 
            this application, you can read and view Level II files in the browser, no installation
            necessary. And you can inspect the data in ways that usually require expensive licenses or subscriptions.</p>`,
            d = It(),
            p = qe("figure"),
            p.innerHTML = `<img class="heroimage svelte-1lhsuho" width="550" height="232" src="cross-hail.png" alt="logo"/> 
        <figcaption class="svelte-1lhsuho">Cross section through a supercell in Hondo, Texas on 29 April 2021 that produced a 6.4&quot; hailstone.</figcaption>`,
            i = It(),
            v = qe("div"),
            v.innerHTML = `<h3 class="svelte-1lhsuho">Steps for Viewing Historical Data</h3> 
        <ol class="svelte-1lhsuho"><li class="svelte-1lhsuho">Locate NEXRAD Level II archive files. The best source for downloading data is the <a href="https://s3.amazonaws.com/noaa-nexrad-level2/index.html" target="_blank">AWS Explorer</a>. 
                A <a href="/KLWX20120630_030520_V06.gz">sample file</a> is also available for the 29 June 2012 derecho.</li> 
            <li class="svelte-1lhsuho">Load the file into the application by either dragging and dropping it into the designated area or choosing files from your file system.</li> 
            <li class="svelte-1lhsuho">The default view is the Elevation View. The application will read the file to determine which elevation scans are present. Click
                on an elevation to view scan data. The default field is Reflectivity, but all fields present in the file can be selected in the map dropdown.</li> 
            <li class="svelte-1lhsuho">View the Reflectivity in 3D by clicking the 3D View button in the top bar then dragging a bounding box over the map. View a cross section 
                by clicking the Cross Section button and dragging a line across the map.</li> 
            <li class="svelte-1lhsuho">The application can load up to five files. Remove a file from the application by entering the File View and clicking the trashcan icon next to the file name.</li></ol>`,
            x = It(),
            E = qe("figure"),
            E.innerHTML = `<img class="heroimage svelte-1lhsuho" width="550" height="238" src="harvey.png" alt="logo"/> 
        <figcaption class="svelte-1lhsuho">3D view of Hurricane Harvey as it made landfall in Texas on 26 August 2017.</figcaption>`,
            A = It(),
            C = qe("div"),
            C.innerHTML = `<h3 class="svelte-1lhsuho">FAQs</h3> 
        <p class="q svelte-1lhsuho">The application isn&#39;t working on my computer, why?</p> 
        <p class="a svelte-1lhsuho">This application uses modern web elements like WebAssembly and WebGL2. It requires an up-to-date, modern browser, and
            a computer with a good amount of memory. It will not work on mobile.</p> 
        <p class="q svelte-1lhsuho">Why does it take so long to load velocity data?</p> 
        <p class="a svelte-1lhsuho">You likely have the application in Dealias mode. Level II data has only been lightly post-processed.
            Often, the raw velocity field suffers from a problem called &quot;aliasing&quot;, which means values fold from positive to negative
            and vice versa. Aliasing makes the velocity field impossible to interpret, so a dealiasing step is necessary. The math to
            perform dealiasing is complex, and your computer is doing heavy-duty calculations to correct the velocity field. The calculation
            can take 10 seconds or more at times.</p>`,
            I = It(),
            D = qe("div"),
            P = qe("span"),
            P.textContent = `${iV}${rV}`,
            k = It(),
            U = qe("a"),
            U.innerHTML = '<img class="twitter svelte-1lhsuho" src="logotwitter.png" alt="twitter"/>',
            Z = It(),
            K = qe("a"),
            K.textContent = "@QuadWeather",
            je(t, "class", "logo svelte-1lhsuho"),
            je(c, "class", "group svelte-1lhsuho"),
            je(p, "class", "hero svelte-1lhsuho"),
            je(v, "class", "steps svelte-1lhsuho"),
            je(E, "class", "hero svelte-1lhsuho"),
            je(C, "class", "faq svelte-1lhsuho"),
            je(P, "class", "email svelte-1lhsuho"),
            je(U, "class", "twitter svelte-1lhsuho"),
            je(U, "href", "https://twitter.com/QuadWeather"),
            je(K, "class", "email svelte-1lhsuho"),
            je(K, "href", "https://twitter.com/QuadWeather"),
            je(D, "class", "footer svelte-1lhsuho"),
            je(e, "class", "about-container svelte-1lhsuho")
        },
        m(X, W) {
            yn(X, e, W),
            Se(e, t),
            Se(e, o),
            Se(e, c),
            Se(e, d),
            Se(e, p),
            Se(e, i),
            Se(e, v),
            Se(e, x),
            Se(e, E),
            Se(e, A),
            Se(e, C),
            Se(e, I),
            Se(e, D),
            Se(D, P),
            Se(D, k),
            Se(D, U),
            Se(D, Z),
            Se(D, K)
        },
        p: Hn,
        i: Hn,
        o: Hn,
        d(X) {
            X && mn(e)
        }
    }
}
var iV = "QuadWx"
  , rV = "@gmail.com"
  , _3 = class extends mi {
    constructor(e) {
        super();
        _i(this, e, null, sV, di, {})
    }
}
  , y3 = _3;
function x3(r) {
    let e, t, o, c, d, p, i, v, x, E, A, C, I, D, P;
    return {
        c() {
            e = qe("div"),
            t = qe("form"),
            o = qe("label"),
            o.innerHTML = 'Mapbox public <a href="https://docs.mapbox.com/api/maps/styles/" target="_blank">style URL</a>',
            c = It(),
            d = qe("input"),
            i = It(),
            v = qe("label"),
            v.innerHTML = 'Layer to render before <span class="optional svelte-9gpduj"><i>(optional)</i></span>',
            x = It(),
            E = qe("input"),
            C = It(),
            I = qe("input"),
            je(o, "class", "man svelte-9gpduj"),
            je(o, "for", "styleid"),
            je(d, "class", "text-input svelte-9gpduj"),
            je(d, "type", "text"),
            je(d, "id", "styleid"),
            je(d, "name", "styleid"),
            d.value = p = r[2].value === "custom" ? r[2].styleid : "",
            je(v, "class", "man svelte-9gpduj"),
            je(v, "for", "layer"),
            je(E, "class", "text-input svelte-9gpduj"),
            je(E, "type", "text"),
            je(E, "id", "layer"),
            je(E, "name", "layer"),
            E.value = A = r[2].value === "custom" ? r[2].layer : "",
            je(I, "class", "b svelte-9gpduj"),
            je(I, "type", "button"),
            I.value = "Load Style",
            je(t, "autocomplete", "off"),
            je(e, "class", "custom-container svelte-9gpduj")
        },
        m(k, U) {
            yn(k, e, U),
            Se(e, t),
            Se(t, o),
            Se(t, c),
            Se(t, d),
            Se(t, i),
            Se(t, v),
            Se(t, x),
            Se(t, E),
            Se(t, C),
            Se(t, I),
            D || (P = wn(I, "click", r[3]),
            D = !0)
        },
        p(k, U) {
            U & 4 && p !== (p = k[2].value === "custom" ? k[2].styleid : "") && d.value !== p && (d.value = p),
            U & 4 && A !== (A = k[2].value === "custom" ? k[2].layer : "") && E.value !== A && (E.value = A)
        },
        d(k) {
            k && mn(e),
            D = !1,
            P()
        }
    }
}
function oV(r) {
    let e, t, o, c, d, p, i, v, x, E, A, C, I, D, P, k, U, Z, K, X, W, fe, ce, _e, oe, ee, j, ne, be, te, ae, se = r[0] === "custom" && x3(r);
    return {
        c() {
            e = qe("div"),
            t = qe("p"),
            t.textContent = "Basemap",
            o = It(),
            c = qe("div"),
            d = qe("label"),
            p = qe("input"),
            i = Un(`
            Default`),
            v = It(),
            x = qe("label"),
            E = qe("input"),
            A = Un(`
            Satellite`),
            C = It(),
            I = qe("label"),
            D = qe("input"),
            P = Un(`
            Traffic`),
            k = It(),
            U = qe("label"),
            Z = qe("input"),
            K = Un(`
            Custom`),
            X = It(),
            se && se.c(),
            W = It(),
            fe = qe("p"),
            fe.textContent = "Radar Data Opacity",
            ce = It(),
            _e = qe("div"),
            oe = qe("span"),
            oe.textContent = "transparent",
            ee = It(),
            j = qe("input"),
            ne = It(),
            be = qe("span"),
            be.textContent = "opaque",
            je(t, "class", "setting basemap svelte-9gpduj"),
            je(p, "type", "radio"),
            p.__value = "monochrome",
            p.value = p.__value,
            je(p, "class", "svelte-9gpduj"),
            r[9][0].push(p),
            je(d, "class", "svelte-9gpduj"),
            je(E, "type", "radio"),
            E.__value = "satellite",
            E.value = E.__value,
            je(E, "class", "svelte-9gpduj"),
            r[9][0].push(E),
            je(x, "class", "svelte-9gpduj"),
            je(D, "type", "radio"),
            D.__value = "traffic",
            D.value = D.__value,
            je(D, "class", "svelte-9gpduj"),
            r[9][0].push(D),
            je(I, "class", "svelte-9gpduj"),
            je(Z, "type", "radio"),
            Z.__value = "custom",
            Z.value = Z.__value,
            je(Z, "class", "svelte-9gpduj"),
            r[9][0].push(Z),
            je(U, "class", "svelte-9gpduj"),
            je(c, "class", "nested svelte-9gpduj"),
            je(fe, "class", "setting svelte-9gpduj"),
            je(j, "type", "range"),
            je(j, "step", "0.01"),
            je(j, "class", "slider svelte-9gpduj"),
            je(j, "id", "opacity"),
            je(j, "name", "opacity"),
            je(j, "min", "0"),
            je(j, "max", "1"),
            je(_e, "class", "slider-container svelte-9gpduj"),
            je(e, "class", "container svelte-9gpduj")
        },
        m(ke, Be) {
            yn(ke, e, Be),
            Se(e, t),
            Se(e, o),
            Se(e, c),
            Se(c, d),
            Se(d, p),
            p.checked = p.__value === r[0],
            Se(d, i),
            Se(c, v),
            Se(c, x),
            Se(x, E),
            E.checked = E.__value === r[0],
            Se(x, A),
            Se(c, C),
            Se(c, I),
            Se(I, D),
            D.checked = D.__value === r[0],
            Se(I, P),
            Se(c, k),
            Se(c, U),
            Se(U, Z),
            Z.checked = Z.__value === r[0],
            Se(U, K),
            Se(e, X),
            se && se.m(e, null),
            Se(e, W),
            Se(e, fe),
            Se(e, ce),
            Se(e, _e),
            Se(_e, oe),
            Se(_e, ee),
            Se(_e, j),
            j_(j, r[1]),
            Se(_e, ne),
            Se(_e, be),
            te || (ae = [wn(p, "keydown", Ga(r[7])), wn(p, "change", r[8]), wn(E, "keydown", Ga(r[6])), wn(E, "change", r[10]), wn(D, "keydown", Ga(r[5])), wn(D, "change", r[11]), wn(Z, "keydown", Ga(r[4])), wn(Z, "change", r[12]), wn(j, "change", r[13]), wn(j, "input", r[13])],
            te = !0)
        },
        p(ke, [Be]) {
            Be & 1 && (p.checked = p.__value === ke[0]),
            Be & 1 && (E.checked = E.__value === ke[0]),
            Be & 1 && (D.checked = D.__value === ke[0]),
            Be & 1 && (Z.checked = Z.__value === ke[0]),
            ke[0] === "custom" ? se ? se.p(ke, Be) : (se = x3(ke),
            se.c(),
            se.m(e, W)) : se && (se.d(1),
            se = null),
            Be & 2 && j_(j, ke[1])
        },
        i: Hn,
        o: Hn,
        d(ke) {
            ke && mn(e),
            r[9][0].splice(r[9][0].indexOf(p), 1),
            r[9][0].splice(r[9][0].indexOf(E), 1),
            r[9][0].splice(r[9][0].indexOf(D), 1),
            r[9][0].splice(r[9][0].indexOf(Z), 1),
            se && se.d(),
            te = !1,
            Wi(ae)
        }
    }
}
function aV(r, e, t) {
    let o, c;
    Ht(r, lm, fe=>t(14, o = fe)),
    Ht(r, ku, fe=>t(2, c = fe));
    let d = c.value
      , p = o.opacity
      , i = {
        monochrome: "mapbox://styles/quadweather/cksxhy0l281db18nvnnfvdigv",
        satellite: "mapbox://styles/mapbox/satellite-streets-v12",
        traffic: "mapbox://styles/mapbox/navigation-night-v1"
    };
    function v() {
        if (d === "custom")
            return;
        let fe;
        d === "satellite" && (fe = "tunnel-minor-case"),
        d === "monochrome" && (fe = "land-structure-line"),
        d === "traffic" && (fe = "turning-feature-outline-navigation"),
        bn(ku, c = {
            value: d,
            styleid: i[d],
            layer: fe
        }, c)
    }
    function x(fe) {
        Yi.update(ce=>(ce.error = !0,
        ce.message = `There was an error loading the style ${fe}. Please check that the style URL is correct and that the style is public.`,
        ce.header = "Style not loaded",
        ce.color = "normal",
        ce))
    }
    async function E(fe) {
        let ce = document.getElementById("styleid").value
          , _e = document.getElementById("layer").value;
        if (ce) {
            let oe = /mapbox:\/\/styles\/([a-zA-Z0-9\-]*)\/([\s\S]*)/i
              , ee = ce.match(oe);
            if (!ee || ee.length != 3) {
                x(ce);
                return
            }
            let j;
            if (await fetch(`https://api.mapbox.com/styles/v1/${ee[1]}/${ee[2]}?access_token=pk.eyJ1IjoicXVhZHdlYXRoZXIiLCJhIjoiY2w2YXZ4YjAzMWdmODNkbWx5YmwycjcxaSJ9.DOMnL520hn-dTFcGgkH2BQ`).then(ne=>{
                if (!ne.ok)
                    throw new Error("Network response was not OK");
                j = 1
            }
            ).catch(ne=>{
                j = 0
            }
            ),
            !j) {
                x(ce);
                return
            }
            bn(ku, c = {
                value: d,
                styleid: ce,
                layer: _e
            }, c)
        }
    }
    function A() {
        let fe = {
            ...o
        };
        fe.opacity = p,
        bn(lm, o = fe, o)
    }
    let C = [[]];
    function I(fe) {
        Wa.call(this, r, fe)
    }
    function D(fe) {
        Wa.call(this, r, fe)
    }
    function P(fe) {
        Wa.call(this, r, fe)
    }
    function k(fe) {
        Wa.call(this, r, fe)
    }
    function U() {
        d = this.__value,
        t(0, d)
    }
    function Z() {
        d = this.__value,
        t(0, d)
    }
    function K() {
        d = this.__value,
        t(0, d)
    }
    function X() {
        d = this.__value,
        t(0, d)
    }
    function W() {
        p = gv(this.value),
        t(1, p)
    }
    return r.$$.update = ()=>{
        if (r.$$.dirty & 1) {
            e: v()
        }
        if (r.$$.dirty & 2) {
            e: A()
        }
    }
    ,
    [d, p, c, E, I, D, P, k, U, C, Z, K, X, W]
}
var v3 = class extends mi {
    constructor(e) {
        super();
        _i(this, e, aV, oV, di, {})
    }
}
  , b3 = v3;
function w3(r) {
    let e, t, o, c, d, p, i, v, x, E;
    return {
        c() {
            e = qe("div"),
            t = qe("button"),
            t.textContent = "Sites",
            o = It(),
            c = qe("button"),
            c.textContent = "Alerts",
            d = It(),
            p = qe("button"),
            p.textContent = "Statements",
            i = It(),
            v = qe("button"),
            v.textContent = "Lightning",
            je(t, "class", "layer-button svelte-1gzp6sh"),
            Gn(t, "layer-active", !!r[9]),
            je(c, "class", "layer-button svelte-1gzp6sh"),
            Gn(c, "layer-active", !!r[8]),
            je(p, "class", "layer-button svelte-1gzp6sh"),
            Gn(p, "layer-active", !!r[7]),
            je(v, "class", "layer-button svelte-1gzp6sh"),
            Gn(v, "layer-active", !!r[6]),
            je(e, "class", "layer-container svelte-1gzp6sh")
        },
        m(A, C) {
            yn(A, e, C),
            Se(e, t),
            Se(e, o),
            Se(e, c),
            Se(e, d),
            Se(e, p),
            Se(e, i),
            Se(e, v),
            x || (E = [wn(t, "click", r[25]), wn(c, "click", r[26]), wn(p, "click", r[27]), wn(v, "click", r[28])],
            x = !0)
        },
        p(A, C) {
            C[0] & 512 && Gn(t, "layer-active", !!A[9]),
            C[0] & 256 && Gn(c, "layer-active", !!A[8]),
            C[0] & 128 && Gn(p, "layer-active", !!A[7]),
            C[0] & 64 && Gn(v, "layer-active", !!A[6])
        },
        d(A) {
            A && mn(e),
            x = !1,
            Wi(E)
        }
    }
}
function T3(r) {
    let e, t, o;
    return {
        c() {
            e = qe("button"),
            e.textContent = "Log in",
            je(e, "class", "main account svelte-1gzp6sh"),
            Gn(e, "active", r[5] === "open")
        },
        m(c, d) {
            yn(c, e, d),
            t || (o = wn(e, "click", r[31]),
            t = !0)
        },
        p(c, d) {
            d[0] & 32 && Gn(e, "active", c[5] === "open")
        },
        d(c) {
            c && mn(e),
            t = !1,
            o()
        }
    }
}
function E3(r) {
    let e, t, o;
    return {
        c() {
            e = qe("button"),
            e.textContent = "Account",
            je(e, "class", "main account svelte-1gzp6sh"),
            Gn(e, "active", r[5] === "open")
        },
        m(c, d) {
            yn(c, e, d),
            t || (o = wn(e, "click", r[30]),
            t = !0)
        },
        p(c, d) {
            d[0] & 32 && Gn(e, "active", c[5] === "open")
        },
        d(c) {
            c && mn(e),
            t = !1,
            o()
        }
    }
}
function A3(r) {
    let e, t, o, c = (r[3] ? r[3].nickname : "") + "", d, p, i, v = (r[3] ? r[3].email : "") + "", x, E, A, C, I, D, P, k, U, Z = r[4] && S3(r);
    return {
        c() {
            e = qe("div"),
            t = qe("div"),
            o = qe("span"),
            d = Un(c),
            p = It(),
            i = qe("span"),
            x = Un(v),
            E = It(),
            A = qe("div"),
            C = qe("button"),
            C.textContent = "Log Out",
            I = It(),
            D = qe("button"),
            D.textContent = "Delete Account",
            P = It(),
            Z && Z.c(),
            je(o, "class", "bold svelte-1gzp6sh"),
            je(i, "class", "secondary svelte-1gzp6sh"),
            je(t, "class", "row svelte-1gzp6sh"),
            je(C, "class", "logout svelte-1gzp6sh"),
            je(D, "class", "subtle svelte-1gzp6sh"),
            je(A, "class", "acontainer svelte-1gzp6sh"),
            je(e, "class", "settings-container svelte-1gzp6sh")
        },
        m(K, X) {
            yn(K, e, X),
            Se(e, t),
            Se(t, o),
            Se(o, d),
            Se(t, p),
            Se(t, i),
            Se(i, x),
            Se(e, E),
            Se(e, A),
            Se(A, C),
            Se(A, I),
            Se(A, D),
            Se(e, P),
            Z && Z.m(e, null),
            k || (U = [wn(C, "click", r[29]), wn(D, "click", r[32])],
            k = !0)
        },
        p(K, X) {
            X[0] & 8 && c !== (c = (K[3] ? K[3].nickname : "") + "") && gi(d, c),
            X[0] & 8 && v !== (v = (K[3] ? K[3].email : "") + "") && gi(x, v),
            K[4] ? Z ? Z.p(K, X) : (Z = S3(K),
            Z.c(),
            Z.m(e, null)) : Z && (Z.d(1),
            Z = null)
        },
        d(K) {
            K && mn(e),
            Z && Z.d(),
            k = !1,
            Wi(U)
        }
    }
}
function S3(r) {
    let e, t, o, c, d, p, i, v;
    return {
        c() {
            e = qe("div"),
            t = qe("p"),
            t.textContent = "Are you sure you want to delete your account?",
            o = It(),
            c = qe("button"),
            c.textContent = "Cancel",
            d = It(),
            p = qe("button"),
            p.textContent = "Delete",
            je(t, "class", "suretext svelte-1gzp6sh"),
            je(c, "class", "logout svelte-1gzp6sh"),
            je(p, "class", "delete svelte-1gzp6sh"),
            je(e, "class", "sure svelte-1gzp6sh")
        },
        m(x, E) {
            yn(x, e, E),
            Se(e, t),
            Se(e, o),
            Se(e, c),
            Se(e, d),
            Se(e, p),
            i || (v = [wn(c, "click", r[33]), wn(p, "click", r[34])],
            i = !0)
        },
        p: Hn,
        d(x) {
            x && mn(e),
            i = !1,
            Wi(v)
        }
    }
}
function M3(r) {
    let e, t;
    return e = new y3({}),
    {
        c() {
            Qi(e.$$.fragment)
        },
        m(o, c) {
            qi(e, o, c),
            t = !0
        },
        i(o) {
            t || (Wn(e.$$.fragment, o),
            t = !0)
        },
        o(o) {
            ri(e.$$.fragment, o),
            t = !1
        },
        d(o) {
            Ki(e, o)
        }
    }
}
function I3(r) {
    let e, t;
    return e = new b3({}),
    {
        c() {
            Qi(e.$$.fragment)
        },
        m(o, c) {
            qi(e, o, c),
            t = !0
        },
        i(o) {
            t || (Wn(e.$$.fragment, o),
            t = !0)
        },
        o(o) {
            ri(e.$$.fragment, o),
            t = !1
        },
        d(o) {
            Ki(e, o)
        }
    }
}
function lV(r) {
    let e, t, o, c, d, p, i, v, x, E, A, C, I, D, P, k, U, Z, K, X, W, fe, ce, _e, oe, ee = r[10] === r[17] && w3(r), j = !r[0] && T3(r), ne = r[0] && E3(r), be = r[5] === "open" && A3(r), te = r[1] && M3(r), ae = r[2] && I3(r);
    return {
        c() {
            e = qe("div"),
            t = qe("div"),
            o = qe("button"),
            o.textContent = "Dual Map",
            c = It(),
            d = qe("button"),
            d.textContent = "3D View",
            p = It(),
            i = qe("button"),
            i.textContent = "Cross Section",
            v = It(),
            x = qe("button"),
            x.textContent = "Dealias",
            E = It(),
            A = qe("button"),
            A.textContent = "Live Radar",
            C = It(),
            ee && ee.c(),
            I = It(),
            D = qe("div"),
            P = qe("button"),
            P.textContent = "Appearance",
            k = It(),
            U = qe("button"),
            U.textContent = "About",
            Z = It(),
            j && j.c(),
            K = It(),
            ne && ne.c(),
            X = It(),
            be && be.c(),
            W = It(),
            te && te.c(),
            fe = It(),
            ae && ae.c(),
            je(o, "class", "main svelte-1gzp6sh"),
            Gn(o, "active", r[13] === Sr),
            je(d, "class", "main svelte-1gzp6sh"),
            Gn(d, "active", r[12] === r[15]),
            je(i, "class", "main svelte-1gzp6sh"),
            Gn(i, "active", r[12] === r[16]),
            je(x, "class", "main svelte-1gzp6sh"),
            Gn(x, "active", r[11] === r[14]),
            je(A, "class", "main svelte-1gzp6sh"),
            Gn(A, "active", r[10] === r[17]),
            je(t, "class", "leftgroup"),
            je(P, "class", "main svelte-1gzp6sh"),
            Gn(P, "active", !!r[2]),
            je(U, "class", "main svelte-1gzp6sh"),
            Gn(U, "active", !!r[1]),
            je(D, "class", "rightgroup"),
            je(e, "class", "barContainer svelte-1gzp6sh")
        },
        m(se, ke) {
            yn(se, e, ke),
            Se(e, t),
            Se(t, o),
            Se(t, c),
            Se(t, d),
            Se(t, p),
            Se(t, i),
            Se(t, v),
            Se(t, x),
            Se(t, E),
            Se(t, A),
            Se(t, C),
            ee && ee.m(t, null),
            Se(e, I),
            Se(e, D),
            Se(D, P),
            Se(D, k),
            Se(D, U),
            Se(D, Z),
            j && j.m(D, null),
            Se(D, K),
            ne && ne.m(D, null),
            Se(D, X),
            be && be.m(D, null),
            Se(D, W),
            te && te.m(D, null),
            Se(D, fe),
            ae && ae.m(D, null),
            ce = !0,
            _e || (oe = [wn(o, "click", r[18]), wn(d, "click", r[19]), wn(i, "click", r[20]), wn(x, "click", r[21]), wn(A, "click", r[24]), wn(P, "click", r[23]), wn(U, "click", r[22])],
            _e = !0)
        },
        p(se, ke) {
            ke[0] & 8192 && Gn(o, "active", se[13] === Sr),
            ke[0] & 36864 && Gn(d, "active", se[12] === se[15]),
            ke[0] & 69632 && Gn(i, "active", se[12] === se[16]),
            ke[0] & 18432 && Gn(x, "active", se[11] === se[14]),
            ke[0] & 132096 && Gn(A, "active", se[10] === se[17]),
            se[10] === se[17] ? ee ? ee.p(se, ke) : (ee = w3(se),
            ee.c(),
            ee.m(t, null)) : ee && (ee.d(1),
            ee = null),
            ke[0] & 4 && Gn(P, "active", !!se[2]),
            ke[0] & 2 && Gn(U, "active", !!se[1]),
            se[0] ? j && (j.d(1),
            j = null) : j ? j.p(se, ke) : (j = T3(se),
            j.c(),
            j.m(D, K)),
            se[0] ? ne ? ne.p(se, ke) : (ne = E3(se),
            ne.c(),
            ne.m(D, X)) : ne && (ne.d(1),
            ne = null),
            se[5] === "open" ? be ? be.p(se, ke) : (be = A3(se),
            be.c(),
            be.m(D, W)) : be && (be.d(1),
            be = null),
            se[1] ? te ? ke[0] & 2 && Wn(te, 1) : (te = M3(se),
            te.c(),
            Wn(te, 1),
            te.m(D, fe)) : te && (eo(),
            ri(te, 1, 1, ()=>{
                te = null
            }
            ),
            to()),
            se[2] ? ae ? ke[0] & 4 && Wn(ae, 1) : (ae = I3(se),
            ae.c(),
            Wn(ae, 1),
            ae.m(D, null)) : ae && (eo(),
            ri(ae, 1, 1, ()=>{
                ae = null
            }
            ),
            to())
        },
        i(se) {
            ce || (Wn(te),
            Wn(ae),
            ce = !0)
        },
        o(se) {
            ri(te),
            ri(ae),
            ce = !1
        },
        d(se) {
            se && mn(e),
            ee && ee.d(),
            j && j.d(),
            ne && ne.d(),
            be && be.d(),
            te && te.d(),
            ae && ae.d(),
            _e = !1,
            Wi(oe)
        }
    }
}
function cV(r, e, t) {
    let o, c, d, p, i, v, x, E, A, C, I, D, P, k, U;
    Ht(r, Sd, ot=>t(0, o = ot)),
    Ht(r, wy, ot=>t(5, c = ot)),
    Ht(r, Pu, ot=>t(6, d = ot)),
    Ht(r, Ru, ot=>t(7, p = ot)),
    Ht(r, ec, ot=>t(8, i = ot)),
    Ht(r, Ql, ot=>t(9, v = ot)),
    Ht(r, js, ot=>t(10, x = ot)),
    Ht(r, Za, ot=>t(11, E = ot)),
    Ht(r, Xa, ot=>t(35, A = ot)),
    Ht(r, ai, ot=>t(36, C = ot)),
    Ht(r, ui, ot=>t(37, I = ot)),
    Ht(r, Ms, ot=>t(38, D = ot)),
    Ht(r, zr, ot=>t(12, P = ot)),
    Ht(r, Ws, ot=>t(39, k = ot)),
    Ht(r, Jr, ot=>t(13, U = ot));
    let Z = Qs(), {DEALIASED: K, RAW: X} = da, {READING: W, MODE3D: fe, CROSS: ce} = Yr, {HISTORICAL: _e, LIVE: oe} = Gs, ee = 0, j = 0, ne, be, te = !1;
    function ae() {
        U === Y_ ? bn(Jr, U = Sr, U) : U === Sr ? bn(Jr, U = ja, U) : U === ja && (bn(Jr, U = Sr, U),
        Z("message", {
            value: "activateMap",
            idx: 1
        }))
    }
    function se() {
        if (k === null || C[k] === void 0) {
            bn(zr, P = W, P);
            return
        }
        if (bn(zr, P = P === fe ? W : fe, P),
        P === fe)
            if (D[I[0].file] === void 0) {
                let ot = Tu.enqueue({
                    fileNum: I[0].file,
                    field: 254,
                    fileName: I[0].scan.fileName,
                    idx: 255,
                    selections: I,
                    scans: C
                });
                bn(Xa, A = !0, A)
            } else
                Z("message", {
                    value: "loadTexture"
                });
        else
            Z("message", {
                value: "removeBox"
            }),
            Z("message", {
                value: "removeLine"
            })
    }
    function ke() {
        if (k === null || C[k] === void 0) {
            bn(zr, P = W, P);
            return
        }
        if (bn(zr, P = P === ce ? W : ce, P),
        P === ce)
            if (D[I[0].file] === void 0) {
                let ot = Tu.enqueue({
                    fileNum: I[0].file,
                    field: 254,
                    fileName: I[0].scan.fileName,
                    idx: 255,
                    selections: I,
                    scans: C
                });
                bn(Xa, A = !0, A)
            } else
                Z("message", {
                    value: "loadTexture"
                });
        else
            Z("message", {
                value: "removeLine"
            }),
            Z("message", {
                value: "removeBox"
            })
    }
    function Be() {
        bn(Za, E = E === K ? X : K, E),
        Z("message", {
            value: "setDealiasState"
        })
    }
    function tt() {
        t(1, ee = ee ? 0 : 1)
    }
    function Ke() {
        t(2, j = j ? 0 : 1)
    }
    async function bt() {
        if (x === _e && !await es.isAuthenticated()) {
            Ja.update(ot=>(ot.error = !0,
            ot.message = "An account is needed to view live radar. Create a free account at",
            ot.header = "Not logged in",
            ot));
            return
        }
        bn(js, x = x === _e ? oe : _e, x),
        x === oe ? (bn(ec, i = !0, i),
        bn(Ql, v = !0, v),
        ji.ws && ji.ws.isAlive ? console.log("alive") : ji.connect().then(function(ot) {
            Z("message", {
                value: "showSites"
            }),
            Z("message", {
                value: "showAlerts"
            }),
            Z("message", {
                value: "showStatements"
            }),
            Z("message", {
                value: "showLightning"
            })
        }).catch(function(ot) {
            console.log("ws connect failed", ot)
        })) : (bn(ec, i = !1, i),
        bn(Ql, v = !1, v),
        bn(Ru, p = !1, p),
        bn(Pu, d = !1, d),
        ji.ws.close())
    }
    function Et() {
        v ? bn(Ql, v = !1, v) : (bn(Ql, v = !0, v),
        Z("message", {
            value: "showSites"
        }))
    }
    function Gt() {
        i ? bn(ec, i = !1, i) : bn(ec, i = !0, i)
    }
    function Ye() {
        p ? bn(Ru, p = !1, p) : bn(Ru, p = !0, p)
    }
    function gn() {
        d ? bn(Pu, d = !1, d) : bn(Pu, d = !0, d)
    }
    async function gt() {
        es.logout()
    }
    function Tn() {
        c === "open" ? (bn(wy, c = "closed", c),
        t(4, te = !1)) : bn(wy, c = "open", c)
    }
    async function xn() {
        await es.isAuthenticated() || await es.login()
    }
    async function Dn() {
        o && es && t(3, be = await es.getUser())
    }
    async function Bt() {
        t(4, te = !0)
    }
    function An() {
        t(4, te = !1)
    }
    async function ut() {
        let ot = await es.getToken();
        fetch("https://radar.quadweather.com/socket/delete", {
            headers: {
                Authorization: `Bearer ${ot}`
            }
        }).then(xt=>xt.json()).then(xt=>{
            xt.message === "deleted" && gt()
        }
        )
    }
    return r.$$.update = ()=>{
        if (r.$$.dirty[0] & 1) {
            e: Dn()
        }
    }
    ,
    [o, ee, j, be, te, c, d, p, i, v, x, E, P, U, K, fe, ce, oe, ae, se, ke, Be, tt, Ke, bt, Et, Gt, Ye, gn, gt, Tn, xn, Bt, An, ut]
}
var C3 = class extends mi {
    constructor(e) {
        super();
        _i(this, e, cV, lV, di, {}, null, [-1, -1])
    }
}
  , D3 = C3;
function uV(r) {
    let e, t, o, c, d, p, i, v, x, E, A, C, I;
    return {
        c() {
            e = qe("div"),
            t = qe("div"),
            o = qe("p"),
            c = Un(r[0]),
            d = It(),
            p = qe("div"),
            p.innerHTML = '<div class="body-text svelte-tefax4"><p>A free account is needed to view live radar.</p></div>',
            i = It(),
            v = qe("div"),
            x = qe("button"),
            x.textContent = "Create Account",
            E = It(),
            A = qe("button"),
            A.textContent = "Close",
            je(o, "class", "header-text svelte-tefax4"),
            je(t, "class", "notice-header svelte-tefax4"),
            je(p, "class", "notice-body svelte-tefax4"),
            je(x, "class", "svelte-tefax4"),
            je(A, "class", "svelte-tefax4"),
            je(v, "class", "close svelte-tefax4"),
            je(e, "class", "notice-wrapper svelte-tefax4")
        },
        m(D, P) {
            yn(D, e, P),
            Se(e, t),
            Se(t, o),
            Se(o, c),
            Se(e, d),
            Se(e, p),
            Se(e, i),
            Se(e, v),
            Se(v, x),
            Se(v, E),
            Se(v, A),
            C || (I = [wn(x, "click", r[1]), wn(A, "click", r[2])],
            C = !0)
        },
        p(D, [P]) {
            P & 1 && gi(c, D[0])
        },
        i: Hn,
        o: Hn,
        d(D) {
            D && mn(e),
            C = !1,
            Wi(I)
        }
    }
}
function hV(r, e, t) {
    let o;
    Ht(r, Ja, x=>t(4, o = x));
    let {header: c} = e
      , {body: d} = e
      , p = Qs();
    async function i() {
        await es.isAuthenticated() || await es.login(),
        v()
    }
    function v() {
        bn(Ja, o.error = !1, o),
        p("message", {
            value: "hideModal"
        })
    }
    return r.$$set = x=>{
        "header"in x && t(0, c = x.header),
        "body"in x && t(3, d = x.body)
    }
    ,
    [c, i, v, d]
}
var L3 = class extends mi {
    constructor(e) {
        super();
        _i(this, e, hV, uV, di, {
            header: 0,
            body: 3
        })
    }
}
  , R3 = L3;
function dV(r, e, t) {
    let o, c, d, p, i, v, x, E, A;
    Ht(r, by, ce=>t(0, o = ce)),
    Ht(r, Ja, ce=>t(1, c = ce)),
    Ht(r, Yi, ce=>t(2, d = ce)),
    Ht(r, Ws, ce=>t(3, p = ce)),
    Ht(r, bs, ce=>t(4, i = ce)),
    Ht(r, ui, ce=>t(5, v = ce)),
    Ht(r, zr, ce=>t(8, x = ce)),
    Ht(r, Ms, ce=>t(9, E = ce)),
    Ht(r, Jr, ce=>t(6, A = ce));
    let {READING: C, MODE3D: I, CROSS: D} = Yr, P = Qs(), k;
    function U() {
        for (let ce = 0; ce < k; ce++)
            if (!!v[ce] && i[v[ce].file] !== void 0) {
                if (i[v[ce].file][v[ce].type][v[ce].elevation] === void 0)
                    continue;
                P("message", {
                    value: "loadVertices",
                    idx: ce
                })
            }
    }
    function Z() {
        for (let ce = 0; ce < k; ce++)
            if (!!v[ce] && !(v[ce].file === null || i[v[ce].file] === void 0)) {
                if (i[v[ce].file][v[ce].type][v[ce].elevation] === void 0)
                    continue;
                P("message", {
                    value: "loadVertices",
                    idx: ce
                })
            }
    }
    function K() {
        if (x === I || x === D) {
            if (E[v[0].file] === void 0)
                return;
            P("message", {
                value: "loadTexture"
            })
        }
    }
    function X() {
        d.error && P("message", {
            value: "showError"
        })
    }
    function W() {
        c.error && P("message", {
            value: "showModal"
        })
    }
    function fe() {
        if (o) {
            for (let ce = 0; ce < k; ce++)
                P("message", {
                    value: "clearMap",
                    idx: ce
                });
            x === I && P("message", {
                value: "removeBox"
            }),
            x === D && P("message", {
                value: "removeLine"
            }),
            bn(by, o = !1, o)
        }
    }
    return r.$$.update = ()=>{
        if (r.$$.dirty & 64) {
            e: A === Sr ? k = 2 : k = 1
        }
        if (r.$$.dirty & 32) {
            e: U()
        }
        if (r.$$.dirty & 16) {
            e: Z()
        }
        if (r.$$.dirty & 8) {
            e: K()
        }
        if (r.$$.dirty & 4) {
            e: X()
        }
        if (r.$$.dirty & 2) {
            e: W()
        }
        if (r.$$.dirty & 1) {
            e: fe()
        }
    }
    ,
    [o, c, d, p, i, v, A]
}
var P3 = class extends mi {
    constructor(e) {
        super();
        _i(this, e, dV, null, di, {})
    }
}
  , k3 = P3;
function fV(r) {
    let e, t, o, c, d, p, i, v, x, E, A, C, I, D, P;
    return {
        c() {
            e = qe("div"),
            t = qe("div"),
            o = qe("p"),
            c = Un(r[0]),
            p = It(),
            i = qe("div"),
            v = qe("div"),
            x = qe("p"),
            E = Un(r[1]),
            A = It(),
            C = qe("div"),
            I = qe("button"),
            I.textContent = "Okay",
            je(o, "class", "header-text svelte-1knftiy"),
            je(t, "class", d = "" + (W_(`notice-header ${r[2]}`) + " svelte-1knftiy")),
            je(v, "class", "body-text svelte-1knftiy"),
            je(i, "class", "notice-body svelte-1knftiy"),
            je(I, "class", "svelte-1knftiy"),
            je(C, "class", "close svelte-1knftiy"),
            je(e, "class", "notice-wrapper svelte-1knftiy")
        },
        m(k, U) {
            yn(k, e, U),
            Se(e, t),
            Se(t, o),
            Se(o, c),
            Se(e, p),
            Se(e, i),
            Se(i, v),
            Se(v, x),
            Se(x, E),
            Se(e, A),
            Se(e, C),
            Se(C, I),
            D || (P = wn(I, "click", r[3]),
            D = !0)
        },
        p(k, [U]) {
            U & 1 && gi(c, k[0]),
            U & 4 && d !== (d = "" + (W_(`notice-header ${k[2]}`) + " svelte-1knftiy")) && je(t, "class", d),
            U & 2 && gi(E, k[1])
        },
        i: Hn,
        o: Hn,
        d(k) {
            k && mn(e),
            D = !1,
            P()
        }
    }
}
function pV(r, e, t) {
    let o;
    Ht(r, Yi, x=>t(4, o = x));
    let {header: c} = e
      , {body: d} = e
      , {className: p} = e
      , i = Qs();
    function v() {
        bn(Yi, o.error = !1, o),
        bn(Yi, o.color = null, o),
        i("message", {
            value: "hideError"
        })
    }
    return r.$$set = x=>{
        "header"in x && t(0, c = x.header),
        "body"in x && t(1, d = x.body),
        "className"in x && t(2, p = x.className)
    }
    ,
    [c, d, p, v]
}
var z3 = class extends mi {
    constructor(e) {
        super();
        _i(this, e, pV, fV, di, {
            header: 0,
            body: 1,
            className: 2
        })
    }
}
  , O3 = z3;
function N3(r) {
    let e;
    return {
        c() {
            e = qe("hr"),
            je(e, "class", "line svelte-se3vb7")
        },
        m(t, o) {
            yn(t, e, o)
        },
        d(t) {
            t && mn(e)
        }
    }
}
function F3(r) {
    let e, t, o = {
        show: r[1],
        idx: 1
    };
    return e = new Pw({
        props: o
    }),
    r[17](e),
    e.$on("message", r[12]),
    {
        c() {
            Qi(e.$$.fragment)
        },
        m(c, d) {
            qi(e, c, d),
            t = !0
        },
        p(c, d) {
            let p = {};
            d & 2 && (p.show = c[1]),
            e.$set(p)
        },
        i(c) {
            t || (Wn(e.$$.fragment, c),
            t = !0)
        },
        o(c) {
            ri(e.$$.fragment, c),
            t = !1
        },
        d(c) {
            r[17](null),
            Ki(e, c)
        }
    }
}
function mV(r) {
    let e;
    return {
        c() {
            e = qe("div"),
            e.innerHTML = '<div class="lds-ripple svelte-se3vb7"><div class="svelte-se3vb7"></div><div class="svelte-se3vb7"></div></div>',
            je(e, "class", "loading svelte-se3vb7")
        },
        m(t, o) {
            yn(t, e, o)
        },
        d(t) {
            t && mn(e)
        }
    }
}
function B3(r) {
    let e, t;
    return e = new O3({
        props: {
            header: r[4],
            body: r[5],
            className: r[6]
        }
    }),
    e.$on("message", r[12]),
    {
        c() {
            Qi(e.$$.fragment)
        },
        m(o, c) {
            qi(e, o, c),
            t = !0
        },
        p(o, c) {
            let d = {};
            c & 16 && (d.header = o[4]),
            c & 32 && (d.body = o[5]),
            c & 64 && (d.className = o[6]),
            e.$set(d)
        },
        i(o) {
            t || (Wn(e.$$.fragment, o),
            t = !0)
        },
        o(o) {
            ri(e.$$.fragment, o),
            t = !1
        },
        d(o) {
            Ki(e, o)
        }
    }
}
function U3(r) {
    let e, t;
    return e = new R3({
        props: {
            header: r[7],
            body: r[8]
        }
    }),
    e.$on("message", r[12]),
    {
        c() {
            Qi(e.$$.fragment)
        },
        m(o, c) {
            qi(e, o, c),
            t = !0
        },
        p(o, c) {
            let d = {};
            c & 128 && (d.header = o[7]),
            c & 256 && (d.body = o[8]),
            e.$set(d)
        },
        i(o) {
            t || (Wn(e.$$.fragment, o),
            t = !0)
        },
        o(o) {
            ri(e.$$.fragment, o),
            t = !1
        },
        d(o) {
            Ki(e, o)
        }
    }
}
function _V(r) {
    let e, t, o, c, d, p, i, v, x, E, A, C, I, D, P, k, U, Z, K, X;
    t = new D3({}),
    t.$on("message", r[12]);
    function W(te) {
        r[14](te)
    }
    function fe(te) {
        r[15](te)
    }
    let ce = {};
    r[9] !== void 0 && (ce.elevationFunctions = r[9]),
    r[10] !== void 0 && (ce.canvas = r[10]),
    d = new JC({
        props: ce
    }),
    Bi.push(()=>ha(d, "elevationFunctions", W)),
    Bi.push(()=>ha(d, "canvas", fe));
    let _e = {
        show: !0,
        idx: 0
    };
    E = new Pw({
        props: _e
    }),
    r[16](E),
    E.$on("message", r[12]);
    let oe = r[0] === Sr && N3(r)
      , ee = (r[0] === Sr || r[0] === ja) && F3(r);
    D = new k3({}),
    D.$on("message", r[12]);
    let j = gV && mV(r)
      , ne = r[2] && B3(r)
      , be = r[3] && U3(r);
    return {
        c() {
            e = qe("div"),
            Qi(t.$$.fragment),
            o = It(),
            c = qe("div"),
            Qi(d.$$.fragment),
            v = It(),
            x = qe("div"),
            Qi(E.$$.fragment),
            A = It(),
            oe && oe.c(),
            C = It(),
            ee && ee.c(),
            I = It(),
            Qi(D.$$.fragment),
            P = It(),
            j && j.c(),
            k = It(),
            ne && ne.c(),
            U = It(),
            be && be.c(),
            je(x, "class", "map-display svelte-se3vb7"),
            je(c, "class", "main-display svelte-se3vb7"),
            je(e, "class", "parent svelte-se3vb7")
        },
        m(te, ae) {
            yn(te, e, ae),
            qi(t, e, null),
            Se(e, o),
            Se(e, c),
            qi(d, c, null),
            Se(c, v),
            Se(c, x),
            qi(E, x, null),
            Se(x, A),
            oe && oe.m(x, null),
            Se(x, C),
            ee && ee.m(x, null),
            Se(c, I),
            qi(D, c, null),
            Se(c, P),
            j && j.m(c, null),
            Se(e, k),
            ne && ne.m(e, null),
            Se(e, U),
            be && be.m(e, null),
            Z = !0,
            K || (X = wn(window, "keydown", r[13]),
            K = !0)
        },
        p(te, [ae]) {
            let se = {};
            !p && ae & 512 && (p = !0,
            se.elevationFunctions = te[9],
            ua(()=>p = !1)),
            !i && ae & 1024 && (i = !0,
            se.canvas = te[10],
            ua(()=>i = !1)),
            d.$set(se);
            let ke = {};
            E.$set(ke),
            te[0] === Sr ? oe || (oe = N3(te),
            oe.c(),
            oe.m(x, C)) : oe && (oe.d(1),
            oe = null),
            te[0] === Sr || te[0] === ja ? ee ? (ee.p(te, ae),
            ae & 1 && Wn(ee, 1)) : (ee = F3(te),
            ee.c(),
            Wn(ee, 1),
            ee.m(x, null)) : ee && (eo(),
            ri(ee, 1, 1, ()=>{
                ee = null
            }
            ),
            to()),
            te[2] ? ne ? (ne.p(te, ae),
            ae & 4 && Wn(ne, 1)) : (ne = B3(te),
            ne.c(),
            Wn(ne, 1),
            ne.m(e, U)) : ne && (eo(),
            ri(ne, 1, 1, ()=>{
                ne = null
            }
            ),
            to()),
            te[3] ? be ? (be.p(te, ae),
            ae & 8 && Wn(be, 1)) : (be = U3(te),
            be.c(),
            Wn(be, 1),
            be.m(e, null)) : be && (eo(),
            ri(be, 1, 1, ()=>{
                be = null
            }
            ),
            to())
        },
        i(te) {
            Z || (Wn(t.$$.fragment, te),
            Wn(d.$$.fragment, te),
            Wn(E.$$.fragment, te),
            Wn(ee),
            Wn(D.$$.fragment, te),
            Wn(ne),
            Wn(be),
            Z = !0)
        },
        o(te) {
            ri(t.$$.fragment, te),
            ri(d.$$.fragment, te),
            ri(E.$$.fragment, te),
            ri(ee),
            ri(D.$$.fragment, te),
            ri(ne),
            ri(be),
            Z = !1
        },
        d(te) {
            te && mn(e),
            Ki(t),
            Ki(d),
            r[16](null),
            Ki(E),
            oe && oe.d(),
            ee && ee.d(),
            Ki(D),
            j && j.d(),
            ne && ne.d(),
            be && be.d(),
            K = !1,
            X()
        }
    }
}
var gV = !1;
function yV(r, e, t) {
    let o, c, d, p;
    Ht(r, cm, ne=>t(19, o = ne)),
    Ht(r, Ja, ne=>t(20, c = ne)),
    Ht(r, Yi, ne=>t(21, d = ne)),
    Ht(r, Jr, ne=>t(0, p = ne));
    let {ELEVATION: i} = pd, {MODE3D: v, CROSS: x} = Yr, E = !1, A = !1, C = !1, I = new Set([0]), D, P, k, U, Z, K, X, W = {};
    function fe(ne) {
        if (ne.detail.value === "setBox") {
            let be = new Set([ne.detail.idx]);
            new Set([...I].filter(ae=>!be.has(ae))).forEach(ae=>W[ae].handleMessage(ne))
        } else if (ne.detail.value === "removeBox")
            Array.from(I).forEach(te=>W[te].handleMessage(ne)),
            X.removeMeshes(v);
        else if (ne.detail.value === "setLine") {
            let be = new Set([ne.detail.idx]);
            new Set([...I].filter(ae=>!be.has(ae))).forEach(ae=>W[ae].handleMessage(ne))
        } else if (ne.detail.value === "removeLine")
            Array.from(I).forEach(te=>W[te].handleMessage(ne)),
            X.removeMeshes(x);
        else if (ne.detail.value === "showSites" || ne.detail.value === "showAlerts" || ne.detail.value === "showStatements" || ne.detail.value === "showLightning")
            for (let be in W)
                W[be].handleMessage(ne);
        else
            ne.detail.value === "setDealiasState" ? Array.from(I).forEach(te=>W[te].handleMessage(ne)) : ne.detail.value === "loadTexture" ? X.loadTexture() : ne.detail.value === "showError" ? (t(4, D = d.header),
            t(5, P = d.message),
            d.color ? t(6, k = "header-message") : t(6, k = "header-error"),
            t(2, A = !0)) : ne.detail.value === "showModal" ? (t(7, U = c.header),
            t(8, Z = c.message),
            t(3, C = !0)) : ne.detail.value === "hideError" ? t(2, A = !1) : ne.detail.value === "hideModal" ? t(3, C = !1) : W[ne.detail.idx].handleMessage(ne)
    }
    function ce(ne) {
        ne.keyCode === 37 ? o === i && Nr.previous() : ne.keyCode === 39 && o === i && Nr.advance()
    }
    function _e(ne) {
        K = ne,
        t(9, K)
    }
    function oe(ne) {
        X = ne,
        t(10, X)
    }
    function ee(ne) {
        Bi[ne ? "unshift" : "push"](()=>{
            W[0] = ne,
            t(11, W)
        }
        )
    }
    function j(ne) {
        Bi[ne ? "unshift" : "push"](()=>{
            W[1] = ne,
            t(11, W)
        }
        )
    }
    return r.$$.update = ()=>{
        if (r.$$.dirty & 1) {
            e: p === ja ? (t(1, E = !1),
            I = new Set([0])) : p === Sr && (t(1, E = !0),
            I = new Set([0, 1]))
        }
    }
    ,
    [p, E, A, C, D, P, k, U, Z, K, X, W, fe, ce, _e, oe, ee, j]
}
var V3 = class extends mi {
    constructor(e) {
        super();
        _i(this, e, yV, _V, di, {})
    }
}
  , G3 = V3;
var xV = new G3({
    target: document.body
})
  , vV = xV;
export {vV as default};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
/*! pako 2.0.4 https://github.com/nodeca/pako @license (MIT AND Zlib) */
/**
 * @license
 * Copyright 2010-2022 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
//# sourceMappingURL=index.js.map
